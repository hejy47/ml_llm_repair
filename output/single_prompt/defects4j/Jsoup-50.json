[{"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = parser.parseInput(docData, baseUri);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = parser.parseInput(docData, baseUri);\n    }\n    doc.outputSettings().charset(charsetName);\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -31,24 +31,22 @@\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                doc = parser.parseInput(docData, baseUri);\n             }\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n         byteData.rewind();\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n-        doc = null;\n+        doc = parser.parseInput(docData, baseUri);\n     }\n-    if (doc == null) {\n-        doc = parser.parseInput(docData, baseUri);\n-        doc.outputSettings().charset(charsetName);\n-    }\n+    doc.outputSettings().charset(charsetName);\n     return doc;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = parser.parseInput(docData, baseUri);\n                doc.outputSettings().charset(charsetName);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -31,22 +31,22 @@\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                doc = parser.parseInput(docData, baseUri);\n+                doc.outputSettings().charset(charsetName);\n             }\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n+        doc.outputSettings().charset(charsetName);\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n         byteData.rewind();\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n-        doc = null;\n-    }\n-    if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = parser.parseInput(docData, baseUri);\n                doc.outputSettings().charset(charsetName);\n            } else {\n                doc.outputSettings().charset(defaultCharset);\n            }\n        } else {\n            doc.outputSettings().charset(defaultCharset);\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -31,22 +31,26 @@\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                doc = parser.parseInput(docData, baseUri);\n+                doc.outputSettings().charset(charsetName);\n+            } else {\n+                doc.outputSettings().charset(defaultCharset);\n             }\n+        } else {\n+            doc.outputSettings().charset(defaultCharset);\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n+        doc.outputSettings().charset(charsetName);\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n         byteData.rewind();\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n-        doc = null;\n-    }\n-    if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -17,15 +17,9 @@\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n             }\n             if (foundCharset == null && meta.hasAttr(\"charset\")) {\n-                try {\n-                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n-                        foundCharset = meta.attr(\"charset\");\n-                    }\n-                } catch (IllegalCharsetNameException e) {\n-                    foundCharset = null;\n-                }\n+                foundCharset = meta.attr(\"charset\");\n             }\n-            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                 // need to re-decode\n                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                 charsetName = foundCharset;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    foundCharset = meta.attr(\"charset\");\n                    Charset.forName(foundCharset); // check if charset is supported\n                } catch (UnsupportedCharsetException e) {\n                    foundCharset = null;\n                } catch (IllegalArgumentException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && !foundCharset.isEmpty() && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -18,14 +18,15 @@\n             }\n             if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 try {\n-                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n-                        foundCharset = meta.attr(\"charset\");\n-                    }\n-                } catch (IllegalCharsetNameException e) {\n+                    foundCharset = meta.attr(\"charset\");\n+                    Charset.forName(foundCharset); // check if charset is supported\n+                } catch (UnsupportedCharsetException e) {\n+                    foundCharset = null;\n+                } catch (IllegalArgumentException e) {\n                     foundCharset = null;\n                 }\n             }\n-            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset != null && !foundCharset.isEmpty() && !foundCharset.equals(defaultCharset)) {\n                 // need to re-decode\n                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                 charsetName = foundCharset;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = parser.parseInput(docData, baseUri);\n                doc.outputSettings().charset(charsetName);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -31,22 +31,22 @@\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                doc = parser.parseInput(docData, baseUri);\n+                doc.outputSettings().charset(charsetName);\n             }\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n+        doc.outputSettings().charset(charsetName);\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n         byteData.rewind();\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n-        doc = null;\n-    }\n-    if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = parser.parseInput(docData, baseUri);\n                doc.outputSettings().charset(foundCharset); // ADD THIS LINE TO SET THE CHARSET OF DOC TO THE FOUND CHARSET\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -31,7 +31,8 @@\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                doc = parser.parseInput(docData, baseUri);\n+                doc.outputSettings().charset(foundCharset); // ADD THIS LINE TO SET THE CHARSET OF DOC TO THE FOUND CHARSET\n             }\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = parser.parseInput(docData, baseUri);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -31,20 +31,21 @@\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                doc = parser.parseInput(docData, baseUri);\n             }\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n         byteData.rewind();\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n-        doc = null;\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalArgumentException e) { // changed the exception thrown\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -21,7 +21,7 @@\n                     if (Charset.isSupported(meta.attr(\"charset\"))) {\n                         foundCharset = meta.attr(\"charset\");\n                     }\n-                } catch (IllegalCharsetNameException e) {\n+                } catch (IllegalArgumentException e) { // changed the exception thrown\n                     foundCharset = null;\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -25,7 +25,7 @@\n                     foundCharset = null;\n                 }\n             }\n-            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                 // need to re-decode\n                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                 charsetName = foundCharset;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n                // Fix: recursively call parseByteData with updated charsetName\n                return parseByteData(byteData, charsetName, baseUri, parser);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -32,6 +32,8 @@\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n                 doc = null;\n+                // Fix: recursively call parseByteData with updated charsetName\n+                return parseByteData(byteData, charsetName, baseUri, parser);\n             }\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -25,7 +25,7 @@\n                     foundCharset = null;\n                 }\n             }\n-            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                 // need to re-decode\n                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                 charsetName = foundCharset;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(StandardCharsets.UTF_8.name()).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(StandardCharsets.UTF_8.name())) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(StandardCharsets.UTF_8.name()).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = StandardCharsets.UTF_8.name();\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -7,7 +7,7 @@\n     if (charsetName == null) {\n         // determine from meta. safe parse as UTF-8\n         // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n+        docData = Charset.forName(StandardCharsets.UTF_8.name()).decode(byteData).toString();\n         doc = parser.parseInput(docData, baseUri);\n         Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n         if (meta != null) {\n@@ -25,7 +25,7 @@\n                     foundCharset = null;\n                 }\n             }\n-            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(StandardCharsets.UTF_8.name())) {\n                 // need to re-decode\n                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                 charsetName = foundCharset;\n@@ -41,9 +41,9 @@\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n         byteData.rewind();\n-        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n+        docData = Charset.forName(StandardCharsets.UTF_8.name()).decode(byteData).toString();\n         docData = docData.substring(1);\n-        charsetName = defaultCharset;\n+        charsetName = StandardCharsets.UTF_8.name();\n         doc = null;\n     }\n     if (doc == null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = parser.parseInput(docData, baseUri); // fixed\n            } else {\n                doc.outputSettings().charset(defaultCharset); // fixed\n            }\n        } else {\n            doc.outputSettings().charset(defaultCharset); // fixed\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri); // fixed\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = parser.parseInput(docData, baseUri); // fixed\n        doc.outputSettings().charset(defaultCharset); // fixed\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -31,24 +31,26 @@\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                doc = parser.parseInput(docData, baseUri); // fixed\n+            } else {\n+                doc.outputSettings().charset(defaultCharset); // fixed\n             }\n+        } else {\n+            doc.outputSettings().charset(defaultCharset); // fixed\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri); // fixed\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n         byteData.rewind();\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n-        doc = null;\n-    }\n-    if (doc == null) {\n-        doc = parser.parseInput(docData, baseUri);\n-        doc.outputSettings().charset(charsetName);\n+        doc = parser.parseInput(docData, baseUri); // fixed\n+        doc.outputSettings().charset(defaultCharset); // fixed\n     }\n     return doc;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = parser.parseInput(docData, baseUri);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc.outputSettings().charset(charsetName);\n    }\n    if (doc != null) {\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -31,23 +31,21 @@\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                doc = parser.parseInput(docData, baseUri);\n             }\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n-        byteData.rewind();\n-        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n-        doc = null;\n+        doc.outputSettings().charset(charsetName);\n     }\n-    if (doc == null) {\n-        doc = parser.parseInput(docData, baseUri);\n+    if (doc != null) {\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException ignored) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1);\n            charsetName = defaultCharset;\n            doc = null;\n        }\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -21,7 +21,7 @@\n                     if (Charset.isSupported(meta.attr(\"charset\"))) {\n                         foundCharset = meta.attr(\"charset\");\n                     }\n-                } catch (IllegalCharsetNameException e) {\n+                } catch (IllegalCharsetNameException ignored) {\n                     foundCharset = null;\n                 }\n             }\n@@ -41,10 +41,15 @@\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n         byteData.rewind();\n-        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n         doc = null;\n+        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n+            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n+            docData = docData.substring(1);\n+            charsetName = defaultCharset;\n+            doc = null;\n+        }\n     }\n     if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                // fixed: retry parsing with new charset\n                doc = parser.parseInput(docData, baseUri);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        // fixed: retry parsing with new charset\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -31,7 +31,8 @@\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                // fixed: retry parsing with new charset\n+                doc = parser.parseInput(docData, baseUri);\n             }\n         }\n     } else {\n@@ -44,7 +45,8 @@\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n-        doc = null;\n+        // fixed: retry parsing with new charset\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n                // re-parse with new charset\n                doc = parser.parseInput(docData, baseUri);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n        // re-parse with new charset\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -32,12 +32,15 @@\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n                 doc = null;\n+                // re-parse with new charset\n+                doc = parser.parseInput(docData, baseUri);\n             }\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n         byteData.rewind();\n@@ -45,6 +48,8 @@\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n         doc = null;\n+        // re-parse with new charset\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = docData.substring(1);\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -41,10 +41,12 @@\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n         byteData.rewind();\n-        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n-        charsetName = defaultCharset;\n-        doc = null;\n+        if (charsetName == null) {\n+            charsetName = defaultCharset;\n+        }\n+        doc = parser.parseInput(docData, baseUri);\n+        doc.outputSettings().charset(charsetName);\n     }\n     if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    // check if charset is supported before using it\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    // do nothing, foundCharset is already null\n                }\n            }\n            if (foundCharset != null && !foundCharset.isEmpty() && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = parser.parseInput(docData, baseUri);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (doc != null) { // check if doc has been initialized in any of the above cases\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -18,36 +18,37 @@\n             }\n             if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 try {\n+                    // check if charset is supported before using it\n                     if (Charset.isSupported(meta.attr(\"charset\"))) {\n                         foundCharset = meta.attr(\"charset\");\n                     }\n                 } catch (IllegalCharsetNameException e) {\n-                    foundCharset = null;\n+                    // do nothing, foundCharset is already null\n                 }\n             }\n-            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset != null && !foundCharset.isEmpty() && !foundCharset.equals(defaultCharset)) {\n                 // need to re-decode\n                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                doc = parser.parseInput(docData, baseUri);\n             }\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n         byteData.rewind();\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n-        doc = null;\n+        doc = parser.parseInput(docData, baseUri);\n     }\n-    if (doc == null) {\n-        doc = parser.parseInput(docData, baseUri);\n+    if (doc != null) { // check if doc has been initialized in any of the above cases\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n", "finish_reason": "stop", "valid": false, "num": 1}]