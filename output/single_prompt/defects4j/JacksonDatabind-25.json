[{"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = null;\n            if (cdDef != null) {\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n            }\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n            // Cache the deserializer for the type\n            if (deser != null) {\n                _deserializers.put(typeId, deser);\n            }\n        }\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    return config.constructType(dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,7 +25,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -24,15 +24,13 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n-            if (kdDef != null) {\n-                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n-                if (kd != null) {\n-                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n-                    // just in case it's used below\n-                    keyType = type.getKeyType();\n-                }\n+            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n+            if (kd != null) {\n+                type = ((MapLikeType) type).withKeyValueHandler(kd);\n+                // just in case it's used below\n+                keyType = type.getKeyType();\n             }\n         }\n         // and finally content class; only applicable to structured types\n@@ -49,19 +47,19 @@\n         if (contentType.getValueHandler() == null) {\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n+            JsonDeserializer<?> cd = null;\n             if (cdDef != null) {\n-                JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n                         cd = ctxt.deserializerInstance(a, cdClass);\n                     }\n                 }\n-                if (cd != null) {\n-                    type = type.withContentValueHandler(cd);\n-                }\n+            }\n+            if (cd != null) {\n+                type = type.withContentValueHandler(cd);\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -9,12 +9,15 @@\n                 deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n+            // Cache the deserializer for the type\n+            if (deser != null) {\n+                _deserializers.put(typeId, deser);\n+            }\n         }\n-        _deserializers.put(typeId, deser);\n     }\n     return deser;\n }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -6,6 +6,5 @@\n     if (dst == null) {\n         return null;\n     }\n-    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return config.constructType(dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cdDef = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n            if (_baseType != null && _baseType.getClass() == type.getClass()) {\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,7 +25,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -24,7 +24,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             if (kdDef != null) {\n                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -9,8 +9,8 @@\n                 deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n+            if (_baseType != null && _baseType.getClass() == type.getClass()) {\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -7,5 +7,5 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    // Use type.getRawClass() instead of type-wrapper\n    Class<?> dst = _mappings.get(src);\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -14,7 +14,9 @@\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -2,10 +2,11 @@\n public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n     // this is the main mapping base, so let's\n     Class<?> src = type.getRawClass();\n-    Class<?> dst = _mappings.get(new ClassKey(src));\n+    // Use type.getRawClass() instead of type-wrapper\n+    Class<?> dst = _mappings.get(src);\n     if (dst == null) {\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n            type = _baseType.narrowBy(type.getRawClass());\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n            _deserializers.put(typeId, deser);\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,7 +25,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -24,7 +24,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             if (kdDef != null) {\n                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,20 +1,21 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n             if (deser == null) {\n                 deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n             }\n+        } else if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+            type = _baseType.narrowBy(type.getRawClass());\n+            deser = ctxt.findContextualValueDeserializer(type, _property);\n+            _deserializers.put(typeId, deser);\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n-            }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n+            _deserializers.put(typeId, deser);\n         }\n-        _deserializers.put(typeId, deser);\n     }\n     return deser;\n }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -7,5 +7,5 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass().equals(type.getClass())) {\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return config.getTypeFactory().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,7 +25,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -24,7 +24,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             if (kdDef != null) {\n                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -9,8 +9,8 @@\n                 deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n+            if ((_baseType != null) && _baseType.getClass().equals(type.getClass())) {\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -7,5 +7,5 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return config.getTypeFactory().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass().equals(type.getClass())) { // Fixed line\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // use TypeFactory for new instances, to ensure sharing of cached instances:\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    return config.getTypeFactory().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -5,7 +5,7 @@\n     Class<?> subclass = intr.findDeserializationType(a, type);\n     if (subclass != null) {\n         try {\n-            type = (T) type.narrowBy(subclass);\n+            type = type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n         }\n@@ -19,26 +19,28 @@\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n-                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n+                type = ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n-            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n-            if (kd != null) {\n-                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n-                // just in case it's used below\n-                keyType = type.getKeyType();\n+            if (kdDef != null) {\n+                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n+                if (kd != null) {\n+                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n+                    // just in case it's used below\n+                    keyType = type.getKeyType();\n+                }\n             }\n         }\n         // and finally content class; only applicable to structured types\n         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n         if (cc != null) {\n             try {\n-                type = (T) type.narrowContentsBy(cc);\n+                type = type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n@@ -48,9 +50,19 @@\n         if (contentType.getValueHandler() == null) {\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n-            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n-            if (cd != null) {\n-                type = (T) type.withContentValueHandler(cd);\n+            if (cdDef != null) {\n+                JsonDeserializer<?> cd = null;\n+                if (cdDef instanceof JsonDeserializer<?>) {\n+                    cd = (JsonDeserializer<?>) cdDef;\n+                } else {\n+                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                    if (cdClass != null) {\n+                        cd = ctxt.deserializerInstance(a, cdClass);\n+                    }\n+                }\n+                if (cd != null) {\n+                    type = type.withContentValueHandler(cd);\n+                }\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -24,7 +24,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             if (kdDef != null) {\n                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -9,8 +9,8 @@\n                 deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n+            if ((_baseType != null) && _baseType.getClass().equals(type.getClass())) { // Fixed line\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -1,11 +1,10 @@\n @Override\n public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n-    // this is the main mapping base, so let's\n+    // use TypeFactory for new instances, to ensure sharing of cached instances:\n     Class<?> src = type.getRawClass();\n     Class<?> dst = _mappings.get(new ClassKey(src));\n     if (dst == null) {\n         return null;\n     }\n-    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return config.getTypeFactory().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // `this._mappings` was not being initialized before\n    // we need to initialize the cache first\n    if (this._mappings == null) {\n        this._mappings = new ConcurrentHashMap<>();\n        for (Map.Entry<Class<?>, Class<?>> entry : _typeMappings.entrySet()) {\n            ClassKey key = new ClassKey(entry.getKey());\n            this._mappings.put(key, entry.getValue());\n        }\n    }\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return type.narrowBy(dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -27,11 +27,13 @@\n         JavaType keyType = type.getKeyType();\n                 if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n-            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n-            if (kd != null) {\n-                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n-                // just in case it's used below\n-                keyType = type.getKeyType();\n+            if (kdDef != null) {\n+                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n+                if (kd != null) {\n+                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    // just in case it's used below\n+                    keyType = type.getKeyType();\n+                }\n             }\n         }\n         // and finally content class; only applicable to structured types\n@@ -48,9 +50,19 @@\n         if (contentType.getValueHandler() == null) {\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n-            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n-            if (cd != null) {\n-                type = (T) type.withContentValueHandler(cd);\n+            if (cdDef != null) {\n+                JsonDeserializer<?> cd = null;\n+                if (cdDef instanceof JsonDeserializer<?>) {\n+                    cd = (JsonDeserializer<?>) cdDef;\n+                } else {\n+                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                    if (cdClass != null) {\n+                        cd = ctxt.deserializerInstance(a, cdClass);\n+                    }\n+                }\n+                if (cd != null) {\n+                    type = (T) type.withContentValueHandler(cd);\n+                }\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -1,5 +1,14 @@\n @Override\n public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n+    // `this._mappings` was not being initialized before\n+    // we need to initialize the cache first\n+    if (this._mappings == null) {\n+        this._mappings = new ConcurrentHashMap<>();\n+        for (Map.Entry<Class<?>, Class<?>> entry : _typeMappings.entrySet()) {\n+            ClassKey key = new ClassKey(entry.getKey());\n+            this._mappings.put(key, entry.getValue());\n+        }\n+    }\n     // this is the main mapping base, so let's\n     Class<?> src = type.getRawClass();\n     Class<?> dst = _mappings.get(new ClassKey(src));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return type.narrowBy(dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            _deserializers.putIfAbsent(typeId, deser);\n        }\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -14,7 +14,9 @@\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.putIfAbsent(typeId, deser);\n+        }\n     }\n     return deser;\n }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -7,5 +7,5 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) throws JsonMappingException {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,13 +25,15 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n-            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n-            if (kd != null) {\n-                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n-                // just in case it's used below\n-                keyType = type.getKeyType();\n+            if (kdDef != null) {\n+                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n+                if (kd != null) {\n+                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    // just in case it's used below\n+                    keyType = type.getKeyType();\n+                }\n             }\n         }\n         // and finally content class; only applicable to structured types\n@@ -48,9 +50,11 @@\n         if (contentType.getValueHandler() == null) {\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n-            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n-            if (cd != null) {\n-                type = (T) type.withContentValueHandler(cd);\n+            if (cdDef != null) {\n+                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n+                if (cd != null) {\n+                    type = (T) type.withContentValueHandler(cd);\n+                }\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -24,7 +24,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             if (kdDef != null) {\n                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n@@ -50,15 +50,7 @@\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n             if (cdDef != null) {\n-                JsonDeserializer<?> cd = null;\n-                if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n-                } else {\n-                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n-                    if (cdClass != null) {\n-                        cd = ctxt.deserializerInstance(a, cdClass);\n-                    }\n-                }\n+                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                 if (cd != null) {\n                     type = type.withContentValueHandler(cd);\n                 }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -1,5 +1,5 @@\n @Override\n-public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n+public JavaType findTypeMapping(DeserializationConfig config, JavaType type) throws JsonMappingException {\n     // this is the main mapping base, so let's\n     Class<?> src = type.getRawClass();\n     Class<?> dst = _mappings.get(new ClassKey(src));\n@@ -7,5 +7,5 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(src);\n    if (dst == null) {\n        return null;\n    }\n    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -5,7 +5,7 @@\n     Class<?> subclass = intr.findDeserializationType(a, type);\n     if (subclass != null) {\n         try {\n-            type = (T) type.narrowBy(subclass);\n+            type = type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n         }\n@@ -19,17 +19,17 @@\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n-                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n+                type = ((MapLikeType) type).narrowKey(keyClass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n-                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                type = ((MapLikeType) type).withKeyValueHandler(kd);\n                 // just in case it's used below\n                 keyType = type.getKeyType();\n             }\n@@ -38,7 +38,7 @@\n         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n         if (cc != null) {\n             try {\n-                type = (T) type.narrowContentsBy(cc);\n+                type = type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n@@ -50,7 +50,7 @@\n             Object cdDef = intr.findContentDeserializer(a);\n             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n             if (cd != null) {\n-                type = (T) type.withContentValueHandler(cd);\n+                type = type.withContentValueHandler(cd);\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -24,7 +24,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             if (kdDef != null) {\n                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -9,8 +9,8 @@\n                 deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -1,11 +1,9 @@\n @Override\n public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n-    // this is the main mapping base, so let's\n     Class<?> src = type.getRawClass();\n-    Class<?> dst = _mappings.get(new ClassKey(src));\n+    Class<?> dst = _mappings.get(src);\n     if (dst == null) {\n         return null;\n     }\n-    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,7 +25,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -24,7 +24,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             if (kdDef != null) {\n                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -9,8 +9,8 @@\n                 deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -7,5 +7,5 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return config.getTypeFactory().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -27,11 +27,13 @@\n         JavaType keyType = type.getKeyType();\n                 if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n-            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n-            if (kd != null) {\n-                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n-                // just in case it's used below\n-                keyType = type.getKeyType();\n+            if (kdDef != null) {\n+                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n+                if (kd != null) {\n+                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    // just in case it's used below\n+                    keyType = type.getKeyType();\n+                }\n             }\n         }\n         // and finally content class; only applicable to structured types\n@@ -48,9 +50,19 @@\n         if (contentType.getValueHandler() == null) {\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n-            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n-            if (cd != null) {\n-                type = (T) type.withContentValueHandler(cd);\n+            if (cdDef != null) {\n+                JsonDeserializer<?> cd = null;\n+                if (cdDef instanceof JsonDeserializer<?>) {\n+                    cd = (JsonDeserializer<?>) cdDef;\n+                } else {\n+                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                    if (cdClass != null) {\n+                        cd = ctxt.deserializerInstance(a, cdClass);\n+                    }\n+                }\n+                if (cd != null) {\n+                    type = (T) type.withContentValueHandler(cd);\n+                }\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -13,8 +13,8 @@\n                                 type = _baseType.narrowBy(type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n+            _deserializers.put(typeId, deser);\n         }\n-        _deserializers.put(typeId, deser);\n     }\n     return deser;\n }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -7,5 +7,5 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return config.getTypeFactory().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return type.narrowBy(dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,7 +25,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -24,7 +24,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             if (kdDef != null) {\n                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -9,12 +9,14 @@\n                 deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -7,5 +7,5 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            JsonDeserializer<Object> newDeser = ctxt.findContextualValueDeserializer(type, _property);\n            if (newDeser != null) {\n                deser = newDeser;\n            }\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -9,10 +9,13 @@\n                 deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n-            deser = ctxt.findContextualValueDeserializer(type, _property);\n+            JsonDeserializer<Object> newDeser = ctxt.findContextualValueDeserializer(type, _property);\n+            if (newDeser != null) {\n+                deser = newDeser;\n+            }\n         }\n         _deserializers.put(typeId, deser);\n     }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -7,5 +7,5 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return TypeFactory.defaultInstance().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.putIfAbsent(typeId, deser);\n        if (deser == null) {\n            throw new JsonMappingException(\"Cannot find a deserializer for type \" + type);\n        }\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return type.narrowBy(dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,13 +25,15 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n-            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n-            if (kd != null) {\n-                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n-                // just in case it's used below\n-                keyType = type.getKeyType();\n+            if (kdDef != null) {\n+                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n+                if (kd != null) {\n+                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    // just in case it's used below\n+                    keyType = type.getKeyType();\n+                }\n             }\n         }\n         // and finally content class; only applicable to structured types\n@@ -48,9 +50,11 @@\n         if (contentType.getValueHandler() == null) {\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n-            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n-            if (cd != null) {\n-                type = (T) type.withContentValueHandler(cd);\n+            if (cdDef != null) {\n+                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n+                if (cd != null) {\n+                    type = (T) type.withContentValueHandler(cd);\n+                }\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -24,7 +24,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             if (kdDef != null) {\n                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -9,12 +9,15 @@\n                 deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        _deserializers.putIfAbsent(typeId, deser);\n+        if (deser == null) {\n+            throw new JsonMappingException(\"Cannot find a deserializer for type \" + type);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n        if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if ((keyType != null) && (keyType.getValueHandler() == null)) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    } else {\n                        cd = null;\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    synchronized (_deserializers) {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser != null) {\n            return deser;\n        }\n    }\n    JavaType type = _idResolver.typeFromId(ctxt, typeId);\n    if (type == null) {\n        deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n        if (deser == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n        }\n    } else if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n        type = _baseType.narrowBy(type.getRawClass());\n    }\n    if (deser == null) {\n        deser = ctxt.findContextualValueDeserializer(type, _property);\n        synchronized (_deserializers) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    // short-circuit, because TypeModifier is not expected to change actual subtypes:\n    if (dst == null) {\n        return type;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return type.narrowBy(dst);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -5,7 +5,7 @@\n     Class<?> subclass = intr.findDeserializationType(a, type);\n     if (subclass != null) {\n         try {\n-            type = (T) type.narrowBy(subclass);\n+            type = type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n         }\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -1,7 +1,6 @@\n private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n-    // first: let's check class for the instance itself:\n-    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n-    Class<?> subclass = intr.findDeserializationType(a, type);\n+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        Class<?> subclass = intr.findDeserializationType(a, type);\n     if (subclass != null) {\n         try {\n             type = type.narrowBy(subclass);\n@@ -9,11 +8,9 @@\n             throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n         }\n     }\n-    // then key class\n-    if (type.isContainerType()) {\n+        if (type.isContainerType()) {\n         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n         if (keyClass != null) {\n-            // illegal to use on non-Maps\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n@@ -24,18 +21,16 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if ((keyType != null) && (keyType.getValueHandler() == null)) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             if (kdDef != null) {\n                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                 if (kd != null) {\n                     type = ((MapLikeType) type).withKeyValueHandler(kd);\n-                    // just in case it's used below\n                     keyType = type.getKeyType();\n                 }\n             }\n         }\n-        // and finally content class; only applicable to structured types\n         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n         if (cc != null) {\n             try {\n@@ -44,19 +39,19 @@\n                 throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n             }\n         }\n-        // ... as well as deserializer for contents:\n         JavaType contentType = type.getContentType();\n         if (contentType.getValueHandler() == null) {\n-            // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n             if (cdDef != null) {\n-                JsonDeserializer<?> cd = null;\n+                JsonDeserializer<?> cd;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n                         cd = ctxt.deserializerInstance(a, cdClass);\n+                    } else {\n+                        cd = null;\n                     }\n                 }\n                 if (cd != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,20 +1,24 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n-    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n+    synchronized (_deserializers) {\n+        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n+        if (deser != null) {\n+            return deser;\n+        }\n+    }\n+    JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+    if (type == null) {\n+        deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n+        if (deser == null) {\n+            deser = _findDefaultImplDeserializer(ctxt);\n+        }\n+    } else if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+        type = _baseType.narrowBy(type.getRawClass());\n+    }\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n-        if (type == null) {\n-            // As per [JACKSON-614], use the default impl if no type id available:\n-            deser = _findDefaultImplDeserializer(ctxt);\n-            if (deser == null) {\n-                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n-            }\n-        } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n-            }\n-            deser = ctxt.findContextualValueDeserializer(type, _property);\n+        deser = ctxt.findContextualValueDeserializer(type, _property);\n+        synchronized (_deserializers) {\n+            _deserializers.put(typeId, deser);\n         }\n-        _deserializers.put(typeId, deser);\n     }\n     return deser;\n }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -3,8 +3,9 @@\n     // this is the main mapping base, so let's\n     Class<?> src = type.getRawClass();\n     Class<?> dst = _mappings.get(new ClassKey(src));\n+    // short-circuit, because TypeModifier is not expected to change actual subtypes:\n     if (dst == null) {\n-        return null;\n+        return type;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n     return type.narrowBy(dst);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 2\nprivate JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cd = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}\n\n## Fixed Function 3\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            JsonDeserializer<Object> tmp = ctxt.findContextualValueDeserializer(type, _property);\n            if (tmp != null) {\n                deser = tmp;\n            } else {\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                }\n            }\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n## Fixed Function 4\n@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Map.Entry<ClassKey, Class<?>> entry = _mappings.find(new ClassKey(src));\n    if (entry == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return type.narrowBy(entry.getValue());\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,13 +25,15 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n-            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n-            if (kd != null) {\n-                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n-                // just in case it's used below\n-                keyType = type.getKeyType();\n+            if (kdDef != null) {\n+                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n+                if (kd != null) {\n+                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    // just in case it's used below\n+                    keyType = type.getKeyType();\n+                }\n             }\n         }\n         // and finally content class; only applicable to structured types\n@@ -48,9 +50,19 @@\n         if (contentType.getValueHandler() == null) {\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n-            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n-            if (cd != null) {\n-                type = (T) type.withContentValueHandler(cd);\n+            if (cdDef != null) {\n+                JsonDeserializer<?> cd = null;\n+                if (cdDef instanceof JsonDeserializer<?>) {\n+                    cd = (JsonDeserializer<?>) cdDef;\n+                } else {\n+                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                    if (cdClass != null) {\n+                        cd = ctxt.deserializerInstance(a, cdClass);\n+                    }\n+                }\n+                if (cd != null) {\n+                    type = (T) type.withContentValueHandler(cd);\n+                }\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@modifyTypeByAnnotation\n@@ -24,7 +24,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             if (kdDef != null) {\n                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n@@ -52,7 +52,7 @@\n             if (cdDef != null) {\n                 JsonDeserializer<?> cd = null;\n                 if (cdDef instanceof JsonDeserializer<?>) {\n-                    cdDef = (JsonDeserializer<?>) cdDef;\n+                    cd = (JsonDeserializer<?>) cdDef;\n                 } else {\n                     Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                     if (cdClass != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -9,10 +9,18 @@\n                 deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                type = _baseType.narrowBy(type.getRawClass());\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n-            deser = ctxt.findContextualValueDeserializer(type, _property);\n+            JsonDeserializer<Object> tmp = ctxt.findContextualValueDeserializer(type, _property);\n+            if (tmp != null) {\n+                deser = tmp;\n+            } else {\n+                deser = _findDefaultImplDeserializer(ctxt);\n+                if (deser == null) {\n+                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n+                }\n+            }\n         }\n         _deserializers.put(typeId, deser);\n     }\n--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -2,10 +2,10 @@\n public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n     // this is the main mapping base, so let's\n     Class<?> src = type.getRawClass();\n-    Class<?> dst = _mappings.get(new ClassKey(src));\n-    if (dst == null) {\n+    Map.Entry<ClassKey, Class<?>> entry = _mappings.find(new ClassKey(src));\n+    if (entry == null) {\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return type.narrowBy(entry.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]