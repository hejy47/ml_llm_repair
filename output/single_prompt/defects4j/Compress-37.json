[{"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(\"UTF-8\");\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            final int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, \"UTF-8\");\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -17,7 +17,7 @@\n                     read++;\n                     if (ch == '=') {\n                         // end of keyword\n-                        final String keyword = coll.toString(CharsetNames.UTF_8);\n+                        final String keyword = coll.toString(\"UTF-8\");\n                         // Get rest of entry\n                         final int restLen = len - read;\n                         if (restLen == 1) {\n@@ -30,7 +30,7 @@\n                                 throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                             }\n                             // Drop trailing NL\n-                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n+                            final String value = new String(rest, 0, restLen - 1, \"UTF-8\");\n                             headers.put(keyword, value);\n                         }\n                         break;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new LinkedHashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    String line;\n    BufferedReader reader = new BufferedReader(new InputStreamReader(i, CharsetNames.UTF_8));\n    while ((line = reader.readLine()) != null) {\n        String[] parts = line.split(\" \", 2);\n        int len = Integer.parseInt(parts[0]);\n        String[] kv = parts[1].split(\"=\", 2);\n        final String keyword = kv[0];\n        // Get rest of entry\n        final int restLen = len - parts[0].length() - parts[1].length() - 2;\n        if (restLen == 1) {\n            // only NL\n            headers.remove(keyword);\n        } else {\n            final char[] rest = new char[restLen];\n            final int got = reader.read(rest);\n            if (got != restLen) {\n               throw new IOException(\"Failed to read Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n            }\n            // Drop trailing NL\n            final String value = new String(rest, 0, restLen - 1);\n            headers.put(keyword, value);\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -1,51 +1,29 @@\n // NOTE, using a Map here makes it impossible to ever support GNU\n // sparse files using the PAX Format 0.0, see\n Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n-    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n+    final Map<String, String> headers = new LinkedHashMap<String, String>(globalPaxHeaders);\n     // Format is \"length keyword=value\\n\";\n-    while (true) {\n-        // get length\n-        int ch;\n-        int len = 0;\n-        int read = 0;\n-        while ((ch = i.read()) != -1) {\n-            read++;\n-            if (ch == ' ') {\n-                // Get keyword\n-                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n-                while ((ch = i.read()) != -1) {\n-                    read++;\n-                    if (ch == '=') {\n-                        // end of keyword\n-                        final String keyword = coll.toString(CharsetNames.UTF_8);\n-                        // Get rest of entry\n-                        final int restLen = len - read;\n-                        if (restLen == 1) {\n-                            // only NL\n-                            headers.remove(keyword);\n-                        } else {\n-                            final byte[] rest = new byte[restLen];\n-                            final int got = IOUtils.readFully(i, rest);\n-                            if (got != restLen) {\n-                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n-                            }\n-                            // Drop trailing NL\n-                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n-                            headers.put(keyword, value);\n-                        }\n-                        break;\n-                    }\n-                    coll.write((byte) ch);\n-                }\n-                // Processed single header\n-                break;\n+    String line;\n+    BufferedReader reader = new BufferedReader(new InputStreamReader(i, CharsetNames.UTF_8));\n+    while ((line = reader.readLine()) != null) {\n+        String[] parts = line.split(\" \", 2);\n+        int len = Integer.parseInt(parts[0]);\n+        String[] kv = parts[1].split(\"=\", 2);\n+        final String keyword = kv[0];\n+        // Get rest of entry\n+        final int restLen = len - parts[0].length() - parts[1].length() - 2;\n+        if (restLen == 1) {\n+            // only NL\n+            headers.remove(keyword);\n+        } else {\n+            final char[] rest = new char[restLen];\n+            final int got = reader.read(rest);\n+            if (got != restLen) {\n+               throw new IOException(\"Failed to read Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n             }\n-            len *= 10;\n-            len += ch - '0';\n-        }\n-        if (ch == -1) {\n-            // EOF\n-            break;\n+            // Drop trailing NL\n+            final String value = new String(rest, 0, restLen - 1);\n+            headers.put(keyword, value);\n         }\n     }\n     return headers;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new LinkedHashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            final int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -1,7 +1,7 @@\n // NOTE, using a Map here makes it impossible to ever support GNU\n // sparse files using the PAX Format 0.0, see\n Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n-    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n+    final Map<String, String> headers = new LinkedHashMap<String, String>(globalPaxHeaders);\n     // Format is \"length keyword=value\\n\";\n     while (true) {\n         // get length\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            int got = 0;\n                            while (got < restLen) {\n                                int x = i.read(rest, got, restLen - got);\n                                if (x == -1) {\n                                    throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                                }\n                                got += x;\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -25,9 +25,13 @@\n                             headers.remove(keyword);\n                         } else {\n                             final byte[] rest = new byte[restLen];\n-                            final int got = IOUtils.readFully(i, rest);\n-                            if (got != restLen) {\n-                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n+                            int got = 0;\n+                            while (got < restLen) {\n+                                int x = i.read(rest, got, restLen - got);\n+                                if (x == -1) {\n+                                    throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n+                                }\n+                                got += x;\n                             }\n                             // Drop trailing NL\n                             final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                            i.read(); // Consume the '\\n' character\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            final int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                            i.read(); // Consume the '\\n' character\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -23,6 +23,7 @@\n                         if (restLen == 1) {\n                             // only NL\n                             headers.remove(keyword);\n+                            i.read(); // Consume the '\\n' character\n                         } else {\n                             final byte[] rest = new byte[restLen];\n                             final int got = IOUtils.readFully(i, rest);\n@@ -32,6 +33,7 @@\n                             // Drop trailing NL\n                             final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                             headers.put(keyword, value);\n+                            i.read(); // Consume the '\\n' character\n                         }\n                         break;\n                     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            int offset = 0;\n                            while (offset < restLen) {\n                                final int got = i.read(rest, offset, restLen - offset);\n                                if (got == -1) {\n                                    throw new EOFException(\"Unexpected EOF while \" + \"reading Paxheader\");\n                                }\n                                offset += got;\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -1,7 +1,7 @@\n // NOTE, using a Map here makes it impossible to ever support GNU\n // sparse files using the PAX Format 0.0, see\n Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n-    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n+    final Map<String, String> headers = new HashMap<>(globalPaxHeaders);\n     // Format is \"length keyword=value\\n\";\n     while (true) {\n         // get length\n@@ -25,9 +25,13 @@\n                             headers.remove(keyword);\n                         } else {\n                             final byte[] rest = new byte[restLen];\n-                            final int got = IOUtils.readFully(i, rest);\n-                            if (got != restLen) {\n-                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n+                            int offset = 0;\n+                            while (offset < restLen) {\n+                                final int got = i.read(rest, offset, restLen - offset);\n+                                if (got == -1) {\n+                                    throw new EOFException(\"Unexpected EOF while \" + \"reading Paxheader\");\n+                                }\n+                                offset += got;\n                             }\n                             // Drop trailing NL\n                             final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            final int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return Collections.unmodifiableMap(headers);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -48,5 +48,5 @@\n             break;\n         }\n     }\n-    return headers;\n+    return Collections.unmodifiableMap(headers);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    int ch;\n    while ((ch = i.read()) != -1) {\n        // get length\n        int len = 0;\n        while (Character.isDigit(ch)) {\n            len *= 10;\n            len += ch - '0';\n            ch = i.read();\n        }\n\n        if (ch != ' ') {\n            throw new IOException(\"Failed to read PAX header\");\n        }\n\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        final byte[] data = new byte[len];\n        int read = 0;\n        while (read < len) {\n            final int bytesRead = i.read(data, read, len - read);\n            if (bytesRead == -1) {\n                throw new IOException(\"Failed to read PAX header\");\n            }\n            read += bytesRead;\n        }\n\n        buffer.write(data, 0, len);\n        buffer.write('\\n');\n\n        String line = buffer.toString(CharsetNames.UTF_8);\n\n        if (line.charAt(line.length() - 1) != '\\n') {\n            throw new IOException(\"Corrupted PAX header\");\n        }\n\n        line = line.substring(0, line.length() - 1);\n\n        final int p = line.indexOf('=');\n        if (p == -1) {\n            // malformed header?\n            continue;\n        }\n        final String key = line.substring(0, p);\n        final String value = line.substring(p + 1, line.length());\n\n        if (key.startsWith(\"SCHILY.\")) {\n            continue;\n        }\n\n        if (value.isEmpty()) {\n            headers.remove(key);\n        } else {\n            headers.put(key, value);\n        }\n    }\n\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -3,50 +3,60 @@\n Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n     final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n     // Format is \"length keyword=value\\n\";\n-    while (true) {\n+    int ch;\n+    while ((ch = i.read()) != -1) {\n         // get length\n-        int ch;\n         int len = 0;\n-        int read = 0;\n-        while ((ch = i.read()) != -1) {\n-            read++;\n-            if (ch == ' ') {\n-                // Get keyword\n-                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n-                while ((ch = i.read()) != -1) {\n-                    read++;\n-                    if (ch == '=') {\n-                        // end of keyword\n-                        final String keyword = coll.toString(CharsetNames.UTF_8);\n-                        // Get rest of entry\n-                        final int restLen = len - read;\n-                        if (restLen == 1) {\n-                            // only NL\n-                            headers.remove(keyword);\n-                        } else {\n-                            final byte[] rest = new byte[restLen];\n-                            final int got = IOUtils.readFully(i, rest);\n-                            if (got != restLen) {\n-                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n-                            }\n-                            // Drop trailing NL\n-                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n-                            headers.put(keyword, value);\n-                        }\n-                        break;\n-                    }\n-                    coll.write((byte) ch);\n-                }\n-                // Processed single header\n-                break;\n-            }\n+        while (Character.isDigit(ch)) {\n             len *= 10;\n             len += ch - '0';\n+            ch = i.read();\n         }\n-        if (ch == -1) {\n-            // EOF\n-            break;\n+\n+        if (ch != ' ') {\n+            throw new IOException(\"Failed to read PAX header\");\n+        }\n+\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final byte[] data = new byte[len];\n+        int read = 0;\n+        while (read < len) {\n+            final int bytesRead = i.read(data, read, len - read);\n+            if (bytesRead == -1) {\n+                throw new IOException(\"Failed to read PAX header\");\n+            }\n+            read += bytesRead;\n+        }\n+\n+        buffer.write(data, 0, len);\n+        buffer.write('\\n');\n+\n+        String line = buffer.toString(CharsetNames.UTF_8);\n+\n+        if (line.charAt(line.length() - 1) != '\\n') {\n+            throw new IOException(\"Corrupted PAX header\");\n+        }\n+\n+        line = line.substring(0, line.length() - 1);\n+\n+        final int p = line.indexOf('=');\n+        if (p == -1) {\n+            // malformed header?\n+            continue;\n+        }\n+        final String key = line.substring(0, p);\n+        final String value = line.substring(p + 1, line.length());\n+\n+        if (key.startsWith(\"SCHILY.\")) {\n+            continue;\n+        }\n+\n+        if (value.isEmpty()) {\n+            headers.remove(key);\n+        } else {\n+            headers.put(key, value);\n         }\n     }\n+\n     return headers;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            int got = 0;\n                            while (got < restLen) {\n                                int ret = i.read(rest, got, restLen - got);\n                                if (ret < 0) {\n                                    throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                                }\n                                got += ret;\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -25,9 +25,13 @@\n                             headers.remove(keyword);\n                         } else {\n                             final byte[] rest = new byte[restLen];\n-                            final int got = IOUtils.readFully(i, rest);\n-                            if (got != restLen) {\n-                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n+                            int got = 0;\n+                            while (got < restLen) {\n+                                int ret = i.read(rest, got, restLen - got);\n+                                if (ret < 0) {\n+                                    throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n+                                }\n+                                got += ret;\n                             }\n                             // Drop trailing NL\n                             final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new LinkedHashMap<String, String>(); // changed to LinkedHashMap for stable iteration order\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.put(keyword, \"\");\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            final int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -1,7 +1,7 @@\n // NOTE, using a Map here makes it impossible to ever support GNU\n // sparse files using the PAX Format 0.0, see\n Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n-    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n+    final Map<String, String> headers = new LinkedHashMap<String, String>(); // changed to LinkedHashMap for stable iteration order\n     // Format is \"length keyword=value\\n\";\n     while (true) {\n         // get length\n@@ -22,7 +22,7 @@\n                         final int restLen = len - read;\n                         if (restLen == 1) {\n                             // only NL\n-                            headers.remove(keyword);\n+                            headers.put(keyword, \"\");\n                         } else {\n                             final byte[] rest = new byte[restLen];\n                             final int got = IOUtils.readFully(i, rest);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            int got = 0;\n                            while (got != restLen) {\n                                int x = i.read(rest, got, restLen - got);\n                                if (x == -1) {\n                                    throw new IOException(\"Truncated pax header\");\n                                }\n                                got += x;\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -25,9 +25,13 @@\n                             headers.remove(keyword);\n                         } else {\n                             final byte[] rest = new byte[restLen];\n-                            final int got = IOUtils.readFully(i, rest);\n-                            if (got != restLen) {\n-                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n+                            int got = 0;\n+                            while (got != restLen) {\n+                                int x = i.read(rest, got, restLen - got);\n+                                if (x == -1) {\n+                                    throw new IOException(\"Truncated pax header\");\n+                                }\n+                                got += x;\n                             }\n                             // Drop trailing NL\n                             final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            int got = i.read(rest, 0, restLen);\n                            while (got != -1 && got < restLen) {\n                                got += i.read(rest, got, restLen - got);\n                            }\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -25,7 +25,10 @@\n                             headers.remove(keyword);\n                         } else {\n                             final byte[] rest = new byte[restLen];\n-                            final int got = IOUtils.readFully(i, rest);\n+                            int got = i.read(rest, 0, restLen);\n+                            while (got != -1 && got < restLen) {\n+                                got += i.read(rest, got, restLen - got);\n+                            }\n                             if (got != restLen) {\n                                 throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            int totalRead = 0;\n                            while (totalRead < restLen) {\n                                int numRead = i.read(rest, totalRead, restLen - totalRead);\n                                if (numRead < 0) {\n                                    throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + totalRead);\n                                }\n                                totalRead += numRead;\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -25,9 +25,13 @@\n                             headers.remove(keyword);\n                         } else {\n                             final byte[] rest = new byte[restLen];\n-                            final int got = IOUtils.readFully(i, rest);\n-                            if (got != restLen) {\n-                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n+                            int totalRead = 0;\n+                            while (totalRead < restLen) {\n+                                int numRead = i.read(rest, totalRead, restLen - totalRead);\n+                                if (numRead < 0) {\n+                                    throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + totalRead);\n+                                }\n+                                totalRead += numRead;\n                             }\n                             // Drop trailing NL\n                             final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE: changed map type to LinkedHashMap to preserve order of elements\nLinkedHashMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final LinkedHashMap<String, String> headers = new LinkedHashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            final int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        byte[] rest = new byte[restLen];\n                        int count = IOUtils.readFully(i, rest, 0, restLen); // Modified line\n                        if (count != restLen) { // Modified line\n                            throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + count); // Modified line\n                        }\n                        // Drop trailing NL\n                        final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                        headers.put(keyword, value);\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -20,19 +20,14 @@\n                         final String keyword = coll.toString(CharsetNames.UTF_8);\n                         // Get rest of entry\n                         final int restLen = len - read;\n-                        if (restLen == 1) {\n-                            // only NL\n-                            headers.remove(keyword);\n-                        } else {\n-                            final byte[] rest = new byte[restLen];\n-                            final int got = IOUtils.readFully(i, rest);\n-                            if (got != restLen) {\n-                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n-                            }\n-                            // Drop trailing NL\n-                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n-                            headers.put(keyword, value);\n+                        byte[] rest = new byte[restLen];\n+                        int count = IOUtils.readFully(i, rest, 0, restLen); // Modified line\n+                        if (count != restLen) { // Modified line\n+                            throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + count); // Modified line\n                         }\n+                        // Drop trailing NL\n+                        final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n+                        headers.put(keyword, value);\n                         break;\n                     }\n                     coll.write((byte) ch);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            int got = 0;\n                            while (got < restLen) {\n                                int x = i.read(rest, got, restLen - got);\n                                if (x == -1) {\n                                    throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + (restLen - got) + \" bytes, read \" + got);\n                                }\n                                got += x;\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -25,9 +25,13 @@\n                             headers.remove(keyword);\n                         } else {\n                             final byte[] rest = new byte[restLen];\n-                            final int got = IOUtils.readFully(i, rest);\n-                            if (got != restLen) {\n-                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n+                            int got = 0;\n+                            while (got < restLen) {\n+                                int x = i.read(rest, got, restLen - got);\n+                                if (x == -1) {\n+                                    throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + (restLen - got) + \" bytes, read \" + got);\n+                                }\n+                                got += x;\n                             }\n                             // Drop trailing NL\n                             final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            final int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n        // Reset the read counter\n        read = 0;\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -47,6 +47,8 @@\n             // EOF\n             break;\n         }\n+        // Reset the read counter\n+        read = 0;\n     }\n     return headers;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// NOTE, using a Map here makes it impossible to ever support GNU\n// sparse files using the PAX Format 0.0, see\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                // Get keyword\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                while ((ch = i.read()) != -1) {\n                    read++;\n                    if (ch == '=') {\n                        // end of keyword\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\n                        // Get rest of entry\n                        final int restLen = len - read;\n                        if (restLen == 1) {\n                            // only NL\n                            headers.remove(keyword);\n                        } else {\n                            final byte[] rest = new byte[restLen];\n                            int got = 0;\n                            while (got < restLen) { // Fixes potential overflow bug\n                                int curGot = i.read(rest, got, restLen - got);\n                                if (curGot == -1) {\n                                    throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n                                }\n                                got += curGot;\n                            }\n                            // Drop trailing NL\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                        }\n                        break;\n                    }\n                    coll.write((byte) ch);\n                }\n                // Processed single header\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) {\n            // EOF\n            break;\n        }\n    }\n    return headers;\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@parsePaxHeaders\n@@ -25,9 +25,13 @@\n                             headers.remove(keyword);\n                         } else {\n                             final byte[] rest = new byte[restLen];\n-                            final int got = IOUtils.readFully(i, rest);\n-                            if (got != restLen) {\n-                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n+                            int got = 0;\n+                            while (got < restLen) { // Fixes potential overflow bug\n+                                int curGot = i.read(rest, got, restLen - got);\n+                                if (curGot == -1) {\n+                                    throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n+                                }\n+                                got += curGot;\n                             }\n                             // Drop trailing NL\n                             final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n", "finish_reason": "stop", "valid": false, "num": 1}]