[{"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\"))\n                foundCharset = prolog.attr(\"encoding\");\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        doc = parser.parseInput(reader, baseUri);\n        // io exception when parsing (not seen before because reading the stream as we go)\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n", "finish_reason": "stop", "valid": false, "num": 7}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    byte[] firstBytes = new byte[firstReadBufferSize];\n    int offset = 0;\n    int read;\n    while (offset < firstReadBufferSize && (read = input.read(firstBytes, offset, firstReadBufferSize - offset)) != -1) {\n        offset += read;\n    }\n    fullyRead = offset < firstReadBufferSize;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(ByteBuffer.wrap(firstBytes));\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        byte[] docDataBytes = Arrays.copyOfRange(firstBytes, 0, offset);\n        String docData = Charset.forName(defaultCharset).decode(ByteBuffer.wrap(docDataBytes)).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\"))\n                foundCharset = prolog.attr(\"encoding\");\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        doc = parser.parseInput(reader, baseUri);\n        // io exception when parsing (not seen before because reading the stream as we go)\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -8,18 +7,24 @@\n     // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n     // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n-    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n-    fullyRead = input.read() == -1;\n+    byte[] firstBytes = new byte[firstReadBufferSize];\n+    int offset = 0;\n+    int read;\n+    while (offset < firstReadBufferSize && (read = input.read(firstBytes, offset, firstReadBufferSize - offset)) != -1) {\n+        offset += read;\n+    }\n+    fullyRead = offset < firstReadBufferSize;\n     input.reset();\n     // look for BOM - overrides any other header or input\n-    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n+    BomCharset bomCharset = detectCharsetFromBom(ByteBuffer.wrap(firstBytes));\n     if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n         input.skip(bomCharset.offset);\n     }\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n-        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n+        byte[] docDataBytes = Arrays.copyOfRange(firstBytes, 0, offset);\n+        String docData = Charset.forName(defaultCharset).decode(ByteBuffer.wrap(docDataBytes)).toString();\n         doc = parser.parseInput(docData, baseUri);\n         // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n         Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\"))\n                foundCharset = prolog.attr(\"encoding\");\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n\n        InputStreamReader isr = new InputStreamReader(input, charsetName);\n        BufferedReader reader = new BufferedReader(isr, bufferSize);\n        doc = parser.parseInput(reader, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,16 +1,20 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n+\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n+\n     Document doc = null;\n     boolean fullyRead = false;\n+\n     // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n+\n     // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n     ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n     fullyRead = input.read() == -1;\n     input.reset();\n+\n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n     if (bomCharset != null) {\n@@ -55,9 +59,10 @@\n     if (doc == null) {\n         if (charsetName == null)\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n+\n+        InputStreamReader isr = new InputStreamReader(input, charsetName);\n+        BufferedReader reader = new BufferedReader(isr, bufferSize);\n         doc = parser.parseInput(reader, baseUri);\n-        // io exception when parsing (not seen before because reading the stream as we go)\n         doc.outputSettings().charset(charsetName);\n     }\n     input.close();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\"))\n                foundCharset = prolog.attr(\"encoding\");\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        doc = parser.parseInput(reader, baseUri);\n        // io exception when parsing (not seen before because reading the stream as we go)\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,7 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -53,8 +53,9 @@\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n+        }\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n         doc = parser.parseInput(reader, baseUri);\n         // io exception when parsing (not seen before because reading the stream as we go)\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, Charset.forName(charsetName)), bufferSize);\n        doc = parser.parseInput(reader, baseUri);\n        // io exception when parsing (not seen before because reading the stream as we go)\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,7 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -26,18 +26,22 @@\n         // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n+            if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            }\n+            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            }\n+            if (foundCharset != null) {\n                 break;\n+            }\n         }\n         // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n             XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n-            if (prolog.name().equals(\"xml\"))\n+            if (prolog.name().equals(\"xml\")) {\n                 foundCharset = prolog.attr(\"encoding\");\n+            }\n         }\n         foundCharset = validateCharset(foundCharset);\n         if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n@@ -53,9 +57,10 @@\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n+        }\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(input, Charset.forName(charsetName)), bufferSize);\n         doc = parser.parseInput(reader, baseUri);\n         // io exception when parsing (not seen before because reading the stream as we go)\n         doc.outputSettings().charset(charsetName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\"))\n                foundCharset = prolog.attr(\"encoding\");\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize)) {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            throw new IOException(e);\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,29 +1,23 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n-    // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n-    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n     ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n     fullyRead = input.read() == -1;\n     input.reset();\n-    // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n     if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n         input.skip(bomCharset.offset);\n     }\n     if (charsetName == null) {\n-        // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n         doc = parser.parseInput(docData, baseUri);\n-        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n         Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n-        // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n             if (meta.hasAttr(\"http-equiv\"))\n@@ -33,7 +27,6 @@\n             if (foundCharset != null)\n                 break;\n         }\n-        // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n             XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n             if (prolog.name().equals(\"xml\"))\n@@ -41,7 +34,6 @@\n         }\n         foundCharset = validateCharset(foundCharset);\n         if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n-            // need to re-decode. (case insensitive check here to match how validate works)\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n             charsetName = foundCharset;\n             doc = null;\n@@ -49,15 +41,17 @@\n             doc = null;\n         }\n     } else {\n-        // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        doc = parser.parseInput(reader, baseUri);\n-        // io exception when parsing (not seen before because reading the stream as we go)\n+        }\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize)) {\n+            doc = parser.parseInput(reader, baseUri);\n+        } catch (UncheckedIOException e) {\n+            throw new IOException(e);\n+        }\n         doc.outputSettings().charset(charsetName);\n     }\n     input.close();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\"))\n                foundCharset = prolog.attr(\"encoding\");\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        doc = parser.parseInput(reader, baseUri);\n    }\n    doc.outputSettings().charset(charsetName);\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,29 +1,22 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n-    // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n-    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n     ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n     fullyRead = input.read() == -1;\n     input.reset();\n-    // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n     if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n         input.skip(bomCharset.offset);\n     }\n     if (charsetName == null) {\n-        // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n         doc = parser.parseInput(docData, baseUri);\n-        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n         Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n-        // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n             if (meta.hasAttr(\"http-equiv\"))\n@@ -33,7 +26,6 @@\n             if (foundCharset != null)\n                 break;\n         }\n-        // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n             XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n             if (prolog.name().equals(\"xml\"))\n@@ -41,7 +33,6 @@\n         }\n         foundCharset = validateCharset(foundCharset);\n         if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n-            // need to re-decode. (case insensitive check here to match how validate works)\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n             charsetName = foundCharset;\n             doc = null;\n@@ -49,7 +40,6 @@\n             doc = null;\n         }\n     } else {\n-        // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n@@ -57,9 +47,8 @@\n             charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n         doc = parser.parseInput(reader, baseUri);\n-        // io exception when parsing (not seen before because reading the stream as we go)\n-        doc.outputSettings().charset(charsetName);\n     }\n+    doc.outputSettings().charset(charsetName);\n     input.close();\n     return doc;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    int bufferSize = 0;\n    if (input instanceof BufferedInputStream) {\n        bufferSize = ((BufferedInputStream) input).buffer.length;\n    } else {\n        input = new BufferedInputStream(input);\n    }\n    input.mark(bufferSize + 1);\n    Charset charset;\n    try {\n        charset = determineCharsetFromStream(input, charsetName);\n    } finally {\n        input.reset();\n    }\n    BufferedReader reader = new BufferedReader(new InputStreamReader(input, charset));\n    Document doc = parser.parseInput(reader, baseUri);\n    doc.outputSettings().charset(charset.name());\n    return doc;\n}\n\n## Fixed Function 2\nprivate static Charset determineCharsetFromStream(InputStream input, String charsetName) throws IOException {\n    Charset charset = null;\n    byte[] firstBytes = new byte[1024];\n    int offset = 0;\n    int length;\n    while (offset < firstBytes.length && (length = input.read(firstBytes, offset, firstBytes.length - offset)) != -1) {\n        offset += length;\n    }\n    ByteBuffer byteData = ByteBuffer.wrap(firstBytes);\n    String docData = Charset.forName(\"UTF-8\").decode(byteData).toString();\n    InputSource inputSource = new InputSource(new StringReader(docData));\n    String systemId = inputSource.getSystemId();\n    if (systemId != null && systemId.toLowerCase().endsWith(\".xml\")) {\n        charset = getCharsetFromContentType(getContentTypeFromDocument(inputSource));\n    }\n    if (charset == null && charsetName != null) {\n        charset = Charset.forName(charsetName);\n    }\n    if (charset == null) {\n        String contentType = getContentTypeFromDocument(inputSource);\n        charset = getCharsetFromContentType(contentType);\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n    }\n    return charset;\n}\n\n## Fixed Function 3\nprivate static String getContentTypeFromDocument(InputSource inputSource) throws IOException {\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n    documentBuilderFactory.setNamespaceAware(false);\n    documentBuilderFactory.setValidating(false);\n    try {\n        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        documentBuilder.setEntityResolver(NO_OP_ENTITY_RESOLVER);\n        documentBuilder.setErrorHandler(new SAXErrorHandler());\n        org.w3c.dom.Document document = documentBuilder.parse(inputSource);\n        NodeList contentTypeTags = document.getElementsByTagName(\"meta\");\n        for (int i = 0; i < contentTypeTags.getLength(); i++) {\n            org.w3c.dom.Node tag = contentTypeTags.item(i);\n            NamedNodeMap attributes = tag.getAttributes();\n            if (attributes != null) {\n                org.w3c.dom.Node httpEquiv = attributes.getNamedItem(\"http-equiv\");\n                if (httpEquiv != null && httpEquiv.getNodeValue().equalsIgnoreCase(\"content-type\")) {\n                    org.w3c.dom.Node content = attributes.getNamedItem(\"content\");\n                    if (content != null) {\n                        String value = content.getNodeValue();\n                        if (value != null && value.contains(\"=\")) {\n                            String[] split = value.split(\"=\");\n                            if (split.length == 2 && split[0].equalsIgnoreCase(\"charset\")) {\n                                return value.trim();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } catch (ParserConfigurationException e) {\n        throw new RuntimeException(e);\n    } catch (SAXException e) {\n        if (e.getCause() instanceof IOException) {\n            throw (IOException) e.getCause();\n        }\n        throw new RuntimeException(e);\n    }\n    return null;\n}\n\n## Fixed Function 4\nprivate static Charset getCharsetFromContentType(String contentType) {\n    if (contentType == null) {\n        return null;\n    }\n    String[] split = contentType.split(\";\");\n    for (int i = 1; i < split.length; i++) {\n        String part = split[i].trim();\n        if (part.startsWith(\"charset=\")) {\n            String charsetName = part.substring(\"charset=\".length()).trim();\n            if (charsetName.startsWith(\"\\\"\") && charsetName.endsWith(\"\\\"\")) {\n                charsetName = charsetName.substring(1, charsetName.length() - 1);\n            }\n            return Charset.forName(charsetName);\n        }\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,65 +1,22 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n-    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n-    Document doc = null;\n-    boolean fullyRead = false;\n-    // read the start of the stream and look for a BOM or meta charset\n-    input.mark(bufferSize);\n-    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n-    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n-    fullyRead = input.read() == -1;\n-    input.reset();\n-    // look for BOM - overrides any other header or input\n-    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null) {\n-        charsetName = bomCharset.charset;\n-        input.skip(bomCharset.offset);\n     }\n-    if (charsetName == null) {\n-        // determine from meta. safe first parse as UTF-8\n-        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n-        doc = parser.parseInput(docData, baseUri);\n-        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n-        // if not found, will keep utf-8 as best attempt\n-        String foundCharset = null;\n-        for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n-                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n-                foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n-                break;\n-        }\n-        // look for <?xml encoding='ISO-8859-1'?>\n-        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n-            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n-            if (prolog.name().equals(\"xml\"))\n-                foundCharset = prolog.attr(\"encoding\");\n-        }\n-        foundCharset = validateCharset(foundCharset);\n-        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n-            // need to re-decode. (case insensitive check here to match how validate works)\n-            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n-            charsetName = foundCharset;\n-            doc = null;\n-        } else if (!fullyRead) {\n-            doc = null;\n-        }\n+    int bufferSize = 0;\n+    if (input instanceof BufferedInputStream) {\n+        bufferSize = ((BufferedInputStream) input).buffer.length;\n     } else {\n-        // specified by content type header (or by user on file load)\n-        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n+        input = new BufferedInputStream(input);\n     }\n-    if (doc == null) {\n-        if (charsetName == null)\n-            charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        doc = parser.parseInput(reader, baseUri);\n-        // io exception when parsing (not seen before because reading the stream as we go)\n-        doc.outputSettings().charset(charsetName);\n+    input.mark(bufferSize + 1);\n+    Charset charset;\n+    try {\n+        charset = determineCharsetFromStream(input, charsetName);\n+    } finally {\n+        input.reset();\n     }\n-    input.close();\n+    BufferedReader reader = new BufferedReader(new InputStreamReader(input, charset));\n+    Document doc = parser.parseInput(reader, baseUri);\n+    doc.outputSettings().charset(charset.name());\n     return doc;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize)) {\n            doc = parser.parseInput(reader, baseUri);\n            doc.outputSettings().charset(charsetName);\n        } catch (IOException e) {\n            throw new IOException(\"Parsing error\", e);\n        }\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,47 +1,43 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n-    // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n-    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n     ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n     fullyRead = input.read() == -1;\n     input.reset();\n-    // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n     if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n         input.skip(bomCharset.offset);\n     }\n     if (charsetName == null) {\n-        // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n         doc = parser.parseInput(docData, baseUri);\n-        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n         Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n-        // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n+            if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            }\n+            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            }\n+            if (foundCharset != null) {\n                 break;\n+            }\n         }\n-        // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n             XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n-            if (prolog.name().equals(\"xml\"))\n+            if (prolog.name().equals(\"xml\")) {\n                 foundCharset = prolog.attr(\"encoding\");\n+            }\n         }\n         foundCharset = validateCharset(foundCharset);\n         if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n-            // need to re-decode. (case insensitive check here to match how validate works)\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n             charsetName = foundCharset;\n             doc = null;\n@@ -49,16 +45,18 @@\n             doc = null;\n         }\n     } else {\n-        // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        doc = parser.parseInput(reader, baseUri);\n-        // io exception when parsing (not seen before because reading the stream as we go)\n-        doc.outputSettings().charset(charsetName);\n+        }\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize)) {\n+            doc = parser.parseInput(reader, baseUri);\n+            doc.outputSettings().charset(charsetName);\n+        } catch (IOException e) {\n+            throw new IOException(\"Parsing error\", e);\n+        }\n     }\n     input.close();\n     return doc;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        Reader reader = new InputStreamReader(input, Charset.forName(charsetName));\n        doc = parser.parseInput(reader, baseUri);\n        // io exception when parsing (not seen before because reading the stream as we go)\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,7 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -36,8 +36,9 @@\n         // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n             XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n-            if (prolog.name().equals(\"xml\"))\n+            if (prolog.name().equals(\"xml\")) {\n                 foundCharset = prolog.attr(\"encoding\");\n+            }\n         }\n         foundCharset = validateCharset(foundCharset);\n         if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n@@ -53,9 +54,10 @@\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n+        }\n+        Reader reader = new InputStreamReader(input, Charset.forName(charsetName));\n         doc = parser.parseInput(reader, baseUri);\n         // io exception when parsing (not seen before because reading the stream as we go)\n         doc.outputSettings().charset(charsetName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        boolean hasBreak = false;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null) {\n                hasBreak = true;\n                break;\n            }\n        }\n\n        // only need to get charset from xml prolog if not found yet\n        if (foundCharset == null && !hasBreak && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        doc = parser.parseInput(reader, baseUri);\n        // io exception when parsing (not seen before because reading the stream as we go)\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,16 +1,18 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n+\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n+\n     // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n     // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n     ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n     fullyRead = input.read() == -1;\n     input.reset();\n+\n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n     if (bomCharset != null) {\n@@ -25,20 +27,26 @@\n         Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n         // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n+        boolean hasBreak = false;\n         for (Element meta : metaElements) {\n             if (meta.hasAttr(\"http-equiv\"))\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n             if (foundCharset == null && meta.hasAttr(\"charset\"))\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            if (foundCharset != null) {\n+                hasBreak = true;\n                 break;\n+            }\n         }\n-        // look for <?xml encoding='ISO-8859-1'?>\n-        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n+\n+        // only need to get charset from xml prolog if not found yet\n+        if (foundCharset == null && !hasBreak && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n             XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n-            if (prolog.name().equals(\"xml\"))\n+            if (prolog.name().equals(\"xml\")) {\n                 foundCharset = prolog.attr(\"encoding\");\n+            }\n         }\n+\n         foundCharset = validateCharset(foundCharset);\n         if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n             // need to re-decode. (case insensitive check here to match how validate works)\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\"))\n                foundCharset = prolog.attr(\"encoding\");\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        InputStreamReader reader = new InputStreamReader(input, charsetName);\n        doc = parser.parseInput(reader, baseUri);\n        // io exception when parsing (not seen before because reading the stream as we go)\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -55,7 +54,7 @@\n     if (doc == null) {\n         if (charsetName == null)\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n+        InputStreamReader reader = new InputStreamReader(input, charsetName);\n         doc = parser.parseInput(reader, baseUri);\n         // io exception when parsing (not seen before because reading the stream as we go)\n         doc.outputSettings().charset(charsetName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\"))\n                foundCharset = prolog.attr(\"encoding\");\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize)) {\n            doc = parser.parseInput(reader, baseUri);\n            // io exception when parsing (not seen before because reading the stream as we go)\n            doc.outputSettings().charset(charsetName);\n        } catch (Exception e) {\n            throw e;\n        }\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -55,10 +54,13 @@\n     if (doc == null) {\n         if (charsetName == null)\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        doc = parser.parseInput(reader, baseUri);\n-        // io exception when parsing (not seen before because reading the stream as we go)\n-        doc.outputSettings().charset(charsetName);\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize)) {\n+            doc = parser.parseInput(reader, baseUri);\n+            // io exception when parsing (not seen before because reading the stream as we go)\n+            doc.outputSettings().charset(charsetName);\n+        } catch (Exception e) {\n+            throw e;\n+        }\n     }\n     input.close();\n     return doc;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    \n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    \n    input.reset();\n    \n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        input.skip(bomCharset.offset);\n    }\n    \n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\"))\n                foundCharset = prolog.attr(\"encoding\");\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    \n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        doc = parser.parseInput(reader, baseUri);\n        // io exception when parsing (not seen before because reading the stream as we go)\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,22 +1,26 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n+    \n     // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n     // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n     ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n     fullyRead = input.read() == -1;\n+    \n     input.reset();\n+    \n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n     if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n         input.skip(bomCharset.offset);\n     }\n+    \n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n@@ -52,6 +56,7 @@\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n+    \n     if (doc == null) {\n         if (charsetName == null)\n             charsetName = defaultCharset;\n", "finish_reason": "stop", "valid": false, "num": 1}]