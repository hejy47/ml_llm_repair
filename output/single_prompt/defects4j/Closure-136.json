[{"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getCompiler().getSourceMap().getSourceFile(t.getSourceName()));\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (t.getCompiler().isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.input.getOriginalName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        reservedNames.add(name);\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getScope().getNextTempIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input.getOriginalName());\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -2,13 +2,13 @@\n     boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n         // The node we're looking at is a function, so we can add it directly\n-        addSignature(name, node, t.getSourceName());\n+        addSignature(name, node, t.getCompiler().getSourceMap().getSourceFile(t.getSourceName()));\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n         String functionName = node.getString();\n         Scope.Var v = t.getScope().getVar(functionName);\n         if (v == null) {\n-            if (compiler.isIdeMode()) {\n+            if (t.getCompiler().isIdeMode()) {\n                 return;\n             } else {\n                 throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n@@ -16,7 +16,7 @@\n         }\n         Node function = v.getInitialValue();\n         if (function != null && function.getType() == Token.FUNCTION) {\n-            addSignature(name, function, v.getInputName());\n+            addSignature(name, function, v.input.getOriginalName());\n             signatureAdded = true;\n         }\n     }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -24,6 +24,7 @@\n     // Check if we can rename this.\n     if (!okToRenameVar(name, local)) {\n         // Blindly de-uniquify for the Prototype library for issue 103.\n+        reservedNames.add(name);\n         return;\n     }\n     if (isExternsPass_) {\n@@ -35,14 +36,14 @@\n     }\n     if (local) {\n         // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        String tempName = LOCAL_VAR_PREFIX + var.getScope().getNextTempIndex();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n     } else if (var != null) {\n         // Not an extern\n         // If it's global, increment global count\n-        incCount(name, var.input);\n+        incCount(name, var.input.getOriginalName());\n         globalNameNodes.add(n);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getScopeRoot().getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.getOptions().ideMode) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getNode().getSourceFileName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isName()) {\n        String name = n.getString();\n        // Ignore anonymous functions\n        if (name.isEmpty()) {\n            return;\n        }\n        // Is this local or Global?\n        Scope.Var var = t.getScope().getVar(name);\n        boolean local = (var != null) && var.isLocal();\n        // Are we renaming global variables?\n        if (!local && localRenamingOnly) {\n            reservedNames.add(name);\n            return;\n        }\n        // Are we renaming anonymous function names?\n        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n            reservedNames.add(name);\n            return;\n        }\n        // Check if we can rename this.\n        if (!okToRenameVar(name, local)) {\n            // Blindly de-uniquify for the Prototype library for issue 103.\n            return;\n        }\n        if (isExternsPass_) {\n            // Keep track of extern globals.\n            if (!local) {\n                externNames.add(name);\n            }\n            return;\n        }\n        if (local) {\n            // Local var: assign a new name\n            String tempName = LOCAL_VAR_PREFIX + var.getScope().getUniqueNameIdSupplier().get();\n            incCount(tempName, null);\n            localNameNodes.add(n);\n            localTempNames.add(tempName);\n        } else if (var != null) {\n            // Not an extern\n            // If it's global, increment global count\n            incCount(name, var.getNode().getSourceFileName());\n            globalNameNodes.add(n);\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -2,13 +2,13 @@\n     boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n         // The node we're looking at is a function, so we can add it directly\n-        addSignature(name, node, t.getSourceName());\n+        addSignature(name, node, t.getScopeRoot().getSourceName());\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n         String functionName = node.getString();\n         Scope.Var v = t.getScope().getVar(functionName);\n         if (v == null) {\n-            if (compiler.isIdeMode()) {\n+            if (compiler.getOptions().ideMode) {\n                 return;\n             } else {\n                 throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n@@ -16,7 +16,7 @@\n         }\n         Node function = v.getInitialValue();\n         if (function != null && function.getType() == Token.FUNCTION) {\n-            addSignature(name, function, v.getInputName());\n+            addSignature(name, function, v.getNode().getSourceFileName());\n             signatureAdded = true;\n         }\n     }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,48 +1,47 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n-        return;\n-    }\n-    String name = n.getString();\n-    // Ignore anonymous functions\n-    if (name.length() == 0) {\n-        return;\n-    }\n-    // Is this local or Global?\n-    Scope.Var var = t.getScope().getVar(name);\n-    boolean local = (var != null) && var.isLocal();\n-    // Are we renaming global variables?\n-    if (!local && localRenamingOnly) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Check if we can rename this.\n-    if (!okToRenameVar(name, local)) {\n-        // Blindly de-uniquify for the Prototype library for issue 103.\n-        return;\n-    }\n-    if (isExternsPass_) {\n-        // Keep track of extern globals.\n-        if (!local) {\n-            externNames.add(name);\n+    if (n.isName()) {\n+        String name = n.getString();\n+        // Ignore anonymous functions\n+        if (name.isEmpty()) {\n+            return;\n         }\n-        return;\n-    }\n-    if (local) {\n-        // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n-        incCount(tempName, null);\n-        localNameNodes.add(n);\n-        localTempNames.add(tempName);\n-    } else if (var != null) {\n-        // Not an extern\n-        // If it's global, increment global count\n-        incCount(name, var.input);\n-        globalNameNodes.add(n);\n+        // Is this local or Global?\n+        Scope.Var var = t.getScope().getVar(name);\n+        boolean local = (var != null) && var.isLocal();\n+        // Are we renaming global variables?\n+        if (!local && localRenamingOnly) {\n+            reservedNames.add(name);\n+            return;\n+        }\n+        // Are we renaming anonymous function names?\n+        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+            reservedNames.add(name);\n+            return;\n+        }\n+        // Check if we can rename this.\n+        if (!okToRenameVar(name, local)) {\n+            // Blindly de-uniquify for the Prototype library for issue 103.\n+            return;\n+        }\n+        if (isExternsPass_) {\n+            // Keep track of extern globals.\n+            if (!local) {\n+                externNames.add(name);\n+            }\n+            return;\n+        }\n+        if (local) {\n+            // Local var: assign a new name\n+            String tempName = LOCAL_VAR_PREFIX + var.getScope().getUniqueNameIdSupplier().get();\n+            incCount(tempName, null);\n+            localNameNodes.add(n);\n+            localTempNames.add(tempName);\n+        } else if (var != null) {\n+            // Not an extern\n+            // If it's global, increment global count\n+            incCount(name, var.getNode().getSourceFileName());\n+            globalNameNodes.add(n);\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION || node.getType() == Token.FUNCTION_EXPRESSION) { // Fix: checking for Function Expression\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME || NodeUtil.isFunctionDeclaration(n)) { // Fix: checking for Function Declaration\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -1,7 +1,6 @@\n private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n     boolean signatureAdded = false;\n-    if (node.getType() == Token.FUNCTION) {\n-        // The node we're looking at is a function, so we can add it directly\n+    if (node.getType() == Token.FUNCTION || node.getType() == Token.FUNCTION_EXPRESSION) { // Fix: checking for Function Expression\n         addSignature(name, node, t.getSourceName());\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,6 +1,6 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (n.getType() != Token.NAME || NodeUtil.isFunctionDeclaration(n)) { // Fix: checking for Function Declaration\n         return;\n     }\n     String name = n.getString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getModule().getName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getScope().getRootNode().getSourceFileName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isNameDeclaration(var.getParentNode()) &&\n            NodeUtil.isAnonymousFunction(var.getParentNode().getFirstChild())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getScope().getVarCount();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -2,7 +2,7 @@\n     boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n         // The node we're looking at is a function, so we can add it directly\n-        addSignature(name, node, t.getSourceName());\n+        addSignature(name, node, t.getModule().getName());\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n         String functionName = node.getString();\n@@ -16,7 +16,7 @@\n         }\n         Node function = v.getInitialValue();\n         if (function != null && function.getType() == Token.FUNCTION) {\n-            addSignature(name, function, v.getInputName());\n+            addSignature(name, function, v.getScope().getRootNode().getSourceFileName());\n             signatureAdded = true;\n         }\n     }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -17,7 +17,8 @@\n         return;\n     }\n     // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isNameDeclaration(var.getParentNode()) &&\n+            NodeUtil.isAnonymousFunction(var.getParentNode().getFirstChild())) {\n         reservedNames.add(name);\n         return;\n     }\n@@ -35,7 +36,7 @@\n     }\n     if (local) {\n         // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        String tempName = LOCAL_VAR_PREFIX + var.getScope().getVarCount();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.getErrorManager().getTypedPercent(\n                JSError.ErrorType.UNDEFINED_VAR_ERROR) == 100) {\n                // skip trying to add a signature if undefined vars in the code\n                return;\n            }\n            if (compiler.isIdeMode()) {\n                compiler.getErrorManager().report(\n                    JSError.make(\n                        \"Function name not defined. Possible typo or missing type declaration.\"));\n                signatureAdded = true;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames &&\n        var != null && NodeUtil.isNameDeclaration(var.getParentNode()) &&\n        NodeUtil.isAnonymousFunction(var.getParentNode().getFirstChild())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    } else if (parent.getType() == Token.MEMBER_FUNCTION_DEF) {\n        // Method definitions not declared are assumed to be auxiliary and not renamed, but\n        // are still not leaked into the global scope.\n        return;\n    } else if (compiler.getErrorManager().getTypedPercent(JSError.ErrorType.NON_GLOBAL_DECLARATION) < 100) {\n        // Treat all undeclared vars as global vars. This is intentionally\n        // leeking symbols, because otherwise we don't track their origin\n        // What if we are in a function nested inside a class or namespace?\n        // That will be addressed with the tracking origin in the AddTracker pass\n        incCount(name, null);\n        globalNameNodes.add(n);\n    } else {\n        // if there is an error report that a variable is never declared, e.g.:\n        // {@code var x = 3;} {@code void foo(){return x+1;}}\n        compiler.report(t.makeError(n, VarCheck.UNDEFINED_VAR_ERROR));\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -8,8 +8,16 @@\n         String functionName = node.getString();\n         Scope.Var v = t.getScope().getVar(functionName);\n         if (v == null) {\n+            if (compiler.getErrorManager().getTypedPercent(\n+                JSError.ErrorType.UNDEFINED_VAR_ERROR) == 100) {\n+                // skip trying to add a signature if undefined vars in the code\n+                return;\n+            }\n             if (compiler.isIdeMode()) {\n-                return;\n+                compiler.getErrorManager().report(\n+                    JSError.make(\n+                        \"Function name not defined. Possible typo or missing type declaration.\"));\n+                signatureAdded = true;\n             } else {\n                 throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n             }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -17,7 +17,9 @@\n         return;\n     }\n     // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+    if (preserveAnonymousFunctionNames &&\n+        var != null && NodeUtil.isNameDeclaration(var.getParentNode()) &&\n+        NodeUtil.isAnonymousFunction(var.getParentNode().getFirstChild())) {\n         reservedNames.add(name);\n         return;\n     }\n@@ -44,5 +46,20 @@\n         // If it's global, increment global count\n         incCount(name, var.input);\n         globalNameNodes.add(n);\n+    } else if (parent.getType() == Token.MEMBER_FUNCTION_DEF) {\n+        // Method definitions not declared are assumed to be auxiliary and not renamed, but\n+        // are still not leaked into the global scope.\n+        return;\n+    } else if (compiler.getErrorManager().getTypedPercent(JSError.ErrorType.NON_GLOBAL_DECLARATION) < 100) {\n+        // Treat all undeclared vars as global vars. This is intentionally\n+        // leeking symbols, because otherwise we don't track their origin\n+        // What if we are in a function nested inside a class or namespace?\n+        // That will be addressed with the tracking origin in the AddTracker pass\n+        incCount(name, null);\n+        globalNameNodes.add(n);\n+    } else {\n+        // if there is an error report that a variable is never declared, e.g.:\n+        // {@code var x = 3;} {@code void foo(){return x+1;}}\n+        compiler.report(t.makeError(n, VarCheck.UNDEFINED_VAR_ERROR));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getScope().getRootNode().getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getSourceFile().getName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME || NodeUtil.isNameDeclOrSimpleAssignment(n)) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions and variables with empty names\n    if (name.isEmpty() || NodeUtil.isAnonymousFunction(n)) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isNameDeclOrSimpleAssignment(var.getParentNode()) && NodeUtil.isAnonymousFunction(var.getParentNode().getFirstChild())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    } else {\n        // Rename undeclared globals for consistency with global renaming\n        incCount(name, null);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -2,7 +2,7 @@\n     boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n         // The node we're looking at is a function, so we can add it directly\n-        addSignature(name, node, t.getSourceName());\n+        addSignature(name, node, t.getScope().getRootNode().getSourceName());\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n         String functionName = node.getString();\n@@ -16,7 +16,7 @@\n         }\n         Node function = v.getInitialValue();\n         if (function != null && function.getType() == Token.FUNCTION) {\n-            addSignature(name, function, v.getInputName());\n+            addSignature(name, function, v.getSourceFile().getName());\n             signatureAdded = true;\n         }\n     }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,11 +1,11 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (n.getType() != Token.NAME || NodeUtil.isNameDeclOrSimpleAssignment(n)) {\n         return;\n     }\n     String name = n.getString();\n-    // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    // Ignore anonymous functions and variables with empty names\n+    if (name.isEmpty() || NodeUtil.isAnonymousFunction(n)) {\n         return;\n     }\n     // Is this local or Global?\n@@ -17,7 +17,7 @@\n         return;\n     }\n     // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isNameDeclOrSimpleAssignment(var.getParentNode()) && NodeUtil.isAnonymousFunction(var.getParentNode().getFirstChild())) {\n         reservedNames.add(name);\n         return;\n     }\n@@ -44,5 +44,9 @@\n         // If it's global, increment global count\n         incCount(name, var.input);\n         globalNameNodes.add(n);\n+    } else {\n+        // Rename undeclared globals for consistency with global renaming\n+        incCount(name, null);\n+        globalNameNodes.add(n);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getCompiler().getSourceFile(t.getSourceName()));\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (t.getCompiler().isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = NodeUtil.getFunctionBody(v.getNode());\n        if (function != null && function.getType() == Token.BLOCK) {\n            addSignature(name, function, v.getNode().getSourceFileName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (!n.isName()) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0 || NodeUtil.isFunctionExpression(n)) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = var != null && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && NodeUtil.isNameAnonymousFunction(var)) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        if (name.equals(\"$super\") || name.equals(\"$superClass\")) {\n            if (parent.isGetProp()) {\n                n.setString(parent.getLastChild().getString());\n            } else {\n                n.setString(\"super\");\n            }\n        }\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getScope().getClosestHoistScope().getVarCount();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n        var.setNewName(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n        var.setNewName(getUniqueName(name, t.getScope()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -2,21 +2,21 @@\n     boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n         // The node we're looking at is a function, so we can add it directly\n-        addSignature(name, node, t.getSourceName());\n+        addSignature(name, node, t.getCompiler().getSourceFile(t.getSourceName()));\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n         String functionName = node.getString();\n         Scope.Var v = t.getScope().getVar(functionName);\n         if (v == null) {\n-            if (compiler.isIdeMode()) {\n+            if (t.getCompiler().isIdeMode()) {\n                 return;\n             } else {\n                 throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n             }\n         }\n-        Node function = v.getInitialValue();\n-        if (function != null && function.getType() == Token.FUNCTION) {\n-            addSignature(name, function, v.getInputName());\n+        Node function = NodeUtil.getFunctionBody(v.getNode());\n+        if (function != null && function.getType() == Token.BLOCK) {\n+            addSignature(name, function, v.getNode().getSourceFileName());\n             signatureAdded = true;\n         }\n     }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,29 +1,36 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (!n.isName()) {\n         return;\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.length() == 0 || NodeUtil.isFunctionExpression(n)) {\n         return;\n     }\n     // Is this local or Global?\n     Scope.Var var = t.getScope().getVar(name);\n-    boolean local = (var != null) && var.isLocal();\n+    boolean local = var != null && var.isLocal();\n     // Are we renaming global variables?\n     if (!local && localRenamingOnly) {\n         reservedNames.add(name);\n         return;\n     }\n     // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+    if (preserveAnonymousFunctionNames && NodeUtil.isNameAnonymousFunction(var)) {\n         reservedNames.add(name);\n         return;\n     }\n     // Check if we can rename this.\n     if (!okToRenameVar(name, local)) {\n         // Blindly de-uniquify for the Prototype library for issue 103.\n+        if (name.equals(\"$super\") || name.equals(\"$superClass\")) {\n+            if (parent.isGetProp()) {\n+                n.setString(parent.getLastChild().getString());\n+            } else {\n+                n.setString(\"super\");\n+            }\n+        }\n         return;\n     }\n     if (isExternsPass_) {\n@@ -35,14 +42,16 @@\n     }\n     if (local) {\n         // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        String tempName = LOCAL_VAR_PREFIX + var.getScope().getClosestHoistScope().getVarCount();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n+        var.setNewName(tempName);\n     } else if (var != null) {\n         // Not an extern\n         // If it's global, increment global count\n         incCount(name, var.input);\n         globalNameNodes.add(n);\n+        var.setNewName(getUniqueName(name, t.getScope()));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION || node.getType() == Token.FUNCTION_EXPR) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && (function.getType() == Token.FUNCTION || function.getType() == Token.FUNCTION_EXPR)) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0 || NodeUtil.isFunctionDeclaration(n)) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -1,6 +1,6 @@\n private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n     boolean signatureAdded = false;\n-    if (node.getType() == Token.FUNCTION) {\n+    if (node.getType() == Token.FUNCTION || node.getType() == Token.FUNCTION_EXPR) {\n         // The node we're looking at is a function, so we can add it directly\n         addSignature(name, node, t.getSourceName());\n         signatureAdded = true;\n@@ -15,7 +15,7 @@\n             }\n         }\n         Node function = v.getInitialValue();\n-        if (function != null && function.getType() == Token.FUNCTION) {\n+        if (function != null && (function.getType() == Token.FUNCTION || function.getType() == Token.FUNCTION_EXPR)) {\n             addSignature(name, function, v.getInputName());\n             signatureAdded = true;\n         }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -5,7 +5,7 @@\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.length() == 0 || NodeUtil.isFunctionDeclaration(n)) {\n         return;\n     }\n     // Is this local or Global?\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getCompiler().getSourceMap().getSourceFile(t.getSourceName()));\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (t.getCompiler().isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (!n.isName()) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.isEmpty()) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        // Remove this line to fix the bug causing anonymous objects to not be renamed.\n        incCount(name, var != null ? var.input : null);\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -2,13 +2,13 @@\n     boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n         // The node we're looking at is a function, so we can add it directly\n-        addSignature(name, node, t.getSourceName());\n+        addSignature(name, node, t.getCompiler().getSourceMap().getSourceFile(t.getSourceName()));\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n         String functionName = node.getString();\n         Scope.Var v = t.getScope().getVar(functionName);\n         if (v == null) {\n-            if (compiler.isIdeMode()) {\n+            if (t.getCompiler().isIdeMode()) {\n                 return;\n             } else {\n                 throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,11 +1,11 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (!n.isName()) {\n         return;\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.isEmpty()) {\n         return;\n     }\n     // Is this local or Global?\n@@ -24,6 +24,8 @@\n     // Check if we can rename this.\n     if (!okToRenameVar(name, local)) {\n         // Blindly de-uniquify for the Prototype library for issue 103.\n+        // Remove this line to fix the bug causing anonymous objects to not be renamed.\n+        incCount(name, var != null ? var.input : null);\n         return;\n     }\n     if (isExternsPass_) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalArgumentException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getNode();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n == null) {\n        return;\n    }\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    if (name == null || name.isEmpty()) {\n        return;\n    }\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    if (!okToRenameVar(name, local)) {\n        return; // Cannot rename this variable.\n    }\n    if (isExternsPass_) {\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null && !var.isExtern()) {\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -11,10 +11,10 @@\n             if (compiler.isIdeMode()) {\n                 return;\n             } else {\n-                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n+                throw new IllegalArgumentException(\"VarCheck should have caught this undefined function\");\n             }\n         }\n-        Node function = v.getInitialValue();\n+        Node function = v.getNode();\n         if (function != null && function.getType() == Token.FUNCTION) {\n             addSignature(name, function, v.getInputName());\n             signatureAdded = true;\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,47 +1,32 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (n == null) {\n+        return;\n+    }\n     if (n.getType() != Token.NAME) {\n         return;\n     }\n     String name = n.getString();\n-    // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name == null || name.isEmpty()) {\n         return;\n     }\n-    // Is this local or Global?\n     Scope.Var var = t.getScope().getVar(name);\n     boolean local = (var != null) && var.isLocal();\n-    // Are we renaming global variables?\n-    if (!local && localRenamingOnly) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Check if we can rename this.\n     if (!okToRenameVar(name, local)) {\n-        // Blindly de-uniquify for the Prototype library for issue 103.\n-        return;\n+        return; // Cannot rename this variable.\n     }\n     if (isExternsPass_) {\n-        // Keep track of extern globals.\n         if (!local) {\n             externNames.add(name);\n         }\n         return;\n     }\n     if (local) {\n-        // Local var: assign a new name\n         String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n-    } else if (var != null) {\n-        // Not an extern\n-        // If it's global, increment global count\n+    } else if (var != null && !var.isExtern()) {\n         incCount(name, var.input);\n         globalNameNodes.add(n);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getCompiler().getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (t.getCompiler().isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = NodeUtil.getRValueOfLValue(node);\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.input);\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.isEmpty()) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        reservedNames.add(name);\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getName();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -2,21 +2,21 @@\n     boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n         // The node we're looking at is a function, so we can add it directly\n-        addSignature(name, node, t.getSourceName());\n+        addSignature(name, node, t.getCompiler().getSourceName());\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n         String functionName = node.getString();\n         Scope.Var v = t.getScope().getVar(functionName);\n         if (v == null) {\n-            if (compiler.isIdeMode()) {\n+            if (t.getCompiler().isIdeMode()) {\n                 return;\n             } else {\n                 throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n             }\n         }\n-        Node function = v.getInitialValue();\n+        Node function = NodeUtil.getRValueOfLValue(node);\n         if (function != null && function.getType() == Token.FUNCTION) {\n-            addSignature(name, function, v.getInputName());\n+            addSignature(name, function, v.input);\n             signatureAdded = true;\n         }\n     }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -5,7 +5,7 @@\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.isEmpty()) {\n         return;\n     }\n     // Is this local or Global?\n@@ -24,6 +24,7 @@\n     // Check if we can rename this.\n     if (!okToRenameVar(name, local)) {\n         // Blindly de-uniquify for the Prototype library for issue 103.\n+        reservedNames.add(name);\n         return;\n     }\n     if (isExternsPass_) {\n@@ -35,7 +36,7 @@\n     }\n     if (local) {\n         // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        String tempName = LOCAL_VAR_PREFIX + var.getName();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getScope().getRootNode().getSourceFileName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getSourceFileName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.isEmpty()) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming local variables?\n    if (local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isFunctionExpression(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -2,7 +2,7 @@\n     boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n         // The node we're looking at is a function, so we can add it directly\n-        addSignature(name, node, t.getSourceName());\n+        addSignature(name, node, t.getScope().getRootNode().getSourceFileName());\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n         String functionName = node.getString();\n@@ -16,7 +16,7 @@\n         }\n         Node function = v.getInitialValue();\n         if (function != null && function.getType() == Token.FUNCTION) {\n-            addSignature(name, function, v.getInputName());\n+            addSignature(name, function, v.getSourceFileName());\n             signatureAdded = true;\n         }\n     }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -5,19 +5,19 @@\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.isEmpty()) {\n         return;\n     }\n     // Is this local or Global?\n     Scope.Var var = t.getScope().getVar(name);\n     boolean local = (var != null) && var.isLocal();\n-    // Are we renaming global variables?\n-    if (!local && localRenamingOnly) {\n+    // Are we renaming local variables?\n+    if (local && localRenamingOnly) {\n         reservedNames.add(name);\n         return;\n     }\n     // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isFunctionExpression(var.getParentNode())) {\n         reservedNames.add(name);\n         return;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION_DECL || node.getType() == Token.FUNCTION_EXPR) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && (function.getType() == Token.FUNCTION_DECL || function.getType() == Token.FUNCTION_EXPR)) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME || n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        if (parent != null && parent.getType() == Token.CATCH) {\n            // Do not allow renaming of catch parameters\n            return;\n        }\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -1,6 +1,6 @@\n private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n     boolean signatureAdded = false;\n-    if (node.getType() == Token.FUNCTION) {\n+    if (node.getType() == Token.FUNCTION_DECL || node.getType() == Token.FUNCTION_EXPR) {\n         // The node we're looking at is a function, so we can add it directly\n         addSignature(name, node, t.getSourceName());\n         signatureAdded = true;\n@@ -15,7 +15,7 @@\n             }\n         }\n         Node function = v.getInitialValue();\n-        if (function != null && function.getType() == Token.FUNCTION) {\n+        if (function != null && (function.getType() == Token.FUNCTION_DECL || function.getType() == Token.FUNCTION_EXPR)) {\n             addSignature(name, function, v.getInputName());\n             signatureAdded = true;\n         }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,6 +1,6 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (n.getType() != Token.NAME || n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n         return;\n     }\n     String name = n.getString();\n@@ -13,6 +13,10 @@\n     boolean local = (var != null) && var.isLocal();\n     // Are we renaming global variables?\n     if (!local && localRenamingOnly) {\n+        if (parent != null && parent.getType() == Token.CATCH) {\n+            // Do not allow renaming of catch parameters\n+            return;\n+        }\n         reservedNames.add(name);\n         return;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getScope().getRootNode().getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getScopeRoot().getSourceName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (!NodeUtil.isNameDeclaration(n, parent)) {\n        return;\n    }\n    Node firstChild = n.getFirstChild();\n    if (!firstChild.isName()) {\n        return;\n    }\n    String name = firstChild.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(firstChild);\n        localTempNames.add(tempName);\n        firstChild.setString(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(firstChild);\n        String newName = getVariableName(name, var.input);\n        if (!newName.equals(name)) {\n            firstChild.setString(newName);\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -2,7 +2,7 @@\n     boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n         // The node we're looking at is a function, so we can add it directly\n-        addSignature(name, node, t.getSourceName());\n+        addSignature(name, node, t.getScope().getRootNode().getSourceName());\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n         String functionName = node.getString();\n@@ -16,7 +16,7 @@\n         }\n         Node function = v.getInitialValue();\n         if (function != null && function.getType() == Token.FUNCTION) {\n-            addSignature(name, function, v.getInputName());\n+            addSignature(name, function, v.getScopeRoot().getSourceName());\n             signatureAdded = true;\n         }\n     }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,9 +1,13 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (!NodeUtil.isNameDeclaration(n, parent)) {\n         return;\n     }\n-    String name = n.getString();\n+    Node firstChild = n.getFirstChild();\n+    if (!firstChild.isName()) {\n+        return;\n+    }\n+    String name = firstChild.getString();\n     // Ignore anonymous functions\n     if (name.length() == 0) {\n         return;\n@@ -37,12 +41,17 @@\n         // Local var: assign a new name\n         String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n         incCount(tempName, null);\n-        localNameNodes.add(n);\n+        localNameNodes.add(firstChild);\n         localTempNames.add(tempName);\n+        firstChild.setString(tempName);\n     } else if (var != null) {\n         // Not an extern\n         // If it's global, increment global count\n         incCount(name, var.input);\n-        globalNameNodes.add(n);\n+        globalNameNodes.add(firstChild);\n+        String newName = getVariableName(name, var.input);\n+        if (!newName.equals(name)) {\n+            firstChild.setString(newName);\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.isFunction()) { // Changed from getType() == Token.FUNCTION to isFunction()\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isName()) { // Changed from getType() != Token.NAME to isName()\n        String name = n.getString();\n        // Ignore anonymous functions\n        if (name.length() == 0) {\n            return;\n        }\n        // Is this local or Global?\n        Scope.Var var = t.getScope().getVar(name);\n        boolean local = (var != null) && var.isLocal();\n        // Are we renaming global variables?\n        if (!local && localRenamingOnly) {\n            reservedNames.add(name);\n            return;\n        }\n        // Are we renaming anonymous function names?\n        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n            reservedNames.add(name);\n            return;\n        }\n        // Check if we can rename this.\n        if (!okToRenameVar(name, local)) {\n            // Blindly de-uniquify for the Prototype library for issue 103.\n            return;\n        }\n        if (isExternsPass_) {\n            // Keep track of extern globals.\n            if (!local) {\n                externNames.add(name);\n            }\n            return;\n        }\n        if (local) {\n            // Local var: assign a new name\n            String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n            incCount(tempName, null);\n            localNameNodes.add(n);\n            localTempNames.add(tempName);\n        } else if (var != null) {\n            // Not an extern\n            // If it's global, increment global count\n            incCount(name, var.input);\n            globalNameNodes.add(n);\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -15,7 +15,7 @@\n             }\n         }\n         Node function = v.getInitialValue();\n-        if (function != null && function.getType() == Token.FUNCTION) {\n+        if (function != null && function.isFunction()) { // Changed from getType() == Token.FUNCTION to isFunction()\n             addSignature(name, function, v.getInputName());\n             signatureAdded = true;\n         }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,48 +1,47 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n-        return;\n-    }\n-    String name = n.getString();\n-    // Ignore anonymous functions\n-    if (name.length() == 0) {\n-        return;\n-    }\n-    // Is this local or Global?\n-    Scope.Var var = t.getScope().getVar(name);\n-    boolean local = (var != null) && var.isLocal();\n-    // Are we renaming global variables?\n-    if (!local && localRenamingOnly) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Check if we can rename this.\n-    if (!okToRenameVar(name, local)) {\n-        // Blindly de-uniquify for the Prototype library for issue 103.\n-        return;\n-    }\n-    if (isExternsPass_) {\n-        // Keep track of extern globals.\n-        if (!local) {\n-            externNames.add(name);\n+    if (n.isName()) { // Changed from getType() != Token.NAME to isName()\n+        String name = n.getString();\n+        // Ignore anonymous functions\n+        if (name.length() == 0) {\n+            return;\n         }\n-        return;\n-    }\n-    if (local) {\n-        // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n-        incCount(tempName, null);\n-        localNameNodes.add(n);\n-        localTempNames.add(tempName);\n-    } else if (var != null) {\n-        // Not an extern\n-        // If it's global, increment global count\n-        incCount(name, var.input);\n-        globalNameNodes.add(n);\n+        // Is this local or Global?\n+        Scope.Var var = t.getScope().getVar(name);\n+        boolean local = (var != null) && var.isLocal();\n+        // Are we renaming global variables?\n+        if (!local && localRenamingOnly) {\n+            reservedNames.add(name);\n+            return;\n+        }\n+        // Are we renaming anonymous function names?\n+        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+            reservedNames.add(name);\n+            return;\n+        }\n+        // Check if we can rename this.\n+        if (!okToRenameVar(name, local)) {\n+            // Blindly de-uniquify for the Prototype library for issue 103.\n+            return;\n+        }\n+        if (isExternsPass_) {\n+            // Keep track of extern globals.\n+            if (!local) {\n+                externNames.add(name);\n+            }\n+            return;\n+        }\n+        if (local) {\n+            // Local var: assign a new name\n+            String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+            incCount(tempName, null);\n+            localNameNodes.add(n);\n+            localTempNames.add(tempName);\n+        } else if (var != null) {\n+            // Not an extern\n+            // If it's global, increment global count\n+            incCount(name, var.input);\n+            globalNameNodes.add(n);\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION || NodeUtil.isFunctionExpression(node)) {\n        // The node we're looking at is a function or a function expression, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && (function.getType() == Token.FUNCTION || NodeUtil.isFunctionExpression(function))) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0 || NodeUtil.isFunctionDeclaration(n)) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -1,7 +1,7 @@\n private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n     boolean signatureAdded = false;\n-    if (node.getType() == Token.FUNCTION) {\n-        // The node we're looking at is a function, so we can add it directly\n+    if (node.getType() == Token.FUNCTION || NodeUtil.isFunctionExpression(node)) {\n+        // The node we're looking at is a function or a function expression, so we can add it directly\n         addSignature(name, node, t.getSourceName());\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n@@ -15,7 +15,7 @@\n             }\n         }\n         Node function = v.getInitialValue();\n-        if (function != null && function.getType() == Token.FUNCTION) {\n+        if (function != null && (function.getType() == Token.FUNCTION || NodeUtil.isFunctionExpression(function))) {\n             addSignature(name, function, v.getInputName());\n             signatureAdded = true;\n         }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -5,7 +5,7 @@\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.length() == 0 || NodeUtil.isFunctionDeclaration(n)) {\n         return;\n     }\n     // Is this local or Global?\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                // Fix: Set signatureAdded to true to avoid adding name to nonMethodProperties\n                signatureAdded = true;\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0 || parent.getType() == Token.OBJECTLIT) { // Fix: Ignore properties in ObjectLiteral nodes\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -9,6 +9,8 @@\n         Scope.Var v = t.getScope().getVar(functionName);\n         if (v == null) {\n             if (compiler.isIdeMode()) {\n+                // Fix: Set signatureAdded to true to avoid adding name to nonMethodProperties\n+                signatureAdded = true;\n                 return;\n             } else {\n                 throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -5,7 +5,7 @@\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.length() == 0 || parent.getType() == Token.OBJECTLIT) { // Fix: Ignore properties in ObjectLiteral nodes\n         return;\n     }\n     // Is this local or Global?\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getCompiler().getCurrentScriptOrFnName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (t.getCompiler().isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getNode().getSourceFileName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME || n.getBooleanProp(Node.IS_NAMESPACE)) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.isEmpty() || n.isFromExterns()) {\n        return;\n    }\n    // Is this local or Global?\n    boolean local = t.getScope().getVar(name) != null && t.getScope().getVar(name).isLocal();\n\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && NodeUtil.isAnonymousFunctionExpression(n) \n            && NodeUtil.isNameAssignedWithFunction(n.getParent())) {\n        reservedNames.add(name);\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + t.getUniqueNameIdSupplier().get();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else {\n        // If it's global, increment global count\n        incCount(name, null);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -2,13 +2,13 @@\n     boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n         // The node we're looking at is a function, so we can add it directly\n-        addSignature(name, node, t.getSourceName());\n+        addSignature(name, node, t.getCompiler().getCurrentScriptOrFnName());\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n         String functionName = node.getString();\n         Scope.Var v = t.getScope().getVar(functionName);\n         if (v == null) {\n-            if (compiler.isIdeMode()) {\n+            if (t.getCompiler().isIdeMode()) {\n                 return;\n             } else {\n                 throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n@@ -16,7 +16,7 @@\n         }\n         Node function = v.getInitialValue();\n         if (function != null && function.getType() == Token.FUNCTION) {\n-            addSignature(name, function, v.getInputName());\n+            addSignature(name, function, v.getNode().getSourceFileName());\n             signatureAdded = true;\n         }\n     }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,29 +1,25 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (n.getType() != Token.NAME || n.getBooleanProp(Node.IS_NAMESPACE)) {\n         return;\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.isEmpty() || n.isFromExterns()) {\n         return;\n     }\n     // Is this local or Global?\n-    Scope.Var var = t.getScope().getVar(name);\n-    boolean local = (var != null) && var.isLocal();\n+    boolean local = t.getScope().getVar(name) != null && t.getScope().getVar(name).isLocal();\n+\n     // Are we renaming global variables?\n     if (!local && localRenamingOnly) {\n         reservedNames.add(name);\n         return;\n     }\n     // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+    if (preserveAnonymousFunctionNames && NodeUtil.isAnonymousFunctionExpression(n) \n+            && NodeUtil.isNameAssignedWithFunction(n.getParent())) {\n         reservedNames.add(name);\n-        return;\n-    }\n-    // Check if we can rename this.\n-    if (!okToRenameVar(name, local)) {\n-        // Blindly de-uniquify for the Prototype library for issue 103.\n         return;\n     }\n     if (isExternsPass_) {\n@@ -35,14 +31,13 @@\n     }\n     if (local) {\n         // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        String tempName = LOCAL_VAR_PREFIX + t.getUniqueNameIdSupplier().get();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n-    } else if (var != null) {\n-        // Not an extern\n+    } else {\n         // If it's global, increment global count\n-        incCount(name, var.input);\n+        incCount(name, null);\n         globalNameNodes.add(n);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getModule().getName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getSourceFile().getName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.isEmpty()) { \n        return;\n    }\n    // Is this local or global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    Node enclosingFunction = NodeUtil.getEnclosingFunction(n);\n    if (preserveAnonymousFunctionNames && enclosingFunction != null && NodeUtil.isFunctionExpression(enclosingFunction)) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        reservedNames.add(name);\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getScope().getVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -2,7 +2,7 @@\n     boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n         // The node we're looking at is a function, so we can add it directly\n-        addSignature(name, node, t.getSourceName());\n+        addSignature(name, node, t.getModule().getName());\n         signatureAdded = true;\n     } else if (node.getType() == Token.NAME) {\n         String functionName = node.getString();\n@@ -16,7 +16,7 @@\n         }\n         Node function = v.getInitialValue();\n         if (function != null && function.getType() == Token.FUNCTION) {\n-            addSignature(name, function, v.getInputName());\n+            addSignature(name, function, v.getSourceFile().getName());\n             signatureAdded = true;\n         }\n     }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -5,10 +5,10 @@\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.isEmpty()) { \n         return;\n     }\n-    // Is this local or Global?\n+    // Is this local or global?\n     Scope.Var var = t.getScope().getVar(name);\n     boolean local = (var != null) && var.isLocal();\n     // Are we renaming global variables?\n@@ -17,13 +17,15 @@\n         return;\n     }\n     // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+    Node enclosingFunction = NodeUtil.getEnclosingFunction(n);\n+    if (preserveAnonymousFunctionNames && enclosingFunction != null && NodeUtil.isFunctionExpression(enclosingFunction)) {\n         reservedNames.add(name);\n         return;\n     }\n     // Check if we can rename this.\n     if (!okToRenameVar(name, local)) {\n         // Blindly de-uniquify for the Prototype library for issue 103.\n+        reservedNames.add(name);\n         return;\n     }\n     if (isExternsPass_) {\n@@ -35,7 +37,7 @@\n     }\n     if (local) {\n         // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        String tempName = LOCAL_VAR_PREFIX + var.getScope().getVarIndex();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.isFunction()) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.isName()) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null && function.isFunction()) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (!n.isName()) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.isEmpty()) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass()) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalId();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null && !var.isExtern()) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.getInputName());\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n+++ com/google/javascript/jscomp/MethodCompilerPass.java@addPossibleSignature\n@@ -1,10 +1,10 @@\n private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n     boolean signatureAdded = false;\n-    if (node.getType() == Token.FUNCTION) {\n+    if (node.isFunction()) {\n         // The node we're looking at is a function, so we can add it directly\n         addSignature(name, node, t.getSourceName());\n         signatureAdded = true;\n-    } else if (node.getType() == Token.NAME) {\n+    } else if (node.isName()) {\n         String functionName = node.getString();\n         Scope.Var v = t.getScope().getVar(functionName);\n         if (v == null) {\n@@ -15,7 +15,7 @@\n             }\n         }\n         Node function = v.getInitialValue();\n-        if (function != null && function.getType() == Token.FUNCTION) {\n+        if (function != null && function.isFunction()) {\n             addSignature(name, function, v.getInputName());\n             signatureAdded = true;\n         }\n--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,11 +1,11 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (!n.isName()) {\n         return;\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.isEmpty()) {\n         return;\n     }\n     // Is this local or Global?\n@@ -26,7 +26,7 @@\n         // Blindly de-uniquify for the Prototype library for issue 103.\n         return;\n     }\n-    if (isExternsPass_) {\n+    if (isExternsPass()) {\n         // Keep track of extern globals.\n         if (!local) {\n             externNames.add(name);\n@@ -35,14 +35,14 @@\n     }\n     if (local) {\n         // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        String tempName = LOCAL_VAR_PREFIX + var.getLocalId();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n-    } else if (var != null) {\n+    } else if (var != null && !var.isExtern()) {\n         // Not an extern\n         // If it's global, increment global count\n-        incCount(name, var.input);\n+        incCount(name, var.getInputName());\n         globalNameNodes.add(n);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]