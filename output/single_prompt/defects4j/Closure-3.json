[{"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true, false);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    CfgNode root = cfg.createSyntheticCfgNode();\n    cfg.connect(root, cfg.getEntry());\n    cfg.connect(cfg.getExit(), root);\n    cfg.connect(root, cfa.getCfg().getEntry());\n    cfg.connect(cfa.getCfg().getExit(), root);\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isSimpleAssignment(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO:user -- Could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correct, inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                case Token.CALL:\n                case Token.FUNCTION:\n                case Token.CLASS:\n                case Token.ARRAY_PATTERN:\n                case Token.DEFAULT_VALUE:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CtrlFlowGraph<Node> graph = CtrlFlowGraph.builder(compiler)\n          .root(getDefCfgNode().getParent())\n          .build();\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck =\n          new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n              cfg, graph.getDirectedGraphNode(getDefCfgNode()),\n              graph.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE,\n              Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n              false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,18 +1,22 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n         return;\n     }\n     // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true, false);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n     cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n+    CfgNode root = cfg.createSyntheticCfgNode();\n+    cfg.connect(root, cfg.getEntry());\n+    cfg.connect(cfg.getExit(), root);\n+    cfg.connect(root, cfa.getCfg().getEntry());\n+    cfg.connect(cfa.getCfg().getExit(), root);\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isSimpleAssignment(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -40,10 +40,10 @@\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n+    // TODO:user -- Could inline all the uses if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n-    // correctly inlining twice increases code size.\n+    // correct, inlining twice increases code size.\n     if (numUseWithinUseCfgNode != 1) {\n         return false;\n     }\n@@ -78,6 +78,11 @@\n                 case Token.OBJECTLIT:\n                 case Token.REGEXP:\n                 case Token.NEW:\n+                case Token.CALL:\n+                case Token.FUNCTION:\n+                case Token.CLASS:\n+                case Token.ARRAY_PATTERN:\n+                case Token.DEFAULT_VALUE:\n                     return true;\n             }\n             return false;\n@@ -96,9 +101,17 @@\n     // they are just next to each other.\n     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n+        // elsewhere along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n-        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        CtrlFlowGraph<Node> graph = CtrlFlowGraph.builder(compiler)\n+          .root(getDefCfgNode().getParent())\n+          .build();\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck =\n+          new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n+              cfg, graph.getDirectedGraphNode(getDefCfgNode()),\n+              graph.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE,\n+              Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n+              false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n             return false;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(defCfgNode, null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO:user We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, defCfgNode);\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, Predicates.not(isFunction()))) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(defCfgNode.getParent()) && defCfgNode.getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(defCfgNode), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -11,14 +11,14 @@\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfa.process(null, t.getScopeRoot());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -11,7 +11,7 @@\n             return false;\n         }\n     }\n-    getDefinition(getDefCfgNode(), null);\n+    getDefinition(defCfgNode, null);\n     getNumUseInUseCfgNode(useCfgNode, null);\n     // Definition was not found.\n     if (def == null) {\n@@ -25,7 +25,7 @@\n     // The right of the definition has side effect:\n     // Example, for x:\n     // x = readProp(b), modifyProp(b); print(x);\n-    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n+    if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) {\n         return false;\n     }\n     // Similar check as the above but this time, all the sub-expressions\n@@ -40,7 +40,7 @@\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n+    // TODO:user We could inline all the uses if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n     // correctly inlining twice increases code size.\n@@ -51,7 +51,7 @@\n     if (NodeUtil.isWithinLoop(use)) {\n         return false;\n     }\n-    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n+    Collection<Node> uses = reachingUses.getUses(varName, defCfgNode);\n     if (uses.size() != 1) {\n         return false;\n     }\n@@ -82,23 +82,16 @@\n             }\n             return false;\n         }\n-    }, new Predicate<Node>() {\n-\n-        @Override\n-        public boolean apply(Node input) {\n-            // Recurse if the node is not a function.\n-            return !input.isFunction();\n-        }\n-    })) {\n+    }, Predicates.not(isFunction()))) {\n         return false;\n     }\n     // We can skip the side effect check along the paths of two nodes if\n     // they are just next to each other.\n-    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+    if (NodeUtil.isStatementBlock(defCfgNode.getParent()) && defCfgNode.getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n         // else where along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n-        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(defCfgNode), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n             return false;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates.\n    new NodeTraversal(compiler, new GatherCandiates(cfg, t.getScope(), reachingDef)).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction() || getDefCfgNode().isCatch()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop.\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in detail\n    // at what j is and what x is trying to look into.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, Predicates.not(NodeUtil::isFunction))) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -17,8 +17,8 @@\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    // candidates.\n+    new NodeTraversal(compiler, new GatherCandiates(cfg, t.getScope(), reachingDef)).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -1,6 +1,6 @@\n private boolean canInline() {\n     // Cannot inline a parameter.\n-    if (getDefCfgNode().isFunction()) {\n+    if (getDefCfgNode().isFunction() || getDefCfgNode().isCatch()) {\n         return false;\n     }\n     // If one of our dependencies has been inlined, then our dependency\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -47,7 +47,7 @@\n     if (numUseWithinUseCfgNode != 1) {\n         return false;\n     }\n-    // Make sure that the name is not within a loop\n+    // Make sure that the name is not within a loop.\n     if (NodeUtil.isWithinLoop(use)) {\n         return false;\n     }\n@@ -62,11 +62,8 @@\n     // Example:\n     // var x = a.b.c; j.c = 1; print(x);\n     // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n-    // TODO(user): We could get more accuracy by looking more in-detail\n-    // what j is and what x is trying to into to.\n-    // TODO(johnlenz): rework catch expression handling when we\n-    // have lexical scope support so catch expressions don't\n-    // need to be special cased.\n+    // TODO(user): We could get more accuracy by looking more in detail\n+    // at what j is and what x is trying to look into.\n     if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n \n         @Override\n@@ -82,23 +79,16 @@\n             }\n             return false;\n         }\n-    }, new Predicate<Node>() {\n-\n-        @Override\n-        public boolean apply(Node input) {\n-            // Recurse if the node is not a function.\n-            return !input.isFunction();\n-        }\n-    })) {\n+    }, Predicates.not(NodeUtil::isFunction))) {\n         return false;\n     }\n     // We can skip the side effect check along the paths of two nodes if\n     // they are just next to each other.\n     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n+        // elsewhere along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n-        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n             return false;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline(reachingUses, inlinedNewDependencies)) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline(MaybeReachingVariableUse reachingUses, Set<Var> inlinedNewDependencies) {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO:user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop.\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,18 +18,17 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n     for (Candidate c : candidates) {\n-        if (c.canInline()) {\n+        if (c.canInline(reachingUses, inlinedNewDependencies)) {\n             c.inlineVariable();\n             // If definition c has dependencies, then inlining it may have\n             // introduced new dependencies for our other inlining candidates.\n             //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n+            // MustBeReachingVariableDef uses this dependency graph in its analysis, so some of these candidates may no longer be valid.\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n             if (!c.defMetadata.depends.isEmpty()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isParamList()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO:user: We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO:user: We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !NodeUtil.isFunctionExpression(input)\n                && !NodeUtil.isFunctionDeclaration(input);\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent())\n        && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck =\n            new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode),\n                SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -11,14 +11,14 @@\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfa.process(null, t.getScopeRoot());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -1,6 +1,6 @@\n private boolean canInline() {\n     // Cannot inline a parameter.\n-    if (getDefCfgNode().isFunction()) {\n+    if (getDefCfgNode().isParamList()) {\n         return false;\n     }\n     // If one of our dependencies has been inlined, then our dependency\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -40,7 +40,7 @@\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n+    // TODO:user: We could inline all the uses if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n     // correctly inlining twice increases code size.\n@@ -62,7 +62,7 @@\n     // Example:\n     // var x = a.b.c; j.c = 1; print(x);\n     // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n-    // TODO(user): We could get more accuracy by looking more in-detail\n+    // TODO:user: We could get more accuracy by looking more in-detail\n     // what j is and what x is trying to into to.\n     // TODO(johnlenz): rework catch expression handling when we\n     // have lexical scope support so catch expressions don't\n@@ -87,18 +87,23 @@\n         @Override\n         public boolean apply(Node input) {\n             // Recurse if the node is not a function.\n-            return !input.isFunction();\n+            return !NodeUtil.isFunctionExpression(input)\n+                && !NodeUtil.isFunctionDeclaration(input);\n         }\n     })) {\n         return false;\n     }\n     // We can skip the side effect check along the paths of two nodes if\n     // they are just next to each other.\n-    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent())\n+        && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n         // else where along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n-        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck =\n+            new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n+                cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode),\n+                SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n             return false;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction() || NodeUtil.isNameDeclaration(getDefCfgNode())) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -1,6 +1,6 @@\n private boolean canInline() {\n     // Cannot inline a parameter.\n-    if (getDefCfgNode().isFunction()) {\n+    if (getDefCfgNode().isFunction() || NodeUtil.isNameDeclaration(getDefCfgNode())) {\n         return false;\n     }\n     // If one of our dependencies has been inlined, then our dependency\n@@ -17,6 +17,10 @@\n     if (def == null) {\n         return false;\n     }\n+    // Check that the name is not within a loop\n+    if (NodeUtil.isWithinLoop(use)) {\n+        return false;\n+    }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n     if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n@@ -28,7 +32,7 @@\n     if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n         return false;\n     }\n-    // Similar check as the above but this time, all the sub-expressions\n+    // Similar check as above but this time, all the sub-expressions\n     // left of the use of the variable.\n     // x = readProp(b); modifyProp(b), print(x);\n     if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n@@ -40,15 +44,10 @@\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n     // correctly inlining twice increases code size.\n     if (numUseWithinUseCfgNode != 1) {\n-        return false;\n-    }\n-    // Make sure that the name is not within a loop\n-    if (NodeUtil.isWithinLoop(use)) {\n         return false;\n     }\n     Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n@@ -96,7 +95,7 @@\n     // they are just next to each other.\n     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n+        // elsewhere along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even brother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction() || getDefCfgNode().isCatch()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE, useCfgNode)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE, getDefCfgNode())) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeTraversal.hasSideEffect(\n            def.getLastChild(), compiler, NodeUtil.SideEffectOptions.MAY_HAVE_SIDE_EFFECTS)) {\n        return false;\n    }\n    // TODO:user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1 || reachingUses.getUses(varName, getDefCfgNode()).size() != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop.\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch (input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if they are just next to each\n    // other.\n    // Similar side effect check as above but this time the side effect is else where along the path.\n    // x = readProp(b); while(modifyProp(b)) {}; print(x);\n    if (!NodeUtil.isStatementBlock(getDefCfgNode().getParent())) {\n        return true;\n    }\n    ControlFlowGraph<Node> graph = reachingUses.getCfg();\n    if (getDefCfgNode().getNext() == useCfgNode) {\n        return true;\n    }\n    Stack<TraversalPath<Node, ControlFlowGraph.Branch>> stack =\n            new Stack<TraversalPath<Node, ControlFlowGraph.Branch>>();\n    ControlFlowGraph.Branch root = new ControlFlowGraph.Branch() {};\n    stack.push(new TraversalPath<Node, ControlFlowGraph.Branch>(\n            graph.getDirectedGraphNode(getDefCfgNode()), root));\n    while (!stack.isEmpty()) {\n        TraversalPath<Node, ControlFlowGraph.Branch> currentPath = stack.pop();\n        String message = currentPath.predicateOutput;\n        ControlFlowGraph.Branch currentBranching = currentPath.endBranch;\n        ControlFlowGraph.Branch startingBranch = (currentPath.getPathLength() == 1) ? root :\n                currentPath.get(currentPath.getPathLength() - 2).getPayload();\n        if (!CheckSideEffectLoop.containsStatement(\n                startingBranch, currentBranching, SIDE_EFFECT_PREDICATE, message)) {\n            continue;\n        }\n        if (currentPath.end().equals(graph.getDirectedGraphNode(useCfgNode))) {\n            return false;\n        }\n        stack.addAll(currentPath.extend(SIDE_EFFECT_PREDICATE));\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -1,6 +1,6 @@\n private boolean canInline() {\n     // Cannot inline a parameter.\n-    if (getDefCfgNode().isFunction()) {\n+    if (getDefCfgNode().isFunction() || getDefCfgNode().isCatch()) {\n         return false;\n     }\n     // If one of our dependencies has been inlined, then our dependency\n@@ -19,40 +19,37 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n     // Example, for x:\n     // x = readProp(b), modifyProp(b); print(x);\n-    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n+    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE, useCfgNode)) {\n         return false;\n     }\n     // Similar check as the above but this time, all the sub-expressions\n     // left of the use of the variable.\n     // x = readProp(b); modifyProp(b), print(x);\n-    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n+    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE, getDefCfgNode())) {\n         return false;\n     }\n     // TODO(user): Side-effect is OK sometimes. As long as there are no\n     // side-effect function down all paths to the use. Once we have all the\n     // side-effect analysis tool.\n-    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n+    if (NodeTraversal.hasSideEffect(\n+            def.getLastChild(), compiler, NodeUtil.SideEffectOptions.MAY_HAVE_SIDE_EFFECTS)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n+    // TODO:user): We could inline all the uses if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n     // correctly inlining twice increases code size.\n-    if (numUseWithinUseCfgNode != 1) {\n+    if (numUseWithinUseCfgNode != 1 || reachingUses.getUses(varName, getDefCfgNode()).size() != 1) {\n         return false;\n     }\n-    // Make sure that the name is not within a loop\n+    // Make sure that the name is not within a loop.\n     if (NodeUtil.isWithinLoop(use)) {\n-        return false;\n-    }\n-    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n-    if (uses.size() != 1) {\n         return false;\n     }\n     // We give up inlining stuff with R-Value that has:\n@@ -71,7 +68,7 @@\n \n         @Override\n         public boolean apply(Node input) {\n-            switch(input.getType()) {\n+            switch (input.getType()) {\n                 case Token.GETELEM:\n                 case Token.GETPROP:\n                 case Token.ARRAYLIT:\n@@ -92,16 +89,36 @@\n     })) {\n         return false;\n     }\n-    // We can skip the side effect check along the paths of two nodes if\n-    // they are just next to each other.\n-    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n-        // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n-        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n-        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n-        if (pathCheck.somePathsSatisfyPredicate()) {\n+    // We can skip the side effect check along the paths of two nodes if they are just next to each\n+    // other.\n+    // Similar side effect check as above but this time the side effect is else where along the path.\n+    // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+    if (!NodeUtil.isStatementBlock(getDefCfgNode().getParent())) {\n+        return true;\n+    }\n+    ControlFlowGraph<Node> graph = reachingUses.getCfg();\n+    if (getDefCfgNode().getNext() == useCfgNode) {\n+        return true;\n+    }\n+    Stack<TraversalPath<Node, ControlFlowGraph.Branch>> stack =\n+            new Stack<TraversalPath<Node, ControlFlowGraph.Branch>>();\n+    ControlFlowGraph.Branch root = new ControlFlowGraph.Branch() {};\n+    stack.push(new TraversalPath<Node, ControlFlowGraph.Branch>(\n+            graph.getDirectedGraphNode(getDefCfgNode()), root));\n+    while (!stack.isEmpty()) {\n+        TraversalPath<Node, ControlFlowGraph.Branch> currentPath = stack.pop();\n+        String message = currentPath.predicateOutput;\n+        ControlFlowGraph.Branch currentBranching = currentPath.endBranch;\n+        ControlFlowGraph.Branch startingBranch = (currentPath.getPathLength() == 1) ? root :\n+                currentPath.get(currentPath.getPathLength() - 2).getPayload();\n+        if (!CheckSideEffectLoop.containsStatement(\n+                startingBranch, currentBranching, SIDE_EFFECT_PREDICATE, message)) {\n+            continue;\n+        }\n+        if (currentPath.end().equals(graph.getDirectedGraphNode(useCfgNode))) {\n             return false;\n         }\n+        stack.addAll(currentPath.extend(SIDE_EFFECT_PREDICATE));\n     }\n     return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverseScopedNodes(t.getScope());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverseScopedNodes(t.getScope());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -96,7 +96,7 @@\n     // they are just next to each other.\n     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n+        // elsewhere along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    Node functionBody = t.getScopeRoot().getLastChild();\n    if (functionBody.getFirstChild() != null) { // Ignore empty functions\n        cfa.process(null, functionBody);\n        cfg = cfa.getCfg();\n        reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n        reachingDef.analyze();\n        candidates = Lists.newLinkedList();\n        // Using the forward reaching definition search to find all the inline\n        // candidates\n        new NodeTraversal(compiler, new GatherCandidates()).traverse(functionBody);\n        // Compute the backward reaching use. The CFG can be reused.\n        reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n        reachingUses.analyze();\n        for (Candidate c : candidates) {\n            if (c.canInline()) {\n                c.inlineVariable();\n                // If definition c has dependencies, then inlining it may have\n                // introduced new dependencies for our other inlining candidates.\n                //\n                // MustBeReachingVariableDef uses this dependency graph in its\n                // analysis, so some of these candidates may no longer be valid.\n                // We keep track of when the variable dependency graph changed\n                // so that we can back off appropriately.\n                if (!c.defMetadata.depends.isEmpty()) {\n                    inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n                }\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction() || getDefCfgNode().isParamList()) {\n        return false;\n    }\n\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n\n    getDefinition(getDefCfgNode(), null);\n    if (def == null) { // Definition was not found.\n        return false;\n    }\n\n    // Check that the assignment isn't used as a R-value.\n    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def.getParent())) {\n        return false;\n    }\n\n    // Ensure that right-hand side of the definition doesn't have side effects.\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n\n    // Ensure that left-hand side of the use doesn't have side effects.\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n\n    // Ensure that the right-hand side of the definition doesn't have any\n    // side effects anywhere in the program.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n\n    // Ensure that the name is not within a loop.\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n\n    // Ensure that the variable is only used once.\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n\n    // Ensure that the definition and use nodes are not part of a finally block\n    // as we cannot determine when the inlined code would be executed in this case.\n    if (NodeUtil.isInFinallyBlock(getDefCfgNode()) || NodeUtil.isInFinallyBlock(useCfgNode)) {\n        return false;\n    }\n\n    // We give up inlining stuff with R-values that have:\n    // 1. GETPROP, GETELEM, or CALL nodes.\n    // 2. Regexp, object literal, or array literal nodes.\n    // 3. Direct reference to catch expressions.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch (input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.CALL:\n                    return true;\n                case Token.REGEXP:\n                case Token.OBJECTLIT:\n                case Token.ARRAYLIT:\n                    // 1 is required because the ContainsReferencesOnlyPredicate skips empty nodes.\n                    return NodeUtil.has(input.getLastChild(), Predicates.alwaysTrue(), Predicates.<Node>equalTo(input)) && input.getFirstChild().hasChildren();\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n\n    // Ensure that inlining twice does not increase code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -11,29 +11,32 @@\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+    Node functionBody = t.getScopeRoot().getLastChild();\n+    if (functionBody.getFirstChild() != null) { // Ignore empty functions\n+        cfa.process(null, functionBody);\n+        cfg = cfa.getCfg();\n+        reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+        reachingDef.analyze();\n+        candidates = Lists.newLinkedList();\n+        // Using the forward reaching definition search to find all the inline\n+        // candidates\n+        new NodeTraversal(compiler, new GatherCandidates()).traverse(functionBody);\n+        // Compute the backward reaching use. The CFG can be reused.\n+        reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+        reachingUses.analyze();\n+        for (Candidate c : candidates) {\n+            if (c.canInline()) {\n+                c.inlineVariable();\n+                // If definition c has dependencies, then inlining it may have\n+                // introduced new dependencies for our other inlining candidates.\n+                //\n+                // MustBeReachingVariableDef uses this dependency graph in its\n+                // analysis, so some of these candidates may no longer be valid.\n+                // We keep track of when the variable dependency graph changed\n+                // so that we can back off appropriately.\n+                if (!c.defMetadata.depends.isEmpty()) {\n+                    inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+                }\n             }\n         }\n     }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -1,8 +1,9 @@\n private boolean canInline() {\n     // Cannot inline a parameter.\n-    if (getDefCfgNode().isFunction()) {\n+    if (getDefCfgNode().isFunction() || getDefCfgNode().isParamList()) {\n         return false;\n     }\n+\n     // If one of our dependencies has been inlined, then our dependency\n     // graph is wrong. Re-computing it would take another CFG computation,\n     // so we just back off for now.\n@@ -11,74 +12,71 @@\n             return false;\n         }\n     }\n+\n     getDefinition(getDefCfgNode(), null);\n-    getNumUseInUseCfgNode(useCfgNode, null);\n-    // Definition was not found.\n-    if (def == null) {\n+    if (def == null) { // Definition was not found.\n         return false;\n     }\n-    // Check that the assignment isn't used as a R-Value.\n-    // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+\n+    // Check that the assignment isn't used as a R-value.\n+    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def.getParent())) {\n         return false;\n     }\n-    // The right of the definition has side effect:\n-    // Example, for x:\n-    // x = readProp(b), modifyProp(b); print(x);\n+\n+    // Ensure that right-hand side of the definition doesn't have side effects.\n     if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n         return false;\n     }\n-    // Similar check as the above but this time, all the sub-expressions\n-    // left of the use of the variable.\n-    // x = readProp(b); modifyProp(b), print(x);\n+\n+    // Ensure that left-hand side of the use doesn't have side effects.\n     if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n         return false;\n     }\n-    // TODO(user): Side-effect is OK sometimes. As long as there are no\n-    // side-effect function down all paths to the use. Once we have all the\n-    // side-effect analysis tool.\n+\n+    // Ensure that the right-hand side of the definition doesn't have any\n+    // side effects anywhere in the program.\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n-    // Finally we have to make sure that there are no more than one use\n-    // in the program and in the CFG node. Even when it is semantically\n-    // correctly inlining twice increases code size.\n-    if (numUseWithinUseCfgNode != 1) {\n-        return false;\n-    }\n-    // Make sure that the name is not within a loop\n+\n+    // Ensure that the name is not within a loop.\n     if (NodeUtil.isWithinLoop(use)) {\n         return false;\n     }\n+\n+    // Ensure that the variable is only used once.\n     Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n     if (uses.size() != 1) {\n         return false;\n     }\n-    // We give up inlining stuff with R-Value that has:\n-    // 1) GETPROP, GETELEM,\n-    // 2) anything that creates a new object.\n-    // 3) a direct reference to a catch expression.\n+\n+    // Ensure that the definition and use nodes are not part of a finally block\n+    // as we cannot determine when the inlined code would be executed in this case.\n+    if (NodeUtil.isInFinallyBlock(getDefCfgNode()) || NodeUtil.isInFinallyBlock(useCfgNode)) {\n+        return false;\n+    }\n+\n+    // We give up inlining stuff with R-values that have:\n+    // 1. GETPROP, GETELEM, or CALL nodes.\n+    // 2. Regexp, object literal, or array literal nodes.\n+    // 3. Direct reference to catch expressions.\n     // Example:\n     // var x = a.b.c; j.c = 1; print(x);\n     // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n-    // TODO(user): We could get more accuracy by looking more in-detail\n-    // what j is and what x is trying to into to.\n-    // TODO(johnlenz): rework catch expression handling when we\n-    // have lexical scope support so catch expressions don't\n-    // need to be special cased.\n     if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n \n         @Override\n         public boolean apply(Node input) {\n-            switch(input.getType()) {\n+            switch (input.getType()) {\n                 case Token.GETELEM:\n                 case Token.GETPROP:\n+                case Token.CALL:\n+                    return true;\n+                case Token.REGEXP:\n+                case Token.OBJECTLIT:\n                 case Token.ARRAYLIT:\n-                case Token.OBJECTLIT:\n-                case Token.REGEXP:\n-                case Token.NEW:\n-                    return true;\n+                    // 1 is required because the ContainsReferencesOnlyPredicate skips empty nodes.\n+                    return NodeUtil.has(input.getLastChild(), Predicates.alwaysTrue(), Predicates.<Node>equalTo(input)) && input.getFirstChild().hasChildren();\n             }\n             return false;\n         }\n@@ -92,16 +90,11 @@\n     })) {\n         return false;\n     }\n-    // We can skip the side effect check along the paths of two nodes if\n-    // they are just next to each other.\n-    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n-        // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n-        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n-        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n-        if (pathCheck.somePathsSatisfyPredicate()) {\n-            return false;\n-        }\n+\n+    // Ensure that inlining twice does not increase code size.\n+    if (numUseWithinUseCfgNode != 1) {\n+        return false;\n     }\n+\n     return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction() || getDefCfgNode().getParent().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use) || NodeUtil.isWithinLoop(getDefCfgNode())) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n            switch (input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                case Token.OPTCHAIN_GETELEM:\n                case Token.OPTCHAIN_GETPROP:\n                case Token.OPTCHAIN_CALL:\n                case Token.OPTCHAIN_GETELEM_NULLISH:\n                case Token.OPTCHAIN_GETPROP_NULLISH:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -1,6 +1,6 @@\n private boolean canInline() {\n     // Cannot inline a parameter.\n-    if (getDefCfgNode().isFunction()) {\n+    if (getDefCfgNode().isFunction() || getDefCfgNode().getParent().isFunction()) {\n         return false;\n     }\n     // If one of our dependencies has been inlined, then our dependency\n@@ -48,7 +48,7 @@\n         return false;\n     }\n     // Make sure that the name is not within a loop\n-    if (NodeUtil.isWithinLoop(use)) {\n+    if (NodeUtil.isWithinLoop(use) || NodeUtil.isWithinLoop(getDefCfgNode())) {\n         return false;\n     }\n     Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n@@ -68,22 +68,25 @@\n     // have lexical scope support so catch expressions don't\n     // need to be special cased.\n     if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n-\n         @Override\n         public boolean apply(Node input) {\n-            switch(input.getType()) {\n+            switch (input.getType()) {\n                 case Token.GETELEM:\n                 case Token.GETPROP:\n                 case Token.ARRAYLIT:\n                 case Token.OBJECTLIT:\n                 case Token.REGEXP:\n                 case Token.NEW:\n+                case Token.OPTCHAIN_GETELEM:\n+                case Token.OPTCHAIN_GETPROP:\n+                case Token.OPTCHAIN_CALL:\n+                case Token.OPTCHAIN_GETELEM_NULLISH:\n+                case Token.OPTCHAIN_GETPROP_NULLISH:\n                     return true;\n             }\n             return false;\n         }\n     }, new Predicate<Node>() {\n-\n         @Override\n         public boolean apply(Node input) {\n             // Recurse if the node is not a function.\n@@ -98,7 +101,7 @@\n         // Similar side effect check as above but this time the side effect is\n         // else where along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n-        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n             return false;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode());\n    getNumUseInUseCfgNode(useCfgNode);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -11,14 +11,14 @@\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfa.process(null, t.getScopeRoot());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -11,8 +11,8 @@\n             return false;\n         }\n     }\n-    getDefinition(getDefCfgNode(), null);\n-    getNumUseInUseCfgNode(useCfgNode, null);\n+    getDefinition(getDefCfgNode());\n+    getNumUseInUseCfgNode(useCfgNode);\n     // Definition was not found.\n     if (def == null) {\n         return false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    CfgFinder cfgFinder = new CfgFinder();\n    Node exeEnv = new Node(Token.EMPTY);\n    cfgFinder.process(null, t.getScopeRoot());\n    ControlFlowGraph<Node> functionBodyCfg = cfgFinder.getCfg();\n    cfg = cfgFinder.extract(t.getScopeRoot(), functionBodyCfg);\n    deptNodeFinder = new DeptNodesFinder();\n    deptNodes = deptNodeFinder.computeDeptNodes(cfgFinder.otherLoops, cfgFinder.backEdges, cfg, t);\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler, deptNodes, exeEnv);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates(cfgFinder, t.getScope(), deptNodeFinder, exeEnv)).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction() || NodeUtil.isNameDeclaration(getDefCfgNode())) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    if (NodeUtil.isVarOrSimpleAssignLhs(use)) {\n        // We can't use inline var that is a simple assign in all occurence of the name\n        if (!isLhsOfAssignOrIncOrDec(use)) {\n            return false;\n        }\n    } else {\n        // We can't inline var if the variable is a part of a larger expression.\n        if (!isExpressionTreeRoot(use)) {\n            return false;\n        }\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -12,13 +12,19 @@\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n     cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    CfgFinder cfgFinder = new CfgFinder();\n+    Node exeEnv = new Node(Token.EMPTY);\n+    cfgFinder.process(null, t.getScopeRoot());\n+    ControlFlowGraph<Node> functionBodyCfg = cfgFinder.getCfg();\n+    cfg = cfgFinder.extract(t.getScopeRoot(), functionBodyCfg);\n+    deptNodeFinder = new DeptNodesFinder();\n+    deptNodes = deptNodeFinder.computeDeptNodes(cfgFinder.otherLoops, cfgFinder.backEdges, cfg, t);\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler, deptNodes, exeEnv);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates(cfgFinder, t.getScope(), deptNodeFinder, exeEnv)).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -1,6 +1,6 @@\n private boolean canInline() {\n     // Cannot inline a parameter.\n-    if (getDefCfgNode().isFunction()) {\n+    if (getDefCfgNode().isFunction() || NodeUtil.isNameDeclaration(getDefCfgNode())) {\n         return false;\n     }\n     // If one of our dependencies has been inlined, then our dependency\n@@ -16,6 +16,17 @@\n     // Definition was not found.\n     if (def == null) {\n         return false;\n+    }\n+    if (NodeUtil.isVarOrSimpleAssignLhs(use)) {\n+        // We can't use inline var that is a simple assign in all occurence of the name\n+        if (!isLhsOfAssignOrIncOrDec(use)) {\n+            return false;\n+        }\n+    } else {\n+        // We can't inline var if the variable is a part of a larger expression.\n+        if (!isExpressionTreeRoot(use)) {\n+            return false;\n+        }\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n@@ -40,7 +51,6 @@\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n     // correctly inlining twice increases code size.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has a side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO:user We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correct, inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO:user We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO:user: rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), input -> {\n            switch (input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n                default:\n                    return false;\n            }\n        }, input -> {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -19,10 +19,10 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n         return false;\n     }\n-    // The right of the definition has side effect:\n+    // The right of the definition has a side effect:\n     // Example, for x:\n     // x = readProp(b), modifyProp(b); print(x);\n     if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n@@ -40,10 +40,10 @@\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n+    // TODO:user We could inline all the uses if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n-    // correctly inlining twice increases code size.\n+    // correct, inlining twice increases code size.\n     if (numUseWithinUseCfgNode != 1) {\n         return false;\n     }\n@@ -62,16 +62,13 @@\n     // Example:\n     // var x = a.b.c; j.c = 1; print(x);\n     // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n-    // TODO(user): We could get more accuracy by looking more in-detail\n+    // TODO:user We could get more accuracy by looking more in-detail\n     // what j is and what x is trying to into to.\n-    // TODO(johnlenz): rework catch expression handling when we\n+    // TODO:user: rework catch expression handling when we\n     // have lexical scope support so catch expressions don't\n     // need to be special cased.\n-    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n-\n-        @Override\n-        public boolean apply(Node input) {\n-            switch(input.getType()) {\n+    if (NodeUtil.has(def.getLastChild(), input -> {\n+            switch (input.getType()) {\n                 case Token.GETELEM:\n                 case Token.GETPROP:\n                 case Token.ARRAYLIT:\n@@ -79,24 +76,20 @@\n                 case Token.REGEXP:\n                 case Token.NEW:\n                     return true;\n+                default:\n+                    return false;\n             }\n-            return false;\n-        }\n-    }, new Predicate<Node>() {\n-\n-        @Override\n-        public boolean apply(Node input) {\n+        }, input -> {\n             // Recurse if the node is not a function.\n             return !input.isFunction();\n-        }\n-    })) {\n+        })) {\n         return false;\n     }\n     // We can skip the side effect check along the paths of two nodes if\n     // they are just next to each other.\n     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n+        // elsewhere along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    // We need to collect all the new variables we inline at this level of the tree\n    List<Var> inlinedNewDependenciesAtThisLevel = new LinkedList<>();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            //\n            // Updating inlinedNewDependencies on every loop causes problems if a dependency is removed and were inlined.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependenciesAtThisLevel.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n    inlinedNewDependencies.addAll(inlinedNewDependenciesAtThisLevel);\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def)) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    Node right = def.getLastChild();\n    if (NodeUtil.has(right, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                    return true;\n                case Token.NEW:\n                    return input.getFirstChild().matchesQualifiedName(\"Object\");\n                case Token.CALL:\n                    return input.getFirstChild().matchesQualifiedName(\"goog.defineClass\") || input.getFirstChild().matchesQualifiedName(\"goog.reflect.objectProperty\");\n                case Token.ASSIGN:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    if (NodeUtil.hasCatchScope(def)) {\n      return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -22,6 +22,8 @@\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n+    // We need to collect all the new variables we inline at this level of the tree\n+    List<Var> inlinedNewDependenciesAtThisLevel = new LinkedList<>();\n     for (Candidate c : candidates) {\n         if (c.canInline()) {\n             c.inlineVariable();\n@@ -32,9 +34,12 @@\n             // analysis, so some of these candidates may no longer be valid.\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n+            //\n+            // Updating inlinedNewDependencies on every loop causes problems if a dependency is removed and were inlined.\n             if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+                inlinedNewDependenciesAtThisLevel.add(t.getScope().getVar(c.varName));\n             }\n         }\n     }\n+    inlinedNewDependencies.addAll(inlinedNewDependenciesAtThisLevel);\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def)) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -67,17 +67,20 @@\n     // TODO(johnlenz): rework catch expression handling when we\n     // have lexical scope support so catch expressions don't\n     // need to be special cased.\n-    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n+    Node right = def.getLastChild();\n+    if (NodeUtil.has(right, new Predicate<Node>() {\n \n         @Override\n         public boolean apply(Node input) {\n             switch(input.getType()) {\n                 case Token.GETELEM:\n                 case Token.GETPROP:\n-                case Token.ARRAYLIT:\n-                case Token.OBJECTLIT:\n-                case Token.REGEXP:\n+                    return true;\n                 case Token.NEW:\n+                    return input.getFirstChild().matchesQualifiedName(\"Object\");\n+                case Token.CALL:\n+                    return input.getFirstChild().matchesQualifiedName(\"goog.defineClass\") || input.getFirstChild().matchesQualifiedName(\"goog.reflect.objectProperty\");\n+                case Token.ASSIGN:\n                     return true;\n             }\n             return false;\n@@ -92,11 +95,14 @@\n     })) {\n         return false;\n     }\n+    if (NodeUtil.hasCatchScope(def)) {\n+      return false;\n+    }\n     // We can skip the side effect check along the paths of two nodes if\n     // they are just next to each other.\n     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n+        // elsewhere along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode() == null || getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO:user We could inline all of the usages if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO:user We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n            switch (input.getType()) {\n                case GETELEM:\n                case GETPROP:\n                case ARRAYLIT:\n                case OBJECTLIT:\n                case REGEXP:\n                case NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n        // Recurse if the node is not a function.\n        @Override\n        public boolean apply(Node input) {\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -1,6 +1,6 @@\n private boolean canInline() {\n     // Cannot inline a parameter.\n-    if (getDefCfgNode().isFunction()) {\n+    if (getDefCfgNode() == null || getDefCfgNode().isFunction()) {\n         return false;\n     }\n     // If one of our dependencies has been inlined, then our dependency\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -40,7 +40,7 @@\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n+    // TODO:user We could inline all of the usages if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n     // correctly inlining twice increases code size.\n@@ -62,31 +62,29 @@\n     // Example:\n     // var x = a.b.c; j.c = 1; print(x);\n     // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n-    // TODO(user): We could get more accuracy by looking more in-detail\n+    // TODO:user We could get more accuracy by looking more in-detail\n     // what j is and what x is trying to into to.\n     // TODO(johnlenz): rework catch expression handling when we\n     // have lexical scope support so catch expressions don't\n     // need to be special cased.\n     if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n-\n         @Override\n         public boolean apply(Node input) {\n-            switch(input.getType()) {\n-                case Token.GETELEM:\n-                case Token.GETPROP:\n-                case Token.ARRAYLIT:\n-                case Token.OBJECTLIT:\n-                case Token.REGEXP:\n-                case Token.NEW:\n+            switch (input.getType()) {\n+                case GETELEM:\n+                case GETPROP:\n+                case ARRAYLIT:\n+                case OBJECTLIT:\n+                case REGEXP:\n+                case NEW:\n                     return true;\n             }\n             return false;\n         }\n     }, new Predicate<Node>() {\n-\n+        // Recurse if the node is not a function.\n         @Override\n         public boolean apply(Node input) {\n-            // Recurse if the node is not a function.\n             return !input.isFunction();\n         }\n     })) {\n@@ -96,7 +94,7 @@\n     // they are just next to each other.\n     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n+        // elsewhere along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduce new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction() || getDefCfgNode().isParamList()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def)) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (NodeTraversal.hasSideEffect(def.getLastChild())) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (NodeTraversal.hasSideEffectBetween(def.getNext(), use)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO: Remove this restriction once inlining non-expressions has better support.\n    if (!NodeUtil.isExpressionResultUsed(use)) {\n        return false;\n    }\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (!reachingUses.isSingleUse(getDefCfgNode(), varName, use)) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO: We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO: remove catch special casing once catch expressions don't need to be special cased.\n    if (NodeTraversal.containsGetElemOrProp(def.getLastChild())) {\n        return false;\n    }\n    if (NodeTraversal.containsNew(def.getLastChild())) {\n        return false;\n    }\n    if (NodeTraversal.containsCatchExpression(def.getLastChild())) {\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -11,14 +11,14 @@\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfa.process(null, t.getScopeRoot());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n@@ -26,7 +26,7 @@\n         if (c.canInline()) {\n             c.inlineVariable();\n             // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n+            // introduce new dependencies for our other inlining candidates.\n             //\n             // MustBeReachingVariableDef uses this dependency graph in its\n             // analysis, so some of these candidates may no longer be valid.\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -1,6 +1,6 @@\n private boolean canInline() {\n     // Cannot inline a parameter.\n-    if (getDefCfgNode().isFunction()) {\n+    if (getDefCfgNode().isFunction() || getDefCfgNode().isParamList()) {\n         return false;\n     }\n     // If one of our dependencies has been inlined, then our dependency\n@@ -19,19 +19,19 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def)) {\n         return false;\n     }\n     // The right of the definition has side effect:\n     // Example, for x:\n     // x = readProp(b), modifyProp(b); print(x);\n-    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n+    if (NodeTraversal.hasSideEffect(def.getLastChild())) {\n         return false;\n     }\n     // Similar check as the above but this time, all the sub-expressions\n     // left of the use of the variable.\n     // x = readProp(b); modifyProp(b), print(x);\n-    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n+    if (NodeTraversal.hasSideEffectBetween(def.getNext(), use)) {\n         return false;\n     }\n     // TODO(user): Side-effect is OK sometimes. As long as there are no\n@@ -40,11 +40,14 @@\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n+    // TODO: Remove this restriction once inlining non-expressions has better support.\n+    if (!NodeUtil.isExpressionResultUsed(use)) {\n+        return false;\n+    }\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n     // correctly inlining twice increases code size.\n-    if (numUseWithinUseCfgNode != 1) {\n+    if (!reachingUses.isSingleUse(getDefCfgNode(), varName, use)) {\n         return false;\n     }\n     // Make sure that the name is not within a loop\n@@ -62,46 +65,17 @@\n     // Example:\n     // var x = a.b.c; j.c = 1; print(x);\n     // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n-    // TODO(user): We could get more accuracy by looking more in-detail\n+    // TODO: We could get more accuracy by looking more in-detail\n     // what j is and what x is trying to into to.\n-    // TODO(johnlenz): rework catch expression handling when we\n-    // have lexical scope support so catch expressions don't\n-    // need to be special cased.\n-    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n-\n-        @Override\n-        public boolean apply(Node input) {\n-            switch(input.getType()) {\n-                case Token.GETELEM:\n-                case Token.GETPROP:\n-                case Token.ARRAYLIT:\n-                case Token.OBJECTLIT:\n-                case Token.REGEXP:\n-                case Token.NEW:\n-                    return true;\n-            }\n-            return false;\n-        }\n-    }, new Predicate<Node>() {\n-\n-        @Override\n-        public boolean apply(Node input) {\n-            // Recurse if the node is not a function.\n-            return !input.isFunction();\n-        }\n-    })) {\n+    // TODO: remove catch special casing once catch expressions don't need to be special cased.\n+    if (NodeTraversal.containsGetElemOrProp(def.getLastChild())) {\n         return false;\n     }\n-    // We can skip the side effect check along the paths of two nodes if\n-    // they are just next to each other.\n-    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n-        // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n-        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n-        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n-        if (pathCheck.somePathsSatisfyPredicate()) {\n-            return false;\n-        }\n+    if (NodeTraversal.containsNew(def.getLastChild())) {\n+        return false;\n+    }\n+    if (NodeTraversal.containsCatchExpression(def.getLastChild())) {\n+        return false;\n     }\n     return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def)) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO[user]: We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop.\n    Node ancestor = use.getAncestor(whileLoopOpsPredicate);\n    if (ancestor != null) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and b alias a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch (input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def)) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -40,15 +40,16 @@\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n+    // TODO[user]: We could inline all the uses if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n     // correctly inlining twice increases code size.\n     if (numUseWithinUseCfgNode != 1) {\n         return false;\n     }\n-    // Make sure that the name is not within a loop\n-    if (NodeUtil.isWithinLoop(use)) {\n+    // Make sure that the name is not within a loop.\n+    Node ancestor = use.getAncestor(whileLoopOpsPredicate);\n+    if (ancestor != null) {\n         return false;\n     }\n     Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n@@ -61,7 +62,7 @@\n     // 3) a direct reference to a catch expression.\n     // Example:\n     // var x = a.b.c; j.c = 1; print(x);\n-    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n+    // Inlining print(a.b.c) is not safe consider j and b alias a.b.\n     // TODO(user): We could get more accuracy by looking more in-detail\n     // what j is and what x is trying to into to.\n     // TODO(johnlenz): rework catch expression handling when we\n@@ -71,7 +72,7 @@\n \n         @Override\n         public boolean apply(Node input) {\n-            switch(input.getType()) {\n+            switch (input.getType()) {\n                 case Token.GETELEM:\n                 case Token.GETPROP:\n                 case Token.ARRAYLIT:\n@@ -96,7 +97,7 @@\n     // they are just next to each other.\n     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n+        // elsewhere along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild().getFirstChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def)) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO:user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO:user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -11,14 +11,14 @@\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfa.process(null, t.getScopeRoot().getLastChild().getFirstChild());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def)) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -40,7 +40,7 @@\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n+    // TODO:user): We could inline all the uses if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n     // correctly inlining twice increases code size.\n@@ -62,7 +62,7 @@\n     // Example:\n     // var x = a.b.c; j.c = 1; print(x);\n     // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n-    // TODO(user): We could get more accuracy by looking more in-detail\n+    // TODO:user): We could get more accuracy by looking more in-detail\n     // what j is and what x is trying to into to.\n     // TODO(johnlenz): rework catch expression handling when we\n     // have lexical scope support so catch expressions don't\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.getDefMetadata().getDepends().isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.getVarName()));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : getDefMetadata().getDepends()) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (getNumUseWithinUseCfgNode() != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(getVarName(), getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n@@ -32,8 +32,8 @@\n             // analysis, so some of these candidates may no longer be valid.\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            if (!c.getDefMetadata().getDepends().isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.getVarName()));\n             }\n         }\n     }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -6,7 +6,7 @@\n     // If one of our dependencies has been inlined, then our dependency\n     // graph is wrong. Re-computing it would take another CFG computation,\n     // so we just back off for now.\n-    for (Var dependency : defMetadata.depends) {\n+    for (Var dependency : getDefMetadata().getDepends()) {\n         if (inlinedNewDependencies.contains(dependency)) {\n             return false;\n         }\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -44,14 +44,14 @@\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n     // correctly inlining twice increases code size.\n-    if (numUseWithinUseCfgNode != 1) {\n+    if (getNumUseWithinUseCfgNode() != 1) {\n         return false;\n     }\n     // Make sure that the name is not within a loop\n     if (NodeUtil.isWithinLoop(use)) {\n         return false;\n     }\n-    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n+    Collection<Node> uses = reachingUses.getUses(getVarName(), getDefCfgNode());\n     if (uses.size() != 1) {\n         return false;\n     }\n@@ -96,7 +96,7 @@\n     // they are just next to each other.\n     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n+        // elsewhere along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(c.getVar());\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction() || getDefCfgNode().isParamList()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO:user: We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // Check whether the assignment is used in an \"for in\" loop where\n    // the object being looped over and the assignment definition are\n    // the same. This can be inlined as the \"for in\" loop only happens once.\n    if (NodeUtil.isEnhancedFor(getDefCfgNode().getParent())\n        && getDefCfgNode().getSecondChild().matchesQualifiedName(varName)\n        && uses.iterator().next().getParent().matchesQualifiedName(NodeUtil.getLoopVariableNode(getDefCfgNode().getParent()).getString())) {\n      return true;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n@@ -33,7 +33,7 @@\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n             if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+                inlinedNewDependencies.add(c.getVar());\n             }\n         }\n     }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javacanInline\n@@ -1,6 +1,6 @@\n private boolean canInline() {\n     // Cannot inline a parameter.\n-    if (getDefCfgNode().isFunction()) {\n+    if (getDefCfgNode().isFunction() || getDefCfgNode().isParamList()) {\n         return false;\n     }\n     // If one of our dependencies has been inlined, then our dependency\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -40,7 +40,7 @@\n     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n     }\n-    // TODO(user): We could inline all the uses if the expression is short.\n+    // TODO:user: We could inline all the uses if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n     // in the program and in the CFG node. Even when it is semantically\n     // correctly inlining twice increases code size.\n@@ -54,6 +54,14 @@\n     Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n     if (uses.size() != 1) {\n         return false;\n+    }\n+    // Check whether the assignment is used in an \"for in\" loop where\n+    // the object being looped over and the assignment definition are\n+    // the same. This can be inlined as the \"for in\" loop only happens once.\n+    if (NodeUtil.isEnhancedFor(getDefCfgNode().getParent())\n+        && getDefCfgNode().getSecondChild().matchesQualifiedName(varName)\n+        && uses.iterator().next().getParent().matchesQualifiedName(NodeUtil.getLoopVariableNode(getDefCfgNode().getParent()).getString())) {\n+      return true;\n     }\n     // We give up inlining stuff with R-Value that has:\n     // 1) GETPROP, GETELEM,\n@@ -96,7 +104,7 @@\n     // they are just next to each other.\n     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n+        // elsewhere along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n", "finish_reason": "stop", "valid": false, "num": 1}]