[{"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            offset++;\n            if (date.length() > offset) {\n                hour = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                if (date.length() > offset) {\n                    minutes = parseInt(date, offset, offset += 2);\n                    if (checkOffset(date, offset, ':')) {\n                        offset += 1;\n                    }\n                    if (date.length() > offset) {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1;\n                            // assume at least one digit\n                            int endOffset = indexOfNonDigit(date, offset + 1);\n                            // parse up to 3 digits\n                            int parseEndOffset = Math.min(endOffset, offset + 3);\n                            int fraction = parseInt(date, offset, parseEndOffset);\n                            // compensate for \"missing\" digits\n                            switch(parseEndOffset - offset) {\n                                case 2:\n                                    milliseconds = fraction * 10;\n                                    break;\n                                case 1:\n                                    milliseconds = fraction * 100;\n                                    break;\n                                default:\n                                    milliseconds = fraction;\n                            }\n                            offset = endOffset;\n                        }\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone;\n        char timezoneIndicator = date.charAt(offset);\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n            offset += timezoneOffset.length();\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                timezoneOffset = timezoneOffset.substring(0, 3) + ':' + timezoneOffset.substring(3);\n                String timezoneId = \"GMT\" + timezoneOffset;\n                timezone = TimeZone.getTimeZone(timezoneId);\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -29,43 +29,39 @@\n         }\n         if (hasT) {\n             // extract hours, minutes, seconds and milliseconds\n-            hour = parseInt(date, offset += 1, offset += 2);\n-            if (checkOffset(date, offset, ':')) {\n-                offset += 1;\n-            }\n-            minutes = parseInt(date, offset, offset += 2);\n-            if (checkOffset(date, offset, ':')) {\n-                offset += 1;\n-            }\n-            // second and milliseconds can be optional\n+            offset++;\n             if (date.length() > offset) {\n-                char c = date.charAt(offset);\n-                if (c != 'Z' && c != '+' && c != '-') {\n-                    seconds = parseInt(date, offset, offset += 2);\n-                    // truncate up to 3 leap seconds\n-                    if (seconds > 59 && seconds < 63)\n-                        seconds = 59;\n-                    // milliseconds can be optional in the format\n-                    if (checkOffset(date, offset, '.')) {\n+                hour = parseInt(date, offset, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+                if (date.length() > offset) {\n+                    minutes = parseInt(date, offset, offset += 2);\n+                    if (checkOffset(date, offset, ':')) {\n                         offset += 1;\n-                        // assume at least one digit\n-                        int endOffset = indexOfNonDigit(date, offset + 1);\n-                        // parse up to 3 digits\n-                        int parseEndOffset = Math.min(endOffset, offset + 3);\n-                        int fraction = parseInt(date, offset, parseEndOffset);\n-                        // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n-                            case 2:\n-                                milliseconds = fraction * 10;\n-                                break;\n-                            case 1:\n-                                milliseconds = fraction * 100;\n-                                break;\n-                            default:\n-                                milliseconds = fraction;\n+                    }\n+                    if (date.length() > offset) {\n+                        seconds = parseInt(date, offset, offset += 2);\n+                        if (checkOffset(date, offset, '.')) {\n+                            offset += 1;\n+                            // assume at least one digit\n+                            int endOffset = indexOfNonDigit(date, offset + 1);\n+                            // parse up to 3 digits\n+                            int parseEndOffset = Math.min(endOffset, offset + 3);\n+                            int fraction = parseInt(date, offset, parseEndOffset);\n+                            // compensate for \"missing\" digits\n+                            switch(parseEndOffset - offset) {\n+                                case 2:\n+                                    milliseconds = fraction * 10;\n+                                    break;\n+                                case 1:\n+                                    milliseconds = fraction * 100;\n+                                    break;\n+                                default:\n+                                    milliseconds = fraction;\n+                            }\n+                            offset = endOffset;\n                         }\n-                        offset = endOffset;\n                     }\n                 }\n             }\n@@ -74,7 +70,7 @@\n         if (date.length() <= offset) {\n             throw new IllegalArgumentException(\"No time zone indicator\");\n         }\n-        TimeZone timezone = null;\n+        TimeZone timezone;\n         char timezoneIndicator = date.charAt(offset);\n         if (timezoneIndicator == 'Z') {\n             timezone = TIMEZONE_UTC;\n@@ -83,20 +79,15 @@\n             String timezoneOffset = date.substring(offset);\n             // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n             offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n             if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                 timezone = TIMEZONE_UTC;\n             } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n+                timezoneOffset = timezoneOffset.substring(0, 3) + ':' + timezoneOffset.substring(3);\n                 String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n                 timezone = TimeZone.getTimeZone(timezoneId);\n                 String act = timezone.getID();\n                 if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n+                    String cleaned = act.replace(\":\", \"\");\n                     if (!cleaned.equals(timezoneId)) {\n                         throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    // truncate up to 3 leap seconds\n                    if (seconds > 59 && seconds < 63)\n                        seconds = 59;\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        int startOffset = offset + 1;\n                        int endOffset = startOffset + 3 < date.length() ? startOffset + 3 : date.length();\n                        offset = startOffset + 1;\n                        try {\n                            milliseconds = Integer.parseInt(date.substring(startOffset, endOffset));\n                        } catch (NumberFormatException ex) {\n                            // ignore\n                        }\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n            offset += timezoneOffset.length();\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -47,25 +47,14 @@\n                         seconds = 59;\n                     // milliseconds can be optional in the format\n                     if (checkOffset(date, offset, '.')) {\n-                        offset += 1;\n-                        // assume at least one digit\n-                        int endOffset = indexOfNonDigit(date, offset + 1);\n-                        // parse up to 3 digits\n-                        int parseEndOffset = Math.min(endOffset, offset + 3);\n-                        int fraction = parseInt(date, offset, parseEndOffset);\n-                        // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n-                            case 2:\n-                                milliseconds = fraction * 10;\n-                                break;\n-                            case 1:\n-                                milliseconds = fraction * 100;\n-                                break;\n-                            default:\n-                                milliseconds = fraction;\n+                        int startOffset = offset + 1;\n+                        int endOffset = startOffset + 3 < date.length() ? startOffset + 3 : date.length();\n+                        offset = startOffset + 1;\n+                        try {\n+                            milliseconds = Integer.parseInt(date.substring(startOffset, endOffset));\n+                        } catch (NumberFormatException ex) {\n+                            // ignore\n                         }\n-                        offset = endOffset;\n                     }\n                 }\n             }\n@@ -83,24 +72,10 @@\n             String timezoneOffset = date.substring(offset);\n             // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n             offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n             if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                 timezone = TIMEZONE_UTC;\n             } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n-                }\n+                timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n             }\n         } else {\n             throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c == '.') {\n                    offset += 1;\n                    int endOffset = indexOfNonDigit(date, offset + 1);\n                    int parseEndOffset = Math.min(endOffset, offset + 3);\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (offset < parseEndOffset) {\n                        int fraction = parseInt(date, offset + 1, parseEndOffset);\n                        int multiplier = (int) Math.pow(10, 3 - (parseEndOffset - offset - 1));\n                        milliseconds = multiplier * fraction;\n                    }\n                } else if (c == 'Z') {\n                    offset += 1;\n                } else if (c == '+' || c == '-') {\n                    offset += 1;\n                    int tzHour = parseInt(date, offset, offset += 2);\n                    if (checkOffset(date, offset, ':')) {\n                        offset += 1;\n                    }\n                    int tzMin = parseInt(date, offset, offset += 2);\n                    timezone = (c == '+') ? GMT_TIMEZONE : GMT_TIMEZONE_NEGATIVE;\n                    calendar.setTimeZone(timezone);\n                    hour -= tzHour;\n                    minutes -= tzMin;\n                } else {\n                    throw new ParseException(\"No time zone indicator\", offset);\n                }\n            }\n        }\n        Calendar calendar = new GregorianCalendar(GMT_TIMEZONE);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}\n\n## Fixed Function 2\npublic static <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException {\n    try {\n        T object =  constructorConstructor.get(classOfT).construct();\n\n        JsonDeserializationContext context = new JsonDeserializationContext() {\n            public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n                return gson.fromJson(json, typeOfT);\n            }\n\n            public JsonElement serialize(Object src, Type typeOfSrc) {\n                return gson.toJsonTree(src, typeOfSrc);\n            }\n        };\n        FieldNamingStrategy2 fieldNamingStrategyForDeserialize = fieldNamingStrategy == null\n                ? FieldNamingPolicy.IDENTITY\n                : fieldNamingStrategy;\n        deserialize(context, json, object, fieldNamingStrategyForDeserialize);\n\n        return object;\n    } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n    } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n    } catch (InvocationTargetException e) {\n        if (e.getCause() instanceof RuntimeException) {\n            throw (RuntimeException) e.getCause();\n        }\n        if (e.getCause() instanceof Error) {\n            throw (Error) e.getCause();\n        }\n        throw new AssertionError(e.getCause());\n    }\n}\n\nprivate static void deserialize(JsonDeserializationContext context, JsonElement json, Object object,\n                                 FieldNamingStrategy2 fieldNamingPolicy) throws JsonParseException, IllegalAccessException {\n    Class<?> objectClass = object.getClass();\n    JsonObject jsonObject = json.getAsJsonObject();\n    for (Map.Entry<String, JsonElement> entry : jsonObject.entrySet()) {\n        String name = entry.getKey();\n        FieldNamingStrategy2 namePolicy = getFieldNamingPolicy(fieldNamingPolicy, name, objectClass);\n        Field field = null;\n        try {\n            field = getField(objectClass, namePolicy.translateName(name));\n        } catch (NoSuchFieldException e) {\n            // ignore\n        }\n        if (field != null) {\n            boolean fieldAccessibility = field.isAccessible();\n            field.setAccessible(true);\n            TypeAdapter<?> adapter = getAdapter(context, field, getFieldGenericType(objectClass, field));\n            Object value = adapter.fromJsonElement(entry.getValue());\n            field.set(object, value);\n            field.setAccessible(fieldAccessibility);\n        }\n    }\n}\n\nprivate static FieldNamingStrategy2 getFieldNamingPolicy(FieldNamingStrategy2 fieldNamingPolicy, String name, Class<?> objectClass) {\n    return fieldNamingPolicy != null ? fieldNamingPolicy : gson.fieldNamingStrategy().getFieldNamingPolicy(name, objectClass);\n}\n\n@SuppressWarnings({\"unchecked\"})\nprivate static <T> TypeAdapter<T> getAdapter(JsonDeserializationContext context, Field f, Type type) {\n    TypeAdapter<?> adapter = getTypeAdapter(gson, context, type);\n    return (TypeAdapter<T>) adapter;\n}\n\nprivate static Type getFieldGenericType(Class<?> objectClass, Field field) {\n    return $Gson$Types.resolve(objectClass, field.getGenericType());\n}\n\nprivate static Field getField(Class<?> objectClass, String name) throws NoSuchFieldException {\n    try {\n        return objectClass.getDeclaredField(name);\n    } catch (NoSuchFieldException e) {\n        Class<?> superclass = objectClass.getSuperclass();\n        if (superclass == null) {\n            throw e;\n        }\n        return getField(superclass, name);\n    }\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -40,72 +40,35 @@\n             // second and milliseconds can be optional\n             if (date.length() > offset) {\n                 char c = date.charAt(offset);\n-                if (c != 'Z' && c != '+' && c != '-') {\n+                if (c == '.') {\n+                    offset += 1;\n+                    int endOffset = indexOfNonDigit(date, offset + 1);\n+                    int parseEndOffset = Math.min(endOffset, offset + 3);\n                     seconds = parseInt(date, offset, offset += 2);\n-                    // truncate up to 3 leap seconds\n-                    if (seconds > 59 && seconds < 63)\n-                        seconds = 59;\n-                    // milliseconds can be optional in the format\n-                    if (checkOffset(date, offset, '.')) {\n+                    if (offset < parseEndOffset) {\n+                        int fraction = parseInt(date, offset + 1, parseEndOffset);\n+                        int multiplier = (int) Math.pow(10, 3 - (parseEndOffset - offset - 1));\n+                        milliseconds = multiplier * fraction;\n+                    }\n+                } else if (c == 'Z') {\n+                    offset += 1;\n+                } else if (c == '+' || c == '-') {\n+                    offset += 1;\n+                    int tzHour = parseInt(date, offset, offset += 2);\n+                    if (checkOffset(date, offset, ':')) {\n                         offset += 1;\n-                        // assume at least one digit\n-                        int endOffset = indexOfNonDigit(date, offset + 1);\n-                        // parse up to 3 digits\n-                        int parseEndOffset = Math.min(endOffset, offset + 3);\n-                        int fraction = parseInt(date, offset, parseEndOffset);\n-                        // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n-                            case 2:\n-                                milliseconds = fraction * 10;\n-                                break;\n-                            case 1:\n-                                milliseconds = fraction * 100;\n-                                break;\n-                            default:\n-                                milliseconds = fraction;\n-                        }\n-                        offset = endOffset;\n                     }\n+                    int tzMin = parseInt(date, offset, offset += 2);\n+                    timezone = (c == '+') ? GMT_TIMEZONE : GMT_TIMEZONE_NEGATIVE;\n+                    calendar.setTimeZone(timezone);\n+                    hour -= tzHour;\n+                    minutes -= tzMin;\n+                } else {\n+                    throw new ParseException(\"No time zone indicator\", offset);\n                 }\n             }\n         }\n-        // extract timezone\n-        if (date.length() <= offset) {\n-            throw new IllegalArgumentException(\"No time zone indicator\");\n-        }\n-        TimeZone timezone = null;\n-        char timezoneIndicator = date.charAt(offset);\n-        if (timezoneIndicator == 'Z') {\n-            timezone = TIMEZONE_UTC;\n-            offset += 1;\n-        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n-            String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n-            offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n-            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n-                timezone = TIMEZONE_UTC;\n-            } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n-                }\n-            }\n-        } else {\n-            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n-        }\n-        Calendar calendar = new GregorianCalendar(timezone);\n+        Calendar calendar = new GregorianCalendar(GMT_TIMEZONE);\n         calendar.setLenient(false);\n         calendar.set(Calendar.YEAR, year);\n         calendar.set(Calendar.MONTH, month - 1);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset && checkOffset(date, offset, '.')) {\n                offset += 1;\n                // assumes at least one digit\n                int endOffset = indexOfNonDigit(date, offset + 1);\n                // parse up to 3 digits\n                int parseEndOffset = Math.min(endOffset, offset + 3);\n                int fraction = parseInt(date, offset, parseEndOffset);\n                // truncate up to 3 leap seconds\n                if (parseEndOffset - offset > 3) {\n                    // round down milliseconds if there is more than 3 decimal places\n                    milliseconds = fraction / (int) Math.pow(10, parseEndOffset - offset - 3);\n                } else {\n                    milliseconds = fraction * (int) Math.pow(10, 3 - parseEndOffset + offset);\n                }\n                offset = parseEndOffset;\n            }\n            // check for optional timezone\n            if (date.length() > offset) {\n                char timezoneIndicator = date.charAt(offset);\n                if (timezoneIndicator == 'Z') {\n                    timezone = TIMEZONE_UTC;\n                    offset += 1;\n                } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                    String timezoneOffset = date.substring(offset);\n                    // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n                    offset += timezoneOffset.length();\n                    if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset) || \"+00\".equals(timezoneOffset)) {\n                        timezone = TIMEZONE_UTC;\n                    } else {\n                        timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n                    }\n                } else {\n                    throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n                }\n            } else {\n                timezone = TimeZone.getDefault();\n            }\n        }\n        // no time components and timezone identifier, we are done\n        else {\n            timezone = TimeZone.getDefault();\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -38,72 +38,47 @@\n                 offset += 1;\n             }\n             // second and milliseconds can be optional\n+            if (date.length() > offset && checkOffset(date, offset, '.')) {\n+                offset += 1;\n+                // assumes at least one digit\n+                int endOffset = indexOfNonDigit(date, offset + 1);\n+                // parse up to 3 digits\n+                int parseEndOffset = Math.min(endOffset, offset + 3);\n+                int fraction = parseInt(date, offset, parseEndOffset);\n+                // truncate up to 3 leap seconds\n+                if (parseEndOffset - offset > 3) {\n+                    // round down milliseconds if there is more than 3 decimal places\n+                    milliseconds = fraction / (int) Math.pow(10, parseEndOffset - offset - 3);\n+                } else {\n+                    milliseconds = fraction * (int) Math.pow(10, 3 - parseEndOffset + offset);\n+                }\n+                offset = parseEndOffset;\n+            }\n+            // check for optional timezone\n             if (date.length() > offset) {\n-                char c = date.charAt(offset);\n-                if (c != 'Z' && c != '+' && c != '-') {\n-                    seconds = parseInt(date, offset, offset += 2);\n-                    // truncate up to 3 leap seconds\n-                    if (seconds > 59 && seconds < 63)\n-                        seconds = 59;\n-                    // milliseconds can be optional in the format\n-                    if (checkOffset(date, offset, '.')) {\n-                        offset += 1;\n-                        // assume at least one digit\n-                        int endOffset = indexOfNonDigit(date, offset + 1);\n-                        // parse up to 3 digits\n-                        int parseEndOffset = Math.min(endOffset, offset + 3);\n-                        int fraction = parseInt(date, offset, parseEndOffset);\n-                        // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n-                            case 2:\n-                                milliseconds = fraction * 10;\n-                                break;\n-                            case 1:\n-                                milliseconds = fraction * 100;\n-                                break;\n-                            default:\n-                                milliseconds = fraction;\n-                        }\n-                        offset = endOffset;\n+                char timezoneIndicator = date.charAt(offset);\n+                if (timezoneIndicator == 'Z') {\n+                    timezone = TIMEZONE_UTC;\n+                    offset += 1;\n+                } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n+                    String timezoneOffset = date.substring(offset);\n+                    // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n+                    offset += timezoneOffset.length();\n+                    if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset) || \"+00\".equals(timezoneOffset)) {\n+                        timezone = TIMEZONE_UTC;\n+                    } else {\n+                        timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n                     }\n+                } else {\n+                    throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n                 }\n+            } else {\n+                timezone = TimeZone.getDefault();\n             }\n         }\n-        // extract timezone\n-        if (date.length() <= offset) {\n-            throw new IllegalArgumentException(\"No time zone indicator\");\n-        }\n-        TimeZone timezone = null;\n-        char timezoneIndicator = date.charAt(offset);\n-        if (timezoneIndicator == 'Z') {\n-            timezone = TIMEZONE_UTC;\n-            offset += 1;\n-        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n-            String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n-            offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n-            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n-                timezone = TIMEZONE_UTC;\n-            } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n-                }\n-            }\n-        } else {\n-            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n+        // no time components and timezone identifier, we are done\n+        else {\n+            timezone = TimeZone.getDefault();\n         }\n         Calendar calendar = new GregorianCalendar(timezone);\n         calendar.setLenient(false);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            calendar.setLenient(false);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    // truncate up to 3 leap seconds\n                    if (seconds > 59 && seconds < 63)\n                        seconds = 59;\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        // assume at least one digit\n                        int endOffset = indexOfNonDigit(date, offset + 1);\n                        // parse up to 3 digits\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch (parseEndOffset - offset) {\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n            offset += timezoneOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException | NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -24,6 +24,7 @@\n         boolean hasT = checkOffset(date, offset, 'T');\n         if (!hasT && (date.length() <= offset)) {\n             Calendar calendar = new GregorianCalendar(year, month - 1, day);\n+            calendar.setLenient(false);\n             pos.setIndex(offset);\n             return calendar.getTime();\n         }\n@@ -54,8 +55,7 @@\n                         int parseEndOffset = Math.min(endOffset, offset + 3);\n                         int fraction = parseInt(date, offset, parseEndOffset);\n                         // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n+                        switch (parseEndOffset - offset) {\n                             case 2:\n                                 milliseconds = fraction * 10;\n                                 break;\n@@ -87,20 +87,7 @@\n             if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                 timezone = TIMEZONE_UTC;\n             } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n-                }\n+                timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n             }\n         } else {\n             throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n@@ -118,9 +105,7 @@\n         return calendar.getTime();\n         // If we get a ParseException it'll already have the right message/offset.\n         // Other exception types can convert here.\n-    } catch (IndexOutOfBoundsException e) {\n-        fail = e;\n-    } catch (NumberFormatException e) {\n+    } catch (IndexOutOfBoundsException | NumberFormatException e) {\n         fail = e;\n     } catch (IllegalArgumentException e) {\n         fail = e;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    // truncate up to 3 leap seconds\n                    if (seconds > 59 && seconds < 63)\n                        seconds = 59;\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        // assume at least one digit\n                        int endOffset = indexOfNonDigit(date, offset);\n                        // parse up to 3 digits\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch(// number of digits parsed\n                        parseEndOffset - offset) {\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n            // Modified the condition to check if string length is >3 instead of >0\n            if(timezoneOffset.length() > 3) {\n                offset += 6;\n            } else if (timezoneOffset.length() > 1) {\n                offset += 5;\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n            }\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                String timezoneId = \"GMT\" + timezoneOffset;\n                //                    String timezoneId = \"UTC\" + timezoneOffset;\n                timezone = TimeZone.getTimeZone(timezoneId);\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                                    String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -49,7 +49,7 @@\n                     if (checkOffset(date, offset, '.')) {\n                         offset += 1;\n                         // assume at least one digit\n-                        int endOffset = indexOfNonDigit(date, offset + 1);\n+                        int endOffset = indexOfNonDigit(date, offset);\n                         // parse up to 3 digits\n                         int parseEndOffset = Math.min(endOffset, offset + 3);\n                         int fraction = parseInt(date, offset, parseEndOffset);\n@@ -82,7 +82,14 @@\n         } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n             String timezoneOffset = date.substring(offset);\n             // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n-            offset += timezoneOffset.length();\n+            // Modified the condition to check if string length is >3 instead of >0\n+            if(timezoneOffset.length() > 3) {\n+                offset += 6;\n+            } else if (timezoneOffset.length() > 1) {\n+                offset += 5;\n+            } else {\n+                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n+            }\n             // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n             if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                 timezone = TIMEZONE_UTC;\n@@ -96,7 +103,7 @@\n                 timezone = TimeZone.getTimeZone(timezoneId);\n                 String act = timezone.getID();\n                 if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n+                                    String cleaned = act.replace(\":\", \"\");\n                     if (!cleaned.equals(timezoneId)) {\n                         throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    // truncate up to 3 leap seconds\n                    if (seconds > 59 && seconds < 63)\n                        seconds = 59;\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        // assume at least one digit\n                        int endOffset = indexOfNonDigit(date, offset + 1);\n                        // parse up to 3 digits\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        int digitCount = parseEndOffset - offset;\n                        if (digitCount == 2) {\n                            milliseconds = fraction * 10;\n                        } else if (digitCount == 1) {\n                            milliseconds = fraction * 100;\n                        } else {\n                            milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n            offset += timezoneOffset.length();\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                String timezoneId = \"GMT\" + timezoneOffset;\n                timezone = TimeZone.getTimeZone(timezoneId);\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException | NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -54,16 +54,13 @@\n                         int parseEndOffset = Math.min(endOffset, offset + 3);\n                         int fraction = parseInt(date, offset, parseEndOffset);\n                         // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n-                            case 2:\n-                                milliseconds = fraction * 10;\n-                                break;\n-                            case 1:\n-                                milliseconds = fraction * 100;\n-                                break;\n-                            default:\n-                                milliseconds = fraction;\n+                        int digitCount = parseEndOffset - offset;\n+                        if (digitCount == 2) {\n+                            milliseconds = fraction * 10;\n+                        } else if (digitCount == 1) {\n+                            milliseconds = fraction * 100;\n+                        } else {\n+                            milliseconds = fraction;\n                         }\n                         offset = endOffset;\n                     }\n@@ -81,22 +78,15 @@\n             offset += 1;\n         } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n             String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n             offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n             if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                 timezone = TIMEZONE_UTC;\n             } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n                 String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n                 timezone = TimeZone.getTimeZone(timezoneId);\n                 String act = timezone.getID();\n                 if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n+                    String cleaned = act.replace(\":\", \"\");\n                     if (!cleaned.equals(timezoneId)) {\n                         throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                     }\n@@ -118,9 +108,7 @@\n         return calendar.getTime();\n         // If we get a ParseException it'll already have the right message/offset.\n         // Other exception types can convert here.\n-    } catch (IndexOutOfBoundsException e) {\n-        fail = e;\n-    } catch (NumberFormatException e) {\n+    } catch (IndexOutOfBoundsException | NumberFormatException e) {\n         fail = e;\n     } catch (IllegalArgumentException e) {\n         fail = e;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    try {\n        int offset = pos.getIndex();\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        int day = parseInt(date, offset, offset += 2);\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0;\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = Calendar.getInstance();\n            calendar.set(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) {\n                        seconds = 59;\n                    }\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        int endOffset = indexOfNonDigit(date, offset + 1);\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        switch (parseEndOffset - offset) {\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n            offset += timezoneOffset.length();\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n        }\n        Calendar calendar = Calendar.getInstance(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n    } catch (IndexOutOfBoundsException | NumberFormatException | IllegalArgumentException e) {\n        ParseException ex = new ParseException(\"Failed to parse date [\" + date + \"]: \" + e.getMessage(), pos.getIndex());\n        ex.initCause(e);\n        throw ex;\n    }\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -1,34 +1,27 @@\n public static Date parse(String date, ParsePosition pos) throws ParseException {\n-    Exception fail = null;\n     try {\n         int offset = pos.getIndex();\n-        // extract year\n         int year = parseInt(date, offset, offset += 4);\n         if (checkOffset(date, offset, '-')) {\n             offset += 1;\n         }\n-        // extract month\n         int month = parseInt(date, offset, offset += 2);\n         if (checkOffset(date, offset, '-')) {\n             offset += 1;\n         }\n-        // extract day\n         int day = parseInt(date, offset, offset += 2);\n-        // default time value\n         int hour = 0;\n         int minutes = 0;\n         int seconds = 0;\n-        // always use 0 otherwise returned date will include millis of current time\n         int milliseconds = 0;\n-        // if the value has no time component (and no time zone), we are done\n         boolean hasT = checkOffset(date, offset, 'T');\n         if (!hasT && (date.length() <= offset)) {\n-            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n+            Calendar calendar = Calendar.getInstance();\n+            calendar.set(year, month - 1, day);\n             pos.setIndex(offset);\n             return calendar.getTime();\n         }\n         if (hasT) {\n-            // extract hours, minutes, seconds and milliseconds\n             hour = parseInt(date, offset += 1, offset += 2);\n             if (checkOffset(date, offset, ':')) {\n                 offset += 1;\n@@ -37,25 +30,19 @@\n             if (checkOffset(date, offset, ':')) {\n                 offset += 1;\n             }\n-            // second and milliseconds can be optional\n             if (date.length() > offset) {\n                 char c = date.charAt(offset);\n                 if (c != 'Z' && c != '+' && c != '-') {\n                     seconds = parseInt(date, offset, offset += 2);\n-                    // truncate up to 3 leap seconds\n-                    if (seconds > 59 && seconds < 63)\n+                    if (seconds > 59 && seconds < 63) {\n                         seconds = 59;\n-                    // milliseconds can be optional in the format\n+                    }\n                     if (checkOffset(date, offset, '.')) {\n                         offset += 1;\n-                        // assume at least one digit\n                         int endOffset = indexOfNonDigit(date, offset + 1);\n-                        // parse up to 3 digits\n                         int parseEndOffset = Math.min(endOffset, offset + 3);\n                         int fraction = parseInt(date, offset, parseEndOffset);\n-                        // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n+                        switch (parseEndOffset - offset) {\n                             case 2:\n                                 milliseconds = fraction * 10;\n                                 break;\n@@ -70,7 +57,6 @@\n                 }\n             }\n         }\n-        // extract timezone\n         if (date.length() <= offset) {\n             throw new IllegalArgumentException(\"No time zone indicator\");\n         }\n@@ -81,31 +67,16 @@\n             offset += 1;\n         } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n             String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n             offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n             if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                 timezone = TIMEZONE_UTC;\n             } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n-                }\n+                timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n             }\n         } else {\n             throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n         }\n-        Calendar calendar = new GregorianCalendar(timezone);\n+        Calendar calendar = Calendar.getInstance(timezone);\n         calendar.setLenient(false);\n         calendar.set(Calendar.YEAR, year);\n         calendar.set(Calendar.MONTH, month - 1);\n@@ -116,21 +87,9 @@\n         calendar.set(Calendar.MILLISECOND, milliseconds);\n         pos.setIndex(offset);\n         return calendar.getTime();\n-        // If we get a ParseException it'll already have the right message/offset.\n-        // Other exception types can convert here.\n-    } catch (IndexOutOfBoundsException e) {\n-        fail = e;\n-    } catch (NumberFormatException e) {\n-        fail = e;\n-    } catch (IllegalArgumentException e) {\n-        fail = e;\n+    } catch (IndexOutOfBoundsException | NumberFormatException | IllegalArgumentException e) {\n+        ParseException ex = new ParseException(\"Failed to parse date [\" + date + \"]: \" + e.getMessage(), pos.getIndex());\n+        ex.initCause(e);\n+        throw ex;\n     }\n-    String input = (date == null) ? null : ('\"' + date + \"'\");\n-    String msg = fail.getMessage();\n-    if (msg == null || msg.isEmpty()) {\n-        msg = \"(\" + fail.getClass().getName() + \")\";\n-    }\n-    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n-    ex.initCause(fail);\n-    throw ex;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c == '.') {\n                    int endIndex = date.indexOf(\"Z\", offset);\n                    if (endIndex == -1) {\n                        endIndex = date.length();\n                    }\n                    int digits = endIndex - offset - 1;\n                    if (digits == 1) {\n                        seconds = parseInt(date, offset += 1, endIndex) * 100;\n                    } else if (digits == 2) {\n                        seconds = parseInt(date, offset += 1, endIndex) * 10;\n                    } else if (digits == 3) {\n                        seconds = parseInt(date, offset += 1, endIndex);\n                    } else {\n                        throw new IndexOutOfBoundsException(\"Invalid date format.\");\n                    }\n                    milliseconds = seconds;\n                } else if (Character.isDigit(c)) {\n                    // truncate up to 3 leap seconds\n                    if (offset + 1 < date.length() && date.charAt(offset + 1) == '6') {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (seconds == 60) {\n                            seconds = 59;\n                        }\n                    } else {\n                        seconds = parseInt(date, offset, offset += 2);\n                    }\n                    if (checkOffset(date, offset, '.')) {\n                        int endIndex = date.indexOf(\"Z\", offset);\n                        if (endIndex == -1) {\n                            endIndex = date.length();\n                        }\n                        int digits = endIndex - offset - 1;\n                        if (digits == 1) {\n                            milliseconds = parseInt(date, offset += 1, endIndex) * 100;\n                        } else if (digits == 2) {\n                            milliseconds = parseInt(date, offset += 1, endIndex) * 10;\n                        } else if (digits == 3) {\n                            milliseconds = parseInt(date, offset += 1, endIndex);\n                        } else {\n                            throw new IndexOutOfBoundsException(\"Invalid date format.\");\n                        }\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n            offset += timezoneOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                String timezoneId = \"GMT\" + timezoneOffset;\n                //                    String timezoneId = \"UTC\" + timezoneOffset;\n                timezone = TimeZone.getTimeZone(timezoneId);\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                                        String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -40,32 +40,47 @@\n             // second and milliseconds can be optional\n             if (date.length() > offset) {\n                 char c = date.charAt(offset);\n-                if (c != 'Z' && c != '+' && c != '-') {\n-                    seconds = parseInt(date, offset, offset += 2);\n+                if (c == '.') {\n+                    int endIndex = date.indexOf(\"Z\", offset);\n+                    if (endIndex == -1) {\n+                        endIndex = date.length();\n+                    }\n+                    int digits = endIndex - offset - 1;\n+                    if (digits == 1) {\n+                        seconds = parseInt(date, offset += 1, endIndex) * 100;\n+                    } else if (digits == 2) {\n+                        seconds = parseInt(date, offset += 1, endIndex) * 10;\n+                    } else if (digits == 3) {\n+                        seconds = parseInt(date, offset += 1, endIndex);\n+                    } else {\n+                        throw new IndexOutOfBoundsException(\"Invalid date format.\");\n+                    }\n+                    milliseconds = seconds;\n+                } else if (Character.isDigit(c)) {\n                     // truncate up to 3 leap seconds\n-                    if (seconds > 59 && seconds < 63)\n-                        seconds = 59;\n-                    // milliseconds can be optional in the format\n+                    if (offset + 1 < date.length() && date.charAt(offset + 1) == '6') {\n+                        seconds = parseInt(date, offset, offset += 2);\n+                        if (seconds == 60) {\n+                            seconds = 59;\n+                        }\n+                    } else {\n+                        seconds = parseInt(date, offset, offset += 2);\n+                    }\n                     if (checkOffset(date, offset, '.')) {\n-                        offset += 1;\n-                        // assume at least one digit\n-                        int endOffset = indexOfNonDigit(date, offset + 1);\n-                        // parse up to 3 digits\n-                        int parseEndOffset = Math.min(endOffset, offset + 3);\n-                        int fraction = parseInt(date, offset, parseEndOffset);\n-                        // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n-                            case 2:\n-                                milliseconds = fraction * 10;\n-                                break;\n-                            case 1:\n-                                milliseconds = fraction * 100;\n-                                break;\n-                            default:\n-                                milliseconds = fraction;\n+                        int endIndex = date.indexOf(\"Z\", offset);\n+                        if (endIndex == -1) {\n+                            endIndex = date.length();\n                         }\n-                        offset = endOffset;\n+                        int digits = endIndex - offset - 1;\n+                        if (digits == 1) {\n+                            milliseconds = parseInt(date, offset += 1, endIndex) * 100;\n+                        } else if (digits == 2) {\n+                            milliseconds = parseInt(date, offset += 1, endIndex) * 10;\n+                        } else if (digits == 3) {\n+                            milliseconds = parseInt(date, offset += 1, endIndex);\n+                        } else {\n+                            throw new IndexOutOfBoundsException(\"Invalid date format.\");\n+                        }\n                     }\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    // truncate up to 3 leap seconds\n                    if (seconds > 59 && seconds < 63)\n                        seconds = 59;\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        // assume at least one digit\n                        int endOffset = indexOfNonDigit(date, offset + 1);\n                        // parse up to 3 digits\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch(// number of digits parsed\n                        parseEndOffset - offset) {\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        String timezoneOffset = date.substring(offset);\n        TimeZone timezone;\n        if (timezoneOffset.equals(\"Z\")) {\n            timezone = TIMEZONE_UTC; // UTC\n        } else if (timezoneOffset.startsWith(\"+\") || timezoneOffset.startsWith(\"-\")) {\n            String offsetId = \"GMT\" + timezoneOffset;\n            timezone = TimeZone.getTimeZone(offsetId);\n            String act = timezone.getID();\n            if (!act.equals(offsetId)) {\n                String cleaned = act.replace(\":\", \"\");\n                if (!cleaned.equals(offsetId)) {\n                    throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + offsetId + \" given, resolves to \" + timezone.getID());\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator \" + timezoneOffset);\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset + timezoneOffset.length());\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -74,36 +74,22 @@\n         if (date.length() <= offset) {\n             throw new IllegalArgumentException(\"No time zone indicator\");\n         }\n-        TimeZone timezone = null;\n-        char timezoneIndicator = date.charAt(offset);\n-        if (timezoneIndicator == 'Z') {\n-            timezone = TIMEZONE_UTC;\n-            offset += 1;\n-        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n-            String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n-            offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n-            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n-                timezone = TIMEZONE_UTC;\n-            } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n+        String timezoneOffset = date.substring(offset);\n+        TimeZone timezone;\n+        if (timezoneOffset.equals(\"Z\")) {\n+            timezone = TIMEZONE_UTC; // UTC\n+        } else if (timezoneOffset.startsWith(\"+\") || timezoneOffset.startsWith(\"-\")) {\n+            String offsetId = \"GMT\" + timezoneOffset;\n+            timezone = TimeZone.getTimeZone(offsetId);\n+            String act = timezone.getID();\n+            if (!act.equals(offsetId)) {\n+                String cleaned = act.replace(\":\", \"\");\n+                if (!cleaned.equals(offsetId)) {\n+                    throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + offsetId + \" given, resolves to \" + timezone.getID());\n                 }\n             }\n         } else {\n-            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n+            throw new IndexOutOfBoundsException(\"Invalid time zone indicator \" + timezoneOffset);\n         }\n         Calendar calendar = new GregorianCalendar(timezone);\n         calendar.setLenient(false);\n@@ -114,7 +100,7 @@\n         calendar.set(Calendar.MINUTE, minutes);\n         calendar.set(Calendar.SECOND, seconds);\n         calendar.set(Calendar.MILLISECOND, milliseconds);\n-        pos.setIndex(offset);\n+        pos.setIndex(offset + timezoneOffset.length());\n         return calendar.getTime();\n         // If we get a ParseException it'll already have the right message/offset.\n         // Other exception types can convert here.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c == '.') {\n                    offset += 1;\n                    // parse milliseconds\n                    int endIndex = indexOfNonDigit(date, offset + 1);\n                    int parseEndIndex = Math.min(endIndex, offset + 3);\n                    milliseconds = parseInt(date, offset, parseEndIndex);\n                    // add trailing zeroes\n                    switch (parseEndIndex - offset) {\n                        case 3:\n                            // no need to multiply\n                            break;\n                        case 2:\n                            milliseconds *= 10;\n                            break;\n                        case 1:\n                            milliseconds *= 100;\n                            break;\n                        default:\n                            // add two trailing zeroes\n                            milliseconds *= 1000;\n                    }\n                    offset = endIndex;\n                }\n                if (c == '+' || c == '-') {\n                    // offset\n                    // extract timezone\n                    String timezoneOffset = date.substring(offset);\n                    offset += timezoneOffset.length();\n                    TimeZone timezone = getTimeZone(timezoneOffset);\n                    Calendar calendar = new GregorianCalendar(timezone);\n                    calendar.setLenient(false);\n                    calendar.set(Calendar.YEAR, year);\n                    calendar.set(Calendar.MONTH, month - 1);\n                    calendar.set(Calendar.DAY_OF_MONTH, day);\n                    calendar.set(Calendar.HOUR_OF_DAY, hour);\n                    calendar.set(Calendar.MINUTE, minutes);\n                    calendar.set(Calendar.SECOND, seconds);\n                    calendar.set(Calendar.MILLISECOND, milliseconds);\n                    pos.setIndex(offset);\n                    return calendar.getTime();\n                }\n                if (c == 'Z') {\n                    pos.setIndex(offset + 1);\n                    TimeZone timezone = getTimeZone(\"UTC\");\n                    Calendar calendar = new GregorianCalendar(timezone);\n                    calendar.setLenient(false);\n                    calendar.set(Calendar.YEAR, year);\n                    calendar.set(Calendar.MONTH, month - 1);\n                    calendar.set(Calendar.DAY_OF_MONTH, day);\n                    calendar.set(Calendar.HOUR_OF_DAY, hour);\n                    calendar.set(Calendar.MINUTE, minutes);\n                    calendar.set(Calendar.SECOND, seconds);\n                    calendar.set(Calendar.MILLISECOND, milliseconds);\n                    return calendar.getTime();\n                }\n                seconds = parseInt(date, offset, offset + 2);\n                if (checkOffset(date, offset + 2, ':')) {\n                    offset += 3;\n                } else {\n                    offset += 2;\n                }\n                if (date.length() > offset) {\n                    c = date.charAt(offset);\n                    if (c == '.') {\n                        offset += 1;\n                        // parse milliseconds\n                        int endIndex = indexOfNonDigit(date, offset + 1);\n                        int parseEndIndex = Math.min(endIndex, offset + 3);\n                        milliseconds = parseInt(date, offset, parseEndIndex);\n                        // add trailing zeroes\n                        switch (parseEndIndex - offset) {\n                            case 3:\n                                // no need to multiply\n                                break;\n                            case 2:\n                                milliseconds *= 10;\n                                break;\n                            case 1:\n                                milliseconds *= 100;\n                                break;\n                            default:\n                                // add two trailing zeroes\n                                milliseconds *= 1000;\n                        }\n                        offset = endIndex;\n                    }\n                    if (c == '+' || c == '-') {\n                        // offset\n                        // extract timezone\n                        String timezoneOffset = date.substring(offset);\n                        offset += timezoneOffset.length();\n                        TimeZone timezone = getTimeZone(timezoneOffset);\n                        Calendar calendar = new GregorianCalendar(timezone);\n                        calendar.setLenient(false);\n                        calendar.set(Calendar.YEAR, year);\n                        calendar.set(Calendar.MONTH, month - 1);\n                        calendar.set(Calendar.DAY_OF_MONTH, day);\n                        calendar.set(Calendar.HOUR_OF_DAY, hour);\n                        calendar.set(Calendar.MINUTE, minutes);\n                        calendar.set(Calendar.SECOND, seconds);\n                        calendar.set(Calendar.MILLISECOND, milliseconds);\n                        pos.setIndex(offset);\n                        return calendar.getTime();\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (offset + 1 < date.length()) {\n            String timezoneOffset = date.substring(offset);\n            TimeZone timezone = getTimeZone(timezoneOffset);\n            if (timezone.getID().equals(timezoneOffset)) {\n                // we don't want to return GMT even if that's what was parsed\n                timezone = TIMEZONE_UTC;\n            }\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n            pos.setIndex(offset + timezoneOffset.length());\n            return calendar.getTime();\n        }\n        Calendar calendar = new GregorianCalendar(TIMEZONE_UTC);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset + 1);\n        return calendar.getTime();\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}\n\n## Fixed Function 2\nprivate static TimeZone getTimeZone(String timezoneOffset) {\n    TimeZone timezone;\n    if (\"Z\".equals(timezoneOffset)) {\n        timezone = TIMEZONE_UTC;\n    } else {\n        String timezoneId;\n        if (timezoneOffset.charAt(0) == '-' || timezoneOffset.charAt(0) == '+') {\n            // offset\n            timezoneId = GMT_ID + timezoneOffset;\n        } else {\n            // timezone ID\n            timezoneId = timezoneOffset;\n        }\n        timezone = TimeZone.getTimeZone(timezoneId);\n        if (GMT_ID.equals(timezone.getID()) && !GMT_ID.equals(timezoneOffset)) {\n            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneOffset + \" given, resolves to GMT\" + timezone.getID());\n        }\n    }\n    return timezone;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -40,72 +40,134 @@\n             // second and milliseconds can be optional\n             if (date.length() > offset) {\n                 char c = date.charAt(offset);\n-                if (c != 'Z' && c != '+' && c != '-') {\n-                    seconds = parseInt(date, offset, offset += 2);\n-                    // truncate up to 3 leap seconds\n-                    if (seconds > 59 && seconds < 63)\n-                        seconds = 59;\n-                    // milliseconds can be optional in the format\n-                    if (checkOffset(date, offset, '.')) {\n+                if (c == '.') {\n+                    offset += 1;\n+                    // parse milliseconds\n+                    int endIndex = indexOfNonDigit(date, offset + 1);\n+                    int parseEndIndex = Math.min(endIndex, offset + 3);\n+                    milliseconds = parseInt(date, offset, parseEndIndex);\n+                    // add trailing zeroes\n+                    switch (parseEndIndex - offset) {\n+                        case 3:\n+                            // no need to multiply\n+                            break;\n+                        case 2:\n+                            milliseconds *= 10;\n+                            break;\n+                        case 1:\n+                            milliseconds *= 100;\n+                            break;\n+                        default:\n+                            // add two trailing zeroes\n+                            milliseconds *= 1000;\n+                    }\n+                    offset = endIndex;\n+                }\n+                if (c == '+' || c == '-') {\n+                    // offset\n+                    // extract timezone\n+                    String timezoneOffset = date.substring(offset);\n+                    offset += timezoneOffset.length();\n+                    TimeZone timezone = getTimeZone(timezoneOffset);\n+                    Calendar calendar = new GregorianCalendar(timezone);\n+                    calendar.setLenient(false);\n+                    calendar.set(Calendar.YEAR, year);\n+                    calendar.set(Calendar.MONTH, month - 1);\n+                    calendar.set(Calendar.DAY_OF_MONTH, day);\n+                    calendar.set(Calendar.HOUR_OF_DAY, hour);\n+                    calendar.set(Calendar.MINUTE, minutes);\n+                    calendar.set(Calendar.SECOND, seconds);\n+                    calendar.set(Calendar.MILLISECOND, milliseconds);\n+                    pos.setIndex(offset);\n+                    return calendar.getTime();\n+                }\n+                if (c == 'Z') {\n+                    pos.setIndex(offset + 1);\n+                    TimeZone timezone = getTimeZone(\"UTC\");\n+                    Calendar calendar = new GregorianCalendar(timezone);\n+                    calendar.setLenient(false);\n+                    calendar.set(Calendar.YEAR, year);\n+                    calendar.set(Calendar.MONTH, month - 1);\n+                    calendar.set(Calendar.DAY_OF_MONTH, day);\n+                    calendar.set(Calendar.HOUR_OF_DAY, hour);\n+                    calendar.set(Calendar.MINUTE, minutes);\n+                    calendar.set(Calendar.SECOND, seconds);\n+                    calendar.set(Calendar.MILLISECOND, milliseconds);\n+                    return calendar.getTime();\n+                }\n+                seconds = parseInt(date, offset, offset + 2);\n+                if (checkOffset(date, offset + 2, ':')) {\n+                    offset += 3;\n+                } else {\n+                    offset += 2;\n+                }\n+                if (date.length() > offset) {\n+                    c = date.charAt(offset);\n+                    if (c == '.') {\n                         offset += 1;\n-                        // assume at least one digit\n-                        int endOffset = indexOfNonDigit(date, offset + 1);\n-                        // parse up to 3 digits\n-                        int parseEndOffset = Math.min(endOffset, offset + 3);\n-                        int fraction = parseInt(date, offset, parseEndOffset);\n-                        // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n+                        // parse milliseconds\n+                        int endIndex = indexOfNonDigit(date, offset + 1);\n+                        int parseEndIndex = Math.min(endIndex, offset + 3);\n+                        milliseconds = parseInt(date, offset, parseEndIndex);\n+                        // add trailing zeroes\n+                        switch (parseEndIndex - offset) {\n+                            case 3:\n+                                // no need to multiply\n+                                break;\n                             case 2:\n-                                milliseconds = fraction * 10;\n+                                milliseconds *= 10;\n                                 break;\n                             case 1:\n-                                milliseconds = fraction * 100;\n+                                milliseconds *= 100;\n                                 break;\n                             default:\n-                                milliseconds = fraction;\n+                                // add two trailing zeroes\n+                                milliseconds *= 1000;\n                         }\n-                        offset = endOffset;\n+                        offset = endIndex;\n+                    }\n+                    if (c == '+' || c == '-') {\n+                        // offset\n+                        // extract timezone\n+                        String timezoneOffset = date.substring(offset);\n+                        offset += timezoneOffset.length();\n+                        TimeZone timezone = getTimeZone(timezoneOffset);\n+                        Calendar calendar = new GregorianCalendar(timezone);\n+                        calendar.setLenient(false);\n+                        calendar.set(Calendar.YEAR, year);\n+                        calendar.set(Calendar.MONTH, month - 1);\n+                        calendar.set(Calendar.DAY_OF_MONTH, day);\n+                        calendar.set(Calendar.HOUR_OF_DAY, hour);\n+                        calendar.set(Calendar.MINUTE, minutes);\n+                        calendar.set(Calendar.SECOND, seconds);\n+                        calendar.set(Calendar.MILLISECOND, milliseconds);\n+                        pos.setIndex(offset);\n+                        return calendar.getTime();\n                     }\n                 }\n             }\n         }\n         // extract timezone\n-        if (date.length() <= offset) {\n-            throw new IllegalArgumentException(\"No time zone indicator\");\n+        if (offset + 1 < date.length()) {\n+            String timezoneOffset = date.substring(offset);\n+            TimeZone timezone = getTimeZone(timezoneOffset);\n+            if (timezone.getID().equals(timezoneOffset)) {\n+                // we don't want to return GMT even if that's what was parsed\n+                timezone = TIMEZONE_UTC;\n+            }\n+            Calendar calendar = new GregorianCalendar(timezone);\n+            calendar.setLenient(false);\n+            calendar.set(Calendar.YEAR, year);\n+            calendar.set(Calendar.MONTH, month - 1);\n+            calendar.set(Calendar.DAY_OF_MONTH, day);\n+            calendar.set(Calendar.HOUR_OF_DAY, hour);\n+            calendar.set(Calendar.MINUTE, minutes);\n+            calendar.set(Calendar.SECOND, seconds);\n+            calendar.set(Calendar.MILLISECOND, milliseconds);\n+            pos.setIndex(offset + timezoneOffset.length());\n+            return calendar.getTime();\n         }\n-        TimeZone timezone = null;\n-        char timezoneIndicator = date.charAt(offset);\n-        if (timezoneIndicator == 'Z') {\n-            timezone = TIMEZONE_UTC;\n-            offset += 1;\n-        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n-            String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n-            offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n-            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n-                timezone = TIMEZONE_UTC;\n-            } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n-                }\n-            }\n-        } else {\n-            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n-        }\n-        Calendar calendar = new GregorianCalendar(timezone);\n+        Calendar calendar = new GregorianCalendar(TIMEZONE_UTC);\n         calendar.setLenient(false);\n         calendar.set(Calendar.YEAR, year);\n         calendar.set(Calendar.MONTH, month - 1);\n@@ -114,10 +176,8 @@\n         calendar.set(Calendar.MINUTE, minutes);\n         calendar.set(Calendar.SECOND, seconds);\n         calendar.set(Calendar.MILLISECOND, milliseconds);\n-        pos.setIndex(offset);\n+        pos.setIndex(offset + 1);\n         return calendar.getTime();\n-        // If we get a ParseException it'll already have the right message/offset.\n-        // Other exception types can convert here.\n     } catch (IndexOutOfBoundsException e) {\n         fail = e;\n     } catch (NumberFormatException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(TimeZone.getTimeZone(\"UTC\"));\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    // truncate up to 3 leap seconds\n                    if (seconds > 59 && seconds < 63)\n                        seconds = 59;\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        // assume at least one digit\n                        int endOffset = indexOfNonDigit(date, offset + 1);\n                        // parse up to 3 digits\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch(// number of digits parsed\n                        parseEndOffset - offset) {\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n            offset += timezoneOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                String timezoneId = \"GMT\" + timezoneOffset;\n                //                    String timezoneId = \"UTC\" + timezoneOffset;\n                timezone = TimeZone.getTimeZone(timezoneId);\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -23,7 +23,11 @@\n         // if the value has no time component (and no time zone), we are done\n         boolean hasT = checkOffset(date, offset, 'T');\n         if (!hasT && (date.length() <= offset)) {\n-            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n+            Calendar calendar = new GregorianCalendar(TimeZone.getTimeZone(\"UTC\"));\n+            calendar.setLenient(false);\n+            calendar.set(Calendar.YEAR, year);\n+            calendar.set(Calendar.MONTH, month - 1);\n+            calendar.set(Calendar.DAY_OF_MONTH, day);\n             pos.setIndex(offset);\n             return calendar.getTime();\n         }\n@@ -96,7 +100,7 @@\n                 timezone = TimeZone.getTimeZone(timezoneId);\n                 String act = timezone.getID();\n                 if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n+                    String cleaned = act.replace(\":\", \"\");\n                     if (!cleaned.equals(timezoneId)) {\n                         throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    // truncate up to 3 leap seconds\n                    if (seconds > 59 && seconds < 63)\n                        seconds = 59;\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        // assume at least one digit\n                        int endOffset = indexOfNonDigit(date, offset + 1);\n                        // parse up to 3 digits\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch(// number of digits parsed\n                        parseEndOffset - offset) {\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (offset < date.length()) {\n            char timezoneIndicator = date.charAt(offset);\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n                offset += timezoneOffset.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                    //    not sure why, but that's the way it looks. Further, Javadocs for\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                    //    custom timezones... odd.\n                    String timezoneId = \"GMT\" + timezoneOffset;\n                    //                    String timezoneId = \"UTC\" + timezoneOffset;\n                    timezone = TimeZone.getTimeZone(timezoneId);\n                    String act = timezone.getID();\n                    if (!act.equals(timezoneId)) {\n                                            String cleaned = act.replace(\":\", \"\");\n                        if (!cleaned.equals(timezoneId)) {\n                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                        }\n                    }\n                }\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n            }\n        } else {\n            timezone = TimeZone.getDefault();\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -71,39 +71,39 @@\n             }\n         }\n         // extract timezone\n-        if (date.length() <= offset) {\n-            throw new IllegalArgumentException(\"No time zone indicator\");\n-        }\n-        TimeZone timezone = null;\n-        char timezoneIndicator = date.charAt(offset);\n-        if (timezoneIndicator == 'Z') {\n-            timezone = TIMEZONE_UTC;\n-            offset += 1;\n-        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n-            String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n-            offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n-            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n+        if (offset < date.length()) {\n+            char timezoneIndicator = date.charAt(offset);\n+            if (timezoneIndicator == 'Z') {\n                 timezone = TIMEZONE_UTC;\n-            } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n+                offset += 1;\n+            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n+                String timezoneOffset = date.substring(offset);\n+                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n+                offset += timezoneOffset.length();\n+                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n+                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n+                    timezone = TIMEZONE_UTC;\n+                } else {\n+                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n+                    //    not sure why, but that's the way it looks. Further, Javadocs for\n+                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n+                    //    custom timezones... odd.\n+                    String timezoneId = \"GMT\" + timezoneOffset;\n+                    //                    String timezoneId = \"UTC\" + timezoneOffset;\n+                    timezone = TimeZone.getTimeZone(timezoneId);\n+                    String act = timezone.getID();\n+                    if (!act.equals(timezoneId)) {\n+                                            String cleaned = act.replace(\":\", \"\");\n+                        if (!cleaned.equals(timezoneId)) {\n+                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n+                        }\n                     }\n                 }\n+            } else {\n+                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n             }\n         } else {\n-            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n+            timezone = TimeZone.getDefault();\n         }\n         Calendar calendar = new GregorianCalendar(timezone);\n         calendar.setLenient(false);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c == '.') {\n                    // milliseconds can be optional in the format\n                    int endOffset = indexOfNonDigit(date, ++offset + 1);\n                    int parseEndOffset = Math.min(endOffset + 1, offset + 4);\n                    int fraction = Integer.parseInt(date.substring(offset, parseEndOffset));\n                    milliseconds = fraction * (int)Math.pow(10, 3 - (parseEndOffset - offset));\n                    offset = parseEndOffset;\n                }\n                if (date.length() > offset && !isGMTIndicator(date.charAt(offset))) {\n                    // parse the second if it exists\n                    if (checkOffset(date, offset, ':')) {\n                        offset += 1;\n                    }\n                    seconds = parseInt(date, offset, offset += 2);\n                    // truncate up to 3 leap seconds\n                    if (seconds > 59 && seconds < 63) {\n                        seconds = 59;\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (isGMTIndicator(timezoneIndicator)) {\n            timezone = TimeZone.getTimeZone(\"GMT\" + timezoneIndicator + date.substring(offset + 1));\n            offset = date.length();\n        } else {\n            String timezoneOffset = date.substring(offset);\n            offset += timezoneOffset.length();\n            if (TIMEZONE_PATTERN.matcher(timezoneOffset).matches()) {\n                timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n            }\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}\n\n## Helper Function\nprivate static boolean isGMTIndicator(char timezoneIndicator) {\n    return timezoneIndicator == '+' || timezoneIndicator == '-';\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -40,32 +40,23 @@\n             // second and milliseconds can be optional\n             if (date.length() > offset) {\n                 char c = date.charAt(offset);\n-                if (c != 'Z' && c != '+' && c != '-') {\n+                if (c == '.') {\n+                    // milliseconds can be optional in the format\n+                    int endOffset = indexOfNonDigit(date, ++offset + 1);\n+                    int parseEndOffset = Math.min(endOffset + 1, offset + 4);\n+                    int fraction = Integer.parseInt(date.substring(offset, parseEndOffset));\n+                    milliseconds = fraction * (int)Math.pow(10, 3 - (parseEndOffset - offset));\n+                    offset = parseEndOffset;\n+                }\n+                if (date.length() > offset && !isGMTIndicator(date.charAt(offset))) {\n+                    // parse the second if it exists\n+                    if (checkOffset(date, offset, ':')) {\n+                        offset += 1;\n+                    }\n                     seconds = parseInt(date, offset, offset += 2);\n                     // truncate up to 3 leap seconds\n-                    if (seconds > 59 && seconds < 63)\n+                    if (seconds > 59 && seconds < 63) {\n                         seconds = 59;\n-                    // milliseconds can be optional in the format\n-                    if (checkOffset(date, offset, '.')) {\n-                        offset += 1;\n-                        // assume at least one digit\n-                        int endOffset = indexOfNonDigit(date, offset + 1);\n-                        // parse up to 3 digits\n-                        int parseEndOffset = Math.min(endOffset, offset + 3);\n-                        int fraction = parseInt(date, offset, parseEndOffset);\n-                        // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n-                            case 2:\n-                                milliseconds = fraction * 10;\n-                                break;\n-                            case 1:\n-                                milliseconds = fraction * 100;\n-                                break;\n-                            default:\n-                                milliseconds = fraction;\n-                        }\n-                        offset = endOffset;\n                     }\n                 }\n             }\n@@ -79,31 +70,17 @@\n         if (timezoneIndicator == 'Z') {\n             timezone = TIMEZONE_UTC;\n             offset += 1;\n-        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n+        } else if (isGMTIndicator(timezoneIndicator)) {\n+            timezone = TimeZone.getTimeZone(\"GMT\" + timezoneIndicator + date.substring(offset + 1));\n+            offset = date.length();\n+        } else {\n             String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n             offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n-            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n-                timezone = TIMEZONE_UTC;\n+            if (TIMEZONE_PATTERN.matcher(timezoneOffset).matches()) {\n+                timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n             } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n-                }\n+                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n             }\n-        } else {\n-            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n         }\n         Calendar calendar = new GregorianCalendar(timezone);\n         calendar.setLenient(false);\n@@ -116,8 +93,6 @@\n         calendar.set(Calendar.MILLISECOND, milliseconds);\n         pos.setIndex(offset);\n         return calendar.getTime();\n-        // If we get a ParseException it'll already have the right message/offset.\n-        // Other exception types can convert here.\n     } catch (IndexOutOfBoundsException e) {\n         fail = e;\n     } catch (NumberFormatException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    // truncate up to 3 leap seconds\n                    if (seconds > 59 && seconds < 63)\n                        seconds = 59;\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        // assume at least one digit\n                        int endOffset = indexOfNonDigit(date, offset + 1);\n                        // parse up to 3 digits\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch(// number of digits parsed\n                        parseEndOffset - offset) {\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n        // extract timezone\n        TimeZone timezone = null;\n        if (date.length() <= offset) {\n            timezone = TIMEZONE_UTC;\n        } else {\n            char timezoneIndicator = date.charAt(offset);\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n                offset += timezoneOffset.length();\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n                }\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n            }\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -71,39 +71,26 @@\n             }\n         }\n         // extract timezone\n+        TimeZone timezone = null;\n         if (date.length() <= offset) {\n-            throw new IllegalArgumentException(\"No time zone indicator\");\n-        }\n-        TimeZone timezone = null;\n-        char timezoneIndicator = date.charAt(offset);\n-        if (timezoneIndicator == 'Z') {\n             timezone = TIMEZONE_UTC;\n-            offset += 1;\n-        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n-            String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n-            offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n-            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n+        } else {\n+            char timezoneIndicator = date.charAt(offset);\n+            if (timezoneIndicator == 'Z') {\n                 timezone = TIMEZONE_UTC;\n+                offset += 1;\n+            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n+                String timezoneOffset = date.substring(offset);\n+                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n+                offset += timezoneOffset.length();\n+                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n+                    timezone = TIMEZONE_UTC;\n+                } else {\n+                    timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n+                }\n             } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n-                }\n+                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n             }\n-        } else {\n-            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n         }\n         Calendar calendar = new GregorianCalendar(timezone);\n         calendar.setLenient(false);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c == '.') {\n                    offset += 1;\n                    // assume at least one digit\n                    int endOffset = indexOfNonDigit(date, offset + 1);\n                    // parse up to 3 digits\n                    int parseEndOffset = Math.min(endOffset, offset + 3);\n                    int fraction = parseInt(date, offset, parseEndOffset);\n                    // compensate for \"missing\" digits\n                    switch(// number of digits parsed\n                    parseEndOffset - offset) {\n                        case 2:\n                            milliseconds = fraction * 10;\n                            break;\n                        case 1:\n                            milliseconds = fraction * 100;\n                            break;\n                        default:\n                            milliseconds = fraction;\n                    }\n                    offset = endOffset;\n                }\n                if (date.length() > offset && date.charAt(offset) == 'Z') {\n                    offset += 1;\n                    timezone = TIMEZONE_UTC;\n                } else if (date.length() > offset && (date.charAt(offset) == '+' || date.charAt(offset) == '-')) {\n                    String timezoneOffset = date.substring(offset);\n                    offset += timezoneOffset.length();\n                    // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                    if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                        timezone = TIMEZONE_UTC;\n                    } else {\n                        String timezoneId = \"GMT\" + timezoneOffset;\n                        // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                        //    not sure why, but that's the way it looks. Further, Javadocs for\n                        //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                        //    custom timezones... odd.\n                        timezone = TimeZone.getTimeZone(timezoneId);\n                        String act = timezone.getID();\n                        if (!act.equals(timezoneId)) {\n                            String cleaned = act.replace(\":\", \"\");\n                            if (!cleaned.equals(timezoneId)) {\n                                throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -40,70 +40,53 @@\n             // second and milliseconds can be optional\n             if (date.length() > offset) {\n                 char c = date.charAt(offset);\n-                if (c != 'Z' && c != '+' && c != '-') {\n-                    seconds = parseInt(date, offset, offset += 2);\n-                    // truncate up to 3 leap seconds\n-                    if (seconds > 59 && seconds < 63)\n-                        seconds = 59;\n-                    // milliseconds can be optional in the format\n-                    if (checkOffset(date, offset, '.')) {\n-                        offset += 1;\n-                        // assume at least one digit\n-                        int endOffset = indexOfNonDigit(date, offset + 1);\n-                        // parse up to 3 digits\n-                        int parseEndOffset = Math.min(endOffset, offset + 3);\n-                        int fraction = parseInt(date, offset, parseEndOffset);\n-                        // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n-                            case 2:\n-                                milliseconds = fraction * 10;\n-                                break;\n-                            case 1:\n-                                milliseconds = fraction * 100;\n-                                break;\n-                            default:\n-                                milliseconds = fraction;\n+                if (c == '.') {\n+                    offset += 1;\n+                    // assume at least one digit\n+                    int endOffset = indexOfNonDigit(date, offset + 1);\n+                    // parse up to 3 digits\n+                    int parseEndOffset = Math.min(endOffset, offset + 3);\n+                    int fraction = parseInt(date, offset, parseEndOffset);\n+                    // compensate for \"missing\" digits\n+                    switch(// number of digits parsed\n+                    parseEndOffset - offset) {\n+                        case 2:\n+                            milliseconds = fraction * 10;\n+                            break;\n+                        case 1:\n+                            milliseconds = fraction * 100;\n+                            break;\n+                        default:\n+                            milliseconds = fraction;\n+                    }\n+                    offset = endOffset;\n+                }\n+                if (date.length() > offset && date.charAt(offset) == 'Z') {\n+                    offset += 1;\n+                    timezone = TIMEZONE_UTC;\n+                } else if (date.length() > offset && (date.charAt(offset) == '+' || date.charAt(offset) == '-')) {\n+                    String timezoneOffset = date.substring(offset);\n+                    offset += timezoneOffset.length();\n+                    // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n+                    if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n+                        timezone = TIMEZONE_UTC;\n+                    } else {\n+                        String timezoneId = \"GMT\" + timezoneOffset;\n+                        // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n+                        //    not sure why, but that's the way it looks. Further, Javadocs for\n+                        //    `java.util.TimeZone` specifically instruct use of GMT as base for\n+                        //    custom timezones... odd.\n+                        timezone = TimeZone.getTimeZone(timezoneId);\n+                        String act = timezone.getID();\n+                        if (!act.equals(timezoneId)) {\n+                            String cleaned = act.replace(\":\", \"\");\n+                            if (!cleaned.equals(timezoneId)) {\n+                                throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n+                            }\n                         }\n-                        offset = endOffset;\n                     }\n                 }\n             }\n-        }\n-        // extract timezone\n-        if (date.length() <= offset) {\n-            throw new IllegalArgumentException(\"No time zone indicator\");\n-        }\n-        TimeZone timezone = null;\n-        char timezoneIndicator = date.charAt(offset);\n-        if (timezoneIndicator == 'Z') {\n-            timezone = TIMEZONE_UTC;\n-            offset += 1;\n-        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n-            String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n-            offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n-            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n-                timezone = TIMEZONE_UTC;\n-            } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n-                }\n-            }\n-        } else {\n-            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n         }\n         Calendar calendar = new GregorianCalendar(timezone);\n         calendar.setLenient(false);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c == '.') { // milliseconds\n                    offset += 1;\n                    int endIndex = indexOfNonDigit(date, offset + 1);\n                    int parseEndIndex = Math.min(endIndex, offset + 3); // up to 3 decimal places\n                    int fraction = parseInt(date, offset, parseEndIndex);\n                    // pad with zeros if necessary\n                    if (parseEndIndex - offset == 1) {\n                        fraction *= 100;\n                    } else if (parseEndIndex - offset == 2) {\n                        fraction *= 10;\n                    }\n                    milliseconds = fraction;\n                    offset = endIndex;\n                }\n                if (c == '+' || c == '-') { // timezone offset\n                    int tzHour = parseInt(date, offset + 1, offset + 3);\n                    int tzMinute = 0;\n                    if (date.length() >= offset + 6 && checkOffset(date, offset + 3, ':')) {\n                        tzMinute = parseInt(date, offset + 4, offset + 6);\n                    }\n                    int tzOffset = (tzHour * 60 + tzMinute) * 60 * 1000;\n                    if (c == '+') {\n                        milliseconds -= tzOffset;\n                    } else {\n                        milliseconds += tzOffset;\n                    }\n                    offset += 6;\n                }\n            }\n        }\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n        if (timezoneIndicator == 'Z') {\n            timezone = TimeZone.getTimeZone(\"UTC\");\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n            timezoneOffset = timezoneOffset.replaceAll(\":\", \"\");\n            String timezoneId = \"GMT\" + timezoneOffset;\n            timezone = TimeZone.getTimeZone(timezoneId);\n            String act = timezone.getID();\n            if (!act.equals(timezoneId)) {\n                throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n            }\n            offset += timezoneOffset.length();\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -40,33 +40,33 @@\n             // second and milliseconds can be optional\n             if (date.length() > offset) {\n                 char c = date.charAt(offset);\n-                if (c != 'Z' && c != '+' && c != '-') {\n-                    seconds = parseInt(date, offset, offset += 2);\n-                    // truncate up to 3 leap seconds\n-                    if (seconds > 59 && seconds < 63)\n-                        seconds = 59;\n-                    // milliseconds can be optional in the format\n-                    if (checkOffset(date, offset, '.')) {\n-                        offset += 1;\n-                        // assume at least one digit\n-                        int endOffset = indexOfNonDigit(date, offset + 1);\n-                        // parse up to 3 digits\n-                        int parseEndOffset = Math.min(endOffset, offset + 3);\n-                        int fraction = parseInt(date, offset, parseEndOffset);\n-                        // compensate for \"missing\" digits\n-                        switch(// number of digits parsed\n-                        parseEndOffset - offset) {\n-                            case 2:\n-                                milliseconds = fraction * 10;\n-                                break;\n-                            case 1:\n-                                milliseconds = fraction * 100;\n-                                break;\n-                            default:\n-                                milliseconds = fraction;\n-                        }\n-                        offset = endOffset;\n+                if (c == '.') { // milliseconds\n+                    offset += 1;\n+                    int endIndex = indexOfNonDigit(date, offset + 1);\n+                    int parseEndIndex = Math.min(endIndex, offset + 3); // up to 3 decimal places\n+                    int fraction = parseInt(date, offset, parseEndIndex);\n+                    // pad with zeros if necessary\n+                    if (parseEndIndex - offset == 1) {\n+                        fraction *= 100;\n+                    } else if (parseEndIndex - offset == 2) {\n+                        fraction *= 10;\n                     }\n+                    milliseconds = fraction;\n+                    offset = endIndex;\n+                }\n+                if (c == '+' || c == '-') { // timezone offset\n+                    int tzHour = parseInt(date, offset + 1, offset + 3);\n+                    int tzMinute = 0;\n+                    if (date.length() >= offset + 6 && checkOffset(date, offset + 3, ':')) {\n+                        tzMinute = parseInt(date, offset + 4, offset + 6);\n+                    }\n+                    int tzOffset = (tzHour * 60 + tzMinute) * 60 * 1000;\n+                    if (c == '+') {\n+                        milliseconds -= tzOffset;\n+                    } else {\n+                        milliseconds += tzOffset;\n+                    }\n+                    offset += 6;\n                 }\n             }\n         }\n@@ -77,31 +77,18 @@\n         TimeZone timezone = null;\n         char timezoneIndicator = date.charAt(offset);\n         if (timezoneIndicator == 'Z') {\n-            timezone = TIMEZONE_UTC;\n+            timezone = TimeZone.getTimeZone(\"UTC\");\n             offset += 1;\n         } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n             String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n+            timezoneOffset = timezoneOffset.replaceAll(\":\", \"\");\n+            String timezoneId = \"GMT\" + timezoneOffset;\n+            timezone = TimeZone.getTimeZone(timezoneId);\n+            String act = timezone.getID();\n+            if (!act.equals(timezoneId)) {\n+                throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n+            }\n             offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n-            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n-                timezone = TIMEZONE_UTC;\n-            } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n-                }\n-            }\n         } else {\n             throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n         }\n@@ -116,8 +103,6 @@\n         calendar.set(Calendar.MILLISECOND, milliseconds);\n         pos.setIndex(offset);\n         return calendar.getTime();\n-        // If we get a ParseException it'll already have the right message/offset.\n-        // Other exception types can convert here.\n     } catch (IndexOutOfBoundsException e) {\n         fail = e;\n     } catch (NumberFormatException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    // truncate up to 3 leap seconds\n                    if (seconds > 59 && seconds < 63)\n                        seconds = 59;\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        // assume at least one digit\n                        int endOffset = indexOfNonDigit(date, offset + 1);\n                        // parse up to 3 digits\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch(// number of digits parsed\n                        parseEndOffset - offset) {\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n            offset += timezoneOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                String timezoneId = \"GMT\" + timezoneOffset;\n                //                    String timezoneId = \"UTC\" + timezoneOffset;\n                timezone = TimeZone.getTimeZone(timezoneId);\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    String cleaned = act.replace(\":\", \"\").replace(\"GMT\", \"\");\n                    if (!cleaned.equals(timezoneOffset)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneOffset + \" given, resolves to \" + timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -96,9 +96,9 @@\n                 timezone = TimeZone.getTimeZone(timezoneId);\n                 String act = timezone.getID();\n                 if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n+                    String cleaned = act.replace(\":\", \"\").replace(\"GMT\", \"\");\n+                    if (!cleaned.equals(timezoneOffset)) {\n+                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneOffset + \" given, resolves to \" + timezone.getID());\n                     }\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        // always use 0 otherwise returned date will include millis of current time\n        int milliseconds = 0;\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(TIMEZONE_UTC);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n        if (hasT) {\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    // truncate up to 3 leap seconds\n                    if (seconds > 59 && seconds < 63)\n                        seconds = 59;\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        // assume at least one digit\n                        int endOffset = indexOfNonDigit(date, offset + 1);\n                        // parse up to 3 digits\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch(// number of digits parsed\n                        parseEndOffset - offset) {\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n        // extract timezone\n        TimeZone timezone;\n        if (date.length() <= offset) {\n            timezone = TIMEZONE_UTC;\n        } else {\n            char timezoneIndicator = date.charAt(offset);\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n                offset += timezoneOffset.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n                }\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n            }\n        }\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}", "diff": "--- com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n+++ com/google/gson/internal/bind/util/ISO8601Utils.java@parse\n@@ -23,7 +23,11 @@\n         // if the value has no time component (and no time zone), we are done\n         boolean hasT = checkOffset(date, offset, 'T');\n         if (!hasT && (date.length() <= offset)) {\n-            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n+            Calendar calendar = new GregorianCalendar(TIMEZONE_UTC);\n+            calendar.setLenient(false);\n+            calendar.set(Calendar.YEAR, year);\n+            calendar.set(Calendar.MONTH, month - 1);\n+            calendar.set(Calendar.DAY_OF_MONTH, day);\n             pos.setIndex(offset);\n             return calendar.getTime();\n         }\n@@ -71,39 +75,27 @@\n             }\n         }\n         // extract timezone\n+        TimeZone timezone;\n         if (date.length() <= offset) {\n-            throw new IllegalArgumentException(\"No time zone indicator\");\n-        }\n-        TimeZone timezone = null;\n-        char timezoneIndicator = date.charAt(offset);\n-        if (timezoneIndicator == 'Z') {\n             timezone = TIMEZONE_UTC;\n-            offset += 1;\n-        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n-            String timezoneOffset = date.substring(offset);\n-            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n-            offset += timezoneOffset.length();\n-            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n-            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n+        } else {\n+            char timezoneIndicator = date.charAt(offset);\n+            if (timezoneIndicator == 'Z') {\n                 timezone = TIMEZONE_UTC;\n+                offset += 1;\n+            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n+                String timezoneOffset = date.substring(offset);\n+                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n+                offset += timezoneOffset.length();\n+                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n+                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n+                    timezone = TIMEZONE_UTC;\n+                } else {\n+                    timezone = TimeZone.getTimeZone(\"GMT\" + timezoneOffset);\n+                }\n             } else {\n-                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n-                //    not sure why, but that's the way it looks. Further, Javadocs for\n-                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n-                //    custom timezones... odd.\n-                String timezoneId = \"GMT\" + timezoneOffset;\n-                //                    String timezoneId = \"UTC\" + timezoneOffset;\n-                timezone = TimeZone.getTimeZone(timezoneId);\n-                String act = timezone.getID();\n-                if (!act.equals(timezoneId)) {\n-                                        String cleaned = act.replace(\":\", \"\");\n-                    if (!cleaned.equals(timezoneId)) {\n-                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\n-                    }\n-                }\n+                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n             }\n-        } else {\n-            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n         }\n         Calendar calendar = new GregorianCalendar(timezone);\n         calendar.setLenient(false);\n", "finish_reason": "stop", "valid": false, "num": 1}]