[{"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // doesn't handle scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; ) {\n        // scan to first instance of startchar:\n        while (offset < length && startChar != input[offset]) {\n            offset++;\n        }\n        if (offset < length) {\n            int i = offset + 1;\n            int last = i + seq.length() - 1;\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) {\n                return offset - pos;\n            }\n        } else {\n            break;\n        }\n        offset++;\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,18 +1,22 @@\n int nextIndexOf(CharSequence seq) {\n     // doesn't handle scanning for surrogates\n     char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n+    for (int offset = pos; offset < length; ) {\n         // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n-        int last = i + seq.length() - 1;\n+        while (offset < length && startChar != input[offset]) {\n+            offset++;\n+        }\n         if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n+            int i = offset + 1;\n+            int last = i + seq.length() - 1;\n+            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n+            if (i == last) {\n                 return offset - pos;\n+            }\n+        } else {\n+            break;\n         }\n+        offset++;\n     }\n     return -1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // correctly handles scanning for surrogates\n    char[] startChars = Character.toChars(seq.charAt(0));\n    for (int offset = pos; offset < length; ) {\n        // scan to first instance of startchar:\n        if (!matchesSurrogatePair(input, offset, startChars))\n            while (++offset < length && !matchesSurrogatePair(input, offset, startChars)) ;\n        int i = offset + startChars.length;\n        int last = i + seq.length() - 1;\n        if (last > length)\n            return -1;\n        if (seq.subSequence(1, seq.length()).equals(input.subSequence(i, last)))\n            return offset - pos;\n        else\n            offset += 1;\n    }\n    return -1;\n}\n\nprivate static boolean matchesSurrogatePair(CharSequence input, int pos, char[] surrogatePair) {\n    if (pos + 1 < input.length() && Character.isHighSurrogate(input.charAt(pos))) {\n        return input.charAt(pos) == surrogatePair[0] && input.charAt(pos + 1) == surrogatePair[1];\n    } else {\n        return input.charAt(pos) == surrogatePair[0];\n    }\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,18 +1,18 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n+    // correctly handles scanning for surrogates\n+    char[] startChars = Character.toChars(seq.charAt(0));\n+    for (int offset = pos; offset < length; ) {\n         // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n+        if (!matchesSurrogatePair(input, offset, startChars))\n+            while (++offset < length && !matchesSurrogatePair(input, offset, startChars)) ;\n+        int i = offset + startChars.length;\n         int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n-                return offset - pos;\n-        }\n+        if (last > length)\n+            return -1;\n+        if (seq.subSequence(1, seq.length()).equals(input.subSequence(i, last)))\n+            return offset - pos;\n+        else\n+            offset += 1;\n     }\n     return -1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; ) {\n        // scan to first instance of startchar:\n        if (!Character.isSurrogate(input[offset]) && startChar != input[offset])\n            while (++offset < length && !Character.isSurrogate(input[offset]) && startChar != input[offset]) ;\n        if (offset >= length)\n            return -1;\n        int i = offset + Character.charCount(input[offset]);\n        int last = i + seq.length() - 1;\n        if (last >= length)\n            return -1;\n        for (int j = 1; i < last && Character.codePointAt(seq, j) == Character.codePointAt(input, i); i += Character.charCount(input[i]), j++) ;\n        if (i == last && Character.codePointAt(seq, seq.length() - 1) == Character.codePointAt(input, last))\n            return offset - pos;\n        offset += Character.charCount(input[offset]);\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,18 +1,20 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length; ) {\n         // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n+        if (!Character.isSurrogate(input[offset]) && startChar != input[offset])\n+            while (++offset < length && !Character.isSurrogate(input[offset]) && startChar != input[offset]) ;\n+        if (offset >= length)\n+            return -1;\n+        int i = offset + Character.charCount(input[offset]);\n         int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n-                return offset - pos;\n-        }\n+        if (last >= length)\n+            return -1;\n+        for (int j = 1; i < last && Character.codePointAt(seq, j) == Character.codePointAt(input, i); i += Character.charCount(input[i]), j++) ;\n+        if (i == last && Character.codePointAt(seq, seq.length() - 1) == Character.codePointAt(input, last))\n+            return offset - pos;\n+        offset += Character.charCount(input[offset]);\n     }\n     return -1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startChar:\n        if (startChar != input[offset]) {\n            while (++offset < length && startChar != input[offset]) {\n                // Skip over surrogates\n                if (Character.isHighSurrogate(input[offset]) && offset + 1 < length &&\n                        Character.isLowSurrogate(input[offset + 1])) {\n                    offset++;\n                }\n            }\n        }\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n            if (i == last) {\n                return offset - pos;\n            }\n        }\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,17 +1,23 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n     char startChar = seq.charAt(0);\n     for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n+        // scan to first instance of startChar:\n+        if (startChar != input[offset]) {\n+            while (++offset < length && startChar != input[offset]) {\n+                // Skip over surrogates\n+                if (Character.isHighSurrogate(input[offset]) && offset + 1 < length &&\n+                        Character.isLowSurrogate(input[offset + 1])) {\n+                    offset++;\n+                }\n+            }\n+        }\n         int i = offset + 1;\n         int last = i + seq.length() - 1;\n         if (offset < length) {\n             for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n+            if (i == last) {\n                 return offset - pos;\n+            }\n         }\n     }\n     return -1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != Character.codePointAt(input, offset))\n            while (++offset < length && startChar != Character.codePointAt(input, offset)) ;\n        int i = offset + Character.charCount(startChar);\n        int last = i + seq.length() - 1;\n        if (last <= length) {\n            for (int j = 1; i <= last && Character.codePointAt(seq, j) == Character.codePointAt(input, i); i += Character.charCount(Character.codePointAt(input, i)), j++) ;\n            if (i > last) {\n                return offset - pos;\n            }\n        }\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,17 +1,17 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n     for (int offset = pos; offset < length; offset++) {\n         // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n+        if (startChar != Character.codePointAt(input, offset))\n+            while (++offset < length && startChar != Character.codePointAt(input, offset)) ;\n+        int i = offset + Character.charCount(startChar);\n         int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n+        if (last <= length) {\n+            for (int j = 1; i <= last && Character.codePointAt(seq, j) == Character.codePointAt(input, i); i += Character.charCount(Character.codePointAt(input, i)), j++) ;\n+            if (i > last) {\n                 return offset - pos;\n+            }\n         }\n     }\n     return -1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startChar\n        if (!Character.isSurrogate(input[offset]) && startChar != input[offset]) {\n            while (++offset < length && (!Character.isSurrogate(input[offset]) && startChar != input[offset])) ;\n        }\n        if (offset >= length) {\n            // couldn't find startChar, return -1\n            return -1;\n        }\n        int i = offset + Character.charCount(startChar);\n        int last = i + seq.length() - 1;\n        if (last >= length) {\n            // not enough characters left in input to match seq\n            break;\n        }\n        boolean foundFullSequence = true;\n        for (int j = 1; i < last; j++) {\n            int expectedChar = Character.codePointAt(seq, j);\n            int actualChar = Character.codePointAt(input, i);\n            if (expectedChar != actualChar) {\n                foundFullSequence = false;\n                break;\n            }\n            i += Character.charCount(actualChar);\n        }\n        if (foundFullSequence) {\n            return offset - pos;\n        }\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,17 +1,33 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n     for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n+        // scan to first instance of startChar\n+        if (!Character.isSurrogate(input[offset]) && startChar != input[offset]) {\n+            while (++offset < length && (!Character.isSurrogate(input[offset]) && startChar != input[offset])) ;\n+        }\n+        if (offset >= length) {\n+            // couldn't find startChar, return -1\n+            return -1;\n+        }\n+        int i = offset + Character.charCount(startChar);\n         int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n-                return offset - pos;\n+        if (last >= length) {\n+            // not enough characters left in input to match seq\n+            break;\n+        }\n+        boolean foundFullSequence = true;\n+        for (int j = 1; i < last; j++) {\n+            int expectedChar = Character.codePointAt(seq, j);\n+            int actualChar = Character.codePointAt(input, i);\n+            if (expectedChar != actualChar) {\n+                foundFullSequence = false;\n+                break;\n+            }\n+            i += Character.charCount(actualChar);\n+        }\n+        if (foundFullSequence) {\n+            return offset - pos;\n         }\n     }\n     return -1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; ) {\n        // scan to first instance of startChar:\n        if (startChar != input[offset]) {\n            offset += Character.charCount(input[offset]);\n            continue;\n        }\n        int i = offset + Character.charCount(input[offset]);\n        int last = i + seq.length() - 1;\n        if (last > length) {\n            break;\n        }\n        CharSequence subSeq = new String(input, i, last - i + 1);\n        if (subSeq.equals(seq)) {\n            return offset - pos;\n        }\n        offset += Character.charCount(input[offset]);\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,18 +1,22 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length; ) {\n+        // scan to first instance of startChar:\n+        if (startChar != input[offset]) {\n+            offset += Character.charCount(input[offset]);\n+            continue;\n+        }\n+        int i = offset + Character.charCount(input[offset]);\n         int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n-                return offset - pos;\n+        if (last > length) {\n+            break;\n         }\n+        CharSequence subSeq = new String(input, i, last - i + 1);\n+        if (subSeq.equals(seq)) {\n+            return offset - pos;\n+        }\n+        offset += Character.charCount(input[offset]);\n     }\n     return -1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; ) {\n        int codePoint = Character.codePointAt(input, offset);\n        int charCount = Character.charCount(codePoint);\n        // scan to first instance of startChar\n        if (startChar != codePoint) {\n            offset += charCount;\n            while (offset < length) {\n                codePoint = Character.codePointAt(input, offset);\n                charCount = Character.charCount(codePoint);\n                if (startChar == codePoint)\n                    break;\n                offset += charCount;\n            }\n        }\n        // compare the rest of the sequence\n        if (offset < length) {\n            int i = offset + charCount;\n            int last = i + seq.length() - 1;\n            if (last > length)\n                return -1;\n            int j = 1;\n            for (; i < last; j++) {\n                int cp = Character.codePointAt(input, i);\n                if (seq.charAt(j) != cp)\n                    break;\n                i += Character.charCount(cp);\n            }\n            if (i == last)\n                return offset - pos;\n            offset += charCount;\n        }\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,17 +1,36 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n+    // handles scanning for surrogates\n     char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n-        int last = i + seq.length() - 1;\n+    for (int offset = pos; offset < length; ) {\n+        int codePoint = Character.codePointAt(input, offset);\n+        int charCount = Character.charCount(codePoint);\n+        // scan to first instance of startChar\n+        if (startChar != codePoint) {\n+            offset += charCount;\n+            while (offset < length) {\n+                codePoint = Character.codePointAt(input, offset);\n+                charCount = Character.charCount(codePoint);\n+                if (startChar == codePoint)\n+                    break;\n+                offset += charCount;\n+            }\n+        }\n+        // compare the rest of the sequence\n         if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n+            int i = offset + charCount;\n+            int last = i + seq.length() - 1;\n+            if (last > length)\n+                return -1;\n+            int j = 1;\n+            for (; i < last; j++) {\n+                int cp = Character.codePointAt(input, i);\n+                if (seq.charAt(j) != cp)\n+                    break;\n+                i += Character.charCount(cp);\n+            }\n+            if (i == last)\n                 return offset - pos;\n+            offset += charCount;\n         }\n     }\n     return -1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n   // handles scanning for surrogates\n   int start = pos;\n   char startChar = seq.charAt(0);\n   while (start < length) {\n      int idx = input.indexOf(startChar, start);\n      if (idx < 0) {\n         return -1;\n      }\n      int remaining = length - idx;\n      if (remaining < seq.length()) {\n         return -1;\n      }\n      if (input.regionMatches(idx, seq, 0, seq.length())) {\n         return idx - pos;\n      }\n      start = idx + 1;\n   }\n   return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,18 +1,20 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n-        int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n-                return offset - pos;\n-        }\n-    }\n-    return -1;\n+   // handles scanning for surrogates\n+   int start = pos;\n+   char startChar = seq.charAt(0);\n+   while (start < length) {\n+      int idx = input.indexOf(startChar, start);\n+      if (idx < 0) {\n+         return -1;\n+      }\n+      int remaining = length - idx;\n+      if (remaining < seq.length()) {\n+         return -1;\n+      }\n+      if (input.regionMatches(idx, seq, 0, seq.length())) {\n+         return idx - pos;\n+      }\n+      start = idx + 1;\n+   }\n+   return -1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length;) {\n        // scan to first instance of startChar:\n        if (startChar != Character.codePointAt(input, offset)) {\n            offset += Character.charCount(Character.codePointAt(input, offset));\n            continue;\n        }\n        int i = offset + Character.charCount(startChar);\n        int last = i + seq.length();\n        if (last > length) {\n            break;\n        }\n        for (int j = 1; i < last && Character.codePointAt(seq, j) == Character.codePointAt(input, i);) {\n            i += Character.charCount(Character.codePointAt(input, i));\n            j++;\n        }\n        if (i == last) {\n            return offset - pos;\n        } else {\n            offset += Character.charCount(Character.codePointAt(input, offset));\n        }\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,17 +1,25 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n-        int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n-                return offset - pos;\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length;) {\n+        // scan to first instance of startChar:\n+        if (startChar != Character.codePointAt(input, offset)) {\n+            offset += Character.charCount(Character.codePointAt(input, offset));\n+            continue;\n+        }\n+        int i = offset + Character.charCount(startChar);\n+        int last = i + seq.length();\n+        if (last > length) {\n+            break;\n+        }\n+        for (int j = 1; i < last && Character.codePointAt(seq, j) == Character.codePointAt(input, i);) {\n+            i += Character.charCount(Character.codePointAt(input, i));\n+            j++;\n+        }\n+        if (i == last) {\n+            return offset - pos;\n+        } else {\n+            offset += Character.charCount(Character.codePointAt(input, offset));\n         }\n     }\n     return -1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; ) {\n        int codePoint = Character.codePointAt(input, offset);\n        if (startChar != codePoint) {\n            offset += Character.charCount(codePoint);\n            while (offset < length) {\n                codePoint = Character.codePointAt(input, offset);\n                if (startChar == codePoint) {\n                    offset -= Character.charCount(startChar);\n                    break;\n                }\n                offset += Character.charCount(codePoint);\n            }\n        }\n        if (offset >= length) {\n            break;\n        }\n        int i = offset + Character.charCount(startChar);\n        int last = i + seq.length() - 1;\n        if (last <= length) {\n            int j = Character.charCount(startChar);\n            while (i < last && input[i] == seq.charAt(j)) {\n                i += Character.charCount(Character.codePointAt(seq, j));\n                j++;\n            }\n            if (i == last) {\n                return offset - pos;\n            }\n        }\n        offset += Character.charCount(codePoint);\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,18 +1,35 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length; ) {\n+        int codePoint = Character.codePointAt(input, offset);\n+        if (startChar != codePoint) {\n+            offset += Character.charCount(codePoint);\n+            while (offset < length) {\n+                codePoint = Character.codePointAt(input, offset);\n+                if (startChar == codePoint) {\n+                    offset -= Character.charCount(startChar);\n+                    break;\n+                }\n+                offset += Character.charCount(codePoint);\n+            }\n+        }\n+        if (offset >= length) {\n+            break;\n+        }\n+        int i = offset + Character.charCount(startChar);\n         int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n+        if (last <= length) {\n+            int j = Character.charCount(startChar);\n+            while (i < last && input[i] == seq.charAt(j)) {\n+                i += Character.charCount(Character.codePointAt(seq, j));\n+                j++;\n+            }\n+            if (i == last) {\n                 return offset - pos;\n+            }\n         }\n+        offset += Character.charCount(codePoint);\n     }\n     return -1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; ) {\n        // scan to first instance of startchar:\n        if (startChar != Character.codePointAt(input, offset)) {\n            offset += Character.charCount(Character.codePointAt(input, offset));\n        } else {\n            int i = offset + Character.charCount(startChar);\n            int last = i + seq.length() - 1;\n            if (last > length) {\n                break;\n            }\n            for (int j = 1; i < last && seq.charAt(j) == Character.charCount(input, i); i += Character.charCount(Character.codePointAt(input, i)), j++);\n            if (i == last) {\n                return offset - pos;\n            }\n            offset += Character.charCount(Character.codePointAt(input, offset));\n        }\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,17 +1,21 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length; ) {\n         // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n-        int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n+        if (startChar != Character.codePointAt(input, offset)) {\n+            offset += Character.charCount(Character.codePointAt(input, offset));\n+        } else {\n+            int i = offset + Character.charCount(startChar);\n+            int last = i + seq.length() - 1;\n+            if (last > length) {\n+                break;\n+            }\n+            for (int j = 1; i < last && seq.charAt(j) == Character.charCount(input, i); i += Character.charCount(Character.codePointAt(input, i)), j++);\n+            if (i == last) {\n                 return offset - pos;\n+            }\n+            offset += Character.charCount(Character.codePointAt(input, offset));\n         }\n     }\n     return -1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length;) {\n        int codePoint = Character.codePointAt(input, offset);\n        if (codePoint != startChar) {\n            offset += Character.charCount(codePoint);\n        } else {\n            int i = offset + Character.charCount(codePoint);\n            int last = i + seq.length() - 1;\n            if (last > length) {\n                break;\n            }\n            for (int j = 1, k = i; j < seq.length() && k < last; j++, k += Character.charCount(Character.codePointAt(input, k))) {\n                if (seq.charAt(j) != input[k]) {\n                    offset += Character.charCount(codePoint);\n                    continue;\n                }\n            }\n            if (i == last) {\n                return offset - pos;\n            }\n            offset += Character.charCount(codePoint);\n        }\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,17 +1,26 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n-        int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length;) {\n+        int codePoint = Character.codePointAt(input, offset);\n+        if (codePoint != startChar) {\n+            offset += Character.charCount(codePoint);\n+        } else {\n+            int i = offset + Character.charCount(codePoint);\n+            int last = i + seq.length() - 1;\n+            if (last > length) {\n+                break;\n+            }\n+            for (int j = 1, k = i; j < seq.length() && k < last; j++, k += Character.charCount(Character.codePointAt(input, k))) {\n+                if (seq.charAt(j) != input[k]) {\n+                    offset += Character.charCount(codePoint);\n+                    continue;\n+                }\n+            }\n+            if (i == last) {\n                 return offset - pos;\n+            }\n+            offset += Character.charCount(codePoint);\n         }\n     }\n     return -1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; ) {\n        // scan to first instance of startChar\n        int codePoint = Character.codePointAt(input, offset);\n        if (startChar != codePoint)\n            while (++offset < length) {\n                codePoint = Character.codePointAt(input, offset);\n                if (startChar == codePoint)\n                    break;\n            }\n        int i = offset + Character.charCount(codePoint);\n        int last = i;\n        for (int j = 1; j < seq.length(); j++) {\n            if (i >= length)\n                return -1;\n            codePoint = Character.codePointAt(input, i);\n            if (seq.charAt(j) != codePoint)\n                break;\n            last += Character.charCount(codePoint);\n            i += Character.charCount(codePoint);\n        }\n        if (i == last)\n            return offset - pos;\n        offset += Character.charCount(codePoint);\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,18 +1,29 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n-        int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n-                return offset - pos;\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length; ) {\n+        // scan to first instance of startChar\n+        int codePoint = Character.codePointAt(input, offset);\n+        if (startChar != codePoint)\n+            while (++offset < length) {\n+                codePoint = Character.codePointAt(input, offset);\n+                if (startChar == codePoint)\n+                    break;\n+            }\n+        int i = offset + Character.charCount(codePoint);\n+        int last = i;\n+        for (int j = 1; j < seq.length(); j++) {\n+            if (i >= length)\n+                return -1;\n+            codePoint = Character.codePointAt(input, i);\n+            if (seq.charAt(j) != codePoint)\n+                break;\n+            last += Character.charCount(codePoint);\n+            i += Character.charCount(codePoint);\n         }\n+        if (i == last)\n+            return offset - pos;\n+        offset += Character.charCount(codePoint);\n     }\n     return -1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length;) {\n        // scan to first instance of startchar:\n        if (!Character.isSurrogate(input[offset]) && startChar != input[offset]) {\n            do {\n                offset++;\n            } while (offset < length && !Character.isSurrogate(input[offset]) && startChar != input[offset]);\n        }\n        if (offset >= length) {\n            break;\n        }\n        int i = offset + Character.charCount(input[offset]);\n        int last = i;\n        for (int j = 1; i < length && j < seq.length(); j++) {\n            i += Character.charCount(input[i]);\n            if (i > length || Character.codePointAt(seq, j) != Character.codePointAt(input, i)) {\n                break;\n            }\n            last = i;\n        }\n        if (last == i) {\n            return offset - pos;\n        }\n        offset += Character.charCount(input[offset]);\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,18 +1,29 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length;) {\n         // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n-        int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n-                return offset - pos;\n+        if (!Character.isSurrogate(input[offset]) && startChar != input[offset]) {\n+            do {\n+                offset++;\n+            } while (offset < length && !Character.isSurrogate(input[offset]) && startChar != input[offset]);\n         }\n+        if (offset >= length) {\n+            break;\n+        }\n+        int i = offset + Character.charCount(input[offset]);\n+        int last = i;\n+        for (int j = 1; i < length && j < seq.length(); j++) {\n+            i += Character.charCount(input[i]);\n+            if (i > length || Character.codePointAt(seq, j) != Character.codePointAt(input, i)) {\n+                break;\n+            }\n+            last = i;\n+        }\n+        if (last == i) {\n+            return offset - pos;\n+        }\n+        offset += Character.charCount(input[offset]);\n     }\n     return -1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; ) {\n        int codePoint = Character.codePointAt(input, offset);\n        if (startChar != codePoint) {\n            offset += Character.charCount(codePoint);\n            while (offset < length) {\n                codePoint = Character.codePointAt(input, offset);\n                offset += Character.charCount(codePoint);\n                if (startChar == codePoint) {\n                    break;\n                }\n            }\n        }\n        if (offset < length) {\n            int i = offset + Character.charCount(codePoint);\n            int last = i + seq.length() - 1;\n            if (last <= length) {\n                for (int j = 1; i < last; j++) {\n                    int cp = Character.codePointAt(input, i);\n                    if (seq.charAt(j) != cp) {\n                        break;\n                    }\n                    i += Character.charCount(cp);\n                }\n                if (i == last) {\n                    return offset - pos;\n                }\n            }\n            offset += Character.charCount(codePoint);\n        } else {\n            break;\n        }\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,17 +1,36 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n-        int last = i + seq.length() - 1;\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length; ) {\n+        int codePoint = Character.codePointAt(input, offset);\n+        if (startChar != codePoint) {\n+            offset += Character.charCount(codePoint);\n+            while (offset < length) {\n+                codePoint = Character.codePointAt(input, offset);\n+                offset += Character.charCount(codePoint);\n+                if (startChar == codePoint) {\n+                    break;\n+                }\n+            }\n+        }\n         if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n-                return offset - pos;\n+            int i = offset + Character.charCount(codePoint);\n+            int last = i + seq.length() - 1;\n+            if (last <= length) {\n+                for (int j = 1; i < last; j++) {\n+                    int cp = Character.codePointAt(input, i);\n+                    if (seq.charAt(j) != cp) {\n+                        break;\n+                    }\n+                    i += Character.charCount(cp);\n+                }\n+                if (i == last) {\n+                    return offset - pos;\n+                }\n+            }\n+            offset += Character.charCount(codePoint);\n+        } else {\n+            break;\n         }\n     }\n     return -1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handle scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; ) {\n        // scan to first instance of startchar:\n        if (!Character.isSurrogate(input[offset]) && startChar != input[offset]) {\n            offset++;\n            continue;\n        }\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length) {\n            for (int j = 1; i < last && Character.codePointAt(seq, j) == Character.codePointAt(input, i); ) {\n                i += Character.charCount(Character.codePointAt(input, i));\n                j++;\n            }\n            if (// found full sequence\n            i == last)\n                return offset - pos;\n        }\n        offset += Character.charCount(Character.codePointAt(input, offset));\n    }\n    return -1;\n}\n\n## Fixed Function 2\nString nodeName(String baseUri, String html) {\n    Document doc = Jsoup.parse(html, baseUri, Parser.htmlParser());\n    Element el = doc.select(\"*\").first();\n    return el != null ? el.nodeName() : \"\";\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,18 +1,24 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n+    // handle scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length; ) {\n         // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n+        if (!Character.isSurrogate(input[offset]) && startChar != input[offset]) {\n+            offset++;\n+            continue;\n+        }\n         int i = offset + 1;\n         int last = i + seq.length() - 1;\n         if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n+            for (int j = 1; i < last && Character.codePointAt(seq, j) == Character.codePointAt(input, i); ) {\n+                i += Character.charCount(Character.codePointAt(input, i));\n+                j++;\n+            }\n             if (// found full sequence\n             i == last)\n                 return offset - pos;\n         }\n+        offset += Character.charCount(Character.codePointAt(input, offset));\n     }\n     return -1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; ) {\n        int codePoint = Character.codePointAt(input, offset);\n        // scan to first instance of startChar:\n        if (startChar != codePoint) {\n            offset += Character.charCount(codePoint);\n            while (offset < length) {\n                codePoint = Character.codePointAt(input, offset);\n                if (startChar == codePoint)\n                    break;\n                offset += Character.charCount(codePoint);\n            }\n        }\n        int i = offset + Character.charCount(codePoint);\n        int last = i + seq.length() - 1;\n        if (last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n            if (// found full sequence\n            i == last)\n                return offset - pos;\n            offset += Character.charCount(Character.codePointAt(input, offset));\n        } else {\n            break;\n        }\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,17 +1,28 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n+    // handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length; ) {\n+        int codePoint = Character.codePointAt(input, offset);\n+        // scan to first instance of startChar:\n+        if (startChar != codePoint) {\n+            offset += Character.charCount(codePoint);\n+            while (offset < length) {\n+                codePoint = Character.codePointAt(input, offset);\n+                if (startChar == codePoint)\n+                    break;\n+                offset += Character.charCount(codePoint);\n+            }\n+        }\n+        int i = offset + Character.charCount(codePoint);\n         int last = i + seq.length() - 1;\n-        if (offset < length) {\n+        if (last <= length) {\n             for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n             if (// found full sequence\n             i == last)\n                 return offset - pos;\n+            offset += Character.charCount(Character.codePointAt(input, offset));\n+        } else {\n+            break;\n         }\n     }\n     return -1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // properly handles scanning for surrogates\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; ) {\n        int codePoint = Character.codePointAt(input, offset);\n        // scan to first instance of startChar:\n        if (startChar != codePoint)\n            do {\n                offset += Character.charCount(codePoint);\n                if (offset >= length)\n                    return -1;\n                codePoint = Character.codePointAt(input, offset);\n            } while (startChar != codePoint);\n        int i = offset + Character.charCount(codePoint);\n        int last = i + seq.length() - 1;\n        if (last <= length) {\n            for (int j = 1; i < last && Character.codePointAt(seq, j) == Character.codePointAt(input, i); ) {\n                i += Character.charCount(Character.codePointAt(input, i));\n                j++;\n            }\n            if (i == last)\n                return offset - pos;\n            offset += Character.charCount(codePoint);\n        } else {\n            return -1;\n        }\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,17 +1,28 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n-        // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n+    // properly handles scanning for surrogates\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length; ) {\n+        int codePoint = Character.codePointAt(input, offset);\n+        // scan to first instance of startChar:\n+        if (startChar != codePoint)\n+            do {\n+                offset += Character.charCount(codePoint);\n+                if (offset >= length)\n+                    return -1;\n+                codePoint = Character.codePointAt(input, offset);\n+            } while (startChar != codePoint);\n+        int i = offset + Character.charCount(codePoint);\n         int last = i + seq.length() - 1;\n-        if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n-            if (// found full sequence\n-            i == last)\n+        if (last <= length) {\n+            for (int j = 1; i < last && Character.codePointAt(seq, j) == Character.codePointAt(input, i); ) {\n+                i += Character.charCount(Character.codePointAt(input, i));\n+                j++;\n+            }\n+            if (i == last)\n                 return offset - pos;\n+            offset += Character.charCount(codePoint);\n+        } else {\n+            return -1;\n         }\n     }\n     return -1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint nextIndexOf(CharSequence seq) {\n    // accounts for surrogates by using Character.codePointAt() and Character.charCount()\n    int startChar = Character.codePointAt(seq, 0);\n    for (int offset = pos; offset < length; ) {\n        // scan to first instance of startchar:\n        if (startChar != Character.codePointAt(input, offset))\n            while (++offset < length && startChar != Character.codePointAt(input, offset)) ;\n        int i = offset + Character.charCount(startChar);\n        int last = i + seq.length() - 1;\n        if (offset < length) {\n            for (int j = 1; i < last && seq.charAt(j) == Character.charCount(input, i); i += Character.charCount(input, i), j++) ;\n            if (// found full sequence\n            i == last)\n                return offset - pos;\n        }\n    }\n    return -1;\n}", "diff": "--- org/jsoup/parser/CharacterReader.java@nextIndexOf\n+++ org/jsoup/parser/CharacterReader.java@nextIndexOf\n@@ -1,14 +1,14 @@\n int nextIndexOf(CharSequence seq) {\n-    // doesn't handle scanning for surrogates\n-    char startChar = seq.charAt(0);\n-    for (int offset = pos; offset < length; offset++) {\n+    // accounts for surrogates by using Character.codePointAt() and Character.charCount()\n+    int startChar = Character.codePointAt(seq, 0);\n+    for (int offset = pos; offset < length; ) {\n         // scan to first instance of startchar:\n-        if (startChar != input[offset])\n-            while (++offset < length && startChar != input[offset]) ;\n-        int i = offset + 1;\n+        if (startChar != Character.codePointAt(input, offset))\n+            while (++offset < length && startChar != Character.codePointAt(input, offset)) ;\n+        int i = offset + Character.charCount(startChar);\n         int last = i + seq.length() - 1;\n         if (offset < length) {\n-            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) ;\n+            for (int j = 1; i < last && seq.charAt(j) == Character.charCount(input, i); i += Character.charCount(input, i), j++) ;\n             if (// found full sequence\n             i == last)\n                 return offset - pos;\n", "finish_reason": "stop", "valid": false, "num": 1}]