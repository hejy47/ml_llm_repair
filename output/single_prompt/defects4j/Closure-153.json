[{"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, fnNameNode);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, a);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, child);\n                child = next;\n            }\n            return;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            return;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, var);\n            scanVars(block, n);\n            // only one child to scan\n            return;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Implementation left to the reader.\n}\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -8,13 +8,13 @@\n         // been declared in the outer scope.\n         String fnName = fnNameNode.getString();\n         if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n-            declareVar(fnName, fnNameNode, n, null, null, n);\n+            declareVar(fnName, fnNameNode, n, null, null, fnNameNode);\n         }\n         // Args: Declare function variables\n         Preconditions.checkState(args.getType() == Token.LP);\n         for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n             Preconditions.checkState(a.getType() == Token.NAME);\n-            declareVar(a.getString(), a, args, n, null, n);\n+            declareVar(a.getString(), a, args, n, null, a);\n         }\n         // Body\n         scanVars(body, n);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -6,7 +6,7 @@\n                 Node next = child.getNext();\n                 Preconditions.checkState(child.getType() == Token.NAME);\n                 String name = child.getString();\n-                declareVar(name, child, n, parent, null, n);\n+                declareVar(name, child, n, parent, null, child);\n                 child = next;\n             }\n             return;\n@@ -29,7 +29,7 @@\n             // is the code block\n             final Node var = n.getFirstChild();\n             final Node block = var.getNext();\n-            declareVar(var.getString(), var, n, parent, null, n);\n+            declareVar(var.getString(), var, n, parent, null, var);\n             scanVars(block, n);\n             // only one child to scan\n             return;\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -19,6 +19,8 @@\n     } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n         // Disallow shadowing \"arguments\" as we can't handle with our current\n         // scope modeling.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nNo change was needed as it was already fixed.\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION || n.getType() == Token.FUNCTION_EXPRESSION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body - added check to skip null nodes\n        if (body != null) {\n            scanVars(body, n);\n        }\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            return;\n        case Token.FUNCTION:\n        case Token.FUNCTION_EXPRESSION: // added case for function expressions\n            if (NodeUtil.isFunctionExpression(n) && !n.getFirstChild().getString().isEmpty()) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            return;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            return;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\nThe fix is to change the access modifier from `void` to `public`.\n\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, nodeWithLineNumber, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -1,5 +1,5 @@\n private void scanRoot(Node n, Scope parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.getType() == Token.FUNCTION || n.getType() == Token.FUNCTION_EXPRESSION) {\n         sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n         final Node fnNameNode = n.getFirstChild();\n         final Node args = fnNameNode.getNext();\n@@ -16,8 +16,10 @@\n             Preconditions.checkState(a.getType() == Token.NAME);\n             declareVar(a.getString(), a, args, n, null, n);\n         }\n-        // Body\n-        scanVars(body, n);\n+        // Body - added check to skip null nodes\n+        if (body != null) {\n+            scanVars(body, n);\n+        }\n     } else {\n         // It's the global block\n         Preconditions.checkState(scope.getParent() == null);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -11,7 +11,8 @@\n             }\n             return;\n         case Token.FUNCTION:\n-            if (NodeUtil.isFunctionExpression(n)) {\n+        case Token.FUNCTION_EXPRESSION: // added case for function expressions\n+            if (NodeUtil.isFunctionExpression(n) && !n.getFirstChild().getString().isEmpty()) {\n                 return;\n             }\n             String fnName = n.getFirstChild().getString();\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration\n@@ -1 +1,27 @@\n void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n+\n+## Fixed Function 5\n+public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n+    // Don't allow multiple variables to be declared at the top level scope\n+    if (scope.isGlobal()) {\n+        Scope.Var origVar = scope.getVar(name);\n+        Node origParent = origVar.getParentNode();\n+        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n+            // Okay, both are 'catch(x)' variables.\n+            return;\n+        }\n+        boolean allowDupe = false;\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info == null) {\n+            info = parent.getJSDocInfo();\n+        }\n+        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n+        if (!allowDupe) {\n+            compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n+        }\n+    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n+        // Disallow shadowing \"arguments\" as we can't handle with our current\n+        // scope modeling.\n+        compiler.report(JSError.make(sourceName, nodeWithLineNumber, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    }\n+}\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -14,11 +14,11 @@\n         }\n         allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n         if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n+            compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n         }\n     } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n         // Disallow shadowing \"arguments\" as we can't handle with our current\n         // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+        compiler.report(JSError.make(sourceName, nodeWithLineNumber, VAR_ARGUMENTS_SHADOWED_ERROR));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nThere is only one buggy function provided in the example project, and it has been fixed in the previous section.\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            // Add fnNameNode to scope\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            // Add the name to the scope\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                // Add the name to the scope\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            return;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            // Add the function name to the scope\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            return;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            // Add the name to the scope\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            return;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\nThe previous section showed the buggy implementation of the method `onRedeclaration`, but did not provide enough context to determine a fix. Without additional information, we cannot fix the buggy function.\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origVar == null || (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH)) {\n            // Original variable not found in scope, or both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        // Pass the nodeWithLineNumber argument to onRedeclaration\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -8,12 +8,14 @@\n         // been declared in the outer scope.\n         String fnName = fnNameNode.getString();\n         if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n+            // Add fnNameNode to scope\n             declareVar(fnName, fnNameNode, n, null, null, n);\n         }\n         // Args: Declare function variables\n         Preconditions.checkState(args.getType() == Token.LP);\n         for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n             Preconditions.checkState(a.getType() == Token.NAME);\n+            // Add the name to the scope\n             declareVar(a.getString(), a, args, n, null, n);\n         }\n         // Body\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -6,6 +6,7 @@\n                 Node next = child.getNext();\n                 Preconditions.checkState(child.getType() == Token.NAME);\n                 String name = child.getString();\n+                // Add the name to the scope\n                 declareVar(name, child, n, parent, null, n);\n                 child = next;\n             }\n@@ -19,16 +20,17 @@\n                 // This is invalid, but allow it so the checks can catch it.\n                 return;\n             }\n+            // Add the function name to the scope\n             declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n             // should not examine function's children\n             return;\n         case Token.CATCH:\n             Preconditions.checkState(n.getChildCount() == 2);\n             Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n-            // the first child is the catch var and the third child\n-            // is the code block\n+            // the first child is the catch var\n             final Node var = n.getFirstChild();\n             final Node block = var.getNext();\n+            // Add the name to the scope\n             declareVar(var.getString(), var, n, parent, null, n);\n             scanVars(block, n);\n             // only one child to scan\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -3,8 +3,8 @@\n     if (scope.isGlobal()) {\n         Scope.Var origVar = scope.getVar(name);\n         Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n+        if (origVar == null || (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH)) {\n+            // Original variable not found in scope, or both are 'catch(x)' variables.\n             return;\n         }\n         boolean allowDupe = false;\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n@@ -1,5 +1,6 @@\n private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n     if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n+        // Pass the nodeWithLineNumber argument to onRedeclaration\n         redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n     } else {\n         scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            return;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            return;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            return;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber){\n    // FIX: Not provided\n}\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (s.isGlobal()) {\n        Scope.Var origVar = s.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput((String) n.getProp(Node.SOURCENAME_PROP)));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,7 +1,7 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n     // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n+    if (s.isGlobal()) {\n+        Scope.Var origVar = s.getVar(name);\n         Node origParent = origVar.getParentNode();\n         if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n             // Okay, both are 'catch(x)' variables.\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n@@ -2,6 +2,6 @@\n     if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n         redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n     } else {\n-        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n+        scope.declare(name, n, declaredType, compiler.getInput((String) n.getProp(Node.SOURCENAME_PROP)));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            return;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            return;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            return;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\n// The correct function signature is:\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node nodeWithLineNumber);\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions() != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -12,7 +12,7 @@\n         if (info == null) {\n             info = parent.getJSDocInfo();\n         }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n+        allowDupe = info != null && info.getSuppressions() != null && info.getSuppressions().contains(\"duplicate\");\n         if (!allowDupe) {\n             compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n         }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n@@ -1,6 +1,6 @@\n private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n     if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n-        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n+        redeclarationHandler.onRedeclaration(scope, name, n, parent, nodeWithLineNumber);\n     } else {\n         scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1 (Buggy Function 1)\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2; // fixed typo (r + l) to (r - l)\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2 (Buggy Function 2)\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        \n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && !NodeUtil.isFunctionExpression(n)) { // fixed condition (added !)\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n      \n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n\n        scanVars(body, n);\n    } else {\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3 (Buggy Function 3)\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            return;\n        case Token.FUNCTION:\n            if (!NodeUtil.isFunctionExpression(n)) { // fixed condition (added !)\n              String fnName = n.getFirstChild().getString();\n              if (!fnName.isEmpty()) { // fixed condition (added !)\n                  declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n              }\n            }\n            return;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            return;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4 (Buggy Function 4)\n// no fix provided as this is only a method signature\n\n## Fixed Function 5 (Buggy Function 5)\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        if (origVar != null) { // fixed null check condition\n            Node origParent = origVar.getParentNode();\n            if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n                return;\n            }\n            boolean allowDupe = false;\n            JSDocInfo info = n.getJSDocInfo();\n            if (info == null) {\n                info = parent.getJSDocInfo();\n            }\n            allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n            if (!allowDupe) {\n                compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n            }\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6 (Buggy Function 6)\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -4,22 +4,20 @@\n         final Node fnNameNode = n.getFirstChild();\n         final Node args = fnNameNode.getNext();\n         final Node body = args.getNext();\n-        // Bleed the function name into the scope, if it hasn't\n-        // been declared in the outer scope.\n+        \n         String fnName = fnNameNode.getString();\n-        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n+        if (!fnName.isEmpty() && !NodeUtil.isFunctionExpression(n)) { // fixed condition (added !)\n             declareVar(fnName, fnNameNode, n, null, null, n);\n         }\n-        // Args: Declare function variables\n+      \n         Preconditions.checkState(args.getType() == Token.LP);\n         for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n             Preconditions.checkState(a.getType() == Token.NAME);\n             declareVar(a.getString(), a, args, n, null, n);\n         }\n-        // Body\n+\n         scanVars(body, n);\n     } else {\n-        // It's the global block\n         Preconditions.checkState(scope.getParent() == null);\n         scanVars(n, null);\n     }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -1,7 +1,6 @@\n private void scanVars(Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.VAR:\n-            // Declare all variables. e.g. var x = 1, y, z;\n             for (Node child = n.getFirstChild(); child != null; ) {\n                 Node next = child.getNext();\n                 Preconditions.checkState(child.getType() == Token.NAME);\n@@ -11,34 +10,25 @@\n             }\n             return;\n         case Token.FUNCTION:\n-            if (NodeUtil.isFunctionExpression(n)) {\n-                return;\n+            if (!NodeUtil.isFunctionExpression(n)) { // fixed condition (added !)\n+              String fnName = n.getFirstChild().getString();\n+              if (!fnName.isEmpty()) { // fixed condition (added !)\n+                  declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n+              }\n             }\n-            String fnName = n.getFirstChild().getString();\n-            if (fnName.isEmpty()) {\n-                // This is invalid, but allow it so the checks can catch it.\n-                return;\n-            }\n-            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n-            // should not examine function's children\n             return;\n         case Token.CATCH:\n             Preconditions.checkState(n.getChildCount() == 2);\n             Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n-            // the first child is the catch var and the third child\n-            // is the code block\n             final Node var = n.getFirstChild();\n             final Node block = var.getNext();\n             declareVar(var.getString(), var, n, parent, null, n);\n             scanVars(block, n);\n-            // only one child to scan\n             return;\n         case Token.SCRIPT:\n             sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n             break;\n     }\n-    // Variables can only occur in statement-level nodes, so\n-    // we only need to traverse children in a couple special cases.\n     if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n         for (Node child = n.getFirstChild(); child != null; ) {\n             Node next = child.getNext();\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,22 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n     if (scope.isGlobal()) {\n         Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n-        }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n+        if (origVar != null) { // fixed null check condition\n+            Node origParent = origVar.getParentNode();\n+            if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n+                return;\n+            }\n+            boolean allowDupe = false;\n+            JSDocInfo info = n.getJSDocInfo();\n+            if (info == null) {\n+                info = parent.getJSDocInfo();\n+            }\n+            allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n+            if (!allowDupe) {\n+                compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n+            }\n         }\n     } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n         compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            return;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            return;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            return;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (s.isGlobal()) {\n        Scope.Var origVar = s.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 5 (Removed - Duplicate of Fixed Function 4)\nN/A\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node grandparent, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, grandparent, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        } else if (!fnName.isEmpty()) {\n            declareVar(fnName, fnNameNode, n, null, null, fnNameNode);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n    case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            Preconditions.checkState(child.getType() == Token.NAME);\n            String name = child.getString();\n            declareVar(name, child, n, parent, null, n);\n            child = next;\n        }\n        break;\n    case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n            return;\n        }\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n            // This is invalid, but allow it so the checks can catch it.\n            return;\n        }\n        declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n        // should not examine function's children\n        break;\n    case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n        declareVar(var.getString(), var, n, parent, null, n);\n        scanVars(block, n);\n        // only one child to scan\n        break;\n    case Token.SCRIPT:\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        break;\n    default:\n        break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n\n## Fixed Function 4\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber){\n    // fixed implementation is missing\n}\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n) && parent.getType() != Token.FUNCTION) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -9,6 +9,8 @@\n         String fnName = fnNameNode.getString();\n         if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n             declareVar(fnName, fnNameNode, n, null, null, n);\n+        } else if (!fnName.isEmpty()) {\n+            declareVar(fnName, fnNameNode, n, null, null, fnNameNode);\n         }\n         // Args: Declare function variables\n         Preconditions.checkState(args.getType() == Token.LP);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -1,41 +1,43 @@\n private void scanVars(Node n, Node parent) {\n     switch(n.getType()) {\n-        case Token.VAR:\n-            // Declare all variables. e.g. var x = 1, y, z;\n-            for (Node child = n.getFirstChild(); child != null; ) {\n-                Node next = child.getNext();\n-                Preconditions.checkState(child.getType() == Token.NAME);\n-                String name = child.getString();\n-                declareVar(name, child, n, parent, null, n);\n-                child = next;\n-            }\n+    case Token.VAR:\n+        // Declare all variables. e.g. var x = 1, y, z;\n+        for (Node child = n.getFirstChild(); child != null; ) {\n+            Node next = child.getNext();\n+            Preconditions.checkState(child.getType() == Token.NAME);\n+            String name = child.getString();\n+            declareVar(name, child, n, parent, null, n);\n+            child = next;\n+        }\n+        break;\n+    case Token.FUNCTION:\n+        if (NodeUtil.isFunctionExpression(n)) {\n             return;\n-        case Token.FUNCTION:\n-            if (NodeUtil.isFunctionExpression(n)) {\n-                return;\n-            }\n-            String fnName = n.getFirstChild().getString();\n-            if (fnName.isEmpty()) {\n-                // This is invalid, but allow it so the checks can catch it.\n-                return;\n-            }\n-            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n-            // should not examine function's children\n+        }\n+        String fnName = n.getFirstChild().getString();\n+        if (fnName.isEmpty()) {\n+            // This is invalid, but allow it so the checks can catch it.\n             return;\n-        case Token.CATCH:\n-            Preconditions.checkState(n.getChildCount() == 2);\n-            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n-            // the first child is the catch var and the third child\n-            // is the code block\n-            final Node var = n.getFirstChild();\n-            final Node block = var.getNext();\n-            declareVar(var.getString(), var, n, parent, null, n);\n-            scanVars(block, n);\n-            // only one child to scan\n-            return;\n-        case Token.SCRIPT:\n-            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n-            break;\n+        }\n+        declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n+        // should not examine function's children\n+        break;\n+    case Token.CATCH:\n+        Preconditions.checkState(n.getChildCount() == 2);\n+        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n+        // the first child is the catch var and the third child\n+        // is the code block\n+        final Node var = n.getFirstChild();\n+        final Node block = var.getNext();\n+        declareVar(var.getString(), var, n, parent, null, n);\n+        scanVars(block, n);\n+        // only one child to scan\n+        break;\n+    case Token.SCRIPT:\n+        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n+        break;\n+    default:\n+        break;\n     }\n     // Variables can only occur in statement-level nodes, so\n     // we only need to traverse children in a couple special cases.\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -16,7 +16,7 @@\n         if (!allowDupe) {\n             compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n         }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n+    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n) && parent.getType() != Token.FUNCTION) {\n         // Disallow shadowing \"arguments\" as we can't handle with our current\n         // scope modeling.\n         compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nNo changes were made to the function as it was already fixed and correct.\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            break;\n        case Token.FUNCTION:\n            if (!NodeUtil.isFunctionExpression(n)) {\n                String fnName = n.getFirstChild().getString();\n                if (!fnName.isEmpty()) {\n                    declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n                }\n            }\n            break;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            break;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n        default:\n            break;\n    }\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Make this function abstract, so it is implemented properly in the relevant subclasses\n}\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        if (info != null) {\n            allowDupe = info.getSuppressions().contains(\"duplicate\");\n        }\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -9,36 +9,29 @@\n                 declareVar(name, child, n, parent, null, n);\n                 child = next;\n             }\n-            return;\n+            break;\n         case Token.FUNCTION:\n-            if (NodeUtil.isFunctionExpression(n)) {\n-                return;\n+            if (!NodeUtil.isFunctionExpression(n)) {\n+                String fnName = n.getFirstChild().getString();\n+                if (!fnName.isEmpty()) {\n+                    declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n+                }\n             }\n-            String fnName = n.getFirstChild().getString();\n-            if (fnName.isEmpty()) {\n-                // This is invalid, but allow it so the checks can catch it.\n-                return;\n-            }\n-            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n-            // should not examine function's children\n-            return;\n+            break;\n         case Token.CATCH:\n             Preconditions.checkState(n.getChildCount() == 2);\n             Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n-            // the first child is the catch var and the third child\n-            // is the code block\n             final Node var = n.getFirstChild();\n             final Node block = var.getNext();\n             declareVar(var.getString(), var, n, parent, null, n);\n             scanVars(block, n);\n-            // only one child to scan\n-            return;\n+            break;\n         case Token.SCRIPT:\n             sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n             break;\n+        default:\n+            break;\n     }\n-    // Variables can only occur in statement-level nodes, so\n-    // we only need to traverse children in a couple special cases.\n     if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n         for (Node child = n.getFirstChild(); child != null; ) {\n             Node next = child.getNext();\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,10 +1,8 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n     if (scope.isGlobal()) {\n         Scope.Var origVar = scope.getVar(name);\n         Node origParent = origVar.getParentNode();\n         if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n             return;\n         }\n         boolean allowDupe = false;\n@@ -12,13 +10,13 @@\n         if (info == null) {\n             info = parent.getJSDocInfo();\n         }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n+        if (info != null) {\n+            allowDupe = info.getSuppressions().contains(\"duplicate\");\n+        }\n         if (!allowDupe) {\n             compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n         }\n     } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n         compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            break;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                break;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                break;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            break;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            break;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\n// Define the onRedeclaration function signature correctly with variable types\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    //code for fixed function\n}\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -9,19 +9,19 @@\n                 declareVar(name, child, n, parent, null, n);\n                 child = next;\n             }\n-            return;\n+            break;\n         case Token.FUNCTION:\n             if (NodeUtil.isFunctionExpression(n)) {\n-                return;\n+                break;\n             }\n             String fnName = n.getFirstChild().getString();\n             if (fnName.isEmpty()) {\n                 // This is invalid, but allow it so the checks can catch it.\n-                return;\n+                break;\n             }\n             declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n             // should not examine function's children\n-            return;\n+            break;\n         case Token.CATCH:\n             Preconditions.checkState(n.getChildCount() == 2);\n             Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n@@ -32,7 +32,7 @@\n             declareVar(var.getString(), var, n, parent, null, n);\n             scanVars(block, n);\n             // only one child to scan\n-            return;\n+            break;\n         case Token.SCRIPT:\n             sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n             break;\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n@@ -1,6 +1,6 @@\n private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n     if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n-        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n+        onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n     } else {\n         scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    } else {\n        s.declare(name, n, n.getJSType(), compiler.getInput(NodeUtil.getSourceName(n)));\n    }\n}\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outermost scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            break;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            break;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            break;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n        default:\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    } else {\n        s.declare(name, n, n.getJSType(), compiler.getInput(NodeUtil.getSourceName(n)));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(NodeUtil.getSourceName(n)));\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -32,5 +32,7 @@\n     } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n         replaceVarWithAssignment(n, parent, gramps);\n+    } else {\n+        s.declare(name, n, n.getJSType(), compiler.getInput(NodeUtil.getSourceName(n)));\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -5,7 +5,7 @@\n         final Node args = fnNameNode.getNext();\n         final Node body = args.getNext();\n         // Bleed the function name into the scope, if it hasn't\n-        // been declared in the outer scope.\n+        // been declared in the outermost scope.\n         String fnName = fnNameNode.getString();\n         if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n             declareVar(fnName, fnNameNode, n, null, null, n);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -9,7 +9,7 @@\n                 declareVar(name, child, n, parent, null, n);\n                 child = next;\n             }\n-            return;\n+            break;\n         case Token.FUNCTION:\n             if (NodeUtil.isFunctionExpression(n)) {\n                 return;\n@@ -21,7 +21,7 @@\n             }\n             declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n             // should not examine function's children\n-            return;\n+            break;\n         case Token.CATCH:\n             Preconditions.checkState(n.getChildCount() == 2);\n             Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n@@ -32,9 +32,11 @@\n             declareVar(var.getString(), var, n, parent, null, n);\n             scanVars(block, n);\n             // only one child to scan\n-            return;\n+            break;\n         case Token.SCRIPT:\n             sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n+            break;\n+        default:\n             break;\n     }\n     // Variables can only occur in statement-level nodes, so\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration\n@@ -1 +1,29 @@\n void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n+\n+## Fixed Function 5\n+public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n+    // Don't allow multiple variables to be declared at the top level scope\n+    if (scope.isGlobal()) {\n+        Scope.Var origVar = scope.getVar(name);\n+        Node origParent = origVar.getParentNode();\n+        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n+            // Okay, both are 'catch(x)' variables.\n+            return;\n+        }\n+        boolean allowDupe = false;\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info == null) {\n+            info = parent.getJSDocInfo();\n+        }\n+        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n+        if (!allowDupe) {\n+            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n+        }\n+    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n+        // Disallow shadowing \"arguments\" as we can't handle with our current\n+        // scope modeling.\n+        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else {\n+        s.declare(name, n, n.getJSType(), compiler.getInput(NodeUtil.getSourceName(n)));\n+    }\n+}\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,37 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION) {\n+        if (v.getParentNode().getType() == Token.VAR) {\n+            s.undeclare(v);\n+            s.declare(name, n, n.getJSType(), v.input);\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n+    } else {\n+        s.declare(name, n, n.getJSType(), compiler.getInput(NodeUtil.getSourceName(n)));\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n@@ -2,6 +2,6 @@\n     if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n         redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n     } else {\n-        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n+        scope.declare(name, n, declaredType, compiler.getInput(NodeUtil.getSourceName(n)));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n) && parent != null && parent.isDeclared(fnName, false)) {\n            // Don't bleed the name into the scope if the parent function\n            // declares the same name.\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            break;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children since we don't want to\n            // scan the inside of nested functions.\n            break;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            break;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n        default:\n            // Variables can only occur in statement-level nodes, so\n            // we only need to traverse children in a couple special cases.\n            if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n                for (Node child = n.getFirstChild(); child != null; ) {\n                    Node next = child.getNext();\n                    scanVars(child, n);\n                    child = next;\n                }\n            }\n            break;\n    }\n}\n\n## Fixed Function 4\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber, RedeclarationHandler redeclarationHandler);\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber, RedeclarationHandler redeclarationHandler) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            redeclarationHandler.onRedeclaration(s, name, n, parent, gramps, nodeWithLineNumber);\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        redeclarationHandler.onRedeclaration(s, name, n, parent, gramps, nodeWithLineNumber);\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber, redeclarationHandler);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -7,7 +7,9 @@\n         // Bleed the function name into the scope, if it hasn't\n         // been declared in the outer scope.\n         String fnName = fnNameNode.getString();\n-        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n+        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n) && parent != null && parent.isDeclared(fnName, false)) {\n+            // Don't bleed the name into the scope if the parent function\n+            // declares the same name.\n             declareVar(fnName, fnNameNode, n, null, null, n);\n         }\n         // Args: Declare function variables\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -9,7 +9,7 @@\n                 declareVar(name, child, n, parent, null, n);\n                 child = next;\n             }\n-            return;\n+            break;\n         case Token.FUNCTION:\n             if (NodeUtil.isFunctionExpression(n)) {\n                 return;\n@@ -20,8 +20,9 @@\n                 return;\n             }\n             declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n-            // should not examine function's children\n-            return;\n+            // should not examine function's children since we don't want to\n+            // scan the inside of nested functions.\n+            break;\n         case Token.CATCH:\n             Preconditions.checkState(n.getChildCount() == 2);\n             Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n@@ -31,19 +32,20 @@\n             final Node block = var.getNext();\n             declareVar(var.getString(), var, n, parent, null, n);\n             scanVars(block, n);\n-            // only one child to scan\n-            return;\n+            break;\n         case Token.SCRIPT:\n             sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n             break;\n-    }\n-    // Variables can only occur in statement-level nodes, so\n-    // we only need to traverse children in a couple special cases.\n-    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n-        for (Node child = n.getFirstChild(); child != null; ) {\n-            Node next = child.getNext();\n-            scanVars(child, n);\n-            child = next;\n-        }\n+        default:\n+            // Variables can only occur in statement-level nodes, so\n+            // we only need to traverse children in a couple special cases.\n+            if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n+                for (Node child = n.getFirstChild(); child != null; ) {\n+                    Node next = child.getNext();\n+                    scanVars(child, n);\n+                    child = next;\n+                }\n+            }\n+            break;\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n@@ -1,6 +1,6 @@\n private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n     if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n-        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n+        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber, redeclarationHandler);\n     } else {\n         scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            break;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            break;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            break;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n        default:\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber){\n    // Fix not provided as it is only a method signature and not a full implementation\n}\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -9,7 +9,7 @@\n                 declareVar(name, child, n, parent, null, n);\n                 child = next;\n             }\n-            return;\n+            break;\n         case Token.FUNCTION:\n             if (NodeUtil.isFunctionExpression(n)) {\n                 return;\n@@ -21,7 +21,7 @@\n             }\n             declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n             // should not examine function's children\n-            return;\n+            break;\n         case Token.CATCH:\n             Preconditions.checkState(n.getChildCount() == 2);\n             Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n@@ -32,9 +32,11 @@\n             declareVar(var.getString(), var, n, parent, null, n);\n             scanVars(block, n);\n             // only one child to scan\n-            return;\n+            break;\n         case Token.SCRIPT:\n             sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n+            break;\n+        default:\n             break;\n     }\n     // Variables can only occur in statement-level nodes, so\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else if (n.getType() == Token.BLOCK && parent == null) {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            break;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                break;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                break;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            break;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            break;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n        default:\n            // Variables can only occur in statement-level nodes, so\n            // we only need to traverse children in a couple special cases.\n            if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n                for (Node child = n.getFirstChild(); child != null; ) {\n                    Node next = child.getNext();\n                    scanVars(child, n);\n                    child = next;\n                }\n            }\n            break;\n    }\n}\n\n## Fixed Function 4\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n\n// No corresponding fix provided as this looks like a method signature, not the actual implementation of the function.\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent != null && origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -18,7 +18,7 @@\n         }\n         // Body\n         scanVars(body, n);\n-    } else {\n+    } else if (n.getType() == Token.BLOCK && parent == null) {\n         // It's the global block\n         Preconditions.checkState(scope.getParent() == null);\n         scanVars(n, null);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -9,19 +9,19 @@\n                 declareVar(name, child, n, parent, null, n);\n                 child = next;\n             }\n-            return;\n+            break;\n         case Token.FUNCTION:\n             if (NodeUtil.isFunctionExpression(n)) {\n-                return;\n+                break;\n             }\n             String fnName = n.getFirstChild().getString();\n             if (fnName.isEmpty()) {\n                 // This is invalid, but allow it so the checks can catch it.\n-                return;\n+                break;\n             }\n             declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n             // should not examine function's children\n-            return;\n+            break;\n         case Token.CATCH:\n             Preconditions.checkState(n.getChildCount() == 2);\n             Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n@@ -32,18 +32,20 @@\n             declareVar(var.getString(), var, n, parent, null, n);\n             scanVars(block, n);\n             // only one child to scan\n-            return;\n+            break;\n         case Token.SCRIPT:\n             sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n             break;\n-    }\n-    // Variables can only occur in statement-level nodes, so\n-    // we only need to traverse children in a couple special cases.\n-    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n-        for (Node child = n.getFirstChild(); child != null; ) {\n-            Node next = child.getNext();\n-            scanVars(child, n);\n-            child = next;\n-        }\n+        default:\n+            // Variables can only occur in statement-level nodes, so\n+            // we only need to traverse children in a couple special cases.\n+            if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n+                for (Node child = n.getFirstChild(); child != null; ) {\n+                    Node next = child.getNext();\n+                    scanVars(child, n);\n+                    child = next;\n+                }\n+            }\n+            break;\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration\n@@ -1 +1,29 @@\n void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n+\n+// No corresponding fix provided as this looks like a method signature, not the actual implementation of the function.\n+\n+## Fixed Function 5\n+public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n+    // Don't allow multiple variables to be declared at the top level scope\n+    if (scope.isGlobal()) {\n+        Scope.Var origVar = scope.getVar(name);\n+        Node origParent = origVar.getParentNode();\n+        if (origParent != null && origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n+            // Okay, both are 'catch(x)' variables.\n+            return;\n+        }\n+        boolean allowDupe = false;\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info == null) {\n+            info = parent.getJSDocInfo();\n+        }\n+        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n+        if (!allowDupe) {\n+            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n+        }\n+    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n+        // Disallow shadowing \"arguments\" as we can't handle with our current\n+        // scope modeling.\n+        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    }\n+}\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -3,7 +3,7 @@\n     if (scope.isGlobal()) {\n         Scope.Var origVar = scope.getVar(name);\n         Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n+        if (origParent != null && origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n             // Okay, both are 'catch(x)' variables.\n             return;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nNo change is needed.\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        if (NodeUtil.isFunctionExpression(n)) {\n            String fnName = fnNameNode.getString();\n            if (!fnName.isEmpty()) {\n                declareVar(fnName, fnNameNode, n, null, null, n);\n            }\n        } else {\n            Preconditions.checkState(fnNameNode.getType() == Token.NAME);\n            String fnName = fnNameNode.getString();\n            if (!fnName.isEmpty()) {\n                declareVar(fnName, fnNameNode, n, null, null, n);\n            }\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            return;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            final Node fnNameNode = n.getFirstChild();\n            String fnName = fnNameNode.getString();\n            if (!fnName.isEmpty()) {\n                declareVar(fnName, fnNameNode, n, parent, null, n);\n            }\n            return;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            return;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber, RedeclarationHandler handler);\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber, RedeclarationHandler handler) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            handler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber, redeclarationHandler);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -6,9 +6,17 @@\n         final Node body = args.getNext();\n         // Bleed the function name into the scope, if it hasn't\n         // been declared in the outer scope.\n-        String fnName = fnNameNode.getString();\n-        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n-            declareVar(fnName, fnNameNode, n, null, null, n);\n+        if (NodeUtil.isFunctionExpression(n)) {\n+            String fnName = fnNameNode.getString();\n+            if (!fnName.isEmpty()) {\n+                declareVar(fnName, fnNameNode, n, null, null, n);\n+            }\n+        } else {\n+            Preconditions.checkState(fnNameNode.getType() == Token.NAME);\n+            String fnName = fnNameNode.getString();\n+            if (!fnName.isEmpty()) {\n+                declareVar(fnName, fnNameNode, n, null, null, n);\n+            }\n         }\n         // Args: Declare function variables\n         Preconditions.checkState(args.getType() == Token.LP);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -1,7 +1,6 @@\n private void scanVars(Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.VAR:\n-            // Declare all variables. e.g. var x = 1, y, z;\n             for (Node child = n.getFirstChild(); child != null; ) {\n                 Node next = child.getNext();\n                 Preconditions.checkState(child.getType() == Token.NAME);\n@@ -14,31 +13,24 @@\n             if (NodeUtil.isFunctionExpression(n)) {\n                 return;\n             }\n-            String fnName = n.getFirstChild().getString();\n-            if (fnName.isEmpty()) {\n-                // This is invalid, but allow it so the checks can catch it.\n-                return;\n+            final Node fnNameNode = n.getFirstChild();\n+            String fnName = fnNameNode.getString();\n+            if (!fnName.isEmpty()) {\n+                declareVar(fnName, fnNameNode, n, parent, null, n);\n             }\n-            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n-            // should not examine function's children\n             return;\n         case Token.CATCH:\n             Preconditions.checkState(n.getChildCount() == 2);\n             Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n-            // the first child is the catch var and the third child\n-            // is the code block\n             final Node var = n.getFirstChild();\n             final Node block = var.getNext();\n             declareVar(var.getString(), var, n, parent, null, n);\n             scanVars(block, n);\n-            // only one child to scan\n             return;\n         case Token.SCRIPT:\n             sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n             break;\n     }\n-    // Variables can only occur in statement-level nodes, so\n-    // we only need to traverse children in a couple special cases.\n     if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n         for (Node child = n.getFirstChild(); child != null; ) {\n             Node next = child.getNext();\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n@@ -1,6 +1,6 @@\n private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n     if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n-        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n+        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber, redeclarationHandler);\n     } else {\n         scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nNo changes made, the original function was corrected.\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            return;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            return;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            return;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n) || NodeUtil.isSwitchCase(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\nChange the access modifier for the method from package-local to public.\n\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -37,9 +37,8 @@\n             sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n             break;\n     }\n-    // Variables can only occur in statement-level nodes, so\n-    // we only need to traverse children in a couple special cases.\n-    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n+    // Variables can only occur in statement-level nodes, so we only need to traverse children in a couple special cases.\n+    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n) || NodeUtil.isSwitchCase(n)) {\n         for (Node child = n.getFirstChild(); child != null; ) {\n             Node next = child.getNext();\n             scanVars(child, n);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration\n@@ -1 +1,27 @@\n void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n+\n+## Fixed Function 5\n+public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n+    // Don't allow multiple variables to be declared at the top level scope\n+    if (scope.isGlobal()) {\n+        Scope.Var origVar = scope.getVar(name);\n+        Node origParent = origVar.getParentNode();\n+        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n+            // Okay, both are 'catch(x)' variables.\n+            return;\n+        }\n+        boolean allowDupe = false;\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info == null) {\n+            info = parent.getJSDocInfo();\n+        }\n+        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n+        if (!allowDupe) {\n+            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n+        }\n+    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n+        // Disallow shadowing \"arguments\" as we can't handle with our current\n+        // scope modeling.\n+        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    }\n+}\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nNo changes needed, the provided fix correctly handles the binary search algorithm.\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else if (n.getType() == Token.SCRIPT) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        scanVars(n, null);\n    } else {\n        throw new IllegalStateException(\"Unexpected node type in scanRoot: \" + n);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n            }\n            break;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            if (!NodeUtil.isFunctionDeclaration(n)) {\n                declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            }\n            // should not examine function's children\n            break;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the second child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            break;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            // fall through\n        default:\n            // Variables can only occur in statement-level nodes, so\n            // we only need to traverse children in a couple special cases.\n            if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n                for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n                    scanVars(child, n);\n                }\n            }\n    }\n}\n\n## Fixed Function 4\nThe function prototype declaration is invalid. The correct version is:\n\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions() != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -18,9 +18,10 @@\n         }\n         // Body\n         scanVars(body, n);\n+    } else if (n.getType() == Token.SCRIPT) {\n+        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n+        scanVars(n, null);\n     } else {\n-        // It's the global block\n-        Preconditions.checkState(scope.getParent() == null);\n-        scanVars(n, null);\n+        throw new IllegalStateException(\"Unexpected node type in scanRoot: \" + n);\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -2,14 +2,12 @@\n     switch(n.getType()) {\n         case Token.VAR:\n             // Declare all variables. e.g. var x = 1, y, z;\n-            for (Node child = n.getFirstChild(); child != null; ) {\n-                Node next = child.getNext();\n+            for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n                 Preconditions.checkState(child.getType() == Token.NAME);\n                 String name = child.getString();\n                 declareVar(name, child, n, parent, null, n);\n-                child = next;\n             }\n-            return;\n+            break;\n         case Token.FUNCTION:\n             if (NodeUtil.isFunctionExpression(n)) {\n                 return;\n@@ -19,31 +17,31 @@\n                 // This is invalid, but allow it so the checks can catch it.\n                 return;\n             }\n-            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n+            if (!NodeUtil.isFunctionDeclaration(n)) {\n+                declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n+            }\n             // should not examine function's children\n-            return;\n+            break;\n         case Token.CATCH:\n             Preconditions.checkState(n.getChildCount() == 2);\n             Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n-            // the first child is the catch var and the third child\n+            // the first child is the catch var and the second child\n             // is the code block\n             final Node var = n.getFirstChild();\n             final Node block = var.getNext();\n             declareVar(var.getString(), var, n, parent, null, n);\n             scanVars(block, n);\n-            // only one child to scan\n-            return;\n+            break;\n         case Token.SCRIPT:\n             sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n-            break;\n-    }\n-    // Variables can only occur in statement-level nodes, so\n-    // we only need to traverse children in a couple special cases.\n-    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n-        for (Node child = n.getFirstChild(); child != null; ) {\n-            Node next = child.getNext();\n-            scanVars(child, n);\n-            child = next;\n-        }\n+            // fall through\n+        default:\n+            // Variables can only occur in statement-level nodes, so\n+            // we only need to traverse children in a couple special cases.\n+            if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n+                for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n+                    scanVars(child, n);\n+                }\n+            }\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration\n@@ -1 +1,27 @@\n void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n+\n+## Fixed Function 5\n+public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n+    // Don't allow multiple variables to be declared at the top level scope\n+    if (scope.isGlobal()) {\n+        Scope.Var origVar = scope.getVar(name);\n+        Node origParent = origVar.getParentNode();\n+        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n+            // Okay, both are 'catch(x)' variables.\n+            return;\n+        }\n+        boolean allowDupe = false;\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info == null) {\n+            info = parent.getJSDocInfo();\n+        }\n+        allowDupe = info != null && info.getSuppressions() != null && info.getSuppressions().contains(\"duplicate\");\n+        if (!allowDupe) {\n+            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n+        }\n+    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n+        // Disallow shadowing \"arguments\" as we can't handle with our current\n+        // scope modeling.\n+        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    }\n+}\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -12,7 +12,7 @@\n         if (info == null) {\n             info = parent.getJSDocInfo();\n         }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n+        allowDupe = info != null && info.getSuppressions() != null && info.getSuppressions().contains(\"duplicate\");\n         if (!allowDupe) {\n             compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && (n.getBooleanProp(Node.IS_ARROW_FUNCTION) || NodeUtil.isFunctionExpression(n))) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}\n\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            return;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n) && !n.getBooleanProp(Node.IS_ARROW_FUNCTION)) {\n                return;\n            }\n            Node fnNameNode = n.getFirstChild();\n            if (fnNameNode == null || fnNameNode.getType() != Token.NAME) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            String fnName = fnNameNode.getString();\n            if (fnName.isEmpty()) {\n                return;\n            }\n            declareVar(fnName, fnNameNode, n, parent, null, n);\n            // should not examine function's children because they're hoisted\n            return;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            return;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n\n## Fixed Function 4\n// The correct fixed function is provided in Buggy Function 5\n\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent != null && origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n          info = NodeUtil.getBestJSDocInfo(parent);\n        }\n        if (info != null) {\n          allowDupe = info.getSuppressions().contains(\"duplicate\");\n        }\n        if (!allowDupe) {\n            // Check whether the original binding is in externs.\n            String inputName =\n                origVar.input != null ? origVar.input.getName() : \"??\";\n            if (origVar.isFromExterns()\n                || s.getVar(name).isFromExterns()) {\n              compiler.report(\n                  JSError.make(\n                      sourceName,\n                      n,\n                      VAR_MULTIPLY_DECLARED_ERROR_IN_EXTERNS,\n                      name,\n                      inputName));\n            } else {\n              compiler.report(\n                  JSError.make(\n                      sourceName,\n                      n,\n                      VAR_MULTIPLY_DECLARED_ERROR,\n                      name,\n                      inputName));\n            }\n        }\n    } else if (name.equals(ARGUMENTS)\n        && !NodeUtil.isVarDeclaration(n)\n        && !n.getBooleanProp(Node.FUNCTION_EXPRESSION)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS) && !n.getBooleanProp(Node.FUNCTION_EXPRESSION))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -7,7 +7,7 @@\n         // Bleed the function name into the scope, if it hasn't\n         // been declared in the outer scope.\n         String fnName = fnNameNode.getString();\n-        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n+        if (!fnName.isEmpty() && (n.getBooleanProp(Node.IS_ARROW_FUNCTION) || NodeUtil.isFunctionExpression(n))) {\n             declareVar(fnName, fnNameNode, n, null, null, n);\n         }\n         // Args: Declare function variables\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -11,16 +11,20 @@\n             }\n             return;\n         case Token.FUNCTION:\n-            if (NodeUtil.isFunctionExpression(n)) {\n+            if (NodeUtil.isFunctionExpression(n) && !n.getBooleanProp(Node.IS_ARROW_FUNCTION)) {\n                 return;\n             }\n-            String fnName = n.getFirstChild().getString();\n-            if (fnName.isEmpty()) {\n+            Node fnNameNode = n.getFirstChild();\n+            if (fnNameNode == null || fnNameNode.getType() != Token.NAME) {\n                 // This is invalid, but allow it so the checks can catch it.\n                 return;\n             }\n-            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n-            // should not examine function's children\n+            String fnName = fnNameNode.getString();\n+            if (fnName.isEmpty()) {\n+                return;\n+            }\n+            declareVar(fnName, fnNameNode, n, parent, null, n);\n+            // should not examine function's children because they're hoisted\n             return;\n         case Token.CATCH:\n             Preconditions.checkState(n.getChildCount() == 2);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,22 +1,45 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n     if (scope.isGlobal()) {\n         Scope.Var origVar = scope.getVar(name);\n         Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n+        if (origParent != null && origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n             // Okay, both are 'catch(x)' variables.\n             return;\n         }\n         boolean allowDupe = false;\n         JSDocInfo info = n.getJSDocInfo();\n         if (info == null) {\n-            info = parent.getJSDocInfo();\n+          info = NodeUtil.getBestJSDocInfo(parent);\n         }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n+        if (info != null) {\n+          allowDupe = info.getSuppressions().contains(\"duplicate\");\n+        }\n         if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n+            // Check whether the original binding is in externs.\n+            String inputName =\n+                origVar.input != null ? origVar.input.getName() : \"??\";\n+            if (origVar.isFromExterns()\n+                || s.getVar(name).isFromExterns()) {\n+              compiler.report(\n+                  JSError.make(\n+                      sourceName,\n+                      n,\n+                      VAR_MULTIPLY_DECLARED_ERROR_IN_EXTERNS,\n+                      name,\n+                      inputName));\n+            } else {\n+              compiler.report(\n+                  JSError.make(\n+                      sourceName,\n+                      n,\n+                      VAR_MULTIPLY_DECLARED_ERROR,\n+                      name,\n+                      inputName));\n+            }\n         }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n+    } else if (name.equals(ARGUMENTS)\n+        && !NodeUtil.isVarDeclaration(n)\n+        && !n.getBooleanProp(Node.FUNCTION_EXPRESSION)) {\n         // Disallow shadowing \"arguments\" as we can't handle with our current\n         // scope modeling.\n         compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n@@ -1,5 +1,5 @@\n private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n-    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n+    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS) && !n.getBooleanProp(Node.FUNCTION_EXPRESSION))) {\n         redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n     } else {\n         scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\nprivate void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body: Don't scan children, just declare vars\n        declareScope(n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        declareScope(n);\n    }\n}\n\n## Fixed Function 3\nprivate void scanVars(Node n, Node parent) {\n    if (n.getType() == Token.SCRIPT) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n    } else if (n.getType() == Token.VAR) {\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            Preconditions.checkState(child.getType() == Token.NAME);\n            String name = child.getString();\n            declareVar(name, child, n, parent, null, n);\n            child = next;\n        }\n    } else if (n.getType() == Token.FUNCTION) {\n        if (NodeUtil.isFunctionExpression(n)) {\n            parent.getFirstChild().setString(\"\");\n        } else {\n            String fnName = n.getFirstChild().getString();\n            if (!fnName.isEmpty()) {\n                declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            }\n            // Don't scan children, just declare function vars\n            declareScope(n);\n        }\n    } else if (n.getType() == Token.CATCH) {\n        Preconditions.checkState(n.getChildCount() == 2, \"Catch node expected to have two children\");\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME, \"First child of catch node is expected to be NAME node\");\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n        declareVar(var.getString(), var, n, parent, null, n);\n        scanVars(block, n);\n    } else if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}\n\n## Fixed Function 4\nvoid onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber, RedeclarationHandler handler);\n\n## Fixed Function 5\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber, RedeclarationHandler handler) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            handler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}\n\n## Fixed Function 6\nprivate void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber, new RedeclarationHandler() {\n            @Override\n            public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n                if (s.isGlobal()) {\n                    JSDocInfo info = n.getJSDocInfo();\n                    if (info == null) {\n                        info = parent.getJSDocInfo();\n                    }\n                    if (info != null && info.getSuppressions().contains(\"duplicate\")) {\n                        return;\n                    }\n                    compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name));\n                } else {\n                    compiler.report(JSError.make(sourceName, n, VAR_DECLARED_IN_BLOCK_ERROR, name));\n                }\n            }\n        });\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -1,36 +1,20 @@\n @Override\n-public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    Preconditions.checkState(n.getType() == Token.NAME);\n-    Var v = s.getVar(name);\n-    // We allow variables to be duplicate declared if one\n-    // declaration appears in source and the other in externs.\n-    // This deals with issues where a browser built-in is declared\n-    // in one browser but not in another.\n-    // If name is \"arguments\", Var maybe null.\n-    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n-        // Redeclaration of a catch expression variable is hard to model\n-        // without support for \"with\" expressions.\n-        // The EcmaScript spec (section 12.14), declares that a catch\n-        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n-        // \"var e\" would refer to the scope variable, but any following\n-        // reference would still refer to \"e\" of the catch expression.\n-        // Until we have support for this disallow it.\n-        // Currently the Scope object adds the catch expression to the\n-        // function scope, which is technically not true but a good\n-        // approximation for most uses.\n-        // TODO(johnlenz): Consider improving how scope handles catch\n-        // expression.\n-        // Use the name of the var before it was made unique.\n-        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n-        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n-            s.undeclare(v);\n-            s.declare(name, n, n.getJSType(), v.input);\n-            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n-        }\n-    } else if (parent.getType() == Token.VAR) {\n-        Preconditions.checkState(parent.hasOneChild());\n-        replaceVarWithAssignment(n, parent, gramps);\n+            public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n+                if (s.isGlobal()) {\n+                    JSDocInfo info = n.getJSDocInfo();\n+                    if (info == null) {\n+                        info = parent.getJSDocInfo();\n+                    }\n+                    if (info != null && info.getSuppressions().contains(\"duplicate\")) {\n+                        return;\n+                    }\n+                    compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name));\n+                } else {\n+                    compiler.report(JSError.make(sourceName, n, VAR_DECLARED_IN_BLOCK_ERROR, name));\n+                }\n+            }\n+        });\n+    } else {\n+        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanRoot\n@@ -16,11 +16,11 @@\n             Preconditions.checkState(a.getType() == Token.NAME);\n             declareVar(a.getString(), a, args, n, null, n);\n         }\n-        // Body\n-        scanVars(body, n);\n+        // Body: Don't scan children, just declare vars\n+        declareScope(n);\n     } else {\n         // It's the global block\n         Preconditions.checkState(scope.getParent() == null);\n-        scanVars(n, null);\n+        declareScope(n);\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@scanVars\n@@ -1,45 +1,34 @@\n private void scanVars(Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.VAR:\n-            // Declare all variables. e.g. var x = 1, y, z;\n-            for (Node child = n.getFirstChild(); child != null; ) {\n-                Node next = child.getNext();\n-                Preconditions.checkState(child.getType() == Token.NAME);\n-                String name = child.getString();\n-                declareVar(name, child, n, parent, null, n);\n-                child = next;\n+    if (n.getType() == Token.SCRIPT) {\n+        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n+    } else if (n.getType() == Token.VAR) {\n+        // Declare all variables. e.g. var x = 1, y, z;\n+        for (Node child = n.getFirstChild(); child != null; ) {\n+            Node next = child.getNext();\n+            Preconditions.checkState(child.getType() == Token.NAME);\n+            String name = child.getString();\n+            declareVar(name, child, n, parent, null, n);\n+            child = next;\n+        }\n+    } else if (n.getType() == Token.FUNCTION) {\n+        if (NodeUtil.isFunctionExpression(n)) {\n+            parent.getFirstChild().setString(\"\");\n+        } else {\n+            String fnName = n.getFirstChild().getString();\n+            if (!fnName.isEmpty()) {\n+                declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n             }\n-            return;\n-        case Token.FUNCTION:\n-            if (NodeUtil.isFunctionExpression(n)) {\n-                return;\n-            }\n-            String fnName = n.getFirstChild().getString();\n-            if (fnName.isEmpty()) {\n-                // This is invalid, but allow it so the checks can catch it.\n-                return;\n-            }\n-            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n-            // should not examine function's children\n-            return;\n-        case Token.CATCH:\n-            Preconditions.checkState(n.getChildCount() == 2);\n-            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n-            // the first child is the catch var and the third child\n-            // is the code block\n-            final Node var = n.getFirstChild();\n-            final Node block = var.getNext();\n-            declareVar(var.getString(), var, n, parent, null, n);\n-            scanVars(block, n);\n-            // only one child to scan\n-            return;\n-        case Token.SCRIPT:\n-            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n-            break;\n-    }\n-    // Variables can only occur in statement-level nodes, so\n-    // we only need to traverse children in a couple special cases.\n-    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n+            // Don't scan children, just declare function vars\n+            declareScope(n);\n+        }\n+    } else if (n.getType() == Token.CATCH) {\n+        Preconditions.checkState(n.getChildCount() == 2, \"Catch node expected to have two children\");\n+        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME, \"First child of catch node is expected to be NAME node\");\n+        final Node var = n.getFirstChild();\n+        final Node block = var.getNext();\n+        declareVar(var.getString(), var, n, parent, null, n);\n+        scanVars(block, n);\n+    } else if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n         for (Node child = n.getFirstChild(); child != null; ) {\n             Node next = child.getNext();\n             scanVars(child, n);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,19 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n-        }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+                if (s.isGlobal()) {\n+                    JSDocInfo info = n.getJSDocInfo();\n+                    if (info == null) {\n+                        info = parent.getJSDocInfo();\n+                    }\n+                    if (info != null && info.getSuppressions().contains(\"duplicate\")) {\n+                        return;\n+                    }\n+                    compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name));\n+                } else {\n+                    compiler.report(JSError.make(sourceName, n, VAR_DECLARED_IN_BLOCK_ERROR, name));\n+                }\n+            }\n+        });\n+    } else {\n+        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@declareVar\n@@ -1,6 +1,22 @@\n private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n     if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n-        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n+        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber, new RedeclarationHandler() {\n+            @Override\n+            public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n+                if (s.isGlobal()) {\n+                    JSDocInfo info = n.getJSDocInfo();\n+                    if (info == null) {\n+                        info = parent.getJSDocInfo();\n+                    }\n+                    if (info != null && info.getSuppressions().contains(\"duplicate\")) {\n+                        return;\n+                    }\n+                    compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name));\n+                } else {\n+                    compiler.report(JSError.make(sourceName, n, VAR_DECLARED_IN_BLOCK_ERROR, name));\n+                }\n+            }\n+        });\n     } else {\n         scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}]