[{"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    Set<String> ignoredProps = null;\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            ignoredProps = new HashSet<>(ignored2);\n        }\n    } else {\n        ignoredProps = Collections.emptySet();\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        String propName = propDef.getName();\n        if (ignoredProps != null && ignoredProps.contains(propName)) {\n            continue;\n        }\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            // but let's call a method just to allow custom builders to be aware...\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (propName.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", propName, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -32,15 +32,14 @@\n     }\n     // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n     // Implicit ones via @JsonIgnore and equivalent?\n+    Set<String> ignoredProps = null;\n     if (anySetterMethod == null && anySetterField == null) {\n         Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n         if (ignored2 != null) {\n-            for (String propName : ignored2) {\n-                // allow ignoral of similarly named JSON property, but do not force;\n-                // latter means NOT adding this to 'ignored':\n-                builder.addIgnorable(propName);\n-            }\n+            ignoredProps = new HashSet<>(ignored2);\n         }\n+    } else {\n+        ignoredProps = Collections.emptySet();\n     }\n     final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n     // Ok: let's then filter out property definitions\n@@ -53,15 +52,19 @@\n     }\n     // At which point we still have all kinds of properties; not all with mutators:\n     for (BeanPropertyDefinition propDef : propDefs) {\n+        String propName = propDef.getName();\n+        if (ignoredProps != null && ignoredProps.contains(propName)) {\n+            continue;\n+        }\n         SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n+        if (propDef.hasSetter()) {\n             JavaType propertyType = propDef.getSetter().getParameterType(0);\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (propDef.hasField()) {\n             JavaType propertyType = propDef.getField().getType();\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n+            AnnotatedMethod getter = propDef.getGetter();\n             // should only consider Collections and Maps, for now?\n             Class<?> rawPropertyType = getter.getRawType();\n             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n@@ -71,12 +74,11 @@\n         // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n         //   (since they are never used anyway)\n         if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n-            final String name = propDef.getName();\n+            // but let's call a method just to allow custom builders to be aware...\n             CreatorProperty cprop = null;\n             if (creatorProps != null) {\n                 for (SettableBeanProperty cp : creatorProps) {\n-                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n+                    if (propName.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                         cprop = (CreatorProperty) cp;\n                         break;\n                     }\n@@ -87,7 +89,7 @@\n                 for (SettableBeanProperty cp : creatorProps) {\n                     n.add(cp.getName());\n                 }\n-                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n+                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", propName, n);\n                 continue;\n             }\n             if (prop != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propDef.getSetter().getParameterType(0));\n        } else if (propDef.hasField()) {\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propDef.getField().getType());\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            // if it's not the expected property type, skip it\n            if (cprop.getType().getRawClass() != propDef.getConstructorParameter().getType().getRawClass()) {\n                continue;\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -54,14 +54,12 @@\n     // At which point we still have all kinds of properties; not all with mutators:\n     for (BeanPropertyDefinition propDef : propDefs) {\n         SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n-            JavaType propertyType = propDef.getSetter().getParameterType(0);\n-            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n+        if (propDef.hasSetter()) {\n+            prop = constructSettableProperty(ctxt, beanDesc, propDef, propDef.getSetter().getParameterType(0));\n         } else if (propDef.hasField()) {\n-            JavaType propertyType = propDef.getField().getType();\n-            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n+            prop = constructSettableProperty(ctxt, beanDesc, propDef, propDef.getField().getType());\n         } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n+            AnnotatedMethod getter = propDef.getGetter();\n             // should only consider Collections and Maps, for now?\n             Class<?> rawPropertyType = getter.getRawType();\n             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n@@ -71,7 +69,7 @@\n         // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n         //   (since they are never used anyway)\n         if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n+            // but let's call a method just to allow custom builders to be aware...\n             final String name = propDef.getName();\n             CreatorProperty cprop = null;\n             if (creatorProps != null) {\n@@ -90,8 +88,9 @@\n                 ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                 continue;\n             }\n-            if (prop != null) {\n-                cprop.setFallbackSetter(prop);\n+            // if it's not the expected property type, skip it\n+            if (cprop.getType().getRawClass() != propDef.getConstructorParameter().getType().getRawClass()) {\n+                continue;\n             }\n             prop = cprop;\n             builder.addCreatorProperty(cprop);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs, beanDesc.getClassInfo());\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    builder.addProperties(propDefs);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -48,66 +48,10 @@\n     // After which we can let custom code change the set\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n+            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs, beanDesc.getClassInfo());\n         }\n     }\n     // At which point we still have all kinds of properties; not all with mutators:\n-    for (BeanPropertyDefinition propDef : propDefs) {\n-        SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n-            JavaType propertyType = propDef.getSetter().getParameterType(0);\n-            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n-        } else if (propDef.hasField()) {\n-            JavaType propertyType = propDef.getField().getType();\n-            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n-        } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n-            // should only consider Collections and Maps, for now?\n-            Class<?> rawPropertyType = getter.getRawType();\n-            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n-                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n-            }\n-        }\n-        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n-        //   (since they are never used anyway)\n-        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n-            final String name = propDef.getName();\n-            CreatorProperty cprop = null;\n-            if (creatorProps != null) {\n-                for (SettableBeanProperty cp : creatorProps) {\n-                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n-                        cprop = (CreatorProperty) cp;\n-                        break;\n-                    }\n-                }\n-            }\n-            if (cprop == null) {\n-                List<String> n = new ArrayList<>();\n-                for (SettableBeanProperty cp : creatorProps) {\n-                    n.add(cp.getName());\n-                }\n-                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n-                continue;\n-            }\n-            if (prop != null) {\n-                cprop.setFallbackSetter(prop);\n-            }\n-            prop = cprop;\n-            builder.addCreatorProperty(cprop);\n-            continue;\n-        }\n-        if (prop != null) {\n-            Class<?>[] views = propDef.findViews();\n-            if (views == null) {\n-                // one more twist: if default inclusion disabled, need to force empty set of views\n-                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n-                    views = NO_VIEWS;\n-                }\n-            }\n-            // one more thing before adding to builder: copy any metadata\n-            prop.setViews(views);\n-            builder.addProperty(prop);\n-        }\n+    builder.addProperties(propDefs);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getFieldType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawReturnType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -54,16 +54,16 @@\n     // At which point we still have all kinds of properties; not all with mutators:\n     for (BeanPropertyDefinition propDef : propDefs) {\n         SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n+        if (propDef.hasSetter()) {\n             JavaType propertyType = propDef.getSetter().getParameterType(0);\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (propDef.hasField()) {\n-            JavaType propertyType = propDef.getField().getType();\n+            JavaType propertyType = propDef.getFieldType();\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n+            AnnotatedMethod getter = propDef.getGetter();\n             // should only consider Collections and Maps, for now?\n-            Class<?> rawPropertyType = getter.getRawType();\n+            Class<?> rawPropertyType = getter.getRawReturnType();\n             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                 prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n             }\n@@ -71,7 +71,7 @@\n         // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n         //   (since they are never used anyway)\n         if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n+            // but let's call a method just to allow custom builders to be aware...\n             final String name = propDef.getName();\n             CreatorProperty cprop = null;\n             if (creatorProps != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "As we cannot see the errors, it is impossible to give a specific fix without more information.", "diff": "", "finish_reason": "stop", "valid": false, "num": 6}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetterMethod();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n                if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n                        AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                        // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -20,7 +20,7 @@\n         ignored = Collections.emptySet();\n     }\n     // Also, do we have a fallback \"any\" setter?\n-    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n+    AnnotatedMethod anySetterMethod = beanDesc.findAnySetterMethod();\n     AnnotatedMember anySetterField = null;\n     if (anySetterMethod != null) {\n         builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                // create a setter from the getter method\n                prop = new MethodBasedSettableBeanProperty(getter, propDef, constructType(ctxt, beanDesc.getType()), null,\n                        // 15-Feb-2017, tatu: Need to consider read-only list/set/map properties as well,\n                        //   but that can require quite a bit of work, may need to revisit.\n                        ctxt.getAnnotationIntrospector().findPropertyIgnorals(beanDesc.getClassInfo(), propDef));\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -54,24 +54,28 @@\n     // At which point we still have all kinds of properties; not all with mutators:\n     for (BeanPropertyDefinition propDef : propDefs) {\n         SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n+        if (propDef.hasSetter()) {\n             JavaType propertyType = propDef.getSetter().getParameterType(0);\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (propDef.hasField()) {\n             JavaType propertyType = propDef.getField().getType();\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n+            AnnotatedMethod getter = propDef.getGetter();\n             // should only consider Collections and Maps, for now?\n             Class<?> rawPropertyType = getter.getRawType();\n             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n-                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n+                // create a setter from the getter method\n+                prop = new MethodBasedSettableBeanProperty(getter, propDef, constructType(ctxt, beanDesc.getType()), null,\n+                        // 15-Feb-2017, tatu: Need to consider read-only list/set/map properties as well,\n+                        //   but that can require quite a bit of work, may need to revisit.\n+                        ctxt.getAnnotationIntrospector().findPropertyIgnorals(beanDesc.getClassInfo(), propDef));\n             }\n         }\n         // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n         //   (since they are never used anyway)\n         if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n+            // but let's call a method just to allow custom builders to be aware...\n             final String name = propDef.getName();\n             CreatorProperty cprop = null;\n             if (creatorProps != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter() && !propDef.hasConstructorParameter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (!hasCreatorProps && propDef.hasConstructorParameter()) {\n            // should NOT consider properties with creator params unless there is a suitable creator\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -54,14 +54,14 @@\n     // At which point we still have all kinds of properties; not all with mutators:\n     for (BeanPropertyDefinition propDef : propDefs) {\n         SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n+        if (propDef.hasSetter()) {\n             JavaType propertyType = propDef.getSetter().getParameterType(0);\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (propDef.hasField()) {\n             JavaType propertyType = propDef.getField().getType();\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n-        } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n+        } else if (useGettersAsSetters && propDef.hasGetter() && !propDef.hasConstructorParameter()) {\n+            AnnotatedMethod getter = propDef.getGetter();\n             // should only consider Collections and Maps, for now?\n             Class<?> rawPropertyType = getter.getRawType();\n             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n@@ -70,31 +70,8 @@\n         }\n         // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n         //   (since they are never used anyway)\n-        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n-            final String name = propDef.getName();\n-            CreatorProperty cprop = null;\n-            if (creatorProps != null) {\n-                for (SettableBeanProperty cp : creatorProps) {\n-                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n-                        cprop = (CreatorProperty) cp;\n-                        break;\n-                    }\n-                }\n-            }\n-            if (cprop == null) {\n-                List<String> n = new ArrayList<>();\n-                for (SettableBeanProperty cp : creatorProps) {\n-                    n.add(cp.getName());\n-                }\n-                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n-                continue;\n-            }\n-            if (prop != null) {\n-                cprop.setFallbackSetter(prop);\n-            }\n-            prop = cprop;\n-            builder.addCreatorProperty(cprop);\n+        if (!hasCreatorProps && propDef.hasConstructorParameter()) {\n+            // should NOT consider properties with creator params unless there is a suitable creator\n             continue;\n         }\n         if (prop != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        if (propDef.isRequired()) {\n            final String propName = propDef.getName();\n            final JavaType type;\n            if (propDef.hasConstructorParameter()) {\n                type = propDef.getCtorParameterType();\n            } else {\n                type = propDef.getPrimaryType();\n            }\n            // 17-Nov-2014, tatu: Should try merging FIRST, then error if multiple require\n            //   for same property. But for now, this does work:\n            SimpleBeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), propDef.getMember());\n            builder.addDirectCreatorProperty(newDef);\n            continue;\n        }\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -53,15 +53,29 @@\n     }\n     // At which point we still have all kinds of properties; not all with mutators:\n     for (BeanPropertyDefinition propDef : propDefs) {\n+        if (propDef.isRequired()) {\n+            final String propName = propDef.getName();\n+            final JavaType type;\n+            if (propDef.hasConstructorParameter()) {\n+                type = propDef.getCtorParameterType();\n+            } else {\n+                type = propDef.getPrimaryType();\n+            }\n+            // 17-Nov-2014, tatu: Should try merging FIRST, then error if multiple require\n+            //   for same property. But for now, this does work:\n+            SimpleBeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), propDef.getMember());\n+            builder.addDirectCreatorProperty(newDef);\n+            continue;\n+        }\n         SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n+        if (propDef.hasSetter()) {\n             JavaType propertyType = propDef.getSetter().getParameterType(0);\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (propDef.hasField()) {\n             JavaType propertyType = propDef.getField().getType();\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n+            AnnotatedMethod getter = propDef.getGetter();\n             // should only consider Collections and Maps, for now?\n             Class<?> rawPropertyType = getter.getRawType();\n             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n@@ -71,7 +85,7 @@\n         // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n         //   (since they are never used anyway)\n         if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n+            // but let's call a method just to allow custom builders to be aware...\n             final String name = propDef.getName();\n             CreatorProperty cprop = null;\n             if (creatorProps != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignoredProps = beanDesc.getIgnoredPropertyNames();\n        if (ignoredProps != null) {\n            for (String propName : ignoredProps) {\n                if (!ignored.contains(propName)) {\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -2,16 +2,11 @@\n     final boolean isConcrete = !beanDesc.getType().isAbstract();\n     final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n     final boolean hasCreatorProps = (creatorProps != null);\n-    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n-    //   it may often make most sense to use general type for overrides,\n-    //   but what we have here may be more specific impl type. But for now\n-    //   just use it as is.\n     JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n     Set<String> ignored;\n     if (ignorals != null) {\n         boolean ignoreAny = ignorals.getIgnoreUnknown();\n         builder.setIgnoreUnknownProperties(ignoreAny);\n-        // Or explicit/implicit definitions?\n         ignored = ignorals.getIgnored();\n         for (String propName : ignored) {\n             builder.addIgnorable(propName);\n@@ -19,7 +14,6 @@\n     } else {\n         ignored = Collections.emptySet();\n     }\n-    // Also, do we have a fallback \"any\" setter?\n     AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n     AnnotatedMember anySetterField = null;\n     if (anySetterMethod != null) {\n@@ -30,48 +24,39 @@\n             builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n         }\n     }\n-    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n-    // Implicit ones via @JsonIgnore and equivalent?\n     if (anySetterMethod == null && anySetterField == null) {\n-        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n-        if (ignored2 != null) {\n-            for (String propName : ignored2) {\n-                // allow ignoral of similarly named JSON property, but do not force;\n-                // latter means NOT adding this to 'ignored':\n-                builder.addIgnorable(propName);\n+        Collection<String> ignoredProps = beanDesc.getIgnoredPropertyNames();\n+        if (ignoredProps != null) {\n+            for (String propName : ignoredProps) {\n+                if (!ignored.contains(propName)) {\n+                    builder.addIgnorable(propName);\n+                }\n             }\n         }\n     }\n     final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n-    // Ok: let's then filter out property definitions\n     List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n-    // After which we can let custom code change the set\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n             propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n         }\n     }\n-    // At which point we still have all kinds of properties; not all with mutators:\n     for (BeanPropertyDefinition propDef : propDefs) {\n         SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n+        if (propDef.hasSetter()) {\n             JavaType propertyType = propDef.getSetter().getParameterType(0);\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (propDef.hasField()) {\n             JavaType propertyType = propDef.getField().getType();\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n-            // should only consider Collections and Maps, for now?\n+            AnnotatedMethod getter = propDef.getGetter();\n             Class<?> rawPropertyType = getter.getRawType();\n             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                 prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n             }\n         }\n-        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n-        //   (since they are never used anyway)\n         if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n             final String name = propDef.getName();\n             CreatorProperty cprop = null;\n             if (creatorProps != null) {\n@@ -100,12 +85,10 @@\n         if (prop != null) {\n             Class<?>[] views = propDef.findViews();\n             if (views == null) {\n-                // one more twist: if default inclusion disabled, need to force empty set of views\n                 if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                     views = NO_VIEWS;\n                 }\n             }\n-            // one more thing before adding to builder: copy any metadata\n             prop.setViews(views);\n             builder.addProperty(prop);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    AnnotatedMember anySetterField = null;\n    if (!ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)) {\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        } else {\n            anySetterField = beanDesc.findAnySetterField();\n            if (anySetterField != null) {\n                builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n            }\n        }\n    }\n    Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n    if (ignored2 != null) {\n        for (String propName : ignored2) {\n            builder.addIgnorable(propName);\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -2,16 +2,11 @@\n     final boolean isConcrete = !beanDesc.getType().isAbstract();\n     final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n     final boolean hasCreatorProps = (creatorProps != null);\n-    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n-    //   it may often make most sense to use general type for overrides,\n-    //   but what we have here may be more specific impl type. But for now\n-    //   just use it as is.\n     JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n     Set<String> ignored;\n     if (ignorals != null) {\n         boolean ignoreAny = ignorals.getIgnoreUnknown();\n         builder.setIgnoreUnknownProperties(ignoreAny);\n-        // Or explicit/implicit definitions?\n         ignored = ignorals.getIgnored();\n         for (String propName : ignored) {\n             builder.addIgnorable(propName);\n@@ -19,27 +14,22 @@\n     } else {\n         ignored = Collections.emptySet();\n     }\n-    // Also, do we have a fallback \"any\" setter?\n-    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n     AnnotatedMember anySetterField = null;\n-    if (anySetterMethod != null) {\n-        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n-    } else {\n-        anySetterField = beanDesc.findAnySetterField();\n-        if (anySetterField != null) {\n-            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n+    if (!ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)) {\n+        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n+        if (anySetterMethod != null) {\n+            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n+        } else {\n+            anySetterField = beanDesc.findAnySetterField();\n+            if (anySetterField != null) {\n+                builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n+            }\n         }\n     }\n-    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n-    // Implicit ones via @JsonIgnore and equivalent?\n-    if (anySetterMethod == null && anySetterField == null) {\n-        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n-        if (ignored2 != null) {\n-            for (String propName : ignored2) {\n-                // allow ignoral of similarly named JSON property, but do not force;\n-                // latter means NOT adding this to 'ignored':\n-                builder.addIgnorable(propName);\n-            }\n+    Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n+    if (ignored2 != null) {\n+        for (String propName : ignored2) {\n+            builder.addIgnorable(propName);\n         }\n     }\n     final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n@@ -54,24 +44,20 @@\n     // At which point we still have all kinds of properties; not all with mutators:\n     for (BeanPropertyDefinition propDef : propDefs) {\n         SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n+        if (propDef.hasSetter()) {\n             JavaType propertyType = propDef.getSetter().getParameterType(0);\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (propDef.hasField()) {\n             JavaType propertyType = propDef.getField().getType();\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n-            // should only consider Collections and Maps, for now?\n+            AnnotatedMethod getter = propDef.getGetter();\n             Class<?> rawPropertyType = getter.getRawType();\n             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                 prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n             }\n         }\n-        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n-        //   (since they are never used anyway)\n         if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n             final String name = propDef.getName();\n             CreatorProperty cprop = null;\n             if (creatorProps != null) {\n@@ -100,12 +86,10 @@\n         if (prop != null) {\n             Class<?>[] views = propDef.findViews();\n             if (views == null) {\n-                // one more twist: if default inclusion disabled, need to force empty set of views\n                 if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                     views = NO_VIEWS;\n                 }\n             }\n-            // one more thing before adding to builder: copy any metadata\n             prop.setViews(views);\n             builder.addProperty(prop);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n                if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n                        AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawReturnType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                        // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -63,7 +63,7 @@\n         } else if (useGettersAsSetters && propDef.hasGetter()) {\n                         AnnotatedMethod getter = propDef.getGetter();\n             // should only consider Collections and Maps, for now?\n-            Class<?> rawPropertyType = getter.getRawType();\n+            Class<?> rawPropertyType = getter.getRawReturnType();\n             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                 prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        final AccessibleObject ao = propDef.getAccessor();\n        if (ao instanceof AnnotatedMethod) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (ao instanceof AnnotatedField) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && ao instanceof AnnotatedMethod) {\n            AnnotatedMethod getter = (AnnotatedMethod)ao;\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -54,14 +54,15 @@\n     // At which point we still have all kinds of properties; not all with mutators:\n     for (BeanPropertyDefinition propDef : propDefs) {\n         SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n+        final AccessibleObject ao = propDef.getAccessor();\n+        if (ao instanceof AnnotatedMethod) {\n             JavaType propertyType = propDef.getSetter().getParameterType(0);\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n-        } else if (propDef.hasField()) {\n+        } else if (ao instanceof AnnotatedField) {\n             JavaType propertyType = propDef.getField().getType();\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n-        } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n+        } else if (useGettersAsSetters && ao instanceof AnnotatedMethod) {\n+            AnnotatedMethod getter = (AnnotatedMethod)ao;\n             // should only consider Collections and Maps, for now?\n             Class<?> rawPropertyType = getter.getRawType();\n             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n@@ -71,7 +72,7 @@\n         // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n         //   (since they are never used anyway)\n         if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n+            // but let's call a method just to allow custom builders to be aware...\n             final String name = propDef.getName();\n             CreatorProperty cprop = null;\n             if (creatorProps != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter() && propDef.hasSetter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            AnnotatedParameter setterParam = propDef.getSetter().getParameters()[0];\n            JsonProperty property = getter.getAnnotation(JsonProperty.class);\n            if (property != null\n                    && (property.access() == JsonProperty.Access.READ_ONLY\n                        || property.access() == JsonProperty.Access.AUTO)) {\n                // getter is read-only or auto-serialization, change it to read-write\n                Method setterMethod = propDef.getSetter().getAnnotated();\n                if (setterMethod != null) {\n                    PropertyNamingStrategy naming =\n                            ctxt.getConfig().getPropertyNamingStrategy();\n                    String name = property.value();\n                    if (name.isEmpty()) {\n                        name = propDef.getName();\n                    }\n                    name = naming.nameForSetterMethod(ctxt.getConfig(), setterMethod, name);\n                    prop = new VirtualBeanPropertyWriter(\n                            propDef,\n                            !ctxt.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS),\n                            setterMethod.getDeclaringClass(),\n                            name,\n                            JavaType.construct(setterParam.getType()),\n                            propDef.getWrapperName(),\n                            null,\n                            setterMethod,\n                            getPropertyFilter(ctxt, propDef),\n                            property);\n                }\n            } else {\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -54,24 +54,53 @@\n     // At which point we still have all kinds of properties; not all with mutators:\n     for (BeanPropertyDefinition propDef : propDefs) {\n         SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n+        if (propDef.hasSetter()) {\n             JavaType propertyType = propDef.getSetter().getParameterType(0);\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (propDef.hasField()) {\n             JavaType propertyType = propDef.getField().getType();\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n-        } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n-            // should only consider Collections and Maps, for now?\n-            Class<?> rawPropertyType = getter.getRawType();\n-            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n-                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n+        } else if (useGettersAsSetters && propDef.hasGetter() && propDef.hasSetter()) {\n+            AnnotatedMethod getter = propDef.getGetter();\n+            AnnotatedParameter setterParam = propDef.getSetter().getParameters()[0];\n+            JsonProperty property = getter.getAnnotation(JsonProperty.class);\n+            if (property != null\n+                    && (property.access() == JsonProperty.Access.READ_ONLY\n+                        || property.access() == JsonProperty.Access.AUTO)) {\n+                // getter is read-only or auto-serialization, change it to read-write\n+                Method setterMethod = propDef.getSetter().getAnnotated();\n+                if (setterMethod != null) {\n+                    PropertyNamingStrategy naming =\n+                            ctxt.getConfig().getPropertyNamingStrategy();\n+                    String name = property.value();\n+                    if (name.isEmpty()) {\n+                        name = propDef.getName();\n+                    }\n+                    name = naming.nameForSetterMethod(ctxt.getConfig(), setterMethod, name);\n+                    prop = new VirtualBeanPropertyWriter(\n+                            propDef,\n+                            !ctxt.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS),\n+                            setterMethod.getDeclaringClass(),\n+                            name,\n+                            JavaType.construct(setterParam.getType()),\n+                            propDef.getWrapperName(),\n+                            null,\n+                            setterMethod,\n+                            getPropertyFilter(ctxt, propDef),\n+                            property);\n+                }\n+            } else {\n+                // should only consider Collections and Maps, for now?\n+                Class<?> rawPropertyType = getter.getRawType();\n+                if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n+                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n+                }\n             }\n         }\n         // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n         //   (since they are never used anyway)\n         if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n+            // but let's call a method just to allow custom builders to be aware...\n             final String name = propDef.getName();\n             CreatorProperty cprop = null;\n             if (creatorProps != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType(ctxt.getTypeFactory());\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawReturnType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@addBeanProps\n@@ -54,16 +54,16 @@\n     // At which point we still have all kinds of properties; not all with mutators:\n     for (BeanPropertyDefinition propDef : propDefs) {\n         SettableBeanProperty prop = null;\n-                if (propDef.hasSetter()) {\n+        if (propDef.hasSetter()) {\n             JavaType propertyType = propDef.getSetter().getParameterType(0);\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (propDef.hasField()) {\n-            JavaType propertyType = propDef.getField().getType();\n+            JavaType propertyType = propDef.getField().getType(ctxt.getTypeFactory());\n             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n         } else if (useGettersAsSetters && propDef.hasGetter()) {\n-                        AnnotatedMethod getter = propDef.getGetter();\n+            AnnotatedMethod getter = propDef.getGetter();\n             // should only consider Collections and Maps, for now?\n-            Class<?> rawPropertyType = getter.getRawType();\n+            Class<?> rawPropertyType = getter.getRawReturnType();\n             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                 prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n             }\n@@ -71,7 +71,7 @@\n         // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n         //   (since they are never used anyway)\n         if (hasCreatorProps && propDef.hasConstructorParameter()) {\n-                        // but let's call a method just to allow custom builders to be aware...\n+            // but let's call a method just to allow custom builders to be aware...\n             final String name = propDef.getName();\n             CreatorProperty cprop = null;\n             if (creatorProps != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}]