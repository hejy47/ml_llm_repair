[{"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0.clone();\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0.clone();\n    if (hasLocale) {\n        df.applyPattern(new SimpleDateFormat(format.getPattern(), format.getLocale()).toPattern());\n    }\n    if (hasTZ) {\n        df.setTimeZone(format.getTimeZone());\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -33,7 +33,7 @@\n     DateFormat df0 = serializers.getConfig().getDateFormat();\n     // Jackson's own `StdDateFormat` is quite easy to deal with...\n     if (df0 instanceof StdDateFormat) {\n-        StdDateFormat std = (StdDateFormat) df0;\n+        StdDateFormat std = (StdDateFormat) df0.clone();\n         if (format.hasLocale()) {\n             std = std.withLocale(format.getLocale());\n         }\n@@ -48,17 +48,12 @@\n     if (!(df0 instanceof SimpleDateFormat)) {\n         serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n     }\n-    SimpleDateFormat df = (SimpleDateFormat) df0;\n+    SimpleDateFormat df = (SimpleDateFormat) df0.clone();\n     if (hasLocale) {\n-        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n-    } else {\n-        df = (SimpleDateFormat) df.clone();\n+        df.applyPattern(new SimpleDateFormat(format.getPattern(), format.getLocale()).toPattern());\n     }\n-    TimeZone newTz = format.getTimeZone();\n-    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n-    if (changeTZ) {\n-        df.setTimeZone(newTz);\n+    if (hasTZ) {\n+        df.setTimeZone(format.getTimeZone());\n     }\n     return withFormat(Boolean.FALSE, df);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    if (property == null || handledType() != Date.class) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getConfig().getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        df.setTimeZone(format.getTimeZone());\n        return withFormat(Boolean.FALSE, df);\n    }\n    if (shape == JsonFormat.Shape.STRING && (format.hasLocale() || format.hasTimeZone())) {\n        SimpleDateFormat df = new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n        if (format.hasLocale()) {\n            df = df.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            df = df.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, df);\n    }\n    return this;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -1,64 +1,31 @@\n @Override\n public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n-    // Note! Should not skip if `property` null since that'd skip check\n-    // for config overrides, in case of root value\n-    if (property == null) {\n+    if (property == null || handledType() != Date.class) {\n         return this;\n     }\n     JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n     if (format == null) {\n         return this;\n     }\n-    // Simple case first: serialize as numeric timestamp?\n     JsonFormat.Shape shape = format.getShape();\n     if (shape.isNumeric()) {\n         return withFormat(Boolean.TRUE, null);\n     }\n-    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n-    // First: custom pattern will override things\n     if (format.hasPattern()) {\n-        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n+        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getConfig().getLocale();\n         SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n-        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n-        df.setTimeZone(tz);\n+        df.setTimeZone(format.getTimeZone());\n         return withFormat(Boolean.FALSE, df);\n     }\n-    // Otherwise, need one of these changes:\n-    final boolean hasLocale = format.hasLocale();\n-    final boolean hasTZ = format.hasTimeZone();\n-    final boolean asString = (shape == JsonFormat.Shape.STRING);\n-    if (!hasLocale && !hasTZ && !asString) {\n-        return this;\n-    }\n-    DateFormat df0 = serializers.getConfig().getDateFormat();\n-    // Jackson's own `StdDateFormat` is quite easy to deal with...\n-    if (df0 instanceof StdDateFormat) {\n-        StdDateFormat std = (StdDateFormat) df0;\n+    if (shape == JsonFormat.Shape.STRING && (format.hasLocale() || format.hasTimeZone())) {\n+        SimpleDateFormat df = new SimpleDateFormat(DEFAULT_DATE_FORMAT);\n         if (format.hasLocale()) {\n-            std = std.withLocale(format.getLocale());\n+            df = df.withLocale(format.getLocale());\n         }\n         if (format.hasTimeZone()) {\n-            std = std.withTimeZone(format.getTimeZone());\n+            df = df.withTimeZone(format.getTimeZone());\n         }\n-        return withFormat(Boolean.FALSE, std);\n+        return withFormat(Boolean.FALSE, df);\n     }\n-    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-    //    So: require it be `SimpleDateFormat`; can't config other types\n-    if (!(df0 instanceof SimpleDateFormat)) {\n-        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n-    }\n-    SimpleDateFormat df = (SimpleDateFormat) df0;\n-    if (hasLocale) {\n-        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n-    } else {\n-        df = (SimpleDateFormat) df.clone();\n-    }\n-    TimeZone newTz = format.getTimeZone();\n-    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n-    if (changeTZ) {\n-        df.setTimeZone(newTz);\n-    }\n-    return withFormat(Boolean.FALSE, df);\n+    return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.getPattern() != null) { // change: use getPattern() instead of hasPattern()\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -16,7 +16,7 @@\n     }\n     // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n     // First: custom pattern will override things\n-    if (format.hasPattern()) {\n+    if (format.getPattern() != null) { // change: use getPattern() instead of hasPattern()\n         final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n         SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n         TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n        return null;\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -47,6 +47,7 @@\n     //    So: require it be `SimpleDateFormat`; can't config other types\n     if (!(df0 instanceof SimpleDateFormat)) {\n         serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n+        return null;\n     }\n     SimpleDateFormat df = (SimpleDateFormat) df0;\n     if (hasLocale) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getConfig()\n                .getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0.clone();\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(),\n                String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0.clone();\n    if (hasLocale) {\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -19,7 +19,8 @@\n     if (format.hasPattern()) {\n         final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n         SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n-        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n+        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getConfig()\n+                .getTimeZone();\n         df.setTimeZone(tz);\n         return withFormat(Boolean.FALSE, df);\n     }\n@@ -33,7 +34,7 @@\n     DateFormat df0 = serializers.getConfig().getDateFormat();\n     // Jackson's own `StdDateFormat` is quite easy to deal with...\n     if (df0 instanceof StdDateFormat) {\n-        StdDateFormat std = (StdDateFormat) df0;\n+        StdDateFormat std = (StdDateFormat) df0.clone();\n         if (format.hasLocale()) {\n             std = std.withLocale(format.getLocale());\n         }\n@@ -46,14 +47,12 @@\n     //    mechanism for changing `DateFormat` instances (or even clone()ing)\n     //    So: require it be `SimpleDateFormat`; can't config other types\n     if (!(df0 instanceof SimpleDateFormat)) {\n-        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n+        serializers.reportBadDefinition(handledType(),\n+                String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n     }\n-    SimpleDateFormat df = (SimpleDateFormat) df0;\n+    SimpleDateFormat df = (SimpleDateFormat) df0.clone();\n     if (hasLocale) {\n-        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n         df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n-    } else {\n-        df = (SimpleDateFormat) df.clone();\n     }\n     TimeZone newTz = format.getTimeZone();\n     boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    if (format.hasPattern()) {\n        return withFormat(Boolean.FALSE, new SimpleDateFormat(format.getPattern(), format.hasLocale() ? format.getLocale() : serializers.getLocale()));\n    }\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -1,7 +1,5 @@\n @Override\n public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n-    // Note! Should not skip if `property` null since that'd skip check\n-    // for config overrides, in case of root value\n     if (property == null) {\n         return this;\n     }\n@@ -9,21 +7,13 @@\n     if (format == null) {\n         return this;\n     }\n-    // Simple case first: serialize as numeric timestamp?\n     JsonFormat.Shape shape = format.getShape();\n     if (shape.isNumeric()) {\n         return withFormat(Boolean.TRUE, null);\n     }\n-    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n-    // First: custom pattern will override things\n     if (format.hasPattern()) {\n-        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n-        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n-        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n-        df.setTimeZone(tz);\n-        return withFormat(Boolean.FALSE, df);\n+        return withFormat(Boolean.FALSE, new SimpleDateFormat(format.getPattern(), format.hasLocale() ? format.getLocale() : serializers.getLocale()));\n     }\n-    // Otherwise, need one of these changes:\n     final boolean hasLocale = format.hasLocale();\n     final boolean hasTZ = format.hasTimeZone();\n     final boolean asString = (shape == JsonFormat.Shape.STRING);\n@@ -31,7 +21,6 @@\n         return this;\n     }\n     DateFormat df0 = serializers.getConfig().getDateFormat();\n-    // Jackson's own `StdDateFormat` is quite easy to deal with...\n     if (df0 instanceof StdDateFormat) {\n         StdDateFormat std = (StdDateFormat) df0;\n         if (format.hasLocale()) {\n@@ -42,15 +31,11 @@\n         }\n         return withFormat(Boolean.FALSE, std);\n     }\n-    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-    //    So: require it be `SimpleDateFormat`; can't config other types\n     if (!(df0 instanceof SimpleDateFormat)) {\n         serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n     }\n     SimpleDateFormat df = (SimpleDateFormat) df0;\n     if (hasLocale) {\n-        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n         df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n     } else {\n         df = (SimpleDateFormat) df.clone();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        if(format.hasTimeZone()){\n            df.setTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    if(format.hasTimeZone()){\n        df.setTimeZone(format.getTimeZone());\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -19,15 +19,15 @@\n     if (format.hasPattern()) {\n         final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n         SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n-        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n-        df.setTimeZone(tz);\n+        if(format.hasTimeZone()){\n+            df.setTimeZone(format.getTimeZone());\n+        }\n         return withFormat(Boolean.FALSE, df);\n     }\n     // Otherwise, need one of these changes:\n     final boolean hasLocale = format.hasLocale();\n-    final boolean hasTZ = format.hasTimeZone();\n     final boolean asString = (shape == JsonFormat.Shape.STRING);\n-    if (!hasLocale && !hasTZ && !asString) {\n+    if (!hasLocale && !asString) {\n         return this;\n     }\n     DateFormat df0 = serializers.getConfig().getDateFormat();\n@@ -55,10 +55,8 @@\n     } else {\n         df = (SimpleDateFormat) df.clone();\n     }\n-    TimeZone newTz = format.getTimeZone();\n-    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n-    if (changeTZ) {\n-        df.setTimeZone(newTz);\n+    if(format.hasTimeZone()){\n+        df.setTimeZone(format.getTimeZone());\n     }\n     return withFormat(Boolean.FALSE, df);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    \n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    \n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    \n    if (shape == null) {\n        return withFormat(Boolean.FALSE, serializers.getConfig().getDateFormat());\n    }\n    \n    final Locale locale = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n    final TimeZone timeZone;\n    if (format.hasTimeZone()) {\n        timeZone = format.getTimeZone();\n    } else {\n        timeZone = serializers.getTimeZone();\n    }\n    \n    if (shape == JsonFormat.Shape.STRING) {\n        final String pattern = format.getPattern();\n        if (format.hasLocale() || format.hasTimeZone()) {\n            // Create copy of format object to ensure thread safety\n            SimpleDateFormat df = new SimpleDateFormat(pattern, locale);\n            df.setTimeZone(timeZone);\n            return withFormat(Boolean.FALSE, df);\n        }\n        return withFormat(Boolean.FALSE, new SimpleDateFormat(pattern, locale));\n    }\n    \n    if (format.hasLocale() || format.hasTimeZone()) {\n        // Create copy of format object to ensure thread safety\n        final DateFormat df = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, locale);\n        df.setTimeZone(timeZone);\n        return withFormat(Boolean.FALSE, df);\n    }\n    return this;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -1,7 +1,5 @@\n @Override\n public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n-    // Note! Should not skip if `property` null since that'd skip check\n-    // for config overrides, in case of root value\n     if (property == null) {\n         return this;\n     }\n@@ -9,13 +7,12 @@\n     if (format == null) {\n         return this;\n     }\n-    // Simple case first: serialize as numeric timestamp?\n+    \n     JsonFormat.Shape shape = format.getShape();\n     if (shape.isNumeric()) {\n         return withFormat(Boolean.TRUE, null);\n     }\n-    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n-    // First: custom pattern will override things\n+    \n     if (format.hasPattern()) {\n         final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n         SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n@@ -23,42 +20,35 @@\n         df.setTimeZone(tz);\n         return withFormat(Boolean.FALSE, df);\n     }\n-    // Otherwise, need one of these changes:\n-    final boolean hasLocale = format.hasLocale();\n-    final boolean hasTZ = format.hasTimeZone();\n-    final boolean asString = (shape == JsonFormat.Shape.STRING);\n-    if (!hasLocale && !hasTZ && !asString) {\n-        return this;\n+    \n+    if (shape == null) {\n+        return withFormat(Boolean.FALSE, serializers.getConfig().getDateFormat());\n     }\n-    DateFormat df0 = serializers.getConfig().getDateFormat();\n-    // Jackson's own `StdDateFormat` is quite easy to deal with...\n-    if (df0 instanceof StdDateFormat) {\n-        StdDateFormat std = (StdDateFormat) df0;\n-        if (format.hasLocale()) {\n-            std = std.withLocale(format.getLocale());\n+    \n+    final Locale locale = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n+    final TimeZone timeZone;\n+    if (format.hasTimeZone()) {\n+        timeZone = format.getTimeZone();\n+    } else {\n+        timeZone = serializers.getTimeZone();\n+    }\n+    \n+    if (shape == JsonFormat.Shape.STRING) {\n+        final String pattern = format.getPattern();\n+        if (format.hasLocale() || format.hasTimeZone()) {\n+            // Create copy of format object to ensure thread safety\n+            SimpleDateFormat df = new SimpleDateFormat(pattern, locale);\n+            df.setTimeZone(timeZone);\n+            return withFormat(Boolean.FALSE, df);\n         }\n-        if (format.hasTimeZone()) {\n-            std = std.withTimeZone(format.getTimeZone());\n-        }\n-        return withFormat(Boolean.FALSE, std);\n+        return withFormat(Boolean.FALSE, new SimpleDateFormat(pattern, locale));\n     }\n-    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-    //    So: require it be `SimpleDateFormat`; can't config other types\n-    if (!(df0 instanceof SimpleDateFormat)) {\n-        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n+    \n+    if (format.hasLocale() || format.hasTimeZone()) {\n+        // Create copy of format object to ensure thread safety\n+        final DateFormat df = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, locale);\n+        df.setTimeZone(timeZone);\n+        return withFormat(Boolean.FALSE, df);\n     }\n-    SimpleDateFormat df = (SimpleDateFormat) df0;\n-    if (hasLocale) {\n-        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n-    } else {\n-        df = (SimpleDateFormat) df.clone();\n-    }\n-    TimeZone newTz = format.getTimeZone();\n-    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n-    if (changeTZ) {\n-        df.setTimeZone(newTz);\n-    }\n-    return withFormat(Boolean.FALSE, df);\n+    return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "There are no buggy functions specified in the JacksonDatabind project.", "diff": "", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0.clone();\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0.clone();\n    if (hasLocale) {\n        df.applyPattern(format.hasPattern() ? format.getPattern() : df.toPattern());\n        df.setLocale(format.getLocale());\n    }\n    if (hasTZ) {\n        df.setTimeZone(format.getTimeZone());\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -33,7 +33,7 @@\n     DateFormat df0 = serializers.getConfig().getDateFormat();\n     // Jackson's own `StdDateFormat` is quite easy to deal with...\n     if (df0 instanceof StdDateFormat) {\n-        StdDateFormat std = (StdDateFormat) df0;\n+        StdDateFormat std = (StdDateFormat) df0.clone();\n         if (format.hasLocale()) {\n             std = std.withLocale(format.getLocale());\n         }\n@@ -48,17 +48,13 @@\n     if (!(df0 instanceof SimpleDateFormat)) {\n         serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n     }\n-    SimpleDateFormat df = (SimpleDateFormat) df0;\n+    SimpleDateFormat df = (SimpleDateFormat) df0.clone();\n     if (hasLocale) {\n-        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n-    } else {\n-        df = (SimpleDateFormat) df.clone();\n+        df.applyPattern(format.hasPattern() ? format.getPattern() : df.toPattern());\n+        df.setLocale(format.getLocale());\n     }\n-    TimeZone newTz = format.getTimeZone();\n-    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n-    if (changeTZ) {\n-        df.setTimeZone(newTz);\n+    if (hasTZ) {\n+        df.setTimeZone(format.getTimeZone());\n     }\n     return withFormat(Boolean.FALSE, df);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        final DateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        final TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    final DateFormat df0 = serializers.getConfig().getDateFormat();\n    final TimeZone newTz = hasTZ ? format.getTimeZone() : null;\n    final Locale newLocale = hasLocale ? format.getLocale() : null;\n    final boolean changeTZ = (newTz != null) && !newTz.equals(df0.getTimeZone());\n    final boolean changeLocale = (newLocale != null) && !newLocale.equals(df0.getLocale());\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (hasLocale) {\n            std = std.withLocale(newLocale);\n        }\n        if (hasTZ) {\n            std = std.withTimeZone(newTz);\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (changeLocale) {\n        df = new SimpleDateFormat(df.toPattern(), newLocale);\n    }\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -18,8 +18,8 @@\n     // First: custom pattern will override things\n     if (format.hasPattern()) {\n         final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n-        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n-        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n+        final DateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n+        final TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n         df.setTimeZone(tz);\n         return withFormat(Boolean.FALSE, df);\n     }\n@@ -30,15 +30,19 @@\n     if (!hasLocale && !hasTZ && !asString) {\n         return this;\n     }\n-    DateFormat df0 = serializers.getConfig().getDateFormat();\n+    final DateFormat df0 = serializers.getConfig().getDateFormat();\n+    final TimeZone newTz = hasTZ ? format.getTimeZone() : null;\n+    final Locale newLocale = hasLocale ? format.getLocale() : null;\n+    final boolean changeTZ = (newTz != null) && !newTz.equals(df0.getTimeZone());\n+    final boolean changeLocale = (newLocale != null) && !newLocale.equals(df0.getLocale());\n     // Jackson's own `StdDateFormat` is quite easy to deal with...\n     if (df0 instanceof StdDateFormat) {\n         StdDateFormat std = (StdDateFormat) df0;\n-        if (format.hasLocale()) {\n-            std = std.withLocale(format.getLocale());\n+        if (hasLocale) {\n+            std = std.withLocale(newLocale);\n         }\n-        if (format.hasTimeZone()) {\n-            std = std.withTimeZone(format.getTimeZone());\n+        if (hasTZ) {\n+            std = std.withTimeZone(newTz);\n         }\n         return withFormat(Boolean.FALSE, std);\n     }\n@@ -49,14 +53,9 @@\n         serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n     }\n     SimpleDateFormat df = (SimpleDateFormat) df0;\n-    if (hasLocale) {\n-        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n-    } else {\n-        df = (SimpleDateFormat) df.clone();\n+    if (changeLocale) {\n+        df = new SimpleDateFormat(df.toPattern(), newLocale);\n     }\n-    TimeZone newTz = format.getTimeZone();\n-    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n     if (changeTZ) {\n         df.setTimeZone(newTz);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0.clone();\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0.clone();\n    if (hasLocale) {\n        df.applyPattern(format.getPattern());\n        df.setLocale(format.getLocale());\n    }\n    if (hasTZ) {\n        df.setTimeZone(format.getTimeZone());\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -33,7 +33,7 @@\n     DateFormat df0 = serializers.getConfig().getDateFormat();\n     // Jackson's own `StdDateFormat` is quite easy to deal with...\n     if (df0 instanceof StdDateFormat) {\n-        StdDateFormat std = (StdDateFormat) df0;\n+        StdDateFormat std = (StdDateFormat) df0.clone();\n         if (format.hasLocale()) {\n             std = std.withLocale(format.getLocale());\n         }\n@@ -48,17 +48,13 @@\n     if (!(df0 instanceof SimpleDateFormat)) {\n         serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n     }\n-    SimpleDateFormat df = (SimpleDateFormat) df0;\n+    SimpleDateFormat df = (SimpleDateFormat) df0.clone();\n     if (hasLocale) {\n-        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n-    } else {\n-        df = (SimpleDateFormat) df.clone();\n+        df.applyPattern(format.getPattern());\n+        df.setLocale(format.getLocale());\n     }\n-    TimeZone newTz = format.getTimeZone();\n-    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n-    if (changeTZ) {\n-        df.setTimeZone(newTz);\n+    if (hasTZ) {\n+        df.setTimeZone(format.getTimeZone());\n     }\n     return withFormat(Boolean.FALSE, df);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n        return this; // fixed line to return this when DateFormat is not a SimpleDateFormat\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -47,6 +47,7 @@\n     //    So: require it be `SimpleDateFormat`; can't config other types\n     if (!(df0 instanceof SimpleDateFormat)) {\n         serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n+        return this; // fixed line to return this when DateFormat is not a SimpleDateFormat\n     }\n     SimpleDateFormat df = (SimpleDateFormat) df0;\n     if (hasLocale) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        throw new IllegalArgumentException(\"Configured `DateFormat` not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\");\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -46,7 +46,7 @@\n     //    mechanism for changing `DateFormat` instances (or even clone()ing)\n     //    So: require it be `SimpleDateFormat`; can't config other types\n     if (!(df0 instanceof SimpleDateFormat)) {\n-        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n+        throw new IllegalArgumentException(\"Configured `DateFormat` not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\");\n     }\n     SimpleDateFormat df = (SimpleDateFormat) df0;\n     if (hasLocale) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0.clone(); //fix\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0.clone(); //fix\n    if (hasLocale) {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -33,7 +33,7 @@\n     DateFormat df0 = serializers.getConfig().getDateFormat();\n     // Jackson's own `StdDateFormat` is quite easy to deal with...\n     if (df0 instanceof StdDateFormat) {\n-        StdDateFormat std = (StdDateFormat) df0;\n+        StdDateFormat std = (StdDateFormat) df0.clone(); //fix\n         if (format.hasLocale()) {\n             std = std.withLocale(format.getLocale());\n         }\n@@ -48,12 +48,10 @@\n     if (!(df0 instanceof SimpleDateFormat)) {\n         serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n     }\n-    SimpleDateFormat df = (SimpleDateFormat) df0;\n+    SimpleDateFormat df = (SimpleDateFormat) df0.clone(); //fix\n     if (hasLocale) {\n         // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n         df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n-    } else {\n-        df = (SimpleDateFormat) df.clone();\n     }\n     TimeZone newTz = format.getTimeZone();\n     boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = (StdDateFormat) std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = (StdDateFormat) std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -35,10 +35,10 @@\n     if (df0 instanceof StdDateFormat) {\n         StdDateFormat std = (StdDateFormat) df0;\n         if (format.hasLocale()) {\n-            std = std.withLocale(format.getLocale());\n+            std = (StdDateFormat) std.withLocale(format.getLocale());\n         }\n         if (format.hasTimeZone()) {\n-            std = std.withTimeZone(format.getTimeZone());\n+            std = (StdDateFormat) std.withTimeZone(format.getTimeZone());\n         }\n         return withFormat(Boolean.FALSE, std);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        //Make sure the timezone is set before setting the formatting details\n        if (format.hasTimeZone()) {\n            df.setTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    if (hasTZ) {\n        df.setTimeZone(format.getTimeZone());\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -19,8 +19,10 @@\n     if (format.hasPattern()) {\n         final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n         SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n-        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n-        df.setTimeZone(tz);\n+        //Make sure the timezone is set before setting the formatting details\n+        if (format.hasTimeZone()) {\n+            df.setTimeZone(format.getTimeZone());\n+        }\n         return withFormat(Boolean.FALSE, df);\n     }\n     // Otherwise, need one of these changes:\n@@ -55,10 +57,8 @@\n     } else {\n         df = (SimpleDateFormat) df.clone();\n     }\n-    TimeZone newTz = format.getTimeZone();\n-    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n-    if (changeTZ) {\n-        df.setTimeZone(newTz);\n+    if (hasTZ) {\n+        df.setTimeZone(format.getTimeZone());\n     }\n     return withFormat(Boolean.FALSE, df);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n        return this;\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -47,6 +47,7 @@\n     //    So: require it be `SimpleDateFormat`; can't config other types\n     if (!(df0 instanceof SimpleDateFormat)) {\n         serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n+        return this;\n     }\n     SimpleDateFormat df = (SimpleDateFormat) df0;\n     if (hasLocale) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.getPattern().length() > 0) {\n        final Locale loc = format.getLocale() == null ? serializers.getLocale() : format.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.getTimeZone() == null ? serializers.getTimeZone() : format.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.getLocale() != null;\n    final boolean hasTZ = format.getTimeZone() != null;\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java@createContextual\n@@ -16,16 +16,16 @@\n     }\n     // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n     // First: custom pattern will override things\n-    if (format.hasPattern()) {\n-        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n+    if (format.getPattern().length() > 0) {\n+        final Locale loc = format.getLocale() == null ? serializers.getLocale() : format.getLocale();\n         SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n-        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n+        TimeZone tz = format.getTimeZone() == null ? serializers.getTimeZone() : format.getTimeZone();\n         df.setTimeZone(tz);\n         return withFormat(Boolean.FALSE, df);\n     }\n     // Otherwise, need one of these changes:\n-    final boolean hasLocale = format.hasLocale();\n-    final boolean hasTZ = format.hasTimeZone();\n+    final boolean hasLocale = format.getLocale() != null;\n+    final boolean hasTZ = format.getTimeZone() != null;\n     final boolean asString = (shape == JsonFormat.Shape.STRING);\n     if (!hasLocale && !hasTZ && !asString) {\n         return this;\n", "finish_reason": "stop", "valid": false, "num": 1}]