[{"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType.getRawClass().getName()));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    newType = newType.withHandlersFrom(baseType);\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(null, parameterClasses[i], null);\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _problem(tokens, \"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            return _factory._constructSimple(parameterTypes.size() > 0 ? base : Object.class, b, parameterTypes);\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    return _factory._fromClass(null, base, null);\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -9,7 +9,7 @@\n         if (\"<\".equals(token)) {\n             List<JavaType> parameterTypes = parseTypes(tokens);\n             TypeBindings b = TypeBindings.create(base, parameterTypes);\n-            return _factory._fromClass(null, base, b);\n+            return _factory._constructSimple(parameterTypes.size() > 0 ? base : Object.class, b, parameterTypes);\n         }\n         // can be comma that separates types, or closing '>'\n         tokens.pushBack(token);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    newType = newType.withHandlersFrom(baseType);\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(null, parameterClasses[i]);\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens, TypeBindings bindings) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _problem(tokens, \"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens, bindings);\n            TypeBindings tb = TypeBindings.create(base, parameterTypes);\n            return _factory._fromClass(null, base, tb);\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    if (bindings == null) {\n        bindings = TypeBindings.emptyBindings();\n    }\n    return _factory._fromClass(null, base, bindings);\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 7}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    newType = newType.withTypeHandler(baseType.getTypeHandler());\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(null, parameterClasses[i], null);\n    }\n    return constructParametrizedType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _constructError(\"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            return _fromClass(null, base, b);\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    return _fromClass(null, base, null);\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -1,6 +1,6 @@\n protected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n     if (!tokens.hasMoreTokens()) {\n-        throw _problem(tokens, \"Unexpected end-of-string\");\n+        throw _constructError(\"Unexpected end-of-string\");\n     }\n     Class<?> base = findClass(tokens.nextToken(), tokens);\n     // either end (ok, non generic type), or generics\n@@ -9,10 +9,10 @@\n         if (\"<\".equals(token)) {\n             List<JavaType> parameterTypes = parseTypes(tokens);\n             TypeBindings b = TypeBindings.create(base, parameterTypes);\n-            return _factory._fromClass(null, base, b);\n+            return _fromClass(null, base, b);\n         }\n         // can be comma that separates types, or closing '>'\n         tokens.pushBack(token);\n     }\n-    return _factory._fromClass(null, base, null);\n+    return _fromClass(null, base, null);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    TypeBindings newBindings = TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType());\n                    newType = _fromClass(null, subclass, newBindings);\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    TypeBindings newBindings = TypeBindings.create(subclass, baseType.getContentType());\n                    newType = _fromClass(null, subclass, newBindings);\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    newType = newType.withHandlersFrom(baseType);\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(parameterClasses[i], null);\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _problem(tokens, \"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            // Parse the generic type parameters\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            return _factory._fromClass(null, base, b);\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    return _factory._fromClass(base, null);\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -7,6 +7,7 @@\n     if (tokens.hasMoreTokens()) {\n         String token = tokens.nextToken();\n         if (\"<\".equals(token)) {\n+            // Parse the generic type parameters\n             List<JavaType> parameterTypes = parseTypes(tokens);\n             TypeBindings b = TypeBindings.create(base, parameterTypes);\n             return _factory._fromClass(null, base, b);\n@@ -14,5 +15,5 @@\n         // can be comma that separates types, or closing '>'\n         tokens.pushBack(token);\n     }\n-    return _factory._fromClass(null, base, null);\n+    return _factory._fromClass(base, null);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    if (newType == null) {\n        newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n    }\n    newType = newType.withHandlersFrom(baseType);\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(null, parameterClasses[i]);\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _problem(tokens, \"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            return _factory._fromParamType(base, b);\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    return _factory._fromClass(null, base, null);\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -9,7 +9,7 @@\n         if (\"<\".equals(token)) {\n             List<JavaType> parameterTypes = parseTypes(tokens);\n             TypeBindings b = TypeBindings.create(base, parameterTypes);\n-            return _factory._fromClass(null, base, b);\n+            return _factory._fromParamType(base, b);\n         }\n         // can be comma that separates types, or closing '>'\n         tokens.pushBack(token);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!subclass.isAssignableFrom(rawBase)) { // fix: reverse arguments of isAssignableFrom()\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    newType = newType.withHandlersFrom(baseType);\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(null, parameterClasses[i], null);\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _problem(tokens, \"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            return _factory._fromClass(null, base, b);\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    return _factory._fromClass(null, base, TypeBindings.emptyBindings()); // fix: use empty bindings instead of null\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -14,5 +14,5 @@\n         // can be comma that separates types, or closing '>'\n         tokens.pushBack(token);\n     }\n-    return _factory._fromClass(null, base, null);\n+    return _factory._fromClass(null, base, TypeBindings.emptyBindings()); // fix: use empty bindings instead of null\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class && !subclass.getName().startsWith(\"java.util.EnumSet\")) {\n                    return baseType.narrowEnum(subclass);\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n        break;\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    if (newType != null) {\n        newType = newType.withHandlersFrom(baseType);\n    }\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(null, parameterClasses[i], TypeBindings.emptyBindings());\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _problem(tokens, \"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            return _factory._fromClass(null, base, b);\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    return _factory._fromClass(null, base, TypeBindings.emptyBindings());\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -14,5 +14,5 @@\n         // can be comma that separates types, or closing '>'\n         tokens.pushBack(token);\n     }\n-    return _factory._fromClass(null, base, null);\n+    return _factory._fromClass(null, base, TypeBindings.emptyBindings());\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    if (newType == null) {\n        return null;\n    }\n    return newType.withHandlersFrom(baseType);\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(null, parameterClasses[i], null);\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw new IllegalArgumentException(\"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            return _factory._fromClass(null, base, b);\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    return _factory._fromClass(null, base, null);\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -1,6 +1,6 @@\n protected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n     if (!tokens.hasMoreTokens()) {\n-        throw _problem(tokens, \"Unexpected end-of-string\");\n+        throw new IllegalArgumentException(\"Unexpected end-of-string\");\n     }\n     Class<?> base = findClass(tokens.nextToken(), tokens);\n     // either end (ok, non generic type), or generics\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    newType = newType.withHandlersFrom(baseType);\n    if (newType.getTypeHandler() == null) {\n        newType = newType.withTypeHandler(baseType.getTypeHandler());\n    }\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(null, parameterClasses[i], null);\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _problem(tokens, \"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            return _factory._fromParamType(base, parameterTypes, b);\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    return _factory._fromClass(null, base, null);\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -9,7 +9,7 @@\n         if (\"<\".equals(token)) {\n             List<JavaType> parameterTypes = parseTypes(tokens);\n             TypeBindings b = TypeBindings.create(base, parameterTypes);\n-            return _factory._fromClass(null, base, b);\n+            return _factory._fromParamType(base, parameterTypes, b);\n         }\n         // can be comma that separates types, or closing '>'\n         tokens.pushBack(token);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    newType = newType.withHandlersFrom(baseType);\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(null, parameterClasses[i], null);\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _problem(tokens, \"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            return _fromParamTypeAndBindings(base, b);\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    return _fromClass(null, base, null);\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -9,10 +9,10 @@\n         if (\"<\".equals(token)) {\n             List<JavaType> parameterTypes = parseTypes(tokens);\n             TypeBindings b = TypeBindings.create(base, parameterTypes);\n-            return _factory._fromClass(null, base, b);\n+            return _fromParamTypeAndBindings(base, b);\n         }\n         // can be comma that separates types, or closing '>'\n         tokens.pushBack(token);\n     }\n-    return _factory._fromClass(null, base, null);\n+    return _fromClass(null, base, null);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    if (newType.getTypeHandler() != baseType.getTypeHandler()) {\n        newType = newType.withTypeHandler(baseType.getTypeHandler());\n    }\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(null, parameterClasses[i], null);\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _problem(tokens, \"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            JavaType javaType = _factory._fromClass(null, base, b);\n            if (tokens.hasMoreTokens()) {\n                token = tokens.nextToken();\n                if (\">\".equals(token)) {\n                    return javaType;\n                } else {\n                    throw _problem(tokens, \"Unexpected token '\" + token + \"', expected '>'\");\n                }\n            } else {\n                return javaType;\n            }\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    return _factory._fromClass(null, base, null);\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -9,7 +9,17 @@\n         if (\"<\".equals(token)) {\n             List<JavaType> parameterTypes = parseTypes(tokens);\n             TypeBindings b = TypeBindings.create(base, parameterTypes);\n-            return _factory._fromClass(null, base, b);\n+            JavaType javaType = _factory._fromClass(null, base, b);\n+            if (tokens.hasMoreTokens()) {\n+                token = tokens.nextToken();\n+                if (\">\".equals(token)) {\n+                    return javaType;\n+                } else {\n+                    throw _problem(tokens, \"Unexpected token '\" + token + \"', expected '>'\");\n+                }\n+            } else {\n+                return javaType;\n+            }\n         }\n         // can be comma that separates types, or closing '>'\n         tokens.pushBack(token);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    do {\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!baseType.isTypeOrSubTypeOf(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (baseType.isMapLikeType()) {\n            if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                break;\n            }\n        } else if (baseType.isCollectionLikeType()) {\n            if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                break;\n            }\n            if (rawBase == EnumSet.class) {\n                return baseType;\n            }\n        }\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    newType = newType.withHandlersFrom(baseType);\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(parameterClasses[i], null);\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _problem(tokens, \"Unexpected end-of-string\");\n    }\n    String className = tokens.nextToken();\n    Class<?> base = findClass(className, tokens);\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            return _factory._fromClass(null, base, b);\n        }\n        tokens.pushBack(token);\n    }\n    return _factory._fromClass(null, base, null);\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -2,8 +2,8 @@\n     if (!tokens.hasMoreTokens()) {\n         throw _problem(tokens, \"Unexpected end-of-string\");\n     }\n-    Class<?> base = findClass(tokens.nextToken(), tokens);\n-    // either end (ok, non generic type), or generics\n+    String className = tokens.nextToken();\n+    Class<?> base = findClass(className, tokens);\n     if (tokens.hasMoreTokens()) {\n         String token = tokens.nextToken();\n         if (\"<\".equals(token)) {\n@@ -11,7 +11,6 @@\n             TypeBindings b = TypeBindings.create(base, parameterTypes);\n             return _factory._fromClass(null, base, b);\n         }\n-        // can be comma that separates types, or closing '>'\n         tokens.pushBack(token);\n     }\n     return _factory._fromClass(null, base, null);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!baseType.isTypeOrSubTypeOf(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    newType = newType.withHandlersFrom(baseType);\n    return newType;\n}\n\n## Fixed Function 2\npublic JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n    int len = parameterClasses.length;\n    JavaType[] pt = new JavaType[len];\n    for (int i = 0; i < len; ++i) {\n        pt[i] = _fromClass(null, parameterClasses[i], null);\n    }\n    return constructParametricType(parametrized, pt);\n}\n\n## Fixed Function 3\nprotected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException {\n    if (!tokens.hasMoreTokens()) {\n        throw _problem(tokens, \"Unexpected end-of-string\");\n    }\n    Class<?> base = findClass(tokens.nextToken(), tokens);\n    // either end (ok, non generic type), or generics\n    if (tokens.hasMoreTokens()) {\n        String token = tokens.nextToken();\n        if (\"<\".equals(token)) {\n            List<JavaType> parameterTypes = parseTypes(tokens);\n            TypeBindings b = TypeBindings.create(base, parameterTypes);\n            return _factory._fromClass(null, base, b);\n        }\n        // can be comma that separates types, or closing '>'\n        tokens.pushBack(token);\n    }\n    return _fromClass(base, TypeBindings.emptyBindings());\n}", "diff": "--- com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n+++ com/fasterxml/jackson/databind/type/TypeParser.java@parseType\n@@ -14,5 +14,5 @@\n         // can be comma that separates types, or closing '>'\n         tokens.pushBack(token);\n     }\n-    return _factory._fromClass(null, base, null);\n+    return _fromClass(base, TypeBindings.emptyBindings());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]