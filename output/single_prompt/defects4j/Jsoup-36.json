[{"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n    }\n    doc.outputSettings().charset(charsetName);\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        //fix: add null check to prevent NullPointerException\n        if(charset==null){\n            return null;\n        }\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -36,7 +36,7 @@\n         if (docData.length() > 0 && docData.charAt(0) == 65279)\n             docData = docData.substring(1);\n         doc = parser.parseInput(docData, baseUri);\n-        doc.outputSettings().charset(charsetName);\n     }\n+    doc.outputSettings().charset(charsetName);\n     return doc;\n }\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -4,6 +4,10 @@\n     Matcher m = charsetPattern.matcher(contentType);\n     if (m.find()) {\n         String charset = m.group(1).trim();\n+        //fix: add null check to prevent NullPointerException\n+        if(charset==null){\n+            return null;\n+        }\n         if (Charset.isSupported(charset))\n             return charset;\n         charset = charset.toUpperCase(Locale.ENGLISH);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.codePointAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -33,7 +33,7 @@\n         // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n         // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n         // into head mode\n-        if (docData.length() > 0 && docData.charAt(0) == 65279)\n+        if (docData.length() > 0 && docData.codePointAt(0) == 65279)\n             docData = docData.substring(1);\n         doc = parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return defaultCharset;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -16,7 +16,7 @@\n             } else {\n                 foundCharset = meta.attr(\"charset\");\n             }\n-            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                 // need to re-decode\n                 charsetName = foundCharset;\n                 byteData.rewind();\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -11,5 +11,5 @@\n             return charset;\n         // if our advanced charset matching fails.... we just take the default\n     }\n-    return null;\n+    return defaultCharset;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = parser.parseInput(docData, baseUri);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n    if (doc != null) {\n        doc.outputSettings().charset(charsetName);\n    } else {\n        // if document was still not created\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        // added a check for \"charset=utf-8\" as it is not considered as a valid charset\n        if (charset.equalsIgnoreCase(\"utf-8\")) {\n            return \"UTF-8\";\n        }\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -21,20 +21,21 @@\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                doc = parser.parseInput(docData, baseUri);\n             }\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n-    if (doc == null) {\n-        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n-        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n-        // into head mode\n-        if (docData.length() > 0 && docData.charAt(0) == 65279)\n+    if (docData.length() > 0 && docData.charAt(0) == 65279)\n             docData = docData.substring(1);\n+    if (doc != null) {\n+        doc.outputSettings().charset(charsetName);\n+    } else {\n+        // if document was still not created\n         doc = parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -4,6 +4,10 @@\n     Matcher m = charsetPattern.matcher(contentType);\n     if (m.find()) {\n         String charset = m.group(1).trim();\n+        // added a check for \"charset=utf-8\" as it is not considered as a valid charset\n+        if (charset.equalsIgnoreCase(\"utf-8\")) {\n+            return \"UTF-8\";\n+        }\n         if (Charset.isSupported(charset))\n             return charset;\n         charset = charset.toUpperCase(Locale.ENGLISH);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(Charset.forName(charsetName));\n    }\n    return doc;\n}\n\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType.toLowerCase(Locale.ENGLISH));\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -36,7 +36,7 @@\n         if (docData.length() > 0 && docData.charAt(0) == 65279)\n             docData = docData.substring(1);\n         doc = parser.parseInput(docData, baseUri);\n-        doc.outputSettings().charset(charsetName);\n+        doc.outputSettings().charset(Charset.forName(charsetName));\n     }\n     return doc;\n }\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -1,7 +1,7 @@\n static String getCharsetFromContentType(String contentType) {\n     if (contentType == null)\n         return null;\n-    Matcher m = charsetPattern.matcher(contentType);\n+    Matcher m = charsetPattern.matcher(contentType.toLowerCase(Locale.ENGLISH));\n     if (m.find()) {\n         String charset = m.group(1).trim();\n         if (Charset.isSupported(charset))\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n                // fix for the bug where \"\\uFEFF\" is added to the start of the string\n                if (docData.length() > 0 && docData.charAt(0) == '\\uFEFF')\n                    docData = docData.substring(1);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -22,6 +22,9 @@\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n                 doc = null;\n+                // fix for the bug where \"\\uFEFF\" is added to the start of the string\n+                if (docData.length() > 0 && docData.charAt(0) == '\\uFEFF')\n+                    docData = docData.substring(1);\n             }\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(\"UTF-8\").decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(\"UTF-8\")) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName == null ? \"UTF-8\" : charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n        return \"UTF-8\";\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -10,6 +10,7 @@\n         if (Charset.isSupported(charset))\n             return charset;\n         // if our advanced charset matching fails.... we just take the default\n+        return \"UTF-8\";\n     }\n     return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // check alternate character set name\n        charset = alternateCharsetNames.get(charset.toLowerCase(Locale.ENGLISH));\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -16,7 +16,7 @@\n             } else {\n                 foundCharset = meta.attr(\"charset\");\n             }\n-            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                 // need to re-decode\n                 charsetName = foundCharset;\n                 byteData.rewind();\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -9,6 +9,10 @@\n         charset = charset.toUpperCase(Locale.ENGLISH);\n         if (Charset.isSupported(charset))\n             return charset;\n+        // check alternate character set name\n+        charset = alternateCharsetNames.get(charset.toLowerCase(Locale.ENGLISH));\n+        if (Charset.isSupported(charset))\n+            return charset;\n         // if our advanced charset matching fails.... we just take the default\n     }\n     return null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (!docData.isEmpty() && docData.charAt(0) == '\\ufeff')\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // Remove quotes around charset\n        charset = charset.replaceAll(\"[\\\"']\", \"\");\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -9,6 +9,10 @@\n         charset = charset.toUpperCase(Locale.ENGLISH);\n         if (Charset.isSupported(charset))\n             return charset;\n+        // Remove quotes around charset\n+        charset = charset.replaceAll(\"[\\\"']\", \"\");\n+        if (Charset.isSupported(charset))\n+            return charset;\n         // if our advanced charset matching fails.... we just take the default\n     }\n     return null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == '\\uFEFF')\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // try to convert the found charset to java standard charset name\n        Charset charsetz = Charset.forName(charset);\n        if (charsetz != null) {\n            charset = charsetz.name();\n            if (Charset.isSupported(charset))\n                return charset;\n        }\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -33,7 +33,7 @@\n         // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n         // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n         // into head mode\n-        if (docData.length() > 0 && docData.charAt(0) == 65279)\n+        if (docData.length() > 0 && docData.charAt(0) == '\\uFEFF')\n             docData = docData.substring(1);\n         doc = parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -9,6 +9,13 @@\n         charset = charset.toUpperCase(Locale.ENGLISH);\n         if (Charset.isSupported(charset))\n             return charset;\n+        // try to convert the found charset to java standard charset name\n+        Charset charsetz = Charset.forName(charset);\n+        if (charsetz != null) {\n+            charset = charsetz.name();\n+            if (Charset.isSupported(charset))\n+                return charset;\n+        }\n         // if our advanced charset matching fails.... we just take the default\n     }\n     return null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName == null ? defaultCharset : charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n        return null;\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -36,7 +36,7 @@\n         if (docData.length() > 0 && docData.charAt(0) == 65279)\n             docData = docData.substring(1);\n         doc = parser.parseInput(docData, baseUri);\n-        doc.outputSettings().charset(charsetName);\n+        doc.outputSettings().charset(charsetName == null ? defaultCharset : charsetName);\n     }\n     return doc;\n }\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -10,6 +10,7 @@\n         if (Charset.isSupported(charset))\n             return charset;\n         // if our advanced charset matching fails.... we just take the default\n+        return null;\n     }\n     return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // check for '-' instead of '_' (e.g. windows-1252 instead of windows_1252)\n        charset = charset.replace('_', '-');\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -16,7 +16,7 @@\n             } else {\n                 foundCharset = meta.attr(\"charset\");\n             }\n-            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                 // need to re-decode\n                 charsetName = foundCharset;\n                 byteData.rewind();\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -9,6 +9,10 @@\n         charset = charset.toUpperCase(Locale.ENGLISH);\n         if (Charset.isSupported(charset))\n             return charset;\n+        // check for '-' instead of '_' (e.g. windows-1252 instead of windows_1252)\n+        charset = charset.replace('_', '-');\n+        if (Charset.isSupported(charset))\n+            return charset;\n         // if our advanced charset matching fails.... we just take the default\n     }\n     return null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        byteData.rewind();\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        charset = charset.replace(\"charset=\", \"\");\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -27,6 +27,7 @@\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n+        byteData.rewind();\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc == null) {\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -4,6 +4,7 @@\n     Matcher m = charsetPattern.matcher(contentType);\n     if (m.find()) {\n         String charset = m.group(1).trim();\n+        charset = charset.replace(\"charset=\", \"\");\n         if (Charset.isSupported(charset))\n             return charset;\n         charset = charset.toUpperCase(Locale.ENGLISH);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n        return null; // fix: return null if unsupported charset found\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -10,6 +10,7 @@\n         if (Charset.isSupported(charset))\n             return charset;\n         // if our advanced charset matching fails.... we just take the default\n+        return null; // fix: return null if unsupported charset found\n     }\n     return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n                doc = parser.parseInput(docData, baseUri);\n                doc.outputSettings().charset(charsetName);\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType.toLowerCase(Locale.ENGLISH)); // fix here, make sure to match case insensitively\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -22,12 +22,16 @@\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n                 doc = null;\n+                doc = parser.parseInput(docData, baseUri);\n+                doc.outputSettings().charset(charsetName);\n             }\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n+        doc.outputSettings().charset(charsetName);\n     }\n     if (doc == null) {\n         // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -1,7 +1,7 @@\n static String getCharsetFromContentType(String contentType) {\n     if (contentType == null)\n         return null;\n-    Matcher m = charsetPattern.matcher(contentType);\n+    Matcher m = charsetPattern.matcher(contentType.toLowerCase(Locale.ENGLISH)); // fix here, make sure to match case insensitively\n     if (m.find()) {\n         String charset = m.group(1).trim();\n         if (Charset.isSupported(charset))\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Elements meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        for (Element element : meta) {\n            String foundCharset;\n            if (element.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(element.attr(\"content\"));\n            } else {\n                foundCharset = element.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n                break;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType.toLowerCase());\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -1,7 +1,7 @@\n static String getCharsetFromContentType(String contentType) {\n     if (contentType == null)\n         return null;\n-    Matcher m = charsetPattern.matcher(contentType);\n+    Matcher m = charsetPattern.matcher(contentType.toLowerCase());\n     if (m.find()) {\n         String charset = m.group(1).trim();\n         if (Charset.isSupported(charset))\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        CharsetEncoder defaultEncoder = Charset.forName(defaultCharset).newEncoder();\n\n        // fix to detect BOM first so it won't interfere with charset detection\n        boolean includeBom = false;\n        if (byteData.order() == ByteOrder.BIG_ENDIAN) {\n            includeBom = byteData.getShort(0) == 0xFEFF;\n        } else if (byteData.order() == ByteOrder.LITTLE_ENDIAN) {\n            includeBom = byteData.getShort(0) == 0xFFFE;\n        }\n\n        if (includeBom) {\n            defaultEncoder.onMalformedInput(CodingErrorAction.REPORT);\n            docData = defaultEncoder.decode(byteData).toString();\n            docData = new StringBuilder(docData.length())\n                    .append(docData.charAt(0))\n                    .append(docData.substring(1).replace(\"\\uFEFF\", \"\"))\n                    .toString();\n        } else {\n            defaultEncoder.onMalformedInput(CodingErrorAction.REPLACE);\n            docData = defaultEncoder.decode(byteData).toString();\n        }\n\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                ByteBuffer byteData2;\n                if (includeBom) {\n                    byteData2 = ByteBuffer.wrap(docData.getBytes(charsetName));\n                } else {\n                    byteData.rewind();\n                    Charset charset = Charset.forName(charsetName);\n                    CharsetDecoder decoder = charset.newDecoder();\n                    decoder.onMalformedInput(CodingErrorAction.REPLACE);\n                    byteData2 = decoder.decode(byteData);\n                }\n                docData = byteData2.toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        CharsetEncoder encoder = Charset.forName(charsetName).newEncoder();\n        encoder.onMalformedInput(CodingErrorAction.REPLACE);\n        docData = encoder.decode(byteData).toString();\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic Charset getCharsetFromContentType(String contentType) {\n    if (contentType == null) {\n        return null;\n    }\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset)) {\n            return Charset.forName(charset);\n        }\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset)) {\n            return Charset.forName(charset);\n        }\n        // if our advanced charset matching fails.... we just return null\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -5,7 +5,28 @@\n     if (charsetName == null) {\n         // determine from meta. safe parse as UTF-8\n         // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n+        CharsetEncoder defaultEncoder = Charset.forName(defaultCharset).newEncoder();\n+\n+        // fix to detect BOM first so it won't interfere with charset detection\n+        boolean includeBom = false;\n+        if (byteData.order() == ByteOrder.BIG_ENDIAN) {\n+            includeBom = byteData.getShort(0) == 0xFEFF;\n+        } else if (byteData.order() == ByteOrder.LITTLE_ENDIAN) {\n+            includeBom = byteData.getShort(0) == 0xFFFE;\n+        }\n+\n+        if (includeBom) {\n+            defaultEncoder.onMalformedInput(CodingErrorAction.REPORT);\n+            docData = defaultEncoder.decode(byteData).toString();\n+            docData = new StringBuilder(docData.length())\n+                    .append(docData.charAt(0))\n+                    .append(docData.substring(1).replace(\"\\uFEFF\", \"\"))\n+                    .toString();\n+        } else {\n+            defaultEncoder.onMalformedInput(CodingErrorAction.REPLACE);\n+            docData = defaultEncoder.decode(byteData).toString();\n+        }\n+\n         doc = parser.parseInput(docData, baseUri);\n         Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n         if (meta != null) {\n@@ -19,22 +40,28 @@\n             if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                 // need to re-decode\n                 charsetName = foundCharset;\n-                byteData.rewind();\n-                docData = Charset.forName(foundCharset).decode(byteData).toString();\n+                ByteBuffer byteData2;\n+                if (includeBom) {\n+                    byteData2 = ByteBuffer.wrap(docData.getBytes(charsetName));\n+                } else {\n+                    byteData.rewind();\n+                    Charset charset = Charset.forName(charsetName);\n+                    CharsetDecoder decoder = charset.newDecoder();\n+                    decoder.onMalformedInput(CodingErrorAction.REPLACE);\n+                    byteData2 = decoder.decode(byteData);\n+                }\n+                docData = byteData2.toString();\n                 doc = null;\n             }\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n-        docData = Charset.forName(charsetName).decode(byteData).toString();\n+        CharsetEncoder encoder = Charset.forName(charsetName).newEncoder();\n+        encoder.onMalformedInput(CodingErrorAction.REPLACE);\n+        docData = encoder.decode(byteData).toString();\n     }\n     if (doc == null) {\n-        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n-        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n-        // into head mode\n-        if (docData.length() > 0 && docData.charAt(0) == 65279)\n-            docData = docData.substring(1);\n         doc = parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName == null ? defaultCharset : charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType.toLowerCase(Locale.ENGLISH));\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -36,7 +36,7 @@\n         if (docData.length() > 0 && docData.charAt(0) == 65279)\n             docData = docData.substring(1);\n         doc = parser.parseInput(docData, baseUri);\n-        doc.outputSettings().charset(charsetName);\n+        doc.outputSettings().charset(charsetName == null ? defaultCharset : charsetName);\n     }\n     return doc;\n }\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -1,7 +1,7 @@\n static String getCharsetFromContentType(String contentType) {\n     if (contentType == null)\n         return null;\n-    Matcher m = charsetPattern.matcher(contentType);\n+    Matcher m = charsetPattern.matcher(contentType.toLowerCase(Locale.ENGLISH));\n     if (m.find()) {\n         String charset = m.group(1).trim();\n         if (Charset.isSupported(charset))\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        byteData.mark();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.reset();\n                byte[] bytes = byteData.array();\n                docData = new String(bytes, Charset.forName(foundCharset));\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.replace(\"\\\"\", \"\").replace(\"'\", \"\").trim().toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return null;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -6,7 +6,7 @@\n         String charset = m.group(1).trim();\n         if (Charset.isSupported(charset))\n             return charset;\n-        charset = charset.toUpperCase(Locale.ENGLISH);\n+        charset = charset.replace(\"\\\"\", \"\").replace(\"'\", \"\").trim().toUpperCase(Locale.ENGLISH);\n         if (Charset.isSupported(charset))\n             return charset;\n         // if our advanced charset matching fails.... we just take the default\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    Charset defaultCharset = Charset.forName(\"UTF-8\"); // added line\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = defaultCharset.decode(byteData).toString(); // changed line\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            // if not found, will keep utf-8 as best attempt\n            String foundCharset;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset.name())) {\n                // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n        if (docData.length() > 0 && docData.charAt(0) == 65279)\n            docData = docData.substring(1);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n## Fixed Function 2\nstatic String getCharsetFromContentType(String contentType) {\n    if (contentType == null)\n        return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        if (Charset.isSupported(charset))\n            return charset;\n        charset = charset.toUpperCase(Locale.ENGLISH);\n        if (Charset.isSupported(charset))\n            return charset;\n        // if our advanced charset matching fails.... we just take the default\n    }\n    return \"UTF-8\"; // changed line\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -2,10 +2,11 @@\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n+    Charset defaultCharset = Charset.forName(\"UTF-8\"); // added line\n     if (charsetName == null) {\n         // determine from meta. safe parse as UTF-8\n         // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n+        docData = defaultCharset.decode(byteData).toString(); // changed line\n         doc = parser.parseInput(docData, baseUri);\n         Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n         if (meta != null) {\n@@ -16,7 +17,7 @@\n             } else {\n                 foundCharset = meta.attr(\"charset\");\n             }\n-            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n+            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset.name())) {\n                 // need to re-decode\n                 charsetName = foundCharset;\n                 byteData.rewind();\n--- org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n+++ org/jsoup/helper/DataUtil.java@getCharsetFromContentType\n@@ -11,5 +11,5 @@\n             return charset;\n         // if our advanced charset matching fails.... we just take the default\n     }\n-    return null;\n+    return \"UTF-8\"; // changed line\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]