[{"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // is this even legal call?\n        return getNullValue(ctxt);\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return getNullValue(ctxt);\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name) || \"fromString\".equals(name)) {\n        int argCount = am.getParameterCount();\n        if (argCount == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -2,7 +2,7 @@\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n         // is this even legal call?\n-        return null;\n+        return getNullValue(ctxt);\n     }\n     try {\n         Object result = _parse(key, ctxt);\n@@ -13,7 +13,8 @@\n         return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n+        return getNullValue(ctxt);\n     }\n     return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,20 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // is this even legal call?\n+        return getNullValue(ctxt);\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return getNullValue(ctxt);\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,19 +1,16 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n-    if (\"valueOf\".equals(name)) {\n-        return true;\n-    }\n-    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n-    if (\"fromString\".equals(name)) {\n-        if (am.getParameterCount() == 1) {\n+    if (\"valueOf\".equals(name) || \"fromString\".equals(name)) {\n+        int argCount = am.getParameterCount();\n+        if (argCount == 1) {\n             Class<?> cls = am.getRawParameterType(0);\n             if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                 return true;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // is this even legal call?\n        return null;\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        ctxt.reportInputMismatch(_keyClass, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    ctxt.reportInputMismatch(_keyClass, \"not a valid representation\");\n    return null;\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am, expArgTypes)) {\n            return am.getAnnotated();\n        }\n    }\n    return null;\n}\n\nprivate boolean isFactoryMethod(AnnotatedMethod am, Class<?>... expArgTypes) {\n    Class<?> actualArgType = am.getRawParameterType(0);\n    for (Class<?> expArgType : expArgTypes) {\n        // And one that matches what we would pass in\n        if (actualArgType.isAssignableFrom(expArgType) && am.getParameterCount() == 1) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n\n    final String name = am.getName();\n    if (\"valueOf\".equals(name) || \"fromString\".equals(name)) {\n        // 24-Oct-2016, tatu: As per [databind#1429], must ensure takes exactly one arg\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (name.equals(\"valueOf\")) {\n                // note: from org.codehaus.groovy.runtime.StringGroovyMethods\n                if (CharSequence.class.isAssignableFrom(cls)) {\n                    return true;\n                }\n            } else { // name.equals(\"fromString\")\n                if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -10,10 +10,11 @@\n             return result;\n         }\n     } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n+        ctxt.reportInputMismatch(_keyClass, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n         return null;\n     }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    ctxt.reportInputMismatch(_keyClass, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,20 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // is this even legal call?\n+        return null;\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        ctxt.reportInputMismatch(_keyClass, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    ctxt.reportInputMismatch(_keyClass, \"not a valid representation\");\n     return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,22 +1,26 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n+\n     final String name = am.getName();\n-    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n-    if (\"valueOf\".equals(name)) {\n-        return true;\n-    }\n-    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n-    if (\"fromString\".equals(name)) {\n+    if (\"valueOf\".equals(name) || \"fromString\".equals(name)) {\n+        // 24-Oct-2016, tatu: As per [databind#1429], must ensure takes exactly one arg\n         if (am.getParameterCount() == 1) {\n             Class<?> cls = am.getRawParameterType(0);\n-            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n-                return true;\n+            if (name.equals(\"valueOf\")) {\n+                // note: from org.codehaus.groovy.runtime.StringGroovyMethods\n+                if (CharSequence.class.isAssignableFrom(cls)) {\n+                    return true;\n+                }\n+            } else { // name.equals(\"fromString\")\n+                if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n+                    return true;\n+                }\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // is this even legal call?\n        return null;\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { //Changed from getConfig() to isEnabled()\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) { //Changed the order of expArgType and actualArgType to check the compatibility\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name)) {\n        if (am.getParameterCount() == 1) { //Added this condition to check if the method takes exactly one argument\n            return true;\n        }\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -12,7 +12,7 @@\n     } catch (Exception re) {\n         return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+    if (_keyClass.isEnum() && ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { //Changed from getConfig() to isEnabled()\n         return null;\n     }\n     return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,19 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // is this even legal call?\n+        return null;\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { //Changed from getConfig() to isEnabled()\n+        return null;\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,15 +1,17 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n     if (\"valueOf\".equals(name)) {\n-        return true;\n+        if (am.getParameterCount() == 1) { //Added this condition to check if the method takes exactly one argument\n+            return true;\n+        }\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n     if (\"fromString\".equals(name)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // is this even legal call?\n        return null;\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        ctxt.reportInputMismatch(_keyClass,\n                \"Problem deserializing key, expected value to be encoded as %s: %s\",\n                _keyType, re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    ctxt.reportInputMismatch(_keyClass, \"Problem deserializing key. Could not find suitable deserializer\");\n    // should not really reach here but:\n    return null;\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        if (am.getParameterCount() != 1) {\n            continue;\n        }\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (actualArgType.isAssignableFrom(expArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name) && (am.getParameterCount() == 1)) {\n        Class<?> argType = am.getRawParameterType(0);\n        if (argType.isPrimitive() || argType == String.class) {\n            return true;\n        }\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        if ((am.getParameterCount() == 1)\n            && CharSequence.class.isAssignableFrom(am.getRawParameterType(0))) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -10,10 +10,14 @@\n             return result;\n         }\n     } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n+        ctxt.reportInputMismatch(_keyClass,\n+                \"Problem deserializing key, expected value to be encoded as %s: %s\",\n+                _keyType, re.getMessage());\n     }\n     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n         return null;\n     }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    ctxt.reportInputMismatch(_keyClass, \"Problem deserializing key. Could not find suitable deserializer\");\n+    // should not really reach here but:\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,23 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // is this even legal call?\n+        return null;\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        ctxt.reportInputMismatch(_keyClass,\n+                \"Problem deserializing key, expected value to be encoded as %s: %s\",\n+                _keyType, re.getMessage());\n     }\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    ctxt.reportInputMismatch(_keyClass, \"Problem deserializing key. Could not find suitable deserializer\");\n+    // should not really reach here but:\n     return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,23 +1,24 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n-    if (\"valueOf\".equals(name)) {\n-        return true;\n+    if (\"valueOf\".equals(name) && (am.getParameterCount() == 1)) {\n+        Class<?> argType = am.getRawParameterType(0);\n+        if (argType.isPrimitive() || argType == String.class) {\n+            return true;\n+        }\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n     if (\"fromString\".equals(name)) {\n-        if (am.getParameterCount() == 1) {\n-            Class<?> cls = am.getRawParameterType(0);\n-            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n-                return true;\n-            }\n+        if ((am.getParameterCount() == 1)\n+            && CharSequence.class.isAssignableFrom(am.getRawParameterType(0))) {\n+            return true;\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException {\n\n    if (key == null) {\n        return ctxt.handleNullKey(_keyClass);\n    }\n\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name)) {\n        return true;\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (String.class.isAssignableFrom(cls) || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,9 +1,11 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+public Object deserializeKey(String key, DeserializationContext ctxt)\n+        throws IOException {\n+\n     if (key == null) {\n-        // is this even legal call?\n-        return null;\n+        return ctxt.handleNullKey(_keyClass);\n     }\n+\n     try {\n         Object result = _parse(key, ctxt);\n         if (result != null) {\n@@ -12,8 +14,10 @@\n     } catch (Exception re) {\n         return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n+\n     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n         return null;\n     }\n+\n     return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,23 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt)\n+        throws IOException {\n+\n+    if (key == null) {\n+        return ctxt.handleNullKey(_keyClass);\n+    }\n+\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,11 +1,13 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n+\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n     if (\"valueOf\".equals(name)) {\n@@ -15,10 +17,11 @@\n     if (\"fromString\".equals(name)) {\n         if (am.getParameterCount() == 1) {\n             Class<?> cls = am.getRawParameterType(0);\n-            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n+            if (String.class.isAssignableFrom(cls) || CharSequence.class.isAssignableFrom(cls)) {\n                 return true;\n             }\n         }\n     }\n+\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // returning null for null values\n        return getNullValue(ctxt);\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return getNullValue(ctxt);\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (actualArgType.isAssignableFrom(expArgType)) {\n                    am.fixAccess(); // fix access if necessary\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            return true;\n        }\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,8 +1,8 @@\n @Override\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n-        // is this even legal call?\n-        return null;\n+        // returning null for null values\n+        return getNullValue(ctxt);\n     }\n     try {\n         Object result = _parse(key, ctxt);\n@@ -13,7 +13,7 @@\n         return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n+        return getNullValue(ctxt);\n     }\n     return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,19 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // returning null for null values\n+        return getNullValue(ctxt);\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return getNullValue(ctxt);\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,15 +1,17 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n     if (\"valueOf\".equals(name)) {\n-        return true;\n+        if (am.getParameterCount() == 1) {\n+            return true;\n+        }\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n     if (\"fromString\".equals(name)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // it is legal to call deserializeKey with a null argument\n        // so it should return null instead of throwing an exception\n        return null;\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am, expArgTypes)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (actualArgType.isAssignableFrom(expArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\nprivate boolean isFactoryMethod(AnnotatedMethod am, Class<?>... expArgTypes) {\n    if (!am.getReturnType().isAssignableFrom(_valueClass)) {\n        return false;\n    }\n    return (_annotationIntrospector.findJsonValueAccessor(am) != null)\n            || ((_propertyName != null) && _propertyName.equals(am.getName())\n                    && (_annotationIntrospector.findCreatorAnnotation(_config, am) != null))\n            || (_annotationIntrospector.findCreatorAnnotation(_config, am) != null\n                    && hasExplicitParamName(am.getParameterCount(), am.getRawParameterTypes()));\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name) && am.getParameterCount() == 1) {\n        return true;\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,7 +1,8 @@\n @Override\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n-        // is this even legal call?\n+        // it is legal to call deserializeKey with a null argument\n+        // so it should return null instead of throwing an exception\n         return null;\n     }\n     try {\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,20 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // it is legal to call deserializeKey with a null argument\n+        // so it should return null instead of throwing an exception\n+        return null;\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,14 +1,14 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n-    if (\"valueOf\".equals(name)) {\n+    if (\"valueOf\".equals(name) && am.getParameterCount() == 1) {\n         return true;\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // is this even legal call?\n        return null;\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        // fix: return null if enum is not found\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }\n    // fix: return null if enum is not found\n    return null;\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // fix: check if expArgType is assignable from actualArgType\n                if (expArgType.isAssignableFrom(actualArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n        Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            return true;\n        }\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -13,7 +13,9 @@\n         return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n+        // fix: return null if enum is not found\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n     }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    // fix: return null if enum is not found\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,21 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // is this even legal call?\n+        return null;\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        // fix: return null if enum is not found\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    }\n+    // fix: return null if enum is not found\n     return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -9,7 +9,9 @@\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n     if (\"valueOf\".equals(name)) {\n-        return true;\n+        if (am.getParameterCount() == 1) {\n+            return true;\n+        }\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n     if (\"fromString\".equals(name)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        return null;\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        // Enum constants are case-sensitive, so we must return null if the key is not a valid enum constant\n        if(Arrays.stream(_keyClass.getEnumConstants()).noneMatch(constant -> constant.name().equals(key))) {\n            return null;\n        }\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am, expArgTypes)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (actualArgType.isAssignableFrom(expArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\nprivate boolean isFactoryMethod(AnnotatedMethod am, Class<?>[] expArgTypes) {\n    if (!am.getDeclaringClass().isAssignableFrom(_classInfo.getAnnotated())) {\n        return false;\n    }\n    if (am.getParameterCount() != 1) {\n        return false;\n    }\n    if (!_classInfo.canCreateFromNonDefaultConstructor()) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name)) {\n        return true;\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        Class<?> cls = am.getRawParameterType(0);\n        if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n            return true;\n        }\n    }\n    if (isEnumValueOfMethod(am, expArgTypes)) {\n        return true;\n    }\n    return false;\n}\n\nprivate boolean isEnumValueOfMethod(AnnotatedMethod am, Class<?>[] expArgTypes) {\n    Class<?> rawReturnType = am.getRawReturnType();\n    if (!rawReturnType.equals(_classInfo.getAnnotated())) {\n        return false;\n    }\n    if (!am.getName().equals(\"valueOf\")) {\n        return false;\n    }\n    if (!am.getParameter(0).getRawType().isAssignableFrom(String.class)) {\n        return false;\n    }\n    if (!_classInfo.getType().isEnum()) {\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am, String name) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    if (name.equals(\"valueOf\") && rt.equals(getBeanClass())) {\n        if (am.getParameterCount() == 1 && am.getRawParameterType(0).equals(String.class)) {\n            return true;\n        }\n    }\n    if (name.equals(\"fromString\") && rt.equals(getBeanClass())) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,7 +1,6 @@\n @Override\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n-        // is this even legal call?\n         return null;\n     }\n     try {\n@@ -13,7 +12,10 @@\n         return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n+        // Enum constants are case-sensitive, so we must return null if the key is not a valid enum constant\n+        if(Arrays.stream(_keyClass.getEnumConstants()).noneMatch(constant -> constant.name().equals(key))) {\n+            return null;\n+        }\n     }\n     return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,21 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        return null;\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n+        }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n+    }\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        // Enum constants are case-sensitive, so we must return null if the key is not a valid enum constant\n+        if(Arrays.stream(_keyClass.getEnumConstants()).noneMatch(constant -> constant.name().equals(key))) {\n+            return null;\n         }\n     }\n-    return null;\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // Legal call, return null instead of exception\n        return null;\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        // More descriptive exception message\n        ctxt.handleWeirdKey(_keyClass, key, \"problem deserializing key, exception: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    // Return exception instead of null with vague message\n    throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        if (am.getParameterCount() == 1) {\n            // Better ensure it only takes 1 arg, no matter what\n            if (isFactoryMethod(am)) {\n                // And must take one of expected arg types (or supertype)\n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (expArgType.isAssignableFrom(actualArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name) && am.getParameterCount() == 1) {\n        return true;\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name) && am.getParameterCount() == 1) {\n        Class<?> cls = am.getRawParameterType(0);\n        if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,7 +1,7 @@\n @Override\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n-        // is this even legal call?\n+        // Legal call, return null instead of exception\n         return null;\n     }\n     try {\n@@ -10,10 +10,12 @@\n             return result;\n         }\n     } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n+        // More descriptive exception message\n+        ctxt.handleWeirdKey(_keyClass, key, \"problem deserializing key, exception: %s\", re.getMessage());\n     }\n     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n         return null;\n     }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    // Return exception instead of null with vague message\n+    throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,21 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // Legal call, return null instead of exception\n+        return null;\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        // More descriptive exception message\n+        ctxt.handleWeirdKey(_keyClass, key, \"problem deserializing key, exception: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    // Return exception instead of null with vague message\n+    throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,23 +1,21 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n-    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n-    if (\"valueOf\".equals(name)) {\n+    // As per [databind#1429] must ensure takes exactly one arg\n+    if (\"valueOf\".equals(name) && am.getParameterCount() == 1) {\n         return true;\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n-    if (\"fromString\".equals(name)) {\n-        if (am.getParameterCount() == 1) {\n-            Class<?> cls = am.getRawParameterType(0);\n-            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n-                return true;\n-            }\n+    if (\"fromString\".equals(name) && am.getParameterCount() == 1) {\n+        Class<?> cls = am.getRawParameterType(0);\n+        if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n+            return true;\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        return ctxt.handleNullKey(_keyClass);\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) { // swap order\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n        Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name)) {\n        if (am.getParameterCount() == 1) { // add check for 1 parameter\n            return true;\n        }\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,8 +1,7 @@\n @Override\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n-        // is this even legal call?\n-        return null;\n+        return ctxt.handleNullKey(_keyClass);\n     }\n     try {\n         Object result = _parse(key, ctxt);\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,18 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        return ctxt.handleNullKey(_keyClass);\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -9,7 +9,9 @@\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n     if (\"valueOf\".equals(name)) {\n-        return true;\n+        if (am.getParameterCount() == 1) { // add check for 1 parameter\n+            return true;\n+        }\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n     if (\"fromString\".equals(name)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        return ctxt.handleUnexpectedToken(_keyClass, JsonToken.VALUE_NULL, ctxt.parser,\n                \"null key for a Map not allowed in JSON (use a converting NullKeyDeserializer?)\");\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am) || _annotationIntrospector.hasAnySetterAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name) && am.getParameterCount() == 1) {\n        return true;\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name) && am.getParameterCount() == 1) {\n        Class<?> cls = am.getRawParameterType(0);\n        return (cls == String.class || CharSequence.class.isAssignableFrom(cls));\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,8 +1,8 @@\n @Override\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n-        // is this even legal call?\n-        return null;\n+        return ctxt.handleUnexpectedToken(_keyClass, JsonToken.VALUE_NULL, ctxt.parser,\n+                \"null key for a Map not allowed in JSON (use a converting NullKeyDeserializer?)\");\n     }\n     try {\n         Object result = _parse(key, ctxt);\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,19 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        return ctxt.handleUnexpectedToken(_keyClass, JsonToken.VALUE_NULL, ctxt.parser,\n+                \"null key for a Map not allowed in JSON (use a converting NullKeyDeserializer?)\");\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,24 +1,20 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am) || _annotationIntrospector.hasAnySetterAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n-    if (\"valueOf\".equals(name)) {\n+    if (\"valueOf\".equals(name) && am.getParameterCount() == 1) {\n         return true;\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n-    if (\"fromString\".equals(name)) {\n-        if (am.getParameterCount() == 1) {\n-            Class<?> cls = am.getRawParameterType(0);\n-            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n-                return true;\n-            }\n-        }\n+    if (\"fromString\".equals(name) && am.getParameterCount() == 1) {\n+        Class<?> cls = am.getRawParameterType(0);\n+        return (cls == String.class || CharSequence.class.isAssignableFrom(cls));\n     }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        return null;\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        if (!ctxt.getConfig().isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n            return null;\n        }\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        if (am.getParameterCount() == 1) { // Need to ensure it only has one parameter\n            // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n            if (isFactoryMethod(am)) {\n                // And must take one of expected arg types (or supertype)\n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (rt == Void.class || rt == Void.TYPE) { // Added check for void return type\n        return false;\n    }\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name) && Modifier.isStatic(am.getModifiers())) { // Check for static method\n        return true;\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name) && Modifier.isStatic(am.getModifiers())) { // Check for static method\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,7 +1,6 @@\n @Override\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n-        // is this even legal call?\n         return null;\n     }\n     try {\n@@ -13,7 +12,9 @@\n         return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n+        if (!ctxt.getConfig().isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n+            return null;\n+        }\n     }\n     return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,20 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        return null;\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n+        }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n+    }\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        if (!ctxt.getConfig().isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {\n+            return null;\n         }\n     }\n-    return null;\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,18 +1,21 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n+    if (rt == Void.class || rt == Void.TYPE) { // Added check for void return type\n+        return false;\n+    }\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n-    if (\"valueOf\".equals(name)) {\n+    if (\"valueOf\".equals(name) && Modifier.isStatic(am.getModifiers())) { // Check for static method\n         return true;\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n-    if (\"fromString\".equals(name)) {\n+    if (\"fromString\".equals(name) && Modifier.isStatic(am.getModifiers())) { // Check for static method\n         if (am.getParameterCount() == 1) {\n             Class<?> cls = am.getRawParameterType(0);\n             if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // is this even legal call?\n        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n            return null;\n        }\n        return ctxt.handleUnexpectedToken(_keyClass, JsonToken.VALUE_NULL, ctxt.parser(),\n                \"need JSON String that contains type id (for subtype of %s)\", baseTypeName());\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    // Check combinations of static/instance, name\n    if ((!_annotationIntrospector.hasCreatorAnnotation(am)) || !am.isStatic()) {\n        return false;\n    }\n    Class<?> returnType = am.getRawReturnType();\n    // for static factory methods, must return type compatible with the class itself\n    if (!getBeanClass().isAssignableFrom(returnType)) {\n        return false;\n    }\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (am.getParameterCount() != 1) {\n        return false;\n    }\n    final String name = am.getName();\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"valueOf\".equals(name) || \"fromString\".equals(name)) {\n        Class<?> paramType = am.getRawParameterType(0);\n        if (paramType == String.class || paramType == CharSequence.class) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -2,7 +2,11 @@\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n         // is this even legal call?\n-        return null;\n+        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+            return null;\n+        }\n+        return ctxt.handleUnexpectedToken(_keyClass, JsonToken.VALUE_NULL, ctxt.parser(),\n+                \"need JSON String that contains type id (for subtype of %s)\", baseTypeName());\n     }\n     try {\n         Object result = _parse(key, ctxt);\n@@ -16,4 +20,23 @@\n         return null;\n     }\n     return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+\n+## Fixed Function 2\n+@Override\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?> actualArgType = am.getRawParameterType(0);\n+            for (Class<?> expArgType : expArgTypes) {\n+                // And one that matches what we would pass in\n+                if (expArgType.isAssignableFrom(actualArgType)) {\n+                    return am.getAnnotated();\n+                }\n+            }\n+        }\n+    }\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,3 +1,27 @@\n+@Override\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // is this even legal call?\n+        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+            return null;\n+        }\n+        return ctxt.handleUnexpectedToken(_keyClass, JsonToken.VALUE_NULL, ctxt.parser(),\n+                \"need JSON String that contains type id (for subtype of %s)\", baseTypeName());\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n+        }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n+    }\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+\n+## Fixed Function 2\n @Override\n public Method findFactoryMethod(Class<?>... expArgTypes) {\n     // So, of all single-arg static methods:\n@@ -8,7 +32,7 @@\n             Class<?> actualArgType = am.getRawParameterType(0);\n             for (Class<?> expArgType : expArgTypes) {\n                 // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n+                if (expArgType.isAssignableFrom(actualArgType)) {\n                     return am.getAnnotated();\n                 }\n             }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,23 +1,23 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n-    if (!getBeanClass().isAssignableFrom(rt)) {\n+    // Check combinations of static/instance, name\n+    if ((!_annotationIntrospector.hasCreatorAnnotation(am)) || !am.isStatic()) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n-        return true;\n+    Class<?> returnType = am.getRawReturnType();\n+    // for static factory methods, must return type compatible with the class itself\n+    if (!getBeanClass().isAssignableFrom(returnType)) {\n+        return false;\n+    }\n+    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n+    if (am.getParameterCount() != 1) {\n+        return false;\n     }\n     final String name = am.getName();\n-    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n-    if (\"valueOf\".equals(name)) {\n-        return true;\n-    }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n-    if (\"fromString\".equals(name)) {\n-        if (am.getParameterCount() == 1) {\n-            Class<?> cls = am.getRawParameterType(0);\n-            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n-                return true;\n-            }\n+    if (\"valueOf\".equals(name) || \"fromString\".equals(name)) {\n+        Class<?> paramType = am.getRawParameterType(0);\n+        if (paramType == String.class || paramType == CharSequence.class) {\n+            return true;\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // is this even legal call?\n        return ctxt.handleNullKey(_keyClass);\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am) && am.getParameterCount() == 1) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (actualArgType.isAssignableFrom(expArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name) || \"fromString\".equals(name)) {\n        return true;\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -2,7 +2,7 @@\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n         // is this even legal call?\n-        return null;\n+        return ctxt.handleNullKey(_keyClass);\n     }\n     try {\n         Object result = _parse(key, ctxt);\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,19 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // is this even legal call?\n+        return ctxt.handleNullKey(_keyClass);\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,24 +1,15 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n-    if (\"valueOf\".equals(name)) {\n+    if (\"valueOf\".equals(name) || \"fromString\".equals(name)) {\n         return true;\n-    }\n-    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n-    if (\"fromString\".equals(name)) {\n-        if (am.getParameterCount() == 1) {\n-            Class<?> cls = am.getRawParameterType(0);\n-            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n-                return true;\n-            }\n-        }\n     }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        return ctxt.handleNullKey();\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name)) {\n        return (am.getParameterCount() == 1);\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,8 +1,7 @@\n @Override\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n-        // is this even legal call?\n-        return null;\n+        return ctxt.handleNullKey();\n     }\n     try {\n         Object result = _parse(key, ctxt);\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,18 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        return ctxt.handleNullKey();\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,15 +1,15 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n     if (\"valueOf\".equals(name)) {\n-        return true;\n+        return (am.getParameterCount() == 1);\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n     if (\"fromString\".equals(name)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        return ctxt.handleUnexpectedToken(_keyClass, \"null key found\", null);\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name)) {\n        return (am.getParameterCount() == 1);\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,8 +1,7 @@\n @Override\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n-        // is this even legal call?\n-        return null;\n+        return ctxt.handleUnexpectedToken(_keyClass, \"null key found\", null);\n     }\n     try {\n         Object result = _parse(key, ctxt);\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,18 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        return ctxt.handleUnexpectedToken(_keyClass, \"null key found\", null);\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,15 +1,15 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n     if (\"valueOf\".equals(name)) {\n-        return true;\n+        return (am.getParameterCount() == 1);\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n     if (\"fromString\".equals(name)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        return ctxt.handleNullKey(_keyClass);\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        if (am.getParameterCount() == 1) { // Ensure it only takes 1 arg\n            // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n            if (isFactoryMethod(am)) {\n                // And must take one of expected arg types (or supertype)\n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name) || \"fromString\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,8 +1,7 @@\n @Override\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n-        // is this even legal call?\n-        return null;\n+        return ctxt.handleNullKey(_keyClass);\n     }\n     try {\n         Object result = _parse(key, ctxt);\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,18 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        return ctxt.handleNullKey(_keyClass);\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,18 +1,14 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n+    Class<?> rt = am.getRawReturnType();\n     if (!getBeanClass().isAssignableFrom(rt)) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n-    if (\"valueOf\".equals(name)) {\n-        return true;\n-    }\n-    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n-    if (\"fromString\".equals(name)) {\n+    if (\"valueOf\".equals(name) || \"fromString\".equals(name)) {\n         if (am.getParameterCount() == 1) {\n             Class<?> cls = am.getRawParameterType(0);\n             if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // is this even legal call?\n        return null;\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", key);\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n    Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt) && !rt.isAssignableFrom(getBeanClass())) {\n        return false;\n    }\n    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name)) {\n        return true;\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -15,5 +15,5 @@\n     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n         return null;\n     }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", key);\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,19 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // is this even legal call?\n+        return null;\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", key);\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -1,9 +1,9 @@\n protected boolean isFactoryMethod(AnnotatedMethod am) {\n-        Class<?> rt = am.getRawReturnType();\n-    if (!getBeanClass().isAssignableFrom(rt)) {\n+    Class<?> rt = am.getRawReturnType();\n+    if (!getBeanClass().isAssignableFrom(rt) && !rt.isAssignableFrom(getBeanClass())) {\n         return false;\n     }\n-        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+    if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n         return true;\n     }\n     final String name = am.getName();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // is this even legal call?\n        return ctxt.handleUnexpectedToken(_keyClass, ctxt.parser.currentToken(), ctxt.parser.currentTokenAsString(), \"null key string\");\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\", (Object[])null);\n}\n\n## Fixed Function 2\n@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\nprotected boolean isFactoryMethod(AnnotatedMethod am) {\n        Class<?> rt = am.getRawReturnType();\n    if (!getBeanClass().isAssignableFrom(rt)) {\n        return false;\n    }\n        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n        return true;\n    }\n    final String name = am.getName();\n    // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n    if (\"valueOf\".equals(name) && am.getParameterCount() == 1) {\n        return true;\n    }\n    // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n    if (\"fromString\".equals(name)) {\n        if (am.getParameterCount() == 1) {\n            Class<?> cls = am.getRawParameterType(0);\n            if (cls == String.class || CharSequence.class.isAssignableFrom(cls)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -2,7 +2,7 @@\n public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n     if (key == null) {\n         // is this even legal call?\n-        return null;\n+        return ctxt.handleUnexpectedToken(_keyClass, ctxt.parser.currentToken(), ctxt.parser.currentTokenAsString(), \"null key string\");\n     }\n     try {\n         Object result = _parse(key, ctxt);\n@@ -15,5 +15,5 @@\n     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n         return null;\n     }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\", (Object[])null);\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -1,18 +1,19 @@\n @Override\n-public Method findFactoryMethod(Class<?>... expArgTypes) {\n-    // So, of all single-arg static methods:\n-    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n-            // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n-            }\n+public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+    if (key == null) {\n+        // is this even legal call?\n+        return ctxt.handleUnexpectedToken(_keyClass, ctxt.parser.currentToken(), ctxt.parser.currentTokenAsString(), \"null key string\");\n+    }\n+    try {\n+        Object result = _parse(key, ctxt);\n+        if (result != null) {\n+            return result;\n         }\n+    } catch (Exception re) {\n+        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n     }\n-    return null;\n+    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        return null;\n+    }\n+    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\", (Object[])null);\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@isFactoryMethod\n@@ -8,7 +8,7 @@\n     }\n     final String name = am.getName();\n     // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n-    if (\"valueOf\".equals(name)) {\n+    if (\"valueOf\".equals(name) && am.getParameterCount() == 1) {\n         return true;\n     }\n     // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n", "finish_reason": "stop", "valid": false, "num": 1}]