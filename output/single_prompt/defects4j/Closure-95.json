[{"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        // Fixed checkArgument to allow LPAREN, OBJECTLIT, ARRAYLIT, CALL nodes as parents\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST ||\n                                    parent.getType() == Token.PARAM_LIST || parent.getType() == Token.LP ||\n                                    parent.getType() == Token.OBJECTLIT || parent.getType() == Token.ARRAYLIT || parent.getType() == Token.CALL ||\n                                    parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -3,7 +3,11 @@\n     // Only allow declarations of NAMEs and qualfied names.\n     boolean shouldDeclareOnGlobalThis = false;\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n+        // Fixed checkArgument to allow LPAREN, OBJECTLIT, ARRAYLIT, CALL nodes as parents\n+        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST ||\n+                                    parent.getType() == Token.PARAM_LIST || parent.getType() == Token.LP ||\n+                                    parent.getType() == Token.OBJECTLIT || parent.getType() == Token.ARRAYLIT || parent.getType() == Token.CALL ||\n+                                    parent.getType() == Token.CATCH);\n         shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && parent.getType() == Token.VAR;\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope.getParent();\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    Var oldVar = scopeToDeclareIn.getVar(variableName);\n    if (oldVar != null && !oldVar.isBleedingFunction()) {\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type, inferred);\n    } else {\n        Node enclosingBlock = NodeUtil.getEnclosingNode(n, new NodeUtil.MatchPredicate() {\n            @Override\n            public boolean evaluate(Node n) {\n                return n.isBlock() || n.isScript();\n            }\n        });\n        // ES6 14.3.2 - Creating Identifiers as Binding Names at Function Declaration Instantiation Time\n        // Handle cases where a parent block (let/const/function) needs to be created\n        if (enclosingBlock.isScript()) {\n            // If we're in the global scope, only declare a global let/const if it has not\n            // already been declared and its types are not inferred.\n            if (!scopeToDeclareIn.isDeclared(variableName, false) && (parent.getType() == Token.LET || parent.getType() == Token.CONST) && !inferred) {\n                parent.removeChildren();\n                parent.addChildToFront(IR.name(variableName).useSourceInfoFrom(n));\n                parent.addChildToBack(n);\n                Node exprResult = parent.getParent();\n                Node block = exprResult.getParent();\n                Node let = NodeUtil.newVarNode(parent.detachChildren());\n                let.useSourceInfoFrom(parent);\n                block.addChildToFront(let);\n                scopeToDeclareIn.declare(variableName, let.getFirstChild(), type, compiler.getInput(sourceName), false, inferred);\n                return;\n            }\n        } else if (!scopeToDeclareIn.isDeclared(variableName, true)) {\n            if ((parent.getType() == Token.LET || parent.getType() == Token.CONST) && !inferred) {\n                if (scope.getVar(variableName) != null) {\n                    validator.error(\"Identifier \" + variableName + \" has already been declared\");\n                    return;\n                }\n                // Add a new block to the parent\n                Node newBlock = IR.block();\n                newBlock.useSourceInfoFrom(n);\n                Node blockNode = newBlock;\n                for (int i = 0; i < 2; i++) {\n                    Node newBlockParent = NodeUtil.getEnclosingNode(blockNode, new NodeUtil.MatchPredicate() {\n                        @Override\n                        public boolean evaluate(Node n) {\n                            return n.isFunction() || n.isBlock() || n.isScript();\n                        }\n                    }).getParent();\n                    Node innerBlock = IR.block(newBlock);\n                    innerBlock.useSourceInfoFrom(newBlock);\n                    Node stmtNode;\n                    if (i == 0) {\n                        stmtNode = NodeUtil.newVarNode(parent.detachChildren());\n                    } else {\n                        stmtNode = NodeUtil.newExpr(parent.detachChildren());\n                    }\n                    stmtNode.useSourceInfoFrom(n);\n                    innerBlock.addChildToBack(stmtNode);\n                    newBlockParent.addChildBefore(innerBlock, blockNode);\n                    blockNode = innerBlock;\n                }\n                scopeToDeclareIn = scopeToDeclareIn.getClosestHoistScope();\n                scopeToDeclareIn.declare(variableName, parent, type, compiler.getInput(sourceName), true, inferred);\n                return;\n            } else if (!inferred) {\n                // If variable names are inferred, they cannot be added to the closest HoistScope.\n                scopeToDeclareIn.declare(variableName, n, type, compiler.getInput(sourceName), false, inferred);\n            } else {\n                // Inferred types are always declared\n                setDeferredType(n, type);\n                scopeToDeclareIn.declare(variableName, n, type, compiler.getInput(sourceName), false, inferred);\n            }\n        }\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = compiler.getInput(sourceName).isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor == null\n                        || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -3,32 +3,91 @@\n     // Only allow declarations of NAMEs and qualfied names.\n     boolean shouldDeclareOnGlobalThis = false;\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n-        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n+        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n+        shouldDeclareOnGlobalThis = scope.isGlobal() && parent.getType() == Token.VAR;\n     } else {\n         Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n-    Scope scopeToDeclareIn = scope;\n+    Scope scopeToDeclareIn = scope.getParent();\n     // don't try to declare in the global scope if there's\n     // already a symbol there with this name.\n-    // declared in closest scope?\n-    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n-        Var oldVar = scopeToDeclareIn.getVar(variableName);\n-        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n+    Var oldVar = scopeToDeclareIn.getVar(variableName);\n+    if (oldVar != null && !oldVar.isBleedingFunction()) {\n+        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type, inferred);\n     } else {\n-        if (!inferred) {\n-            setDeferredType(n, type);\n+        Node enclosingBlock = NodeUtil.getEnclosingNode(n, new NodeUtil.MatchPredicate() {\n+            @Override\n+            public boolean evaluate(Node n) {\n+                return n.isBlock() || n.isScript();\n+            }\n+        });\n+        // ES6 14.3.2 - Creating Identifiers as Binding Names at Function Declaration Instantiation Time\n+        // Handle cases where a parent block (let/const/function) needs to be created\n+        if (enclosingBlock.isScript()) {\n+            // If we're in the global scope, only declare a global let/const if it has not\n+            // already been declared and its types are not inferred.\n+            if (!scopeToDeclareIn.isDeclared(variableName, false) && (parent.getType() == Token.LET || parent.getType() == Token.CONST) && !inferred) {\n+                parent.removeChildren();\n+                parent.addChildToFront(IR.name(variableName).useSourceInfoFrom(n));\n+                parent.addChildToBack(n);\n+                Node exprResult = parent.getParent();\n+                Node block = exprResult.getParent();\n+                Node let = NodeUtil.newVarNode(parent.detachChildren());\n+                let.useSourceInfoFrom(parent);\n+                block.addChildToFront(let);\n+                scopeToDeclareIn.declare(variableName, let.getFirstChild(), type, compiler.getInput(sourceName), false, inferred);\n+                return;\n+            }\n+        } else if (!scopeToDeclareIn.isDeclared(variableName, true)) {\n+            if ((parent.getType() == Token.LET || parent.getType() == Token.CONST) && !inferred) {\n+                if (scope.getVar(variableName) != null) {\n+                    validator.error(\"Identifier \" + variableName + \" has already been declared\");\n+                    return;\n+                }\n+                // Add a new block to the parent\n+                Node newBlock = IR.block();\n+                newBlock.useSourceInfoFrom(n);\n+                Node blockNode = newBlock;\n+                for (int i = 0; i < 2; i++) {\n+                    Node newBlockParent = NodeUtil.getEnclosingNode(blockNode, new NodeUtil.MatchPredicate() {\n+                        @Override\n+                        public boolean evaluate(Node n) {\n+                            return n.isFunction() || n.isBlock() || n.isScript();\n+                        }\n+                    }).getParent();\n+                    Node innerBlock = IR.block(newBlock);\n+                    innerBlock.useSourceInfoFrom(newBlock);\n+                    Node stmtNode;\n+                    if (i == 0) {\n+                        stmtNode = NodeUtil.newVarNode(parent.detachChildren());\n+                    } else {\n+                        stmtNode = NodeUtil.newExpr(parent.detachChildren());\n+                    }\n+                    stmtNode.useSourceInfoFrom(n);\n+                    innerBlock.addChildToBack(stmtNode);\n+                    newBlockParent.addChildBefore(innerBlock, blockNode);\n+                    blockNode = innerBlock;\n+                }\n+                scopeToDeclareIn = scopeToDeclareIn.getClosestHoistScope();\n+                scopeToDeclareIn.declare(variableName, parent, type, compiler.getInput(sourceName), true, inferred);\n+                return;\n+            } else if (!inferred) {\n+                // If variable names are inferred, they cannot be added to the closest HoistScope.\n+                scopeToDeclareIn.declare(variableName, n, type, compiler.getInput(sourceName), false, inferred);\n+            } else {\n+                // Inferred types are always declared\n+                setDeferredType(n, type);\n+                scopeToDeclareIn.declare(variableName, n, type, compiler.getInput(sourceName), false, inferred);\n+            }\n         }\n-        CompilerInput input = compiler.getInput(sourceName);\n-        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n         if (shouldDeclareOnGlobalThis) {\n             ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n-            boolean isExtern = input.isExtern();\n+            boolean isExtern = compiler.getInput(sourceName).isExtern();\n             if (inferred) {\n                 globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n             } else {\n@@ -41,8 +100,8 @@\n             FunctionType fnType = (FunctionType) type;\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor == null\n+                        || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            JSType declaredType = (type == null) ? getNativeType(JSTypeNative.NO_TYPE) : type;\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, declaredType, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, declaredType, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                boolean declared = superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE));\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, declared);\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -9,7 +9,7 @@\n         Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n@@ -29,10 +29,11 @@\n         if (shouldDeclareOnGlobalThis) {\n             ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n             boolean isExtern = input.isExtern();\n+            JSType declaredType = (type == null) ? getNativeType(JSTypeNative.NO_TYPE) : type;\n             if (inferred) {\n-                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n+                globalThis.defineInferredProperty(variableName, declaredType, isExtern);\n             } else {\n-                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n+                globalThis.defineDeclaredProperty(variableName, declaredType, isExtern);\n             }\n         }\n         // If we're in the global scope, also declare var.prototype\n@@ -41,8 +42,8 @@\n             FunctionType fnType = (FunctionType) type;\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                boolean declared = superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE));\n+                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, declared);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualified names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(\n                parent.getType() == Token.FUNCTION ||\n                        parent.getType() == Token.VAR ||\n                        parent.getType() == Token.LET ||\n                        parent.getType() == Token.CONST ||\n                        parent.getParent().getType() == Token.FOR ||\n                        parent.getParent().getType() == Token.FOR_OF ||\n                        parent.getParent().getType() == Token.FOR_AWAIT_OF ||\n                        parent.getParent().getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis =\n                scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        // Allow access to properties on functions for creating a higher-order function.\n        Node root = n.getFirstChild();\n        if (root != null && root.getType() == Token.NAME && scope.isDeclared(root.getString(), true)) {\n            Node rootParent = root.getParent();\n            shouldDeclareOnGlobalThis = rootParent.getType() == Token.FUNCTION && n.getType() == Token.GETPROP;\n        } else {\n            Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n        }\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    // If n is a property, then we should really declare it in the scope where the root object appears. This helps out people who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope.getScope(variableName);\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(\n                        variableName + \".prototype\",\n                        n,\n                        fnType.getPrototype(),\n                        compiler.getInput(sourceName),\n                        /* declared iff there's an explicit supertype */\n                        superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -1,22 +1,33 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type != null);\n-    // Only allow declarations of NAMEs and qualfied names.\n+    // Only allow declarations of NAMEs and qualified names.\n     boolean shouldDeclareOnGlobalThis = false;\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n-        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n+        Preconditions.checkArgument(\n+                parent.getType() == Token.FUNCTION ||\n+                        parent.getType() == Token.VAR ||\n+                        parent.getType() == Token.LET ||\n+                        parent.getType() == Token.CONST ||\n+                        parent.getParent().getType() == Token.FOR ||\n+                        parent.getParent().getType() == Token.FOR_OF ||\n+                        parent.getParent().getType() == Token.FOR_AWAIT_OF ||\n+                        parent.getParent().getType() == Token.CATCH);\n+        shouldDeclareOnGlobalThis =\n+                scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n     } else {\n-        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n+        // Allow access to properties on functions for creating a higher-order function.\n+        Node root = n.getFirstChild();\n+        if (root != null && root.getType() == Token.NAME && scope.isDeclared(root.getString(), true)) {\n+            Node rootParent = root.getParent();\n+            shouldDeclareOnGlobalThis = rootParent.getType() == Token.FUNCTION && n.getType() == Token.GETPROP;\n+        } else {\n+            Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n+        }\n     }\n     String variableName = n.getQualifiedName();\n     Preconditions.checkArgument(!variableName.isEmpty());\n-    // If n is a property, then we should really declare it in the\n-    // scope where the root object appears. This helps out people\n-    // who declare \"global\" names in an anonymous namespace.\n-    Scope scopeToDeclareIn = scope;\n-    // don't try to declare in the global scope if there's\n-    // already a symbol there with this name.\n-    // declared in closest scope?\n+    // If n is a property, then we should really declare it in the scope where the root object appears. This helps out people who declare \"global\" names in an anonymous namespace.\n+    Scope scopeToDeclareIn = scope.getScope(variableName);\n     if (scopeToDeclareIn.isDeclared(variableName, false)) {\n         Var oldVar = scopeToDeclareIn.getVar(variableName);\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n@@ -35,14 +46,18 @@\n                 globalThis.defineDeclaredProperty(variableName, type, isExtern);\n             }\n         }\n-        // If we're in the global scope, also declare var.prototype\n-        // in the scope chain.\n+        // If we're in the global scope, also declare var.prototype in the scope chain.\n         if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n             FunctionType fnType = (FunctionType) type;\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                scopeToDeclareIn.declare(\n+                        variableName + \".prototype\",\n+                        n,\n+                        fnType.getPrototype(),\n+                        compiler.getInput(sourceName),\n+                        /* declared iff there's an explicit supertype */\n+                        superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scope.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            boolean isDeclared = !inferred;\n            if (!isDeclared) {\n                isDeclared = typeRegistry.getExpressionType(n) != null;\n            }\n            Property prop =\n                ObjectType.getPropertyWithGlobalFallback(\n                    globalThis, variableName, isDeclared, isExtern);\n            JSType propType =\n                inferred ? (type == null ? getNativeType(JSTypeNative.NO_TYPE) : type) : typeRegistry.getExpressionType(n);\n            propType = ObjectType.mayExcludeReceiver(propType);\n            ObjectType.setProperty(prop, propType, input, inferred);\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -3,13 +3,13 @@\n     // Only allow declarations of NAMEs and qualfied names.\n     boolean shouldDeclareOnGlobalThis = false;\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n+        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n         shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n@@ -18,7 +18,7 @@\n     // already a symbol there with this name.\n     // declared in closest scope?\n     if (scopeToDeclareIn.isDeclared(variableName, false)) {\n-        Var oldVar = scopeToDeclareIn.getVar(variableName);\n+        Var oldVar = scope.getVar(variableName);\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n     } else {\n         if (!inferred) {\n@@ -29,11 +29,17 @@\n         if (shouldDeclareOnGlobalThis) {\n             ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n             boolean isExtern = input.isExtern();\n-            if (inferred) {\n-                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n-            } else {\n-                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n+            boolean isDeclared = !inferred;\n+            if (!isDeclared) {\n+                isDeclared = typeRegistry.getExpressionType(n) != null;\n             }\n+            Property prop =\n+                ObjectType.getPropertyWithGlobalFallback(\n+                    globalThis, variableName, isDeclared, isExtern);\n+            JSType propType =\n+                inferred ? (type == null ? getNativeType(JSTypeNative.NO_TYPE) : type) : typeRegistry.getExpressionType(n);\n+            propType = ObjectType.mayExcludeReceiver(propType);\n+            ObjectType.setProperty(prop, propType, input, inferred);\n         }\n         // If we're in the global scope, also declare var.prototype\n         // in the scope chain.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty(), \"Empty variable name\");\n\n    if (n.getType() == Token.NAME) {\n        // Only allow declarations of NAMEs and qualified names.\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH || parent.getType() == Token.PARAM_LIST,\n                                    \"Invalid parent node type for NAME %s\", variableName);\n\n        // Only allow \"var\" declarations in the global scope\n        boolean shouldDeclareOnGlobalThis = false;\n        if (scope.isGlobal() && (parent.getType() == Token.VAR)) {\n            shouldDeclareOnGlobalThis = true;\n        }\n        \n        ObjectType globalThis = null;\n        if (shouldDeclareOnGlobalThis) {\n            globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n        }\n\n        // Check if the variable is already declared in the current scope\n        if (scope.isDeclared(variableName, false)) {\n            Var oldVar = scope.getVar(variableName);\n            validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n        } else {\n            // Declare the variable in the current scope\n            scope.declare(variableName, n, type, compiler.getInput(sourceName), inferred);\n\n            if (shouldDeclareOnGlobalThis) {\n                // Declare the variable also on the global \"this\" object\n                boolean isExtern = compiler.getInput(sourceName).isExtern();\n                if (inferred) {\n                    globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n                } else {\n                    globalThis.defineDeclaredProperty(variableName, type, isExtern);\n                }\n            }\n\n            // If we're in the global scope, also declare var.prototype in the scope chain for constructor functions\n            if (scope.isGlobal() && type instanceof FunctionType) {\n                FunctionType fnType = (FunctionType) type;\n                if (fnType.isConstructor() || fnType.isInterface()) {\n                    FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                    scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n                }\n            }\n        }\n\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n    } else if (n.getType() == Token.GETPROP) {\n        Preconditions.checkArgument(parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT,\n                                    \"Invalid parent node type for GETPROP %s\", variableName);\n        // Validate properties access\n        Preconditions.checkState(\n            !scope.isDeclared(variableName, true),\n            \"Getprop access to undeclared variable %s (inferred=%s)\", variableName, String.valueOf(inferred)\n        );\n    } else {\n        throw new IllegalStateException(\"Unexpected variable type: \" + Token.name(n.getType()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -1,49 +1,63 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n-    Preconditions.checkArgument(inferred || type != null);\n-    // Only allow declarations of NAMEs and qualfied names.\n-    boolean shouldDeclareOnGlobalThis = false;\n+    String variableName = n.getQualifiedName();\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty(), \"Empty variable name\");\n+\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n-        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n-    } else {\n-        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n-    }\n-    String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n-    // If n is a property, then we should really declare it in the\n-    // scope where the root object appears. This helps out people\n-    // who declare \"global\" names in an anonymous namespace.\n-    Scope scopeToDeclareIn = scope;\n-    // don't try to declare in the global scope if there's\n-    // already a symbol there with this name.\n-    // declared in closest scope?\n-    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n-        Var oldVar = scopeToDeclareIn.getVar(variableName);\n-        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n-    } else {\n+        // Only allow declarations of NAMEs and qualified names.\n+        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH || parent.getType() == Token.PARAM_LIST,\n+                                    \"Invalid parent node type for NAME %s\", variableName);\n+\n+        // Only allow \"var\" declarations in the global scope\n+        boolean shouldDeclareOnGlobalThis = false;\n+        if (scope.isGlobal() && (parent.getType() == Token.VAR)) {\n+            shouldDeclareOnGlobalThis = true;\n+        }\n+        \n+        ObjectType globalThis = null;\n+        if (shouldDeclareOnGlobalThis) {\n+            globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n+        }\n+\n+        // Check if the variable is already declared in the current scope\n+        if (scope.isDeclared(variableName, false)) {\n+            Var oldVar = scope.getVar(variableName);\n+            validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n+        } else {\n+            // Declare the variable in the current scope\n+            scope.declare(variableName, n, type, compiler.getInput(sourceName), inferred);\n+\n+            if (shouldDeclareOnGlobalThis) {\n+                // Declare the variable also on the global \"this\" object\n+                boolean isExtern = compiler.getInput(sourceName).isExtern();\n+                if (inferred) {\n+                    globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n+                } else {\n+                    globalThis.defineDeclaredProperty(variableName, type, isExtern);\n+                }\n+            }\n+\n+            // If we're in the global scope, also declare var.prototype in the scope chain for constructor functions\n+            if (scope.isGlobal() && type instanceof FunctionType) {\n+                FunctionType fnType = (FunctionType) type;\n+                if (fnType.isConstructor() || fnType.isInterface()) {\n+                    FunctionType superClassCtor = fnType.getSuperClassConstructor();\n+                    scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                }\n+            }\n+        }\n+\n         if (!inferred) {\n             setDeferredType(n, type);\n         }\n-        CompilerInput input = compiler.getInput(sourceName);\n-        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n-        if (shouldDeclareOnGlobalThis) {\n-            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n-            boolean isExtern = input.isExtern();\n-            if (inferred) {\n-                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n-            } else {\n-                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n-            }\n-        }\n-        // If we're in the global scope, also declare var.prototype\n-        // in the scope chain.\n-        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n-            FunctionType fnType = (FunctionType) type;\n-            if (fnType.isConstructor() || fnType.isInterface()) {\n-                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n-            }\n-        }\n+    } else if (n.getType() == Token.GETPROP) {\n+        Preconditions.checkArgument(parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT,\n+                                    \"Invalid parent node type for GETPROP %s\", variableName);\n+        // Validate properties access\n+        Preconditions.checkState(\n+            !scope.isDeclared(variableName, true),\n+            \"Getprop access to undeclared variable %s (inferred=%s)\", variableName, String.valueOf(inferred)\n+        );\n+    } else {\n+        throw new IllegalStateException(\"Unexpected variable type: \" + Token.name(n.getType()));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // Check if the variable is already declared.\n    Var oldVar = scopeToDeclareIn.getOwnSlot(variableName);\n    if (oldVar != null) {\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        // Declare the variable in the current scope and set its type.\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -3,24 +3,23 @@\n     // Only allow declarations of NAMEs and qualfied names.\n     boolean shouldDeclareOnGlobalThis = false;\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n+        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n         shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n     Scope scopeToDeclareIn = scope;\n-    // don't try to declare in the global scope if there's\n-    // already a symbol there with this name.\n-    // declared in closest scope?\n-    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n-        Var oldVar = scopeToDeclareIn.getVar(variableName);\n+    // Check if the variable is already declared.\n+    Var oldVar = scopeToDeclareIn.getOwnSlot(variableName);\n+    if (oldVar != null) {\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n     } else {\n+        // Declare the variable in the current scope and set its type.\n         if (!inferred) {\n             setDeferredType(n, type);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualified names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.isName()) {\n        Preconditions.checkArgument(parent.isFunction() || parent.isVar() || parent.isParamList() || parent.isCatch());\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.isVar() || parent.isFunction());\n    } else {\n        Preconditions.checkArgument(n.isGetProp() && (parent.isAssign() || parent.isExprResult()));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope.getClosestHoistScope();\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                    superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -1,19 +1,19 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type != null);\n-    // Only allow declarations of NAMEs and qualfied names.\n+    // Only allow declarations of NAMEs and qualified names.\n     boolean shouldDeclareOnGlobalThis = false;\n-    if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n-        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n+    if (n.isName()) {\n+        Preconditions.checkArgument(parent.isFunction() || parent.isVar() || parent.isParamList() || parent.isCatch());\n+        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.isVar() || parent.isFunction());\n     } else {\n-        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n+        Preconditions.checkArgument(n.isGetProp() && (parent.isAssign() || parent.isExprResult()));\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n-    Scope scopeToDeclareIn = scope;\n+    Scope scopeToDeclareIn = scope.getClosestHoistScope();\n     // don't try to declare in the global scope if there's\n     // already a symbol there with this name.\n     // declared in closest scope?\n@@ -42,7 +42,7 @@\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                 scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                    superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)));\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualified names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, true)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -1,15 +1,15 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type != null);\n-    // Only allow declarations of NAMEs and qualfied names.\n+    // Only allow declarations of NAMEs and qualified names.\n     boolean shouldDeclareOnGlobalThis = false;\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n+        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n         shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n@@ -17,7 +17,7 @@\n     // don't try to declare in the global scope if there's\n     // already a symbol there with this name.\n     // declared in closest scope?\n-    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n+    if (scopeToDeclareIn.isDeclared(variableName, true)) {\n         Var oldVar = scopeToDeclareIn.getVar(variableName);\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    int parentType = parent.getType();\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parentType == Token.FUNCTION || parentType == Token.VAR || parentType == Token.LET || parentType == Token.CONST || parentType == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parentType == Token.VAR || parentType == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parentType == Token.ASSIGN || parentType == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope.getClosestHoistScope();\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scope.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                ObjectType instanceType = fnType.getInstanceType();\n                boolean isImplicitProtoAlias = n.matchesQualifiedName(\"prototype\") && !inferred;\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, instanceType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                superClassCtor == null || instanceType.equals(getNativeType(OBJECT_TYPE)) || isImplicitProtoAlias);\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -2,18 +2,19 @@\n     Preconditions.checkArgument(inferred || type != null);\n     // Only allow declarations of NAMEs and qualfied names.\n     boolean shouldDeclareOnGlobalThis = false;\n+    int parentType = parent.getType();\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n-        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n+        Preconditions.checkArgument(parentType == Token.FUNCTION || parentType == Token.VAR || parentType == Token.LET || parentType == Token.CONST || parentType == Token.CATCH);\n+        shouldDeclareOnGlobalThis = scope.isGlobal() && (parentType == Token.VAR || parentType == Token.FUNCTION);\n     } else {\n-        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n+        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parentType == Token.ASSIGN || parentType == Token.EXPR_RESULT));\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n-    Scope scopeToDeclareIn = scope;\n+    Scope scopeToDeclareIn = scope.getClosestHoistScope();\n     // don't try to declare in the global scope if there's\n     // already a symbol there with this name.\n     // declared in closest scope?\n@@ -37,12 +38,14 @@\n         }\n         // If we're in the global scope, also declare var.prototype\n         // in the scope chain.\n-        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n+        if (scope.isGlobal() && type instanceof FunctionType) {\n             FunctionType fnType = (FunctionType) type;\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                ObjectType instanceType = fnType.getInstanceType();\n+                boolean isImplicitProtoAlias = n.matchesQualifiedName(\"prototype\") && !inferred;\n+                scopeToDeclareIn.declare(variableName + \".prototype\", n, instanceType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n+                superClassCtor == null || instanceType.equals(getNativeType(OBJECT_TYPE)) || isImplicitProtoAlias);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkNotNull(type);\n    Preconditions.checkArgument(!n.matchesQualifiedName(\"prototype\"), \"Cannot redefine prototype\");\n    boolean isGlobalDeclaration = n.matchesQualifiedName(\"this\");\n    if (isGlobalDeclaration) {\n        Preconditions.checkArgument(scope.isGlobal(), \"'this' should be declared only in the global scope\");\n    }\n    boolean isNameDeclaration = (n.getType() == Token.NAME);\n    boolean isQualifiedDeclaration = (n.getType() == Token.GETPROP);\n    Preconditions.checkArgument(isNameDeclaration || isQualifiedDeclaration, \"Invalid lvalue\");\n    if (isQualifiedDeclaration && parent.getType() == Token.ASSIGN) {\n        Node rhs = parent.getLastChild();\n        if (rhs.getType() == Token.FUNCTION && rhs.getFirstChild().matchesQualifiedName(\"prototype\")) {\n            // Make sure we are assigning to a class's prototype.\n            setDeferredType(n, getNativeType(OBJECT_TYPE));\n        }\n    }\n    boolean shouldDeclareOnGlobalThis = isGlobalDeclaration && isNameDeclaration;\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty(), \"Name is empty\");\n    if (inferred) {\n        setDeferredType(n, type);\n    }\n    CompilerInput input = compiler.getInput(sourceName);\n    if (isGlobalDeclaration) {\n        ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n        boolean isExtern = input.isExtern();\n        if (inferred) {\n            globalThis.defineInferredProperty(variableName, type, isExtern);\n        } else {\n            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n        }\n    }\n    // only declare variables in the global scope once\n    if (scope.isDeclared(variableName, false)) {\n        return;\n    }\n    if (shouldDeclareOnGlobalThis) {\n        // don't use getGlobalScope() because we may be in a FUNCTION scope\n        Scope globalScope = scope.getParent();\n        if (globalScope.isDeclared(variableName, false)) {\n            return;\n        }\n    }\n    if (isQualifiedDeclaration) {\n        // Declare the root of the qualified name so that\n        // passes such as createVars will create a variable\n        // for the entire chain.\n        Node root = n.getFirstChild();\n        String rootName = root.getQualifiedName(); \n        if (!rootName.isEmpty() && !rootName.equals(variableName)) {\n            Scope scopeToDeclareIn = scope.getClosestHoistScope().getGlobalScope();\n            scopeToDeclareIn.declare(rootName, n, getNativeType(OBJECT_TYPE), input, inferred);\n        }\n    }\n    scope.declare(variableName, n, type, input, inferred);\n    // Declare a prototype object for the function.\n    if (isNameDeclaration && type instanceof FunctionType) {\n        FunctionType functionType = (FunctionType) type;\n        if (functionType.isConstructor() || functionType.isInterface()) {\n            FunctionType superClassCtor = functionType.getSuperClassConstructor();\n            ObjectType prototypeType = functionType.getPrototype();\n            scope.declare(variableName + \".prototype\", n, prototypeType, input, superClassCtor == null\n                    || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -1,49 +1,67 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n-    Preconditions.checkArgument(inferred || type != null);\n-    // Only allow declarations of NAMEs and qualfied names.\n-    boolean shouldDeclareOnGlobalThis = false;\n-    if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n-        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n-    } else {\n-        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n+    Preconditions.checkNotNull(type);\n+    Preconditions.checkArgument(!n.matchesQualifiedName(\"prototype\"), \"Cannot redefine prototype\");\n+    boolean isGlobalDeclaration = n.matchesQualifiedName(\"this\");\n+    if (isGlobalDeclaration) {\n+        Preconditions.checkArgument(scope.isGlobal(), \"'this' should be declared only in the global scope\");\n     }\n+    boolean isNameDeclaration = (n.getType() == Token.NAME);\n+    boolean isQualifiedDeclaration = (n.getType() == Token.GETPROP);\n+    Preconditions.checkArgument(isNameDeclaration || isQualifiedDeclaration, \"Invalid lvalue\");\n+    if (isQualifiedDeclaration && parent.getType() == Token.ASSIGN) {\n+        Node rhs = parent.getLastChild();\n+        if (rhs.getType() == Token.FUNCTION && rhs.getFirstChild().matchesQualifiedName(\"prototype\")) {\n+            // Make sure we are assigning to a class's prototype.\n+            setDeferredType(n, getNativeType(OBJECT_TYPE));\n+        }\n+    }\n+    boolean shouldDeclareOnGlobalThis = isGlobalDeclaration && isNameDeclaration;\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n-    // If n is a property, then we should really declare it in the\n-    // scope where the root object appears. This helps out people\n-    // who declare \"global\" names in an anonymous namespace.\n-    Scope scopeToDeclareIn = scope;\n-    // don't try to declare in the global scope if there's\n-    // already a symbol there with this name.\n-    // declared in closest scope?\n-    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n-        Var oldVar = scopeToDeclareIn.getVar(variableName);\n-        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n-    } else {\n-        if (!inferred) {\n-            setDeferredType(n, type);\n+    Preconditions.checkArgument(!variableName.isEmpty(), \"Name is empty\");\n+    if (inferred) {\n+        setDeferredType(n, type);\n+    }\n+    CompilerInput input = compiler.getInput(sourceName);\n+    if (isGlobalDeclaration) {\n+        ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n+        boolean isExtern = input.isExtern();\n+        if (inferred) {\n+            globalThis.defineInferredProperty(variableName, type, isExtern);\n+        } else {\n+            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n         }\n-        CompilerInput input = compiler.getInput(sourceName);\n-        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n-        if (shouldDeclareOnGlobalThis) {\n-            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n-            boolean isExtern = input.isExtern();\n-            if (inferred) {\n-                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n-            } else {\n-                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n-            }\n+    }\n+    // only declare variables in the global scope once\n+    if (scope.isDeclared(variableName, false)) {\n+        return;\n+    }\n+    if (shouldDeclareOnGlobalThis) {\n+        // don't use getGlobalScope() because we may be in a FUNCTION scope\n+        Scope globalScope = scope.getParent();\n+        if (globalScope.isDeclared(variableName, false)) {\n+            return;\n         }\n-        // If we're in the global scope, also declare var.prototype\n-        // in the scope chain.\n-        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n-            FunctionType fnType = (FunctionType) type;\n-            if (fnType.isConstructor() || fnType.isInterface()) {\n-                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n-            }\n+    }\n+    if (isQualifiedDeclaration) {\n+        // Declare the root of the qualified name so that\n+        // passes such as createVars will create a variable\n+        // for the entire chain.\n+        Node root = n.getFirstChild();\n+        String rootName = root.getQualifiedName(); \n+        if (!rootName.isEmpty() && !rootName.equals(variableName)) {\n+            Scope scopeToDeclareIn = scope.getClosestHoistScope().getGlobalScope();\n+            scopeToDeclareIn.declare(rootName, n, getNativeType(OBJECT_TYPE), input, inferred);\n+        }\n+    }\n+    scope.declare(variableName, n, type, input, inferred);\n+    // Declare a prototype object for the function.\n+    if (isNameDeclaration && type instanceof FunctionType) {\n+        FunctionType functionType = (FunctionType) type;\n+        if (functionType.isConstructor() || functionType.isInterface()) {\n+            FunctionType superClassCtor = functionType.getSuperClassConstructor();\n+            ObjectType prototypeType = functionType.getPrototype();\n+            scope.declare(variableName + \".prototype\", n, prototypeType, input, superClassCtor == null\n+                    || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n         }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualified names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else if (n.getType() == Token.GETPROP) {\n        Preconditions.checkArgument(parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT);\n    } else {\n        throw new IllegalStateException(\"A name or qualified name is expected.\");\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -1,15 +1,17 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type != null);\n-    // Only allow declarations of NAMEs and qualfied names.\n+    // Only allow declarations of NAMEs and qualified names.\n     boolean shouldDeclareOnGlobalThis = false;\n     if (n.getType() == Token.NAME) {\n         Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n         shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n+    } else if (n.getType() == Token.GETPROP) {\n+        Preconditions.checkArgument(parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT);\n     } else {\n-        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n+        throw new IllegalStateException(\"A name or qualified name is expected.\");\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else if (n.getType() == Token.GETPROP) {\n        Preconditions.checkArgument(parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT);\n    } else {\n        throw new IllegalStateException(\"Unexpected node type: \" + n);\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -5,11 +5,13 @@\n     if (n.getType() == Token.NAME) {\n         Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n         shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n+    } else if (n.getType() == Token.GETPROP) {\n+        Preconditions.checkArgument(parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT);\n     } else {\n-        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n+        throw new IllegalStateException(\"Unexpected node type: \" + n);\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n@@ -42,7 +44,7 @@\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                 scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)));\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualified names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = n.isGetProp() ? scope.getVar(variableName).getScope() : scope;\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    if (!isBlockScope(parent.getType()) && scopeToDeclareIn.isDeclared(variableName, false) && !parent.isFunction()) {\n        validator.expectUndeclaredVariable(sourceName, n, parent, scopeToDeclareIn.getVar(variableName), variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), // declared iff there's an explicit supertype\n                        superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -1,25 +1,23 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type != null);\n-    // Only allow declarations of NAMEs and qualfied names.\n+    // Only allow declarations of NAMEs and qualified names.\n     boolean shouldDeclareOnGlobalThis = false;\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n-        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n+        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n+        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n-    Scope scopeToDeclareIn = scope;\n+    Scope scopeToDeclareIn = n.isGetProp() ? scope.getVar(variableName).getScope() : scope;\n     // don't try to declare in the global scope if there's\n     // already a symbol there with this name.\n-    // declared in closest scope?\n-    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n-        Var oldVar = scopeToDeclareIn.getVar(variableName);\n-        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n+    if (!isBlockScope(parent.getType()) && scopeToDeclareIn.isDeclared(variableName, false) && !parent.isFunction()) {\n+        validator.expectUndeclaredVariable(sourceName, n, parent, scopeToDeclareIn.getVar(variableName), variableName, type);\n     } else {\n         if (!inferred) {\n             setDeferredType(n, type);\n@@ -41,8 +39,8 @@\n             FunctionType fnType = (FunctionType) type;\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), // declared iff there's an explicit supertype\n+                        superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    boolean isName = false;\n    boolean isGetProp = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n        isName = true;\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else if (n.getType() == Token.GETPROP) {\n        Preconditions.checkArgument(parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT);\n        isGetProp = true;\n    } else {\n        Preconditions.checkArgument(false, \"illegal node type for LHS of assignment: %s\", n.getType());\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        if (isName) {\n            scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n            if (shouldDeclareOnGlobalThis) {\n                ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n                boolean isExtern = input.isExtern();\n                if (inferred) {\n                    globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n                } else {\n                    globalThis.defineDeclaredProperty(variableName, type, isExtern);\n                }\n            }\n            // If we're in the global scope, also declare var.prototype\n            // in the scope chain.\n            if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n                FunctionType fnType = (FunctionType) type;\n                if (fnType.isConstructor() || fnType.isInterface()) {\n                    FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                    scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                    superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n                }\n            }\n        } else if (isGetProp) {\n            Node obj = n.getFirstChild();\n            String propName = obj.getNext().getString();\n            TypeI objectType = determineType(obj);\n            ObjectType objType;\n            if (objectType != null) {\n                objectType = objectType.restrictByNotNullOrUndefined();\n            objType = objectType.autoboxElementTypeToNullableTypeIfSubclassOf(JSTypeNative.OBJECT_TYPE);\n            } else {\n                objType = typeRegistry.createAnonymousObjectType();\n            }\n            boolean isTemplateType = objType.hasReferenceToGenericType(propName);\n            if (isTemplateType) {\n                objType = objType.instantiateGenericsFromArgumentTypes(determineTypeStrict(parent).getTemplateTypes());\n            }\n            if (inferred) {\n                objType.defineInferredProperty(propName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, false);\n            } else {\n                objType.defineDeclaredProperty(propName, type, false);\n            }\n            ObjectType ownerType = null;\n            if (NodeUtil.mayHaveSideEffects(obj)) {\n                String tempVarName = scope.createTempName();\n                Node tempVar = IR.var(IR.name(tempVarName).setJSType(objType.toJSType()), obj.detach());\n                scopeToDeclareIn.declare(tempVarName, tempVar.getFirstChild(), objType.toJSType(), input, true);\n                obj = tempVar.getFirstChild();\n                ownerType = objectType == null ? objType : null;\n            }\n            Node newGetProp = IR.getprop(obj, propName);\n            newGetProp.setJSType(objType.getPropertyType(propName));\n            parent.replaceChild(n, newGetProp);\n            n = newGetProp;\n            if (ownerType != null) {\n                ownerType.defineDeclaredProperty(propName, n.getJSType(), false);\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -2,11 +2,17 @@\n     Preconditions.checkArgument(inferred || type != null);\n     // Only allow declarations of NAMEs and qualfied names.\n     boolean shouldDeclareOnGlobalThis = false;\n+    boolean isName = false;\n+    boolean isGetProp = false;\n     if (n.getType() == Token.NAME) {\n         Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n+        isName = true;\n         shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n+    } else if (n.getType() == Token.GETPROP) {\n+        Preconditions.checkArgument(parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT);\n+        isGetProp = true;\n     } else {\n-        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n+        Preconditions.checkArgument(false, \"illegal node type for LHS of assignment: %s\", n.getType());\n     }\n     String variableName = n.getQualifiedName();\n     Preconditions.checkArgument(!variableName.isEmpty());\n@@ -25,24 +31,61 @@\n             setDeferredType(n, type);\n         }\n         CompilerInput input = compiler.getInput(sourceName);\n-        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n-        if (shouldDeclareOnGlobalThis) {\n-            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n-            boolean isExtern = input.isExtern();\n+        if (isName) {\n+            scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n+            if (shouldDeclareOnGlobalThis) {\n+                ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n+                boolean isExtern = input.isExtern();\n+                if (inferred) {\n+                    globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n+                } else {\n+                    globalThis.defineDeclaredProperty(variableName, type, isExtern);\n+                }\n+            }\n+            // If we're in the global scope, also declare var.prototype\n+            // in the scope chain.\n+            if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n+                FunctionType fnType = (FunctionType) type;\n+                if (fnType.isConstructor() || fnType.isInterface()) {\n+                    FunctionType superClassCtor = fnType.getSuperClassConstructor();\n+                    scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n+                    superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                }\n+            }\n+        } else if (isGetProp) {\n+            Node obj = n.getFirstChild();\n+            String propName = obj.getNext().getString();\n+            TypeI objectType = determineType(obj);\n+            ObjectType objType;\n+            if (objectType != null) {\n+                objectType = objectType.restrictByNotNullOrUndefined();\n+            objType = objectType.autoboxElementTypeToNullableTypeIfSubclassOf(JSTypeNative.OBJECT_TYPE);\n+            } else {\n+                objType = typeRegistry.createAnonymousObjectType();\n+            }\n+            boolean isTemplateType = objType.hasReferenceToGenericType(propName);\n+            if (isTemplateType) {\n+                objType = objType.instantiateGenericsFromArgumentTypes(determineTypeStrict(parent).getTemplateTypes());\n+            }\n             if (inferred) {\n-                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n+                objType.defineInferredProperty(propName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, false);\n             } else {\n-                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n+                objType.defineDeclaredProperty(propName, type, false);\n             }\n-        }\n-        // If we're in the global scope, also declare var.prototype\n-        // in the scope chain.\n-        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n-            FunctionType fnType = (FunctionType) type;\n-            if (fnType.isConstructor() || fnType.isInterface()) {\n-                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+            ObjectType ownerType = null;\n+            if (NodeUtil.mayHaveSideEffects(obj)) {\n+                String tempVarName = scope.createTempName();\n+                Node tempVar = IR.var(IR.name(tempVarName).setJSType(objType.toJSType()), obj.detach());\n+                scopeToDeclareIn.declare(tempVarName, tempVar.getFirstChild(), objType.toJSType(), input, true);\n+                obj = tempVar.getFirstChild();\n+                ownerType = objectType == null ? objType : null;\n+            }\n+            Node newGetProp = IR.getprop(obj, propName);\n+            newGetProp.setJSType(objType.getPropertyType(propName));\n+            parent.replaceChild(n, newGetProp);\n+            n = newGetProp;\n+            if (ownerType != null) {\n+                ownerType.defineDeclaredProperty(propName, n.getJSType(), false);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope.getParentScope();\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -13,7 +13,7 @@\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n-    Scope scopeToDeclareIn = scope;\n+    Scope scopeToDeclareIn = scope.getParentScope();\n     // don't try to declare in the global scope if there's\n     // already a symbol there with this name.\n     // declared in closest scope?\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualified names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // Don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // Declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        boolean isDeclared = scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (!isDeclared) {\n            // Happens when the variable was declared as extern in the externs.\n            return;\n        }\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                        superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -1,22 +1,22 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type != null);\n-    // Only allow declarations of NAMEs and qualfied names.\n+    // Only allow declarations of NAMEs and qualified names.\n     boolean shouldDeclareOnGlobalThis = false;\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n+        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n         shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n     Scope scopeToDeclareIn = scope;\n-    // don't try to declare in the global scope if there's\n+    // Don't try to declare in the global scope if there's\n     // already a symbol there with this name.\n-    // declared in closest scope?\n+    // Declared in closest scope?\n     if (scopeToDeclareIn.isDeclared(variableName, false)) {\n         Var oldVar = scopeToDeclareIn.getVar(variableName);\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n@@ -25,7 +25,11 @@\n             setDeferredType(n, type);\n         }\n         CompilerInput input = compiler.getInput(sourceName);\n-        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n+        boolean isDeclared = scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n+        if (!isDeclared) {\n+            // Happens when the variable was declared as extern in the externs.\n+            return;\n+        }\n         if (shouldDeclareOnGlobalThis) {\n             ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n             boolean isExtern = input.isExtern();\n@@ -42,7 +46,7 @@\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                 scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                        superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)));\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualified names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.isName()) {\n        Preconditions.checkArgument(parent.isFunction() || parent.isVar() || parent.isParamList() || parent.isCatch());\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.isVar() || parent.isFunction());\n    } else {\n        Preconditions.checkArgument(n.isGetProp() && (parent.isAssign() || parent.isExprResult()));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope.getClosestHoistScope();\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scope.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -1,19 +1,19 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type != null);\n-    // Only allow declarations of NAMEs and qualfied names.\n+    // Only allow declarations of NAMEs and qualified names.\n     boolean shouldDeclareOnGlobalThis = false;\n-    if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n-        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n+    if (n.isName()) {\n+        Preconditions.checkArgument(parent.isFunction() || parent.isVar() || parent.isParamList() || parent.isCatch());\n+        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.isVar() || parent.isFunction());\n     } else {\n-        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n+        Preconditions.checkArgument(n.isGetProp() && (parent.isAssign() || parent.isExprResult()));\n     }\n     String variableName = n.getQualifiedName();\n     Preconditions.checkArgument(!variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n-    Scope scopeToDeclareIn = scope;\n+    Scope scopeToDeclareIn = scope.getClosestHoistScope();\n     // don't try to declare in the global scope if there's\n     // already a symbol there with this name.\n     // declared in closest scope?\n@@ -37,12 +37,12 @@\n         }\n         // If we're in the global scope, also declare var.prototype\n         // in the scope chain.\n-        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n+        if (scope.isGlobal() && type instanceof FunctionType) {\n             FunctionType fnType = (FunctionType) type;\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                 scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)));\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                        superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -3,13 +3,13 @@\n     // Only allow declarations of NAMEs and qualfied names.\n     boolean shouldDeclareOnGlobalThis = false;\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n+        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n         shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n@@ -42,7 +42,7 @@\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                 scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                        superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)));\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type != null);\n    // Only allow declarations of NAMEs and qualfied names.\n    boolean shouldDeclareOnGlobalThis = false;\n    if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n    }\n    String variableName = n.getQualifiedName();\n    Preconditions.checkArgument(variableName != null && !variableName.isEmpty(), \"Error: Variable name cannot be null or empty\");\n    // If n is a property, then we should really declare it in the\n    // scope where the root object appears. This helps out people\n    // who declare \"global\" names in an anonymous namespace.\n    Scope scopeToDeclareIn = scope;\n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n    // declared in closest scope?\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n                        superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n+++ com/google/javascript/jscomp/TypedScopeCreator.javadefineSlot\n@@ -3,13 +3,13 @@\n     // Only allow declarations of NAMEs and qualfied names.\n     boolean shouldDeclareOnGlobalThis = false;\n     if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\n+        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST || parent.getType() == Token.CATCH);\n         shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\n     }\n     String variableName = n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n+    Preconditions.checkArgument(variableName != null && !variableName.isEmpty(), \"Error: Variable name cannot be null or empty\");\n     // If n is a property, then we should really declare it in the\n     // scope where the root object appears. This helps out people\n     // who declare \"global\" names in an anonymous namespace.\n@@ -42,7 +42,7 @@\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor = fnType.getSuperClassConstructor();\n                 scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), /* declared iff there's an explicit supertype */\n-                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                        superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}]