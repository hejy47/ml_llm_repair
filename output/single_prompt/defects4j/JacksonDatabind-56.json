[{"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value.isEmpty() ? null : value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n  \t\t\t\t    if ((ix >= 0) && (value.indexOf(':', ix + 1) < 0)) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return null;\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return Locale.ROOT;\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,7 +6,7 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n-            return URI.create(value);\n+            return URI.create(value.isEmpty() ? null : value);\n         case STD_CLASS:\n             try {\n                 return ctxt.findClass(value);\n@@ -56,7 +56,7 @@\n                 return new InetSocketAddress(value.substring(0, i + 1), port);\n             } else {\n                 int ix = value.indexOf(':');\n-                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+  \t\t\t\t    if ((ix >= 0) && (value.indexOf(':', ix + 1) < 0)) {\n                     // host:port\n                     int port = Integer.parseInt(value.substring(ix + 1));\n                     return new InetSocketAddress(value.substring(0, ix), port);\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,69 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value.isEmpty() ? null : value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+  \t\t\t\t    if ((ix >= 0) && (value.indexOf(':', ix + 1) < 0)) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            if (\"\".equals(value)) {\n                return null; // null for empty URI\n            }\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            if (\"\".equals(value)) {\n                return null; // null for empty locale\n            }\n            int ix = value.indexOf('_');\n            if (ix < 0) {\n                // single argument\n                return new Locale(value);\n            }\n            String first = value.substring(0, ix);\n            value = value.substring(ix + 1);\n            ix = value.indexOf('_');\n            if (ix < 0) {\n                // two pieces\n                return new Locale(first, value);\n            }\n            String second = value.substring(0, ix);\n            return new Locale(first, second, value.substring(ix + 1));\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return null; // null for empty URI\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return null; // null for empty locale\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,6 +6,9 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n+            if (\"\".equals(value)) {\n+                return null; // null for empty URI\n+            }\n             return URI.create(value);\n         case STD_CLASS:\n             try {\n@@ -22,22 +25,23 @@\n             // will throw IAE (or its subclass) if malformed\n             return Pattern.compile(value);\n         case STD_LOCALE:\n-            {\n-                int ix = value.indexOf('_');\n-                if (ix < 0) {\n-                    // single argument\n-                    return new Locale(value);\n-                }\n-                String first = value.substring(0, ix);\n-                value = value.substring(ix + 1);\n-                ix = value.indexOf('_');\n-                if (ix < 0) {\n-                    // two pieces\n-                    return new Locale(first, value);\n-                }\n-                String second = value.substring(0, ix);\n-                return new Locale(first, second, value.substring(ix + 1));\n+            if (\"\".equals(value)) {\n+                return null; // null for empty locale\n             }\n+            int ix = value.indexOf('_');\n+            if (ix < 0) {\n+                // single argument\n+                return new Locale(value);\n+            }\n+            String first = value.substring(0, ix);\n+            value = value.substring(ix + 1);\n+            ix = value.indexOf('_');\n+            if (ix < 0) {\n+                // two pieces\n+                return new Locale(first, value);\n+            }\n+            String second = value.substring(0, ix);\n+            return new Locale(first, second, value.substring(ix + 1));\n         case STD_CHARSET:\n             return Charset.forName(value);\n         case STD_TIME_ZONE:\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,73 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            if (\"\".equals(value)) {\n+                return null; // null for empty URI\n+            }\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            if (\"\".equals(value)) {\n+                return null; // null for empty locale\n+            }\n+            int ix = value.indexOf('_');\n+            if (ix < 0) {\n+                // single argument\n+                return new Locale(value);\n+            }\n+            String first = value.substring(0, ix);\n+            value = value.substring(ix + 1);\n+            ix = value.indexOf('_');\n+            if (ix < 0) {\n+                // two pieces\n+                return new Locale(first, value);\n+            }\n+            String second = value.substring(0, ix);\n+            return new Locale(first, second, value.substring(ix + 1));\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            if (value.isEmpty()) {\n                return null; // URI requires non-empty string\n            }\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            if (value.isEmpty()) {\n                return null; // Locale requires non-empty string\n            }\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return null; // URI requires non-empty string\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return Locale.ROOT;\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,6 +6,9 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n+            if (value.isEmpty()) {\n+                return null; // URI requires non-empty string\n+            }\n             return URI.create(value);\n         case STD_CLASS:\n             try {\n@@ -22,6 +25,9 @@\n             // will throw IAE (or its subclass) if malformed\n             return Pattern.compile(value);\n         case STD_LOCALE:\n+            if (value.isEmpty()) {\n+                return null; // Locale requires non-empty string\n+            }\n             {\n                 int ix = value.indexOf('_');\n                 if (ix < 0) {\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,75 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            if (value.isEmpty()) {\n+                return null; // URI requires non-empty string\n+            }\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            if (value.isEmpty()) {\n+                return null; // Locale requires non-empty string\n+            }\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            if (value.isEmpty()) {\n                return null;\n            }\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            if (value.isEmpty()) {\n                return null;\n            }\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    if (_kind == STD_URI) {\n        return null;\n    }\n    if (_kind == STD_LOCALE) {\n        return null;\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,6 +6,9 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n+            if (value.isEmpty()) {\n+                return null;\n+            }\n             return URI.create(value);\n         case STD_CLASS:\n             try {\n@@ -22,6 +25,9 @@\n             // will throw IAE (or its subclass) if malformed\n             return Pattern.compile(value);\n         case STD_LOCALE:\n+            if (value.isEmpty()) {\n+                return null;\n+            }\n             {\n                 int ix = value.indexOf('_');\n                 if (ix < 0) {\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,75 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            if (value.isEmpty()) {\n+                return null;\n+            }\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            if (value.isEmpty()) {\n+                return null;\n+            }\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n        default:\n            return ctxt.handleUnknownTypeId(_type, value, this, \"no such type id\");\n    }\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return URI.create(\"\");\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return Locale.ROOT;\n    }\n    // As per [databind#1582], use default value for EnumSet\n    if (_kind == STD_ENUM_SET) {\n        return EnumSet.noneOf(_enumClass);\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -64,6 +64,7 @@\n                 // host or unbracketed IPv6, without port number\n                 return new InetSocketAddress(value, 0);\n             }\n+        default:\n+            return ctxt.handleUnknownTypeId(_type, value, this, \"no such type id\");\n     }\n-    throw new IllegalArgumentException();\n }\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,70 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n+        default:\n+            return ctxt.handleUnknownTypeId(_type, value, this, \"no such type id\");\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            if (value.isEmpty()) {\n                return null; // Or throw an exception if an empty value is not expected\n            }\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                if (value.isEmpty()) {\n                    return null; // Or throw an exception if an empty value is not expected\n                }\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return null; // Or throw an exception if an empty value is not expected\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return Locale.ROOT;\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,6 +6,9 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n+            if (value.isEmpty()) {\n+                return null; // Or throw an exception if an empty value is not expected\n+            }\n             return URI.create(value);\n         case STD_CLASS:\n             try {\n@@ -23,6 +26,9 @@\n             return Pattern.compile(value);\n         case STD_LOCALE:\n             {\n+                if (value.isEmpty()) {\n+                    return null; // Or throw an exception if an empty value is not expected\n+                }\n                 int ix = value.indexOf('_');\n                 if (ix < 0) {\n                     // single argument\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,75 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            if (value.isEmpty()) {\n+                return null; // Or throw an exception if an empty value is not expected\n+            }\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                if (value.isEmpty()) {\n+                    return null; // Or throw an exception if an empty value is not expected\n+                }\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nThe provided code for this function seems to be correct. However, one potential issue could be with the usage of the `URI.create(value)` method. This method can throw an unchecked `IllegalArgumentException` if the provided string is not a valid URI. To avoid this, we can use the `new URI(value)` constructor instead, which throws a checked `URISyntaxException`. The fixed function would look like:\n\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            try {\n                return new URI(value);\n            } catch (URISyntaxException e) {\n                throw new InvalidFormatException(ctxt.getParser(), \"Invalid URI: \" + value, value, _valueClass);\n            }\n        // rest of the cases omitted for brevity\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\nThe provided code for this function is also correct. However, we can improve it by using constants instead of hardcoding the values for `STD_URI` and `STD_LOCALE`. This would make the code more readable and easier to maintain. The fixed function would look like:\n\nprivate static final int STD_URI = 2;\nprivate static final int STD_LOCALE = 8;\n\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    if (_kind == STD_URI) {\n        return URI.create(\"\");\n    }\n    if (_kind == STD_LOCALE) {\n        return Locale.ROOT;\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,64 +6,12 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n-            return URI.create(value);\n-        case STD_CLASS:\n             try {\n-                return ctxt.findClass(value);\n-            } catch (Exception e) {\n-                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+                return new URI(value);\n+            } catch (URISyntaxException e) {\n+                throw new InvalidFormatException(ctxt.getParser(), \"Invalid URI: \" + value, value, _valueClass);\n             }\n-        case STD_JAVA_TYPE:\n-            return ctxt.getTypeFactory().constructFromCanonical(value);\n-        case STD_CURRENCY:\n-            // will throw IAE if unknown:\n-            return Currency.getInstance(value);\n-        case STD_PATTERN:\n-            // will throw IAE (or its subclass) if malformed\n-            return Pattern.compile(value);\n-        case STD_LOCALE:\n-            {\n-                int ix = value.indexOf('_');\n-                if (ix < 0) {\n-                    // single argument\n-                    return new Locale(value);\n-                }\n-                String first = value.substring(0, ix);\n-                value = value.substring(ix + 1);\n-                ix = value.indexOf('_');\n-                if (ix < 0) {\n-                    // two pieces\n-                    return new Locale(first, value);\n-                }\n-                String second = value.substring(0, ix);\n-                return new Locale(first, second, value.substring(ix + 1));\n-            }\n-        case STD_CHARSET:\n-            return Charset.forName(value);\n-        case STD_TIME_ZONE:\n-            return TimeZone.getTimeZone(value);\n-        case STD_INET_ADDRESS:\n-            return InetAddress.getByName(value);\n-        case STD_INET_SOCKET_ADDRESS:\n-            if (value.startsWith(\"[\")) {\n-                // bracketed IPv6 (with port number)\n-                int i = value.lastIndexOf(']');\n-                if (i == -1) {\n-                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n-                }\n-                int j = value.indexOf(':', i);\n-                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n-                return new InetSocketAddress(value.substring(0, i + 1), port);\n-            } else {\n-                int ix = value.indexOf(':');\n-                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n-                    // host:port\n-                    int port = Integer.parseInt(value.substring(ix + 1));\n-                    return new InetSocketAddress(value.substring(0, ix), port);\n-                }\n-                // host or unbracketed IPv6, without port number\n-                return new InetSocketAddress(value, 0);\n-            }\n+        // rest of the cases omitted for brevity\n     }\n     throw new IllegalArgumentException();\n }\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,17 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            try {\n+                return new URI(value);\n+            } catch (URISyntaxException e) {\n+                throw new InvalidFormatException(ctxt.getParser(), \"Invalid URI: \" + value, value, _valueClass);\n+            }\n+        // rest of the cases omitted for brevity\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            // handle empty string as null as per [databind#398]\n            if (value.isEmpty()) {\n                return null;\n            }\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            // handle empty string as null as per [databind#1123]\n            if (value.isEmpty()) {\n                return null;\n            }\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return null; // handle empty string as null as per [databind#398]\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return null; // handle empty string as null as per [databind#1123]\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,6 +6,10 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n+            // handle empty string as null as per [databind#398]\n+            if (value.isEmpty()) {\n+                return null;\n+            }\n             return URI.create(value);\n         case STD_CLASS:\n             try {\n@@ -22,6 +26,10 @@\n             // will throw IAE (or its subclass) if malformed\n             return Pattern.compile(value);\n         case STD_LOCALE:\n+            // handle empty string as null as per [databind#1123]\n+            if (value.isEmpty()) {\n+                return null;\n+            }\n             {\n                 int ix = value.indexOf('_');\n                 if (ix < 0) {\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,77 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            // handle empty string as null as per [databind#398]\n+            if (value.isEmpty()) {\n+                return null;\n+            }\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            // handle empty string as null as per [databind#1123]\n+            if (value.isEmpty()) {\n+                return null;\n+            }\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            if (value.isEmpty()) {\n                return null; // return null instead of creating an empty URI\n            }\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                if (value.isEmpty()) {\n                    return null; // return null instead of creating an empty Locale\n                }\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI || _kind == STD_LOCALE) {\n        return null; // return null instead of creating an empty URI or Locale\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,6 +6,9 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n+            if (value.isEmpty()) {\n+                return null; // return null instead of creating an empty URI\n+            }\n             return URI.create(value);\n         case STD_CLASS:\n             try {\n@@ -23,6 +26,9 @@\n             return Pattern.compile(value);\n         case STD_LOCALE:\n             {\n+                if (value.isEmpty()) {\n+                    return null; // return null instead of creating an empty Locale\n+                }\n                 int ix = value.indexOf('_');\n                 if (ix < 0) {\n                     // single argument\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,75 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            if (value.isEmpty()) {\n+                return null; // return null instead of creating an empty URI\n+            }\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                if (value.isEmpty()) {\n+                    return null; // return null instead of creating an empty Locale\n+                }\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            if (\"\".equals(value)){\n                return null;\n            }\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            if (\"\".equals(value)) {\n                return Locale.ROOT;\n            }\n            int ix = value.indexOf('_');\n            if (ix < 0) {\n                // single argument\n                return new Locale(value);\n            }\n            String first = value.substring(0, ix);\n            value = value.substring(ix + 1);\n            ix = value.indexOf('_');\n            if (ix < 0) {\n                // two pieces\n                return new Locale(first, value);\n            }\n            String second = value.substring(0, ix);\n            return new Locale(first, second, value.substring(ix + 1));\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return null;\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return Locale.ROOT;\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,6 +6,9 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n+            if (\"\".equals(value)){\n+                return null;\n+            }\n             return URI.create(value);\n         case STD_CLASS:\n             try {\n@@ -22,22 +25,23 @@\n             // will throw IAE (or its subclass) if malformed\n             return Pattern.compile(value);\n         case STD_LOCALE:\n-            {\n-                int ix = value.indexOf('_');\n-                if (ix < 0) {\n-                    // single argument\n-                    return new Locale(value);\n-                }\n-                String first = value.substring(0, ix);\n-                value = value.substring(ix + 1);\n-                ix = value.indexOf('_');\n-                if (ix < 0) {\n-                    // two pieces\n-                    return new Locale(first, value);\n-                }\n-                String second = value.substring(0, ix);\n-                return new Locale(first, second, value.substring(ix + 1));\n+            if (\"\".equals(value)) {\n+                return Locale.ROOT;\n             }\n+            int ix = value.indexOf('_');\n+            if (ix < 0) {\n+                // single argument\n+                return new Locale(value);\n+            }\n+            String first = value.substring(0, ix);\n+            value = value.substring(ix + 1);\n+            ix = value.indexOf('_');\n+            if (ix < 0) {\n+                // two pieces\n+                return new Locale(first, value);\n+            }\n+            String second = value.substring(0, ix);\n+            return new Locale(first, second, value.substring(ix + 1));\n         case STD_CHARSET:\n             return Charset.forName(value);\n         case STD_TIME_ZONE:\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,73 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            if (\"\".equals(value)){\n+                return null;\n+            }\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            if (\"\".equals(value)) {\n+                return Locale.ROOT;\n+            }\n+            int ix = value.indexOf('_');\n+            if (ix < 0) {\n+                // single argument\n+                return new Locale(value);\n+            }\n+            String first = value.substring(0, ix);\n+            value = value.substring(ix + 1);\n+            ix = value.indexOf('_');\n+            if (ix < 0) {\n+                // two pieces\n+                return new Locale(first, value);\n+            }\n+            String second = value.substring(0, ix);\n+            return new Locale(first, second, value.substring(ix + 1));\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            try {\n                return new URL(value);\n            } catch (MalformedURLException e) {\n                throw new InvalidFormatException(ctxt.getParser(), \"Invalid URL format\", value, URL.class);\n            }\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return URI.create(\"\"); // Return an empty URI instead of throwing an exception\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return Locale.ROOT;\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -4,7 +4,11 @@\n         case STD_FILE:\n             return new File(value);\n         case STD_URL:\n-            return new URL(value);\n+            try {\n+                return new URL(value);\n+            } catch (MalformedURLException e) {\n+                throw new InvalidFormatException(ctxt.getParser(), \"Invalid URL format\", value, URL.class);\n+            }\n         case STD_URI:\n             return URI.create(value);\n         case STD_CLASS:\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,73 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            try {\n+                return new URL(value);\n+            } catch (MalformedURLException e) {\n+                throw new InvalidFormatException(ctxt.getParser(), \"Invalid URL format\", value, URL.class);\n+            }\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nIt is unclear what the exact issue is in the given function, therefore a fix cannot be provided.\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return URI.create(\"\"); // return empty URI instead of null\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return Locale.ROOT; // return root locale instead of null\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -1,69 +1,12 @@\n @Override\n-protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n-    switch(_kind) {\n-        case STD_FILE:\n-            return new File(value);\n-        case STD_URL:\n-            return new URL(value);\n-        case STD_URI:\n-            return URI.create(value);\n-        case STD_CLASS:\n-            try {\n-                return ctxt.findClass(value);\n-            } catch (Exception e) {\n-                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n-            }\n-        case STD_JAVA_TYPE:\n-            return ctxt.getTypeFactory().constructFromCanonical(value);\n-        case STD_CURRENCY:\n-            // will throw IAE if unknown:\n-            return Currency.getInstance(value);\n-        case STD_PATTERN:\n-            // will throw IAE (or its subclass) if malformed\n-            return Pattern.compile(value);\n-        case STD_LOCALE:\n-            {\n-                int ix = value.indexOf('_');\n-                if (ix < 0) {\n-                    // single argument\n-                    return new Locale(value);\n-                }\n-                String first = value.substring(0, ix);\n-                value = value.substring(ix + 1);\n-                ix = value.indexOf('_');\n-                if (ix < 0) {\n-                    // two pieces\n-                    return new Locale(first, value);\n-                }\n-                String second = value.substring(0, ix);\n-                return new Locale(first, second, value.substring(ix + 1));\n-            }\n-        case STD_CHARSET:\n-            return Charset.forName(value);\n-        case STD_TIME_ZONE:\n-            return TimeZone.getTimeZone(value);\n-        case STD_INET_ADDRESS:\n-            return InetAddress.getByName(value);\n-        case STD_INET_SOCKET_ADDRESS:\n-            if (value.startsWith(\"[\")) {\n-                // bracketed IPv6 (with port number)\n-                int i = value.lastIndexOf(']');\n-                if (i == -1) {\n-                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n-                }\n-                int j = value.indexOf(':', i);\n-                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n-                return new InetSocketAddress(value.substring(0, i + 1), port);\n-            } else {\n-                int ix = value.indexOf(':');\n-                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n-                    // host:port\n-                    int port = Integer.parseInt(value.substring(ix + 1));\n-                    return new InetSocketAddress(value.substring(0, ix), port);\n-                }\n-                // host or unbracketed IPv6, without port number\n-                return new InetSocketAddress(value, 0);\n-            }\n+protected Object _deserializeFromEmptyString() throws IOException {\n+    // As per [databind#398], URI requires special handling\n+    if (_kind == STD_URI) {\n+        return URI.create(\"\"); // return empty URI instead of null\n     }\n-    throw new IllegalArgumentException();\n+    // As per [databind#1123], Locale too\n+    if (_kind == STD_LOCALE) {\n+        return Locale.ROOT; // return root locale instead of null\n+    }\n+    return super._deserializeFromEmptyString();\n }\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -2,11 +2,11 @@\n protected Object _deserializeFromEmptyString() throws IOException {\n     // As per [databind#398], URI requires special handling\n     if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+        return URI.create(\"\"); // return empty URI instead of null\n     }\n     // As per [databind#1123], Locale too\n     if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n+        return Locale.ROOT; // return root locale instead of null\n     }\n     return super._deserializeFromEmptyString();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            if (value.isEmpty()) {\n                return null;\n            } else {\n                return URI.create(value);\n            }\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            if (value.isEmpty()) {\n                return null;\n            } else {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#1123], Locale requires special handling\n    if (_kind == STD_LOCALE) {\n        return null;\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,7 +6,11 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n-            return URI.create(value);\n+            if (value.isEmpty()) {\n+                return null;\n+            } else {\n+                return URI.create(value);\n+            }\n         case STD_CLASS:\n             try {\n                 return ctxt.findClass(value);\n@@ -22,7 +26,9 @@\n             // will throw IAE (or its subclass) if malformed\n             return Pattern.compile(value);\n         case STD_LOCALE:\n-            {\n+            if (value.isEmpty()) {\n+                return null;\n+            } else {\n                 int ix = value.indexOf('_');\n                 if (ix < 0) {\n                     // single argument\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,75 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            if (value.isEmpty()) {\n+                return null;\n+            } else {\n+                return URI.create(value);\n+            }\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            if (value.isEmpty()) {\n+                return null;\n+            } else {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n        default:\n            throw ctxt.mappingException(\"Unsupported type: \" + _kind);\n    }\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    if (_kind == STD_URI) {\n        return null;\n    }\n    if (_kind == STD_LOCALE) {\n        return Locale.ROOT;\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -64,6 +64,7 @@\n                 // host or unbracketed IPv6, without port number\n                 return new InetSocketAddress(value, 0);\n             }\n+        default:\n+            throw ctxt.mappingException(\"Unsupported type: \" + _kind);\n     }\n-    throw new IllegalArgumentException();\n }\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,70 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n+        default:\n+            throw ctxt.mappingException(\"Unsupported type: \" + _kind);\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid kind: \" + _kind);\n    }\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return null; // return null instead of an empty URI\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return Locale.ROOT;\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -64,6 +64,7 @@\n                 // host or unbracketed IPv6, without port number\n                 return new InetSocketAddress(value, 0);\n             }\n+        default:\n+            throw new IllegalArgumentException(\"Invalid kind: \" + _kind);\n     }\n-    throw new IllegalArgumentException();\n }\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,70 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n+        default:\n+            throw new IllegalArgumentException(\"Invalid kind: \" + _kind);\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            if (value.isEmpty()) {\n                return null;\n            }\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                if (value.isEmpty()) {\n                    return null;\n                }\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return null;\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return null;\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,6 +6,9 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n+            if (value.isEmpty()) {\n+                return null;\n+            }\n             return URI.create(value);\n         case STD_CLASS:\n             try {\n@@ -23,6 +26,9 @@\n             return Pattern.compile(value);\n         case STD_LOCALE:\n             {\n+                if (value.isEmpty()) {\n+                    return null;\n+                }\n                 int ix = value.indexOf('_');\n                 if (ix < 0) {\n                     // single argument\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,75 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            if (value.isEmpty()) {\n+                return null;\n+            }\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                if (value.isEmpty()) {\n+                    return null;\n+                }\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            if (value.isEmpty()) { // check for empty string\n                return null;\n            }\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            if (value.isEmpty()) { // check for empty string\n                return null;\n            }\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return null; // return null instead of creating empty URI\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return null; // return null instead of creating root Locale\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,6 +6,9 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n+            if (value.isEmpty()) { // check for empty string\n+                return null;\n+            }\n             return URI.create(value);\n         case STD_CLASS:\n             try {\n@@ -22,6 +25,9 @@\n             // will throw IAE (or its subclass) if malformed\n             return Pattern.compile(value);\n         case STD_LOCALE:\n+            if (value.isEmpty()) { // check for empty string\n+                return null;\n+            }\n             {\n                 int ix = value.indexOf('_');\n                 if (ix < 0) {\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,75 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            if (value.isEmpty()) { // check for empty string\n+                return null;\n+            }\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            if (value.isEmpty()) { // check for empty string\n+                return null;\n+            }\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            if (\"\".equals(value.trim())) { // check for empty URI string\n                return null;\n            }\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            if (\"\".equals(value.trim())) { // check for empty Locale string\n                return null;\n            }\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return null; // return null for empty URI string\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return null; // return null for empty Locale string\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,6 +6,9 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n+            if (\"\".equals(value.trim())) { // check for empty URI string\n+                return null;\n+            }\n             return URI.create(value);\n         case STD_CLASS:\n             try {\n@@ -22,6 +25,9 @@\n             // will throw IAE (or its subclass) if malformed\n             return Pattern.compile(value);\n         case STD_LOCALE:\n+            if (\"\".equals(value.trim())) { // check for empty Locale string\n+                return null;\n+            }\n             {\n                 int ix = value.indexOf('_');\n                 if (ix < 0) {\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,75 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            if (\"\".equals(value.trim())) { // check for empty URI string\n+                return null;\n+            }\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            if (\"\".equals(value.trim())) { // check for empty Locale string\n+                return null;\n+            }\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            if (value.isEmpty()) {\n                return null; // or throw an exception, depending on the use case\n            }\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            if (value.isEmpty()) {\n                return null; // or throw an exception, depending on the use case\n            }\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}\n\n## Fixed Function 2\n@Override\nprotected Object _deserializeFromEmptyString() throws IOException {\n    // As per [databind#398], URI requires special handling\n    if (_kind == STD_URI) {\n        return null; // or throw an exception, depending on the use case\n    }\n    // As per [databind#1123], Locale too\n    if (_kind == STD_LOCALE) {\n        return null; // or throw an exception, depending on the use case\n    }\n    return super._deserializeFromEmptyString();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -6,6 +6,9 @@\n         case STD_URL:\n             return new URL(value);\n         case STD_URI:\n+            if (value.isEmpty()) {\n+                return null; // or throw an exception, depending on the use case\n+            }\n             return URI.create(value);\n         case STD_CLASS:\n             try {\n@@ -22,6 +25,9 @@\n             // will throw IAE (or its subclass) if malformed\n             return Pattern.compile(value);\n         case STD_LOCALE:\n+            if (value.isEmpty()) {\n+                return null; // or throw an exception, depending on the use case\n+            }\n             {\n                 int ix = value.indexOf('_');\n                 if (ix < 0) {\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,75 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            if (value.isEmpty()) {\n+                return null; // or throw an exception, depending on the use case\n+            }\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            if (value.isEmpty()) {\n+                return null; // or throw an exception, depending on the use case\n+            }\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]