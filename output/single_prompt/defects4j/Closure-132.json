[{"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n            return n;  // Moved return statement to prevent further execution of function\n        }          \n    }\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -60,10 +60,10 @@\n                     }\n                 }\n             }\n-        }\n-        return n;\n+            return n;  // Moved return statement to prevent further execution of function\n+        }          \n     }\n-        tryRemoveRepeatedStatements(n);\n+    tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n            return n;\n        }\n    }\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -60,10 +60,10 @@\n                     }\n                 }\n             }\n+            return n;\n         }\n-        return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n+    tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n@@ -105,8 +105,7 @@\n                     n.removeChild(cond);\n                     Node assignName = thenOp.removeFirstChild();\n                     Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n+                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                     Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                     Node expr = NodeUtil.newExpr(assign);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n            return n;\n        }\n    }\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -60,10 +60,10 @@\n                     }\n                 }\n             }\n+            return n;\n         }\n-        return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n+    tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        // If condition is always true, return the then branch\n        Node thenBranch = cond.getNext();\n        parent.replaceChild(n, thenBranch.detachFromParent());\n        reportCodeChange();\n        return thenBranch;\n    } else if (NodeUtil.isLiteralValue(cond, false)) {\n        // If condition is always false, return the else branch (if it exists)\n        Node elseBranch = cond.getNext().getNext();\n        if (elseBranch != null) {\n            parent.replaceChild(n, elseBranch.detachFromParent());\n            reportCodeChange();\n            return elseBranch;\n        } else {\n            // If there is no else branch, return undefined\n            Node undefined = NodeUtil.newUndefinedNode(n);\n            parent.replaceChild(n, undefined);\n            reportCodeChange();\n            return undefined;\n        }\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        // The if statement has no else branch\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,12 +1,31 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n-        return n;\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n+        // If condition is always true, return the then branch\n+        Node thenBranch = cond.getNext();\n+        parent.replaceChild(n, thenBranch.detachFromParent());\n+        reportCodeChange();\n+        return thenBranch;\n+    } else if (NodeUtil.isLiteralValue(cond, false)) {\n+        // If condition is always false, return the else branch (if it exists)\n+        Node elseBranch = cond.getNext().getNext();\n+        if (elseBranch != null) {\n+            parent.replaceChild(n, elseBranch.detachFromParent());\n+            reportCodeChange();\n+            return elseBranch;\n+        } else {\n+            // If there is no else branch, return undefined\n+            Node undefined = NodeUtil.newUndefinedNode(n);\n+            parent.replaceChild(n, undefined);\n+            reportCodeChange();\n+            return undefined;\n+        }\n     }\n     Node thenBranch = cond.getNext();\n     Node elseBranch = thenBranch.getNext();\n     if (elseBranch == null) {\n+        // The if statement has no else branch\n         if (isFoldableExpressBlock(thenBranch)) {\n             Node expr = getBlockExpression(thenBranch);\n             if (!late && isPropertyAssignmentInExpression(expr)) {\n@@ -63,7 +82,7 @@\n         }\n         return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n+    tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                return n;\n            }\n            if (cond.isNot()) {\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n    tryRemoveRepeatedStatements(n);\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node returnNode = IR.returnNode(hookNode);\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        Node thenOpParent = thenOp.getParent();\n        Node elseOpParent = elseOp.getParent();\n        if (thenOpParent.isExprResult() && elseOpParent.isExprResult()) {\n            n.removeChild(cond);\n            thenOp.detachFromParent();\n            elseOp.detachFromParent();\n            Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n            Node expr = IR.exprResult(hookNode);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n            return expr;\n        }\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -10,15 +10,10 @@\n         if (isFoldableExpressBlock(thenBranch)) {\n             Node expr = getBlockExpression(thenBranch);\n             if (!late && isPropertyAssignmentInExpression(expr)) {\n-                // Keep opportunities for CollapseProperties such as\n-                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-                // until CollapseProperties has been run.\n                 return n;\n             }\n             if (cond.isNot()) {\n-                // if(!x)bar(); -> x||bar();\n                 if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n-                    // It's not okay to add two sets of parentheses.\n                     return n;\n                 }\n                 Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n@@ -27,12 +22,7 @@\n                 reportCodeChange();\n                 return newExpr;\n             }\n-            // if(x)foo(); -> x&&foo();\n             if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n-                // One additional set of parentheses is worth the change even if\n-                // there is no immediate code size win. However, two extra pair of\n-                // {}, we would have to think twice. (unless we know for sure the\n-                // we can further optimize its parent.\n                 return n;\n             }\n             n.removeChild(cond);\n@@ -42,7 +32,6 @@\n             reportCodeChange();\n             return newExpr;\n         } else {\n-            // Try to combine two IF-ELSE\n             if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                 Node innerIf = thenBranch.getFirstChild();\n                 if (innerIf.isIf()) {\n@@ -54,8 +43,6 @@\n                         n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                         n.addChildrenToBack(innerThenBranch.detachFromParent());\n                         reportCodeChange();\n-                        // Not worth trying to fold the current IF-ELSE into && because\n-                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                         return n;\n                     }\n                 }\n@@ -63,9 +50,7 @@\n         }\n         return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n+    tryRemoveRepeatedStatements(n);\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n         n.replaceChild(cond, cond.removeFirstChild());\n         n.removeChild(thenBranch);\n@@ -73,17 +58,14 @@\n         reportCodeChange();\n         return n;\n     }\n-    // if(x)return 1;else return 2; -> return x?1:2;\n     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n         Node thenExpr = getBlockReturnExpression(thenBranch);\n         Node elseExpr = getBlockReturnExpression(elseBranch);\n         n.removeChild(cond);\n         thenExpr.detachFromParent();\n         elseExpr.detachFromParent();\n-        // note - we ignore any cases with \"return;\", technically this\n-        // can be converted to \"return undefined;\" or some variant, but\n-        // that does not help code size.\n-        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n+        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+        Node returnNode = IR.returnNode(hookNode);\n         parent.replaceChild(n, returnNode);\n         reportCodeChange();\n         return returnNode;\n@@ -94,19 +76,13 @@\n         Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n         Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n         if (thenOp.getType() == elseOp.getType()) {\n-            // if(x)a=1;else a=2; -> a=x?1:2;\n             if (NodeUtil.isAssignmentOp(thenOp)) {\n                 Node lhs = thenOp.getFirstChild();\n-                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n-                // evaluates LHS before cond]\n-                // NOTE - there are some circumstances where we can\n-                // proceed even if there are side effects...\n-                !mayEffectMutableState(lhs)) {\n+                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {\n                     n.removeChild(cond);\n                     Node assignName = thenOp.removeFirstChild();\n                     Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n+                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                     Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                     Node expr = NodeUtil.newExpr(assign);\n@@ -116,18 +92,21 @@\n                 }\n             }\n         }\n-        // if(x)foo();else bar(); -> x?foo():bar()\n-        n.removeChild(cond);\n-        thenOp.detachFromParent();\n-        elseOp.detachFromParent();\n-        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n-        parent.replaceChild(n, expr);\n-        reportCodeChange();\n-        return expr;\n+        Node thenOpParent = thenOp.getParent();\n+        Node elseOpParent = elseOp.getParent();\n+        if (thenOpParent.isExprResult() && elseOpParent.isExprResult()) {\n+            n.removeChild(cond);\n+            thenOp.detachFromParent();\n+            elseOp.detachFromParent();\n+            Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n+            Node expr = IR.exprResult(hookNode);\n+            parent.replaceChild(n, expr);\n+            reportCodeChange();\n+            return expr;\n+        }\n     }\n     boolean thenBranchIsVar = isVarBlock(thenBranch);\n     boolean elseBranchIsVar = isVarBlock(elseBranch);\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n     if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n         Node var = getBlockVar(thenBranch);\n         Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n@@ -144,7 +123,6 @@\n             reportCodeChange();\n             return var;\n         }\n-        // if(x)y=1;else var y=2  ->  var y=x?1:2\n     } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n         Node var = getBlockVar(elseBranch);\n         Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return cond; // return the literal directly\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE)\n                        && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE)\n                    && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE)\n                            && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node returnNode = IR.returnNode(hookNode);\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild())\n                        && !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n        Node expr = IR.exprResult(hookNode);\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock\n            && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName()\n                && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,8 +1,8 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n-        return n;\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n+        return cond; // return the literal directly\n     }\n     Node thenBranch = cond.getNext();\n     Node elseBranch = thenBranch.getNext();\n@@ -10,15 +10,12 @@\n         if (isFoldableExpressBlock(thenBranch)) {\n             Node expr = getBlockExpression(thenBranch);\n             if (!late && isPropertyAssignmentInExpression(expr)) {\n-                // Keep opportunities for CollapseProperties such as\n-                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-                // until CollapseProperties has been run.\n                 return n;\n             }\n             if (cond.isNot()) {\n                 // if(!x)bar(); -> x||bar();\n-                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n-                    // It's not okay to add two sets of parentheses.\n+                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE)\n+                        && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                     return n;\n                 }\n                 Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n@@ -28,11 +25,8 @@\n                 return newExpr;\n             }\n             // if(x)foo(); -> x&&foo();\n-            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n-                // One additional set of parentheses is worth the change even if\n-                // there is no immediate code size win. However, two extra pair of\n-                // {}, we would have to think twice. (unless we know for sure the\n-                // we can further optimize its parent.\n+            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE)\n+                    && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                 return n;\n             }\n             n.removeChild(cond);\n@@ -49,13 +43,12 @@\n                     Node innerCond = innerIf.getFirstChild();\n                     Node innerThenBranch = innerCond.getNext();\n                     Node innerElseBranch = innerThenBranch.getNext();\n-                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n+                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE)\n+                            && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                         n.detachChildren();\n                         n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                         n.addChildrenToBack(innerThenBranch.detachFromParent());\n                         reportCodeChange();\n-                        // Not worth trying to fold the current IF-ELSE into && because\n-                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                         return n;\n                     }\n                 }\n@@ -63,7 +56,7 @@\n         }\n         return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n+    tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n@@ -80,10 +73,8 @@\n         n.removeChild(cond);\n         thenExpr.detachFromParent();\n         elseExpr.detachFromParent();\n-        // note - we ignore any cases with \"return;\", technically this\n-        // can be converted to \"return undefined;\" or some variant, but\n-        // that does not help code size.\n-        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n+        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+        Node returnNode = IR.returnNode(hookNode);\n         parent.replaceChild(n, returnNode);\n         reportCodeChange();\n         return returnNode;\n@@ -97,16 +88,12 @@\n             // if(x)a=1;else a=2; -> a=x?1:2;\n             if (NodeUtil.isAssignmentOp(thenOp)) {\n                 Node lhs = thenOp.getFirstChild();\n-                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n-                // evaluates LHS before cond]\n-                // NOTE - there are some circumstances where we can\n-                // proceed even if there are side effects...\n-                !mayEffectMutableState(lhs)) {\n+                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild())\n+                        && !mayEffectMutableState(lhs)) {\n                     n.removeChild(cond);\n                     Node assignName = thenOp.removeFirstChild();\n                     Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n+                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                     Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                     Node expr = NodeUtil.newExpr(assign);\n@@ -120,7 +107,8 @@\n         n.removeChild(cond);\n         thenOp.detachFromParent();\n         elseOp.detachFromParent();\n-        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n+        Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n+        Node expr = IR.exprResult(hookNode);\n         parent.replaceChild(n, expr);\n         reportCodeChange();\n         return expr;\n@@ -145,12 +133,14 @@\n             return var;\n         }\n         // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n+    } else if (elseBranchIsVar && thenBranchIsExpressionBlock\n+            && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n         Node var = getBlockVar(elseBranch);\n         Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n         Node maybeName1 = thenAssign.getFirstChild();\n         Node name2 = var.getFirstChild();\n-        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n+        if (name2.hasChildren() && maybeName1.isName()\n+                && maybeName1.getString().equals(name2.getString())) {\n             Node thenExpr = thenAssign.getLastChild().detachFromParent();\n             Node elseExpr = name2.removeChildren();\n             cond.detachFromParent();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n            return n;\n        }\n    } else {\n        tryRemoveRepeatedStatements(n);\n        // if(!x)foo();else bar(); -> if(x)bar();else foo();\n        // An additional set of curly braces isn't worth it.\n        if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n            n.replaceChild(cond, cond.removeFirstChild());\n            n.removeChild(thenBranch);\n            n.addChildToBack(elseBranch.detachFromParent());\n            n.addChildToBack(thenBranch.detachFromParent());\n            reportCodeChange();\n            return n;\n        }\n        // if(x)return 1;else return 2; -> return x?1:2;\n        if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n            Node thenExpr = getBlockReturnExpression(thenBranch);\n            Node elseExpr = getBlockReturnExpression(elseBranch);\n            cond.detachFromParent();\n            thenExpr.detachFromParent();\n            elseExpr.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            Node returnNode = IR.returnNode(hookNode);\n            parent.replaceChild(n, returnNode);\n            reportCodeChange();\n            return returnNode;\n        }\n        boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n        boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n        if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n            Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n            Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n            if (thenOp.getType() == elseOp.getType()) {\n                // if(x)a=1;else a=2; -> a=x?1:2;\n                if (NodeUtil.isAssignmentOp(thenOp)) {\n                    Node lhs = thenOp.getFirstChild();\n                    if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                    // evaluates LHS before cond]\n                    // NOTE - there are some circumstances where we can\n                    // proceed even if there are side effects...\n                            !mayEffectMutableState(lhs)) {\n                        cond.detachFromParent();\n                        Node assignName = thenOp.removeFirstChild();\n                        Node thenExpr = thenOp.removeFirstChild();\n                        Node elseExpr = elseOp.getLastChild().detachFromParent();\n                        elseOp.removeChild(elseExpr);\n                        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                        Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                        Node expr = NodeUtil.newExpr(assign);\n                        parent.replaceChild(n, expr);\n                        reportCodeChange();\n                        return expr;\n                    }\n                }\n            }\n            // if(x)foo();else bar(); -> x?foo():bar()\n            cond.detachFromParent();\n            thenOp.detachFromParent();\n            elseOp.detachFromParent();\n            Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n            Node expr = IR.exprResult(hookNode);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n            return expr;\n        }\n        boolean thenBranchIsVar = isVarBlock(thenBranch);\n        boolean elseBranchIsVar = isVarBlock(elseBranch);\n        // if(x)var y=1;else y=2  ->  var y=x?1:2\n        if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n            Node var = getBlockVar(thenBranch);\n            Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n            Node name1 = var.getFirstChild();\n            Node maybeName2 = elseAssign.getFirstChild();\n            if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n                Node thenExpr = name1.removeChildren();\n                Node elseExpr = elseAssign.getLastChild().detachFromParent();\n                cond.detachFromParent();\n                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                var.detachFromParent();\n                name1.addChildrenToBack(hookNode);\n                parent.replaceChild(n, var);\n                reportCodeChange();\n                return var;\n            }\n            // if(x)y=1;else var y=2  ->  var y=x?1:2\n        } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n            Node var = getBlockVar(elseBranch);\n            Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n            Node maybeName1 = thenAssign.getFirstChild();\n            Node name2 = var.getFirstChild();\n            if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n                Node thenExpr = thenAssign.getLastChild().detachFromParent();\n                Node elseExpr = name2.removeChildren();\n                cond.detachFromParent();\n                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                var.detachFromParent();\n                name2.addChildrenToBack(hookNode);\n                parent.replaceChild(n, var);\n                reportCodeChange();\n                return var;\n            }\n        }\n        return n;\n    }\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -60,107 +60,108 @@\n                     }\n                 }\n             }\n+            return n;\n+        }\n+    } else {\n+        tryRemoveRepeatedStatements(n);\n+        // if(!x)foo();else bar(); -> if(x)bar();else foo();\n+        // An additional set of curly braces isn't worth it.\n+        if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n+            n.replaceChild(cond, cond.removeFirstChild());\n+            n.removeChild(thenBranch);\n+            n.addChildToBack(elseBranch.detachFromParent());\n+            n.addChildToBack(thenBranch.detachFromParent());\n+            reportCodeChange();\n+            return n;\n+        }\n+        // if(x)return 1;else return 2; -> return x?1:2;\n+        if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n+            Node thenExpr = getBlockReturnExpression(thenBranch);\n+            Node elseExpr = getBlockReturnExpression(elseBranch);\n+            cond.detachFromParent();\n+            thenExpr.detachFromParent();\n+            elseExpr.detachFromParent();\n+            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+            Node returnNode = IR.returnNode(hookNode);\n+            parent.replaceChild(n, returnNode);\n+            reportCodeChange();\n+            return returnNode;\n+        }\n+        boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n+        boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n+        if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n+            Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n+            Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n+            if (thenOp.getType() == elseOp.getType()) {\n+                // if(x)a=1;else a=2; -> a=x?1:2;\n+                if (NodeUtil.isAssignmentOp(thenOp)) {\n+                    Node lhs = thenOp.getFirstChild();\n+                    if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n+                    // evaluates LHS before cond]\n+                    // NOTE - there are some circumstances where we can\n+                    // proceed even if there are side effects...\n+                            !mayEffectMutableState(lhs)) {\n+                        cond.detachFromParent();\n+                        Node assignName = thenOp.removeFirstChild();\n+                        Node thenExpr = thenOp.removeFirstChild();\n+                        Node elseExpr = elseOp.getLastChild().detachFromParent();\n+                        elseOp.removeChild(elseExpr);\n+                        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                        Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n+                        Node expr = NodeUtil.newExpr(assign);\n+                        parent.replaceChild(n, expr);\n+                        reportCodeChange();\n+                        return expr;\n+                    }\n+                }\n+            }\n+            // if(x)foo();else bar(); -> x?foo():bar()\n+            cond.detachFromParent();\n+            thenOp.detachFromParent();\n+            elseOp.detachFromParent();\n+            Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n+            Node expr = IR.exprResult(hookNode);\n+            parent.replaceChild(n, expr);\n+            reportCodeChange();\n+            return expr;\n+        }\n+        boolean thenBranchIsVar = isVarBlock(thenBranch);\n+        boolean elseBranchIsVar = isVarBlock(elseBranch);\n+        // if(x)var y=1;else y=2  ->  var y=x?1:2\n+        if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n+            Node var = getBlockVar(thenBranch);\n+            Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n+            Node name1 = var.getFirstChild();\n+            Node maybeName2 = elseAssign.getFirstChild();\n+            if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n+                Node thenExpr = name1.removeChildren();\n+                Node elseExpr = elseAssign.getLastChild().detachFromParent();\n+                cond.detachFromParent();\n+                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                var.detachFromParent();\n+                name1.addChildrenToBack(hookNode);\n+                parent.replaceChild(n, var);\n+                reportCodeChange();\n+                return var;\n+            }\n+            // if(x)y=1;else var y=2  ->  var y=x?1:2\n+        } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n+            Node var = getBlockVar(elseBranch);\n+            Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n+            Node maybeName1 = thenAssign.getFirstChild();\n+            Node name2 = var.getFirstChild();\n+            if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n+                Node thenExpr = thenAssign.getLastChild().detachFromParent();\n+                Node elseExpr = name2.removeChildren();\n+                cond.detachFromParent();\n+                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                var.detachFromParent();\n+                name2.addChildrenToBack(hookNode);\n+                parent.replaceChild(n, var);\n+                reportCodeChange();\n+                return var;\n+            }\n         }\n         return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n-    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n-        n.replaceChild(cond, cond.removeFirstChild());\n-        n.removeChild(thenBranch);\n-        n.addChildToBack(thenBranch);\n-        reportCodeChange();\n-        return n;\n-    }\n-    // if(x)return 1;else return 2; -> return x?1:2;\n-    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n-        Node thenExpr = getBlockReturnExpression(thenBranch);\n-        Node elseExpr = getBlockReturnExpression(elseBranch);\n-        n.removeChild(cond);\n-        thenExpr.detachFromParent();\n-        elseExpr.detachFromParent();\n-        // note - we ignore any cases with \"return;\", technically this\n-        // can be converted to \"return undefined;\" or some variant, but\n-        // that does not help code size.\n-        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n-        parent.replaceChild(n, returnNode);\n-        reportCodeChange();\n-        return returnNode;\n-    }\n-    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n-    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n-    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n-        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n-        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n-        if (thenOp.getType() == elseOp.getType()) {\n-            // if(x)a=1;else a=2; -> a=x?1:2;\n-            if (NodeUtil.isAssignmentOp(thenOp)) {\n-                Node lhs = thenOp.getFirstChild();\n-                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n-                // evaluates LHS before cond]\n-                // NOTE - there are some circumstances where we can\n-                // proceed even if there are side effects...\n-                !mayEffectMutableState(lhs)) {\n-                    n.removeChild(cond);\n-                    Node assignName = thenOp.removeFirstChild();\n-                    Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n-                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n-                    Node expr = NodeUtil.newExpr(assign);\n-                    parent.replaceChild(n, expr);\n-                    reportCodeChange();\n-                    return expr;\n-                }\n-            }\n-        }\n-        // if(x)foo();else bar(); -> x?foo():bar()\n-        n.removeChild(cond);\n-        thenOp.detachFromParent();\n-        elseOp.detachFromParent();\n-        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n-        parent.replaceChild(n, expr);\n-        reportCodeChange();\n-        return expr;\n-    }\n-    boolean thenBranchIsVar = isVarBlock(thenBranch);\n-    boolean elseBranchIsVar = isVarBlock(elseBranch);\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n-        Node var = getBlockVar(thenBranch);\n-        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-        Node name1 = var.getFirstChild();\n-        Node maybeName2 = elseAssign.getFirstChild();\n-        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n-            Node thenExpr = name1.removeChildren();\n-            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-            cond.detachFromParent();\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            var.detachFromParent();\n-            name1.addChildrenToBack(hookNode);\n-            parent.replaceChild(n, var);\n-            reportCodeChange();\n-            return var;\n-        }\n-        // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n-        Node var = getBlockVar(elseBranch);\n-        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-        Node maybeName1 = thenAssign.getFirstChild();\n-        Node name2 = var.getFirstChild();\n-        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n-            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n-            Node elseExpr = name2.removeChildren();\n-            cond.detachFromParent();\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            var.detachFromParent();\n-            name2.addChildrenToBack(hookNode);\n-            parent.replaceChild(n, var);\n-            reportCodeChange();\n-            return var;\n-        }\n-    }\n-    return n;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return cond;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n            return n;\n        }\n    }\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                        !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,8 +1,8 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n-        return n;\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n+        return cond;\n     }\n     Node thenBranch = cond.getNext();\n     Node elseBranch = thenBranch.getNext();\n@@ -60,10 +60,10 @@\n                     }\n                 }\n             }\n+            return n;\n         }\n-        return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n+    tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n@@ -101,12 +101,11 @@\n                 // evaluates LHS before cond]\n                 // NOTE - there are some circumstances where we can\n                 // proceed even if there are side effects...\n-                !mayEffectMutableState(lhs)) {\n+                        !mayEffectMutableState(lhs)) {\n                     n.removeChild(cond);\n                     Node assignName = thenOp.removeFirstChild();\n                     Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n+                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                     Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                     Node expr = NodeUtil.newExpr(assign);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n            return n;\n        }\n    }\n\n    // Check if there are any repeated statements in the then or else branches\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node returnNode = IR.returnNode(hookNode).srcref(n);\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        Node thenExpr = getBlockExpression(thenBranch).removeFirstChild();\n        Node elseExpr = getBlockExpression(elseBranch).removeFirstChild();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node expr = NodeUtil.newExpr(hookNode);\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,11 +1,12 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n     Node elseBranch = thenBranch.getNext();\n+\n     if (elseBranch == null) {\n         if (isFoldableExpressBlock(thenBranch)) {\n             Node expr = getBlockExpression(thenBranch);\n@@ -60,10 +61,13 @@\n                     }\n                 }\n             }\n+            return n;\n         }\n-        return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n+\n+    // Check if there are any repeated statements in the then or else branches\n+    tryRemoveRepeatedStatements(n);\n+\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n@@ -77,13 +81,8 @@\n     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n         Node thenExpr = getBlockReturnExpression(thenBranch);\n         Node elseExpr = getBlockReturnExpression(elseBranch);\n-        n.removeChild(cond);\n-        thenExpr.detachFromParent();\n-        elseExpr.detachFromParent();\n-        // note - we ignore any cases with \"return;\", technically this\n-        // can be converted to \"return undefined;\" or some variant, but\n-        // that does not help code size.\n-        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n+        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+        Node returnNode = IR.returnNode(hookNode).srcref(n);\n         parent.replaceChild(n, returnNode);\n         reportCodeChange();\n         return returnNode;\n@@ -97,16 +96,10 @@\n             // if(x)a=1;else a=2; -> a=x?1:2;\n             if (NodeUtil.isAssignmentOp(thenOp)) {\n                 Node lhs = thenOp.getFirstChild();\n-                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n-                // evaluates LHS before cond]\n-                // NOTE - there are some circumstances where we can\n-                // proceed even if there are side effects...\n-                !mayEffectMutableState(lhs)) {\n-                    n.removeChild(cond);\n+                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {\n                     Node assignName = thenOp.removeFirstChild();\n                     Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n+                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                     Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                     Node expr = NodeUtil.newExpr(assign);\n@@ -117,10 +110,10 @@\n             }\n         }\n         // if(x)foo();else bar(); -> x?foo():bar()\n-        n.removeChild(cond);\n-        thenOp.detachFromParent();\n-        elseOp.detachFromParent();\n-        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n+        Node thenExpr = getBlockExpression(thenBranch).removeFirstChild();\n+        Node elseExpr = getBlockExpression(elseBranch).removeFirstChild();\n+        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+        Node expr = NodeUtil.newExpr(hookNode);\n         parent.replaceChild(n, expr);\n         reportCodeChange();\n         return expr;\n@@ -136,7 +129,6 @@\n         if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n             Node thenExpr = name1.removeChildren();\n             Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-            cond.detachFromParent();\n             Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n             var.detachFromParent();\n             name1.addChildrenToBack(hookNode);\n@@ -153,7 +145,6 @@\n         if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n             Node thenExpr = thenAssign.getLastChild().detachFromParent();\n             Node elseExpr = name2.removeChildren();\n-            cond.detachFromParent();\n             Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n             var.detachFromParent();\n             name2.addChildrenToBack(hookNode);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n        if (NodeUtil.isLiteralValue(cond, true)) {\n        return cond; // return the literal value directly\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n        tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -2,7 +2,7 @@\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n         if (NodeUtil.isLiteralValue(cond, true)) {\n-        return n;\n+        return cond; // return the literal value directly\n     }\n     Node thenBranch = cond.getNext();\n     Node elseBranch = thenBranch.getNext();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n            return n;\n        }\n    } else {\n        tryRemoveRepeatedStatements(n);\n        // if(!x)foo();else bar(); -> if(x)bar();else foo();\n        // An additional set of curly braces isn't worth it.\n        if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n            n.replaceChild(cond, cond.removeFirstChild());\n            n.removeChild(thenBranch);\n            n.addChildToBack(thenBranch);\n            reportCodeChange();\n            return n;\n        }\n        // if(x)return 1;else return 2; -> return x?1:2;\n        if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n            Node thenExpr = getBlockReturnExpression(thenBranch);\n            Node elseExpr = getBlockReturnExpression(elseBranch);\n            n.removeChild(cond);\n            thenExpr.detachFromParent();\n            elseExpr.detachFromParent();\n            // note - we ignore any cases with \"return;\", technically this\n            // can be converted to \"return undefined;\" or some variant, but\n            // that does not help code size.\n            Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n            parent.replaceChild(n, returnNode);\n            reportCodeChange();\n            return returnNode;\n        }\n        boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n        boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n        if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n            Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n            Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n            if (thenOp.getType() == elseOp.getType()) {\n                // if(x)a=1;else a=2; -> a=x?1:2;\n                if (NodeUtil.isAssignmentOp(thenOp)) {\n                    Node lhs = thenOp.getFirstChild();\n                    if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                        // evaluates LHS before cond]\n                        // NOTE - there are some circumstances where we can\n                        // proceed even if there are side effects...\n                        !mayEffectMutableState(lhs)) {\n                        n.removeChild(cond);\n                        Node assignName = thenOp.removeFirstChild();\n                        Node thenExpr = thenOp.removeFirstChild();\n                        Node elseExpr = elseOp.getLastChild();\n                        elseOp.removeChild(elseExpr);\n                        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                        Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                        Node expr = NodeUtil.newExpr(assign);\n                        parent.replaceChild(n, expr);\n                        reportCodeChange();\n                        return expr;\n                    }\n                }\n            }\n            // if(x)foo();else bar(); -> x?foo():bar()\n            n.removeChild(cond);\n            thenOp.detachFromParent();\n            elseOp.detachFromParent();\n            Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n            return expr;\n        }\n        boolean thenBranchIsVar = isVarBlock(thenBranch);\n        boolean elseBranchIsVar = isVarBlock(elseBranch);\n        // if(x)var y=1;else y=2  ->  var y=x?1:2\n        if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n            Node var = getBlockVar(thenBranch);\n            Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n            Node name1 = var.getFirstChild();\n            Node maybeName2 = elseAssign.getFirstChild();\n            if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n                Node thenExpr = name1.removeChildren();\n                Node elseExpr = elseAssign.getLastChild().detachFromParent();\n                cond.detachFromParent();\n                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                var.detachFromParent();\n                name1.addChildrenToBack(hookNode);\n                parent.replaceChild(n, var);\n                reportCodeChange();\n                return var;\n            }\n            // if(x)y=1;else var y=2  ->  var y=x?1:2\n        } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n            Node var = getBlockVar(elseBranch);\n            Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n            Node maybeName1 = thenAssign.getFirstChild();\n            Node name2 = var.getFirstChild();\n            if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n                Node thenExpr = thenAssign.getLastChild().detachFromParent();\n                Node elseExpr = name2.removeChildren();\n                cond.detachFromParent();\n                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                var.detachFromParent();\n                name2.addChildrenToBack(hookNode);\n                parent.replaceChild(n, var);\n                reportCodeChange();\n                return var;\n            }\n        }\n        return n;\n    }\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -60,107 +60,108 @@\n                     }\n                 }\n             }\n+            return n;\n+        }\n+    } else {\n+        tryRemoveRepeatedStatements(n);\n+        // if(!x)foo();else bar(); -> if(x)bar();else foo();\n+        // An additional set of curly braces isn't worth it.\n+        if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n+            n.replaceChild(cond, cond.removeFirstChild());\n+            n.removeChild(thenBranch);\n+            n.addChildToBack(thenBranch);\n+            reportCodeChange();\n+            return n;\n+        }\n+        // if(x)return 1;else return 2; -> return x?1:2;\n+        if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n+            Node thenExpr = getBlockReturnExpression(thenBranch);\n+            Node elseExpr = getBlockReturnExpression(elseBranch);\n+            n.removeChild(cond);\n+            thenExpr.detachFromParent();\n+            elseExpr.detachFromParent();\n+            // note - we ignore any cases with \"return;\", technically this\n+            // can be converted to \"return undefined;\" or some variant, but\n+            // that does not help code size.\n+            Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n+            parent.replaceChild(n, returnNode);\n+            reportCodeChange();\n+            return returnNode;\n+        }\n+        boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n+        boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n+        if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n+            Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n+            Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n+            if (thenOp.getType() == elseOp.getType()) {\n+                // if(x)a=1;else a=2; -> a=x?1:2;\n+                if (NodeUtil.isAssignmentOp(thenOp)) {\n+                    Node lhs = thenOp.getFirstChild();\n+                    if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n+                        // evaluates LHS before cond]\n+                        // NOTE - there are some circumstances where we can\n+                        // proceed even if there are side effects...\n+                        !mayEffectMutableState(lhs)) {\n+                        n.removeChild(cond);\n+                        Node assignName = thenOp.removeFirstChild();\n+                        Node thenExpr = thenOp.removeFirstChild();\n+                        Node elseExpr = elseOp.getLastChild();\n+                        elseOp.removeChild(elseExpr);\n+                        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                        Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n+                        Node expr = NodeUtil.newExpr(assign);\n+                        parent.replaceChild(n, expr);\n+                        reportCodeChange();\n+                        return expr;\n+                    }\n+                }\n+            }\n+            // if(x)foo();else bar(); -> x?foo():bar()\n+            n.removeChild(cond);\n+            thenOp.detachFromParent();\n+            elseOp.detachFromParent();\n+            Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n+            parent.replaceChild(n, expr);\n+            reportCodeChange();\n+            return expr;\n+        }\n+        boolean thenBranchIsVar = isVarBlock(thenBranch);\n+        boolean elseBranchIsVar = isVarBlock(elseBranch);\n+        // if(x)var y=1;else y=2  ->  var y=x?1:2\n+        if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n+            Node var = getBlockVar(thenBranch);\n+            Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n+            Node name1 = var.getFirstChild();\n+            Node maybeName2 = elseAssign.getFirstChild();\n+            if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n+                Node thenExpr = name1.removeChildren();\n+                Node elseExpr = elseAssign.getLastChild().detachFromParent();\n+                cond.detachFromParent();\n+                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                var.detachFromParent();\n+                name1.addChildrenToBack(hookNode);\n+                parent.replaceChild(n, var);\n+                reportCodeChange();\n+                return var;\n+            }\n+            // if(x)y=1;else var y=2  ->  var y=x?1:2\n+        } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n+            Node var = getBlockVar(elseBranch);\n+            Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n+            Node maybeName1 = thenAssign.getFirstChild();\n+            Node name2 = var.getFirstChild();\n+            if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n+                Node thenExpr = thenAssign.getLastChild().detachFromParent();\n+                Node elseExpr = name2.removeChildren();\n+                cond.detachFromParent();\n+                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                var.detachFromParent();\n+                name2.addChildrenToBack(hookNode);\n+                parent.replaceChild(n, var);\n+                reportCodeChange();\n+                return var;\n+            }\n         }\n         return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n-    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n-        n.replaceChild(cond, cond.removeFirstChild());\n-        n.removeChild(thenBranch);\n-        n.addChildToBack(thenBranch);\n-        reportCodeChange();\n-        return n;\n-    }\n-    // if(x)return 1;else return 2; -> return x?1:2;\n-    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n-        Node thenExpr = getBlockReturnExpression(thenBranch);\n-        Node elseExpr = getBlockReturnExpression(elseBranch);\n-        n.removeChild(cond);\n-        thenExpr.detachFromParent();\n-        elseExpr.detachFromParent();\n-        // note - we ignore any cases with \"return;\", technically this\n-        // can be converted to \"return undefined;\" or some variant, but\n-        // that does not help code size.\n-        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n-        parent.replaceChild(n, returnNode);\n-        reportCodeChange();\n-        return returnNode;\n-    }\n-    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n-    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n-    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n-        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n-        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n-        if (thenOp.getType() == elseOp.getType()) {\n-            // if(x)a=1;else a=2; -> a=x?1:2;\n-            if (NodeUtil.isAssignmentOp(thenOp)) {\n-                Node lhs = thenOp.getFirstChild();\n-                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n-                // evaluates LHS before cond]\n-                // NOTE - there are some circumstances where we can\n-                // proceed even if there are side effects...\n-                !mayEffectMutableState(lhs)) {\n-                    n.removeChild(cond);\n-                    Node assignName = thenOp.removeFirstChild();\n-                    Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n-                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n-                    Node expr = NodeUtil.newExpr(assign);\n-                    parent.replaceChild(n, expr);\n-                    reportCodeChange();\n-                    return expr;\n-                }\n-            }\n-        }\n-        // if(x)foo();else bar(); -> x?foo():bar()\n-        n.removeChild(cond);\n-        thenOp.detachFromParent();\n-        elseOp.detachFromParent();\n-        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n-        parent.replaceChild(n, expr);\n-        reportCodeChange();\n-        return expr;\n-    }\n-    boolean thenBranchIsVar = isVarBlock(thenBranch);\n-    boolean elseBranchIsVar = isVarBlock(elseBranch);\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n-        Node var = getBlockVar(thenBranch);\n-        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-        Node name1 = var.getFirstChild();\n-        Node maybeName2 = elseAssign.getFirstChild();\n-        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n-            Node thenExpr = name1.removeChildren();\n-            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-            cond.detachFromParent();\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            var.detachFromParent();\n-            name1.addChildrenToBack(hookNode);\n-            parent.replaceChild(n, var);\n-            reportCodeChange();\n-            return var;\n-        }\n-        // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n-        Node var = getBlockVar(elseBranch);\n-        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-        Node maybeName1 = thenAssign.getFirstChild();\n-        Node name2 = var.getFirstChild();\n-        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n-            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n-            Node elseExpr = name2.removeChildren();\n-            cond.detachFromParent();\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            var.detachFromParent();\n-            name2.addChildrenToBack(hookNode);\n-            parent.replaceChild(n, var);\n-            reportCodeChange();\n-            return var;\n-        }\n-    }\n-    return n;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                return n;\n            }\n            if (cond.isNot()) {\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n    tryRemoveRepeatedStatements(n);\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node returnNode = IR.returnNode(hookNode);\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n                    !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        Node thenOpFirstChild = thenOp.getFirstChild();\n        Node elseOpFirstChild = elseOp.getFirstChild();\n        if (thenOpFirstChild.isComma() && elseOpFirstChild.isComma()) {\n            if (thenOpFirstChild.hasSameShape(elseOpFirstChild)) {\n                n.removeChild(cond);\n                Node hookNode = IR.hook(cond, thenOpFirstChild, elseOpFirstChild).srcref(n);\n                parent.replaceChild(n, hookNode);\n                reportCodeChange();\n                return hookNode;\n            }\n        }\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -10,15 +10,10 @@\n         if (isFoldableExpressBlock(thenBranch)) {\n             Node expr = getBlockExpression(thenBranch);\n             if (!late && isPropertyAssignmentInExpression(expr)) {\n-                // Keep opportunities for CollapseProperties such as\n-                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-                // until CollapseProperties has been run.\n                 return n;\n             }\n             if (cond.isNot()) {\n-                // if(!x)bar(); -> x||bar();\n                 if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n-                    // It's not okay to add two sets of parentheses.\n                     return n;\n                 }\n                 Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n@@ -27,12 +22,7 @@\n                 reportCodeChange();\n                 return newExpr;\n             }\n-            // if(x)foo(); -> x&&foo();\n             if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n-                // One additional set of parentheses is worth the change even if\n-                // there is no immediate code size win. However, two extra pair of\n-                // {}, we would have to think twice. (unless we know for sure the\n-                // we can further optimize its parent.\n                 return n;\n             }\n             n.removeChild(cond);\n@@ -42,7 +32,6 @@\n             reportCodeChange();\n             return newExpr;\n         } else {\n-            // Try to combine two IF-ELSE\n             if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                 Node innerIf = thenBranch.getFirstChild();\n                 if (innerIf.isIf()) {\n@@ -54,8 +43,6 @@\n                         n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                         n.addChildrenToBack(innerThenBranch.detachFromParent());\n                         reportCodeChange();\n-                        // Not worth trying to fold the current IF-ELSE into && because\n-                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                         return n;\n                     }\n                 }\n@@ -63,9 +50,7 @@\n         }\n         return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n+    tryRemoveRepeatedStatements(n);\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n         n.replaceChild(cond, cond.removeFirstChild());\n         n.removeChild(thenBranch);\n@@ -73,17 +58,14 @@\n         reportCodeChange();\n         return n;\n     }\n-    // if(x)return 1;else return 2; -> return x?1:2;\n     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n         Node thenExpr = getBlockReturnExpression(thenBranch);\n         Node elseExpr = getBlockReturnExpression(elseBranch);\n         n.removeChild(cond);\n         thenExpr.detachFromParent();\n         elseExpr.detachFromParent();\n-        // note - we ignore any cases with \"return;\", technically this\n-        // can be converted to \"return undefined;\" or some variant, but\n-        // that does not help code size.\n-        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n+        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+        Node returnNode = IR.returnNode(hookNode);\n         parent.replaceChild(n, returnNode);\n         reportCodeChange();\n         return returnNode;\n@@ -94,19 +76,14 @@\n         Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n         Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n         if (thenOp.getType() == elseOp.getType()) {\n-            // if(x)a=1;else a=2; -> a=x?1:2;\n             if (NodeUtil.isAssignmentOp(thenOp)) {\n                 Node lhs = thenOp.getFirstChild();\n-                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n-                // evaluates LHS before cond]\n-                // NOTE - there are some circumstances where we can\n-                // proceed even if there are side effects...\n-                !mayEffectMutableState(lhs)) {\n+                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n+                    !mayEffectMutableState(lhs)) {\n                     n.removeChild(cond);\n                     Node assignName = thenOp.removeFirstChild();\n                     Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n+                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                     Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                     Node expr = NodeUtil.newExpr(assign);\n@@ -116,7 +93,17 @@\n                 }\n             }\n         }\n-        // if(x)foo();else bar(); -> x?foo():bar()\n+        Node thenOpFirstChild = thenOp.getFirstChild();\n+        Node elseOpFirstChild = elseOp.getFirstChild();\n+        if (thenOpFirstChild.isComma() && elseOpFirstChild.isComma()) {\n+            if (thenOpFirstChild.hasSameShape(elseOpFirstChild)) {\n+                n.removeChild(cond);\n+                Node hookNode = IR.hook(cond, thenOpFirstChild, elseOpFirstChild).srcref(n);\n+                parent.replaceChild(n, hookNode);\n+                reportCodeChange();\n+                return hookNode;\n+            }\n+        }\n         n.removeChild(cond);\n         thenOp.detachFromParent();\n         elseOp.detachFromParent();\n@@ -127,7 +114,6 @@\n     }\n     boolean thenBranchIsVar = isVarBlock(thenBranch);\n     boolean elseBranchIsVar = isVarBlock(elseBranch);\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n     if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n         Node var = getBlockVar(thenBranch);\n         Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n@@ -144,7 +130,6 @@\n             reportCodeChange();\n             return var;\n         }\n-        // if(x)y=1;else var y=2  ->  var y=x?1:2\n     } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n         Node var = getBlockVar(elseBranch);\n         Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n        if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    } else if (NodeUtil.isLiteralValue(cond, false) && n.getNext() != null && NodeUtil.isIfStatement(n.getNext())) {\n        Node nextIf = n.getNext();\n        Node nextCond = nextIf.getFirstChild();\n        if (NodeUtil.isLiteralValue(nextCond, true)) {\n            parent.replaceChild(nextIf, n);\n            reportCodeChange();\n            return n;\n        } else if (NodeUtil.isLiteralValue(nextCond, false)) {\n            Node thenBranch = cond.getNext();\n            Node elseBranch = thenBranch.getNext();\n            if (elseBranch == null) {\n                if (isFoldableExpressBlock(thenBranch)) {\n                    Node expr = getBlockExpression(thenBranch);\n                    if (!late && isPropertyAssignmentInExpression(expr)) {\n                        // Keep opportunities for CollapseProperties such as\n                        // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                        // until CollapseProperties has been run.\n                        return n;\n                    }\n                    if (cond.isNot()) {\n                        // if(!x)bar(); -> x||bar();\n                        if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                            // It's not okay to add two sets of parentheses.\n                            return n;\n                        }\n                        Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                        Node newExpr = NodeUtil.newExpr(or);\n                        parent.replaceChild(n, newExpr);\n                        reportCodeChange();\n                        return newExpr;\n                    }\n                    // if(x)foo(); -> x&&foo();\n                    if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                        // One additional set of parentheses is worth the change even if\n                        // there is no immediate code size win. However, two extra pair of\n                        // {}, we would have to think twice. (unless we know for sure the\n                        // we can further optimize its parent.\n                        return n;\n                    }\n                    n.removeChild(cond);\n                    Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n                    Node newExpr = NodeUtil.newExpr(and);\n                    parent.replaceChild(n, newExpr);\n                    reportCodeChange();\n                    return newExpr;\n                } else {\n                    // Try to combine two IF-ELSE\n                    if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                        Node innerIf = thenBranch.getFirstChild();\n                        if (innerIf.isIf()) {\n                            Node innerCond = innerIf.getFirstChild();\n                            Node innerThenBranch = innerCond.getNext();\n                            Node innerElseBranch = innerThenBranch.getNext();\n                            if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                                n.detachChildren();\n                                n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                                n.addChildrenToBack(innerThenBranch.detachFromParent());\n                                reportCodeChange();\n                                // Not worth trying to fold the current IF-ELSE into && because\n                                // the inner IF-ELSE wasn't able to be folded into && anyways.\n                                return n;\n                            }\n                        }\n                    }\n                    return n;\n                }\n            }\n                    tryRemoveRepeatedStatements(n);\n            // if(!x)foo();else bar(); -> if(x)bar();else foo();\n            // An additional set of curly braces isn't worth it.\n            if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n                n.replaceChild(cond, cond.removeFirstChild());\n                n.removeChild(thenBranch);\n                n.addChildToBack(thenBranch);\n                reportCodeChange();\n                return n;\n            }\n            // if(x)return 1;else return 2; -> return x?1:2;\n            if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n                Node thenExpr = getBlockReturnExpression(thenBranch);\n                Node elseExpr = getBlockReturnExpression(elseBranch);\n                n.removeChild(cond);\n                thenExpr.detachFromParent();\n                elseExpr.detachFromParent();\n                // note - we ignore any cases with \"return;\", technically this\n                // can be converted to \"return undefined;\" or some variant, but\n                // that does not help code size.\n                Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n                parent.replaceChild(n, returnNode);\n                reportCodeChange();\n                return returnNode;\n            }\n            boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n            boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n            if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n                Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n                Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n                if (thenOp.getType() == elseOp.getType()) {\n                    // if(x)a=1;else a=2; -> a=x?1:2;\n                    if (NodeUtil.isAssignmentOp(thenOp)) {\n                        Node lhs = thenOp.getFirstChild();\n                        if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                        // evaluates LHS before cond]\n                        // NOTE - there are some circumstances where we can\n                        // proceed even if there are side effects...\n                        !mayEffectMutableState(lhs)) {\n                            n.removeChild(cond);\n                            Node assignName = thenOp.removeFirstChild();\n                            Node thenExpr = thenOp.removeFirstChild();\n                            Node elseExpr = elseOp.getLastChild();\n                            elseOp.removeChild(elseExpr);\n                            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                            Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                            Node expr = NodeUtil.newExpr(assign);\n                            parent.replaceChild(n, expr);\n                            reportCodeChange();\n                            return expr;\n                        }\n                    }\n                }\n                // if(x)foo();else bar(); -> x?foo():bar()\n                n.removeChild(cond);\n                thenOp.detachFromParent();\n                elseOp.detachFromParent();\n                Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n                parent.replaceChild(n, expr);\n                reportCodeChange();\n                return expr;\n            }\n            boolean thenBranchIsVar = isVarBlock(thenBranch);\n            boolean elseBranchIsVar = isVarBlock(elseBranch);\n            // if(x)var y=1;else y=2  ->  var y=x?1:2\n            if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n                Node var = getBlockVar(thenBranch);\n                Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n                Node name1 = var.getFirstChild();\n                Node maybeName2 = elseAssign.getFirstChild();\n                if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n                    Node thenExpr = name1.removeChildren();\n                    Node elseExpr = elseAssign.getLastChild().detachFromParent();\n                    cond.detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    var.detachFromParent();\n                    name1.addChildrenToBack(hookNode);\n                    parent.replaceChild(n, var);\n                    reportCodeChange();\n                    return var;\n                }\n                // if(x)y=1;else var y=2  ->  var y=x?1:2\n            } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n                Node var = getBlockVar(elseBranch);\n                Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n                Node maybeName1 = thenAssign.getFirstChild();\n                Node name2 = var.getFirstChild();\n                if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n                    Node thenExpr = thenAssign.getLastChild().detachFromParent();\n                    Node elseExpr = name2.removeChildren();\n                    cond.detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    var.detachFromParent();\n                    name2.addChildrenToBack(hookNode);\n                    parent.replaceChild(n, var);\n                    reportCodeChange();\n                    return var;\n                }\n            }\n            return n;\n    }\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -3,164 +3,172 @@\n     Node cond = n.getFirstChild();\n         if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n-    }\n-    Node thenBranch = cond.getNext();\n-    Node elseBranch = thenBranch.getNext();\n-    if (elseBranch == null) {\n-        if (isFoldableExpressBlock(thenBranch)) {\n-            Node expr = getBlockExpression(thenBranch);\n-            if (!late && isPropertyAssignmentInExpression(expr)) {\n-                // Keep opportunities for CollapseProperties such as\n-                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-                // until CollapseProperties has been run.\n+    } else if (NodeUtil.isLiteralValue(cond, false) && n.getNext() != null && NodeUtil.isIfStatement(n.getNext())) {\n+        Node nextIf = n.getNext();\n+        Node nextCond = nextIf.getFirstChild();\n+        if (NodeUtil.isLiteralValue(nextCond, true)) {\n+            parent.replaceChild(nextIf, n);\n+            reportCodeChange();\n+            return n;\n+        } else if (NodeUtil.isLiteralValue(nextCond, false)) {\n+            Node thenBranch = cond.getNext();\n+            Node elseBranch = thenBranch.getNext();\n+            if (elseBranch == null) {\n+                if (isFoldableExpressBlock(thenBranch)) {\n+                    Node expr = getBlockExpression(thenBranch);\n+                    if (!late && isPropertyAssignmentInExpression(expr)) {\n+                        // Keep opportunities for CollapseProperties such as\n+                        // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n+                        // until CollapseProperties has been run.\n+                        return n;\n+                    }\n+                    if (cond.isNot()) {\n+                        // if(!x)bar(); -> x||bar();\n+                        if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n+                            // It's not okay to add two sets of parentheses.\n+                            return n;\n+                        }\n+                        Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n+                        Node newExpr = NodeUtil.newExpr(or);\n+                        parent.replaceChild(n, newExpr);\n+                        reportCodeChange();\n+                        return newExpr;\n+                    }\n+                    // if(x)foo(); -> x&&foo();\n+                    if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n+                        // One additional set of parentheses is worth the change even if\n+                        // there is no immediate code size win. However, two extra pair of\n+                        // {}, we would have to think twice. (unless we know for sure the\n+                        // we can further optimize its parent.\n+                        return n;\n+                    }\n+                    n.removeChild(cond);\n+                    Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n+                    Node newExpr = NodeUtil.newExpr(and);\n+                    parent.replaceChild(n, newExpr);\n+                    reportCodeChange();\n+                    return newExpr;\n+                } else {\n+                    // Try to combine two IF-ELSE\n+                    if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n+                        Node innerIf = thenBranch.getFirstChild();\n+                        if (innerIf.isIf()) {\n+                            Node innerCond = innerIf.getFirstChild();\n+                            Node innerThenBranch = innerCond.getNext();\n+                            Node innerElseBranch = innerThenBranch.getNext();\n+                            if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n+                                n.detachChildren();\n+                                n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n+                                n.addChildrenToBack(innerThenBranch.detachFromParent());\n+                                reportCodeChange();\n+                                // Not worth trying to fold the current IF-ELSE into && because\n+                                // the inner IF-ELSE wasn't able to be folded into && anyways.\n+                                return n;\n+                            }\n+                        }\n+                    }\n+                    return n;\n+                }\n+            }\n+                    tryRemoveRepeatedStatements(n);\n+            // if(!x)foo();else bar(); -> if(x)bar();else foo();\n+            // An additional set of curly braces isn't worth it.\n+            if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n+                n.replaceChild(cond, cond.removeFirstChild());\n+                n.removeChild(thenBranch);\n+                n.addChildToBack(thenBranch);\n+                reportCodeChange();\n                 return n;\n             }\n-            if (cond.isNot()) {\n-                // if(!x)bar(); -> x||bar();\n-                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n-                    // It's not okay to add two sets of parentheses.\n-                    return n;\n-                }\n-                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n-                Node newExpr = NodeUtil.newExpr(or);\n-                parent.replaceChild(n, newExpr);\n+            // if(x)return 1;else return 2; -> return x?1:2;\n+            if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n+                Node thenExpr = getBlockReturnExpression(thenBranch);\n+                Node elseExpr = getBlockReturnExpression(elseBranch);\n+                n.removeChild(cond);\n+                thenExpr.detachFromParent();\n+                elseExpr.detachFromParent();\n+                // note - we ignore any cases with \"return;\", technically this\n+                // can be converted to \"return undefined;\" or some variant, but\n+                // that does not help code size.\n+                Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n+                parent.replaceChild(n, returnNode);\n                 reportCodeChange();\n-                return newExpr;\n+                return returnNode;\n             }\n-            // if(x)foo(); -> x&&foo();\n-            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n-                // One additional set of parentheses is worth the change even if\n-                // there is no immediate code size win. However, two extra pair of\n-                // {}, we would have to think twice. (unless we know for sure the\n-                // we can further optimize its parent.\n-                return n;\n-            }\n-            n.removeChild(cond);\n-            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n-            Node newExpr = NodeUtil.newExpr(and);\n-            parent.replaceChild(n, newExpr);\n-            reportCodeChange();\n-            return newExpr;\n-        } else {\n-            // Try to combine two IF-ELSE\n-            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n-                Node innerIf = thenBranch.getFirstChild();\n-                if (innerIf.isIf()) {\n-                    Node innerCond = innerIf.getFirstChild();\n-                    Node innerThenBranch = innerCond.getNext();\n-                    Node innerElseBranch = innerThenBranch.getNext();\n-                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n-                        n.detachChildren();\n-                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n-                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n-                        reportCodeChange();\n-                        // Not worth trying to fold the current IF-ELSE into && because\n-                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n-                        return n;\n+            boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n+            boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n+            if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n+                Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n+                Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n+                if (thenOp.getType() == elseOp.getType()) {\n+                    // if(x)a=1;else a=2; -> a=x?1:2;\n+                    if (NodeUtil.isAssignmentOp(thenOp)) {\n+                        Node lhs = thenOp.getFirstChild();\n+                        if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n+                        // evaluates LHS before cond]\n+                        // NOTE - there are some circumstances where we can\n+                        // proceed even if there are side effects...\n+                        !mayEffectMutableState(lhs)) {\n+                            n.removeChild(cond);\n+                            Node assignName = thenOp.removeFirstChild();\n+                            Node thenExpr = thenOp.removeFirstChild();\n+                            Node elseExpr = elseOp.getLastChild();\n+                            elseOp.removeChild(elseExpr);\n+                            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                            Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n+                            Node expr = NodeUtil.newExpr(assign);\n+                            parent.replaceChild(n, expr);\n+                            reportCodeChange();\n+                            return expr;\n+                        }\n                     }\n                 }\n+                // if(x)foo();else bar(); -> x?foo():bar()\n+                n.removeChild(cond);\n+                thenOp.detachFromParent();\n+                elseOp.detachFromParent();\n+                Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n+                parent.replaceChild(n, expr);\n+                reportCodeChange();\n+                return expr;\n             }\n-        }\n-        return n;\n-    }\n-        tryRemoveRepeatedStatements(n);\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n-    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n-        n.replaceChild(cond, cond.removeFirstChild());\n-        n.removeChild(thenBranch);\n-        n.addChildToBack(thenBranch);\n-        reportCodeChange();\n-        return n;\n-    }\n-    // if(x)return 1;else return 2; -> return x?1:2;\n-    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n-        Node thenExpr = getBlockReturnExpression(thenBranch);\n-        Node elseExpr = getBlockReturnExpression(elseBranch);\n-        n.removeChild(cond);\n-        thenExpr.detachFromParent();\n-        elseExpr.detachFromParent();\n-        // note - we ignore any cases with \"return;\", technically this\n-        // can be converted to \"return undefined;\" or some variant, but\n-        // that does not help code size.\n-        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n-        parent.replaceChild(n, returnNode);\n-        reportCodeChange();\n-        return returnNode;\n-    }\n-    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n-    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n-    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n-        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n-        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n-        if (thenOp.getType() == elseOp.getType()) {\n-            // if(x)a=1;else a=2; -> a=x?1:2;\n-            if (NodeUtil.isAssignmentOp(thenOp)) {\n-                Node lhs = thenOp.getFirstChild();\n-                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n-                // evaluates LHS before cond]\n-                // NOTE - there are some circumstances where we can\n-                // proceed even if there are side effects...\n-                !mayEffectMutableState(lhs)) {\n-                    n.removeChild(cond);\n-                    Node assignName = thenOp.removeFirstChild();\n-                    Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n+            boolean thenBranchIsVar = isVarBlock(thenBranch);\n+            boolean elseBranchIsVar = isVarBlock(elseBranch);\n+            // if(x)var y=1;else y=2  ->  var y=x?1:2\n+            if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n+                Node var = getBlockVar(thenBranch);\n+                Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n+                Node name1 = var.getFirstChild();\n+                Node maybeName2 = elseAssign.getFirstChild();\n+                if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n+                    Node thenExpr = name1.removeChildren();\n+                    Node elseExpr = elseAssign.getLastChild().detachFromParent();\n+                    cond.detachFromParent();\n                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n-                    Node expr = NodeUtil.newExpr(assign);\n-                    parent.replaceChild(n, expr);\n+                    var.detachFromParent();\n+                    name1.addChildrenToBack(hookNode);\n+                    parent.replaceChild(n, var);\n                     reportCodeChange();\n-                    return expr;\n+                    return var;\n+                }\n+                // if(x)y=1;else var y=2  ->  var y=x?1:2\n+            } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n+                Node var = getBlockVar(elseBranch);\n+                Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n+                Node maybeName1 = thenAssign.getFirstChild();\n+                Node name2 = var.getFirstChild();\n+                if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n+                    Node thenExpr = thenAssign.getLastChild().detachFromParent();\n+                    Node elseExpr = name2.removeChildren();\n+                    cond.detachFromParent();\n+                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                    var.detachFromParent();\n+                    name2.addChildrenToBack(hookNode);\n+                    parent.replaceChild(n, var);\n+                    reportCodeChange();\n+                    return var;\n                 }\n             }\n-        }\n-        // if(x)foo();else bar(); -> x?foo():bar()\n-        n.removeChild(cond);\n-        thenOp.detachFromParent();\n-        elseOp.detachFromParent();\n-        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n-        parent.replaceChild(n, expr);\n-        reportCodeChange();\n-        return expr;\n+            return n;\n     }\n-    boolean thenBranchIsVar = isVarBlock(thenBranch);\n-    boolean elseBranchIsVar = isVarBlock(elseBranch);\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n-        Node var = getBlockVar(thenBranch);\n-        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-        Node name1 = var.getFirstChild();\n-        Node maybeName2 = elseAssign.getFirstChild();\n-        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n-            Node thenExpr = name1.removeChildren();\n-            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-            cond.detachFromParent();\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            var.detachFromParent();\n-            name1.addChildrenToBack(hookNode);\n-            parent.replaceChild(n, var);\n-            reportCodeChange();\n-            return var;\n-        }\n-        // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n-        Node var = getBlockVar(elseBranch);\n-        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-        Node maybeName1 = thenAssign.getFirstChild();\n-        Node name2 = var.getFirstChild();\n-        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n-            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n-            Node elseExpr = name2.removeChildren();\n-            cond.detachFromParent();\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            var.detachFromParent();\n-            name2.addChildrenToBack(hookNode);\n-            parent.replaceChild(n, var);\n-            reportCodeChange();\n-            return var;\n-        }\n-    }\n-    return n;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return cond.cloneNode();\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n            return n.cloneNode();\n        }\n    }\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        Node conditionExpression = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node returnStatement = new Node(Token.RETURN, conditionExpression).srcref(n);\n        parent.replaceChild(n, returnStatement);\n        reportCodeChange();\n        return returnStatement;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                    Node conditionExpression = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, conditionExpression).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        Node thenExpr = getBlockExpression(thenBranch).removeFirstChild();\n        Node elseExpr = getBlockExpression(elseBranch).removeFirstChild();\n        Node conditionExpression = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node expr = NodeUtil.newExpr(conditionExpression);\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            Node conditionExpression = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(conditionExpression);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            Node conditionExpression = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(conditionExpression);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n.cloneNode();\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,8 +1,8 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n-        return n;\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n+        return cond.cloneNode();\n     }\n     Node thenBranch = cond.getNext();\n     Node elseBranch = thenBranch.getNext();\n@@ -60,10 +60,10 @@\n                     }\n                 }\n             }\n+            return n.cloneNode();\n         }\n-        return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n+    tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n@@ -77,16 +77,11 @@\n     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n         Node thenExpr = getBlockReturnExpression(thenBranch);\n         Node elseExpr = getBlockReturnExpression(elseBranch);\n-        n.removeChild(cond);\n-        thenExpr.detachFromParent();\n-        elseExpr.detachFromParent();\n-        // note - we ignore any cases with \"return;\", technically this\n-        // can be converted to \"return undefined;\" or some variant, but\n-        // that does not help code size.\n-        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n-        parent.replaceChild(n, returnNode);\n+        Node conditionExpression = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+        Node returnStatement = new Node(Token.RETURN, conditionExpression).srcref(n);\n+        parent.replaceChild(n, returnStatement);\n         reportCodeChange();\n-        return returnNode;\n+        return returnStatement;\n     }\n     boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n     boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n@@ -102,13 +97,11 @@\n                 // NOTE - there are some circumstances where we can\n                 // proceed even if there are side effects...\n                 !mayEffectMutableState(lhs)) {\n-                    n.removeChild(cond);\n                     Node assignName = thenOp.removeFirstChild();\n                     Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n-                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n+                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n+                    Node conditionExpression = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                    Node assign = new Node(thenOp.getType(), assignName, conditionExpression).srcref(thenOp);\n                     Node expr = NodeUtil.newExpr(assign);\n                     parent.replaceChild(n, expr);\n                     reportCodeChange();\n@@ -117,10 +110,10 @@\n             }\n         }\n         // if(x)foo();else bar(); -> x?foo():bar()\n-        n.removeChild(cond);\n-        thenOp.detachFromParent();\n-        elseOp.detachFromParent();\n-        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n+        Node thenExpr = getBlockExpression(thenBranch).removeFirstChild();\n+        Node elseExpr = getBlockExpression(elseBranch).removeFirstChild();\n+        Node conditionExpression = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+        Node expr = NodeUtil.newExpr(conditionExpression);\n         parent.replaceChild(n, expr);\n         reportCodeChange();\n         return expr;\n@@ -136,10 +129,9 @@\n         if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n             Node thenExpr = name1.removeChildren();\n             Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-            cond.detachFromParent();\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+            Node conditionExpression = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n             var.detachFromParent();\n-            name1.addChildrenToBack(hookNode);\n+            name1.addChildrenToBack(conditionExpression);\n             parent.replaceChild(n, var);\n             reportCodeChange();\n             return var;\n@@ -153,14 +145,13 @@\n         if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n             Node thenExpr = thenAssign.getLastChild().detachFromParent();\n             Node elseExpr = name2.removeChildren();\n-            cond.detachFromParent();\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+            Node conditionExpression = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n             var.detachFromParent();\n-            name2.addChildrenToBack(hookNode);\n+            name2.addChildrenToBack(conditionExpression);\n             parent.replaceChild(n, var);\n             reportCodeChange();\n             return var;\n         }\n     }\n-    return n;\n+    return n.cloneNode();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent).\n                n.removeChild(cond);\n                Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(and);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n            return n;\n        }\n    }\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        Node thenExp = getBlockExpression(thenBranch).removeFirstChild();\n        Node elseExp = getBlockExpression(elseBranch).removeFirstChild();\n        Node ternary = IR.hook(cond, thenExp, elseExp).srcref(n);\n        Node expr = NodeUtil.newExpr(ternary);\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node ternary = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(ternary);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node ternary = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(ternary);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -32,8 +32,13 @@\n                 // One additional set of parentheses is worth the change even if\n                 // there is no immediate code size win. However, two extra pair of\n                 // {}, we would have to think twice. (unless we know for sure the\n-                // we can further optimize its parent.\n-                return n;\n+                // we can further optimize its parent).\n+                n.removeChild(cond);\n+                Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n+                Node newExpr = NodeUtil.newExpr(and);\n+                parent.replaceChild(n, newExpr);\n+                reportCodeChange();\n+                return newExpr;\n             }\n             n.removeChild(cond);\n             Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n@@ -60,10 +65,10 @@\n                     }\n                 }\n             }\n+            return n;\n         }\n-        return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n+    tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n@@ -105,8 +110,7 @@\n                     n.removeChild(cond);\n                     Node assignName = thenOp.removeFirstChild();\n                     Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n+                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                     Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                     Node expr = NodeUtil.newExpr(assign);\n@@ -118,9 +122,10 @@\n         }\n         // if(x)foo();else bar(); -> x?foo():bar()\n         n.removeChild(cond);\n-        thenOp.detachFromParent();\n-        elseOp.detachFromParent();\n-        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n+        Node thenExp = getBlockExpression(thenBranch).removeFirstChild();\n+        Node elseExp = getBlockExpression(elseBranch).removeFirstChild();\n+        Node ternary = IR.hook(cond, thenExp, elseExp).srcref(n);\n+        Node expr = NodeUtil.newExpr(ternary);\n         parent.replaceChild(n, expr);\n         reportCodeChange();\n         return expr;\n@@ -137,14 +142,14 @@\n             Node thenExpr = name1.removeChildren();\n             Node elseExpr = elseAssign.getLastChild().detachFromParent();\n             cond.detachFromParent();\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+            Node ternary = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n             var.detachFromParent();\n-            name1.addChildrenToBack(hookNode);\n+            name1.addChildrenToBack(ternary);\n             parent.replaceChild(n, var);\n             reportCodeChange();\n             return var;\n         }\n-        // if(x)y=1;else var y=2  ->  var y=x?1:2\n+    // if(x)y=1;else var y=2  ->  var y=x?1:2\n     } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n         Node var = getBlockVar(elseBranch);\n         Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n@@ -154,9 +159,9 @@\n             Node thenExpr = thenAssign.getLastChild().detachFromParent();\n             Node elseExpr = name2.removeChildren();\n             cond.detachFromParent();\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+            Node ternary = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n             var.detachFromParent();\n-            name2.addChildrenToBack(hookNode);\n+            name2.addChildrenToBack(ternary);\n             parent.replaceChild(n, var);\n             reportCodeChange();\n             return var;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n        if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n            return n;\n        }\n    }\n        tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(elseBranch.detachFromParent());\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -60,8 +60,8 @@\n                     }\n                 }\n             }\n+            return n;\n         }\n-        return n;\n     }\n         tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n@@ -69,7 +69,7 @@\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n         n.replaceChild(cond, cond.removeFirstChild());\n         n.removeChild(thenBranch);\n-        n.addChildToBack(thenBranch);\n+        n.addChildToBack(elseBranch.detachFromParent());\n         reportCodeChange();\n         return n;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties.\n                return n;\n            }\n            if (cond.isNot()) {\n                Node innerFirstChild = expr.getFirstChild();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(innerFirstChild, OR_PRECEDENCE)) {\n                    Node or = IR.or(cond.removeFirstChild(), innerFirstChild).srcref(n);\n                    Node newExpr = NodeUtil.newExpr(or);\n                    parent.replaceChild(n, newExpr);\n                    reportCodeChange();\n                    return newExpr;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                Node and = IR.and(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(and);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n    tryRemoveRepeatedStatements(n);\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        n.removeChild(cond);\n        Node thenExpr = thenOp.detachFromParent();\n        Node elseExpr = elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -10,30 +10,30 @@\n         if (isFoldableExpressBlock(thenBranch)) {\n             Node expr = getBlockExpression(thenBranch);\n             if (!late && isPropertyAssignmentInExpression(expr)) {\n-                // Keep opportunities for CollapseProperties such as\n-                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-                // until CollapseProperties has been run.\n+                // Keep opportunities for CollapseProperties.\n                 return n;\n             }\n             if (cond.isNot()) {\n-                // if(!x)bar(); -> x||bar();\n-                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n-                    // It's not okay to add two sets of parentheses.\n-                    return n;\n+                Node innerFirstChild = expr.getFirstChild();\n+                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(innerFirstChild, OR_PRECEDENCE)) {\n+                    Node or = IR.or(cond.removeFirstChild(), innerFirstChild).srcref(n);\n+                    Node newExpr = NodeUtil.newExpr(or);\n+                    parent.replaceChild(n, newExpr);\n+                    reportCodeChange();\n+                    return newExpr;\n                 }\n-                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n+                Node or = IR.or(cond.removeFirstChild(), expr).srcref(n);\n                 Node newExpr = NodeUtil.newExpr(or);\n                 parent.replaceChild(n, newExpr);\n                 reportCodeChange();\n                 return newExpr;\n             }\n-            // if(x)foo(); -> x&&foo();\n             if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n-                // One additional set of parentheses is worth the change even if\n-                // there is no immediate code size win. However, two extra pair of\n-                // {}, we would have to think twice. (unless we know for sure the\n-                // we can further optimize its parent.\n-                return n;\n+                Node and = IR.and(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n+                Node newExpr = NodeUtil.newExpr(and);\n+                parent.replaceChild(n, newExpr);\n+                reportCodeChange();\n+                return newExpr;\n             }\n             n.removeChild(cond);\n             Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n@@ -42,7 +42,6 @@\n             reportCodeChange();\n             return newExpr;\n         } else {\n-            // Try to combine two IF-ELSE\n             if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                 Node innerIf = thenBranch.getFirstChild();\n                 if (innerIf.isIf()) {\n@@ -54,8 +53,6 @@\n                         n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                         n.addChildrenToBack(innerThenBranch.detachFromParent());\n                         reportCodeChange();\n-                        // Not worth trying to fold the current IF-ELSE into && because\n-                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                         return n;\n                     }\n                 }\n@@ -63,9 +60,7 @@\n         }\n         return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n+    tryRemoveRepeatedStatements(n);\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n         n.replaceChild(cond, cond.removeFirstChild());\n         n.removeChild(thenBranch);\n@@ -73,16 +68,12 @@\n         reportCodeChange();\n         return n;\n     }\n-    // if(x)return 1;else return 2; -> return x?1:2;\n     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n         Node thenExpr = getBlockReturnExpression(thenBranch);\n         Node elseExpr = getBlockReturnExpression(elseBranch);\n         n.removeChild(cond);\n         thenExpr.detachFromParent();\n         elseExpr.detachFromParent();\n-        // note - we ignore any cases with \"return;\", technically this\n-        // can be converted to \"return undefined;\" or some variant, but\n-        // that does not help code size.\n         Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n         parent.replaceChild(n, returnNode);\n         reportCodeChange();\n@@ -94,19 +85,13 @@\n         Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n         Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n         if (thenOp.getType() == elseOp.getType()) {\n-            // if(x)a=1;else a=2; -> a=x?1:2;\n             if (NodeUtil.isAssignmentOp(thenOp)) {\n                 Node lhs = thenOp.getFirstChild();\n-                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n-                // evaluates LHS before cond]\n-                // NOTE - there are some circumstances where we can\n-                // proceed even if there are side effects...\n-                !mayEffectMutableState(lhs)) {\n+                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {\n                     n.removeChild(cond);\n                     Node assignName = thenOp.removeFirstChild();\n                     Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n+                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                     Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                     Node expr = NodeUtil.newExpr(assign);\n@@ -116,18 +101,16 @@\n                 }\n             }\n         }\n-        // if(x)foo();else bar(); -> x?foo():bar()\n         n.removeChild(cond);\n-        thenOp.detachFromParent();\n-        elseOp.detachFromParent();\n-        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n+        Node thenExpr = thenOp.detachFromParent();\n+        Node elseExpr = elseOp.detachFromParent();\n+        Node expr = IR.exprResult(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n         parent.replaceChild(n, expr);\n         reportCodeChange();\n         return expr;\n     }\n     boolean thenBranchIsVar = isVarBlock(thenBranch);\n     boolean elseBranchIsVar = isVarBlock(elseBranch);\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n     if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n         Node var = getBlockVar(thenBranch);\n         Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n@@ -144,7 +127,6 @@\n             reportCodeChange();\n             return var;\n         }\n-        // if(x)y=1;else var y=2  ->  var y=x?1:2\n     } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n         Node var = getBlockVar(elseBranch);\n         Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n            return n;\n        }\n    }\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(elseBranch);\n        n.addChildToFront(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -60,16 +60,17 @@\n                     }\n                 }\n             }\n+            return n;\n         }\n-        return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n+    tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n         n.replaceChild(cond, cond.removeFirstChild());\n         n.removeChild(thenBranch);\n-        n.addChildToBack(thenBranch);\n+        n.addChildToBack(elseBranch);\n+        n.addChildToFront(thenBranch);\n         reportCodeChange();\n         return n;\n     }\n@@ -105,8 +106,7 @@\n                     n.removeChild(cond);\n                     Node assignName = thenOp.removeFirstChild();\n                     Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n+                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                     Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                     Node expr = NodeUtil.newExpr(assign);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -63,7 +63,7 @@\n         }\n         return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n+    tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n                return newExpr;\n            }\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pairs of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n                    if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n        }\n        return n;\n    }\n    tryRemoveRepeatedStatements(n);\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(elseBranch.detachFromParent());\n        reportCodeChange();\n        return n;\n    }\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == elseOp.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && // if LHS has side effects, don't proceed [since the optimization\n                // evaluates LHS before cond]\n                // NOTE - there are some circumstances where we can\n                // proceed even if there are side effects...\n                !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n                    return expr;\n                }\n            }\n        }\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenOp.detachFromParent();\n        elseOp.detachFromParent();\n        Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n    }\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n        // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryMinimizeIf\n@@ -1,7 +1,7 @@\n private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n     Node cond = n.getFirstChild();\n-        if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n         return n;\n     }\n     Node thenBranch = cond.getNext();\n@@ -30,7 +30,7 @@\n             // if(x)foo(); -> x&&foo();\n             if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                 // One additional set of parentheses is worth the change even if\n-                // there is no immediate code size win. However, two extra pair of\n+                // there is no immediate code size win. However, two extra pairs of\n                 // {}, we would have to think twice. (unless we know for sure the\n                 // we can further optimize its parent.\n                 return n;\n@@ -63,13 +63,13 @@\n         }\n         return n;\n     }\n-        tryRemoveRepeatedStatements(n);\n+    tryRemoveRepeatedStatements(n);\n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n         n.replaceChild(cond, cond.removeFirstChild());\n         n.removeChild(thenBranch);\n-        n.addChildToBack(thenBranch);\n+        n.addChildToBack(elseBranch.detachFromParent());\n         reportCodeChange();\n         return n;\n     }\n@@ -105,8 +105,7 @@\n                     n.removeChild(cond);\n                     Node assignName = thenOp.removeFirstChild();\n                     Node thenExpr = thenOp.removeFirstChild();\n-                    Node elseExpr = elseOp.getLastChild();\n-                    elseOp.removeChild(elseExpr);\n+                    Node elseExpr = elseOp.getLastChild().detachFromParent();\n                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                     Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                     Node expr = NodeUtil.newExpr(assign);\n", "finish_reason": "stop", "valid": false, "num": 1}]