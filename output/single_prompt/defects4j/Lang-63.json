[{"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        int maxDays = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        days += maxDays - start.get(Calendar.DAY_OF_MONTH) + 1;\n        months -= 1;\n        start.add(Calendar.MONTH, 1);\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,13 +36,10 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        int maxDays = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        days += maxDays - start.get(Calendar.DAY_OF_MONTH) + 1;\n         months -= 1;\n+        start.add(Calendar.MONTH, 1);\n     }\n     while (months < 0) {\n         months += 12;\n@@ -64,7 +61,7 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        end.add(Calendar.MONTH, -1);\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        end.add(field, difference);\n        return startValue - endValue;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,12 +36,8 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        end.add(Calendar.MONTH, -1);\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -1,11 +1,10 @@\n static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n-    end.add(field, -1 * difference);\n+    end.add(field, -difference);\n     int endValue = end.get(field);\n     int startValue = start.get(field);\n     if (endValue < startValue) {\n-        int newdiff = startValue - endValue;\n-        end.add(field, newdiff);\n-        return newdiff;\n+        end.add(field, difference);\n+        return startValue - endValue;\n     } else {\n         return 0;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        // Fixing the calculation of days difference between two dates.\n        // While adding the end date, add the time of day as well, \n        // so that if the end time is before the start time, that time is not counted as a day difference\n        end.add(Calendar.DAY_OF_MONTH, -1);\n        days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,13 +36,12 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n-        months -= 1;\n+        // Fixing the calculation of days difference between two dates.\n+        // While adding the end date, add the time of day as well, \n+        // so that if the end time is before the start time, that time is not counted as a day difference\n+        end.add(Calendar.DAY_OF_MONTH, -1);\n+        days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n+        months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n     }\n     while (months < 0) {\n         months += 12;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n        end.add(Calendar.MONTH, -1);\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n\n    end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            end = Calendar.getInstance(timezone);\n            end.setTimeInMillis(endMillis);\n\n            long endTime = end.getTimeInMillis() + timezone.getOffset(end.getTimeInMillis());\n            long startTime = start.getTimeInMillis() + timezone.getOffset(start.getTimeInMillis());\n            long diff = endTime-startTime;\n            days = (int) (diff / DateUtils.MILLIS_PER_DAY);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff;\n        if (field == Calendar.MONTH) {\n            newdiff = 1;\n            end.add(field, -newdiff);\n        } else if (field == Calendar.HOUR_OF_DAY) {\n            newdiff = 24;\n            end.add(field, -newdiff);\n        } else if (field == Calendar.DAY_OF_MONTH) {\n            newdiff = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n            end.add(field, -newdiff);\n        } else {\n            newdiff = startValue - endValue;\n            end.add(field, newdiff);\n        }\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,18 +36,18 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n+        end.add(Calendar.MONTH, -1);\n     }\n     while (months < 0) {\n         months += 12;\n         years -= 1;\n     }\n+\n+    end = Calendar.getInstance(timezone);\n+    end.setTimeInMillis(endMillis);\n+\n     milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n     seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n     minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n@@ -55,6 +55,7 @@\n     days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n     months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n     years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n+\n     // This next block of code adds in values that\n     // aren't requested. This allows the user to ask for the\n     // number of months and get the real count and not just 0->11.\n@@ -63,8 +64,13 @@\n             months += 12 * years;\n             years = 0;\n         } else {\n-            // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            end = Calendar.getInstance(timezone);\n+            end.setTimeInMillis(endMillis);\n+\n+            long endTime = end.getTimeInMillis() + timezone.getOffset(end.getTimeInMillis());\n+            long startTime = start.getTimeInMillis() + timezone.getOffset(start.getTimeInMillis());\n+            long diff = endTime-startTime;\n+            days = (int) (diff / DateUtils.MILLIS_PER_DAY);\n             years = 0;\n         }\n     }\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -3,8 +3,20 @@\n     int endValue = end.get(field);\n     int startValue = start.get(field);\n     if (endValue < startValue) {\n-        int newdiff = startValue - endValue;\n-        end.add(field, newdiff);\n+        int newdiff;\n+        if (field == Calendar.MONTH) {\n+            newdiff = 1;\n+            end.add(field, -newdiff);\n+        } else if (field == Calendar.HOUR_OF_DAY) {\n+            newdiff = 24;\n+            end.add(field, -newdiff);\n+        } else if (field == Calendar.DAY_OF_MONTH) {\n+            newdiff = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+            end.add(field, -newdiff);\n+        } else {\n+            newdiff = startValue - endValue;\n+            end.add(field, newdiff);\n+        }\n         return newdiff;\n     } else {\n         return 0;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        // days += 31;\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH)\n                    - start.get(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, -newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,12 +36,9 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        // days += 31;\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH)\n+                    - start.get(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -64,7 +61,7 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -4,7 +4,7 @@\n     int startValue = start.get(field);\n     if (endValue < startValue) {\n         int newdiff = startValue - endValue;\n-        end.add(field, newdiff);\n+        end.add(field, -newdiff);\n         return newdiff;\n     } else {\n         return 0;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        end.add(Calendar.MONTH, -1);\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        start.add(field, -1);\n        int newdiff = end.getActualMaximum(field) - startValue + endValue;\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,12 +36,8 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        end.add(Calendar.MONTH, -1);\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -1,10 +1,10 @@\n static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n-    end.add(field, -1 * difference);\n+    end.add(field, -difference);\n     int endValue = end.get(field);\n     int startValue = start.get(field);\n     if (endValue < startValue) {\n-        int newdiff = startValue - endValue;\n-        end.add(field, newdiff);\n+        start.add(field, -1);\n+        int newdiff = end.getActualMaximum(field) - startValue + endValue;\n         return newdiff;\n     } else {\n         return 0;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        if (months == 1 && start.get(Calendar.MONTH) == 1 && end.get(Calendar.YEAR) == start.get(Calendar.YEAR) && end.get(Calendar.MONTH) == start.get(Calendar.MONTH) + 1){\n            days = 28;\n            // for checking if the year is leap year or not\n            int daysInFeb = 28;\n            if (end.get(Calendar.YEAR) % 4 == 0) {\n                daysInFeb = 29;\n            }\n            if (end.get(Calendar.YEAR) % 100 == 0 && end.get(Calendar.YEAR) % 400 != 0) {\n                daysInFeb = 28;\n            }\n            if (end.get(Calendar.MONTH) == 2 && end.get(Calendar.DAY_OF_MONTH) == daysInFeb && start.get(Calendar.DAY_OF_MONTH) == 31) {\n                days = 29;\n            }\n        } else {\n            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n        }\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,12 +36,22 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        if (months == 1 && start.get(Calendar.MONTH) == 1 && end.get(Calendar.YEAR) == start.get(Calendar.YEAR) && end.get(Calendar.MONTH) == start.get(Calendar.MONTH) + 1){\n+            days = 28;\n+            // for checking if the year is leap year or not\n+            int daysInFeb = 28;\n+            if (end.get(Calendar.YEAR) % 4 == 0) {\n+                daysInFeb = 29;\n+            }\n+            if (end.get(Calendar.YEAR) % 100 == 0 && end.get(Calendar.YEAR) % 400 != 0) {\n+                daysInFeb = 28;\n+            }\n+            if (end.get(Calendar.MONTH) == 2 && end.get(Calendar.DAY_OF_MONTH) == daysInFeb && start.get(Calendar.DAY_OF_MONTH) == 31) {\n+                days = 29;\n+            }\n+        } else {\n+            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        }\n         months -= 1;\n     }\n     while (months < 0) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        int maxDayInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        days += maxDayInMonth;\n        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n        // Also it's contextual - if asked for no M in the format then I should probably\n        // be doing no calculating here.\n        months -= 1;\n        end.set(Calendar.MONTH, end.get(Calendar.MONTH)-1);\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        end.add(field, 1);\n        return 1;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,13 +36,15 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n+        int maxDayInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        days += maxDayInMonth;\n         //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n         // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n         // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n         // Also it's contextual - if asked for no M in the format then I should probably\n         // be doing no calculating here.\n         months -= 1;\n+        end.set(Calendar.MONTH, end.get(Calendar.MONTH)-1);\n     }\n     while (months < 0) {\n         months += 12;\n@@ -64,7 +66,7 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -3,9 +3,8 @@\n     int endValue = end.get(field);\n     int startValue = start.get(field);\n     if (endValue < startValue) {\n-        int newdiff = startValue - endValue;\n-        end.add(field, newdiff);\n-        return newdiff;\n+        end.add(field, 1);\n+        return 1;\n     } else {\n         return 0;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        int maxDayOfMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        days += maxDayOfMonth;\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        if(field == Calendar.MONTH) {\n            end.add(Calendar.MONTH, 1);\n        } else {\n            end.add(field, newdiff);\n        }\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,12 +36,8 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        int maxDayOfMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        days += maxDayOfMonth;\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -64,7 +60,7 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -4,7 +4,11 @@\n     int startValue = start.get(field);\n     if (endValue < startValue) {\n         int newdiff = startValue - endValue;\n-        end.add(field, newdiff);\n+        if(field == Calendar.MONTH) {\n+            end.add(Calendar.MONTH, 1);\n+        } else {\n+            end.add(field, newdiff);\n+        }\n         return newdiff;\n     } else {\n         return 0;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        // days += 31; // TODO: Need tests to show this is bad and the new code is good.\n        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n        // Also it's contextual - if asked for no M in the format then I should probably\n        // be doing no calculating here.\n        int maxDay = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        days += maxDay - start.get(Calendar.DAY_OF_MONTH) + 1;\n        start.add(Calendar.MONTH, 1);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += (int) ((endMillis- startMillis)/(24*60*60*1000));   // 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,12 +36,14 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n+        // days += 31; // TODO: Need tests to show this is bad and the new code is good.\n         // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n         // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n         // Also it's contextual - if asked for no M in the format then I should probably\n         // be doing no calculating here.\n+        int maxDay = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        days += maxDay - start.get(Calendar.DAY_OF_MONTH) + 1;\n+        start.add(Calendar.MONTH, 1);\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -52,7 +54,6 @@\n     seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n     minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n     hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n-    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n     months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n     years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n     // This next block of code adds in values that\n@@ -64,7 +65,7 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += (int) ((endMillis- startMillis)/(24*60*60*1000));   // 365 * years;\n             years = 0;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n        if (Token.containsTokenWithValue(tokens, Token.M)) {\n            months += years * 12;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        end.add(field, difference);\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,12 +36,7 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -58,33 +53,33 @@\n     // This next block of code adds in values that\n     // aren't requested. This allows the user to ask for the\n     // number of months and get the real count and not just 0->11.\n-    if (!Token.containsTokenWithValue(tokens, y)) {\n-        if (Token.containsTokenWithValue(tokens, M)) {\n-            months += 12 * years;\n+    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n+        if (Token.containsTokenWithValue(tokens, Token.M)) {\n+            months += years * 12;\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n-    if (!Token.containsTokenWithValue(tokens, M)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n         days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n         months = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, d)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n         hours += 24 * days;\n         days = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, H)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n         minutes += 60 * hours;\n         hours = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, m)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n         seconds += 60 * minutes;\n         minutes = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, s)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n         milliseconds += 1000 * seconds;\n         seconds = 0;\n     }\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -7,6 +7,7 @@\n         end.add(field, newdiff);\n         return newdiff;\n     } else {\n+        end.add(field, difference);\n         return 0;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n        if (Token.containsTokenWithValue(tokens, Token.M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        end.add(field, difference);\n        return startValue - endValue;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,12 +36,7 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -58,33 +53,33 @@\n     // This next block of code adds in values that\n     // aren't requested. This allows the user to ask for the\n     // number of months and get the real count and not just 0->11.\n-    if (!Token.containsTokenWithValue(tokens, y)) {\n-        if (Token.containsTokenWithValue(tokens, M)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n+        if (Token.containsTokenWithValue(tokens, Token.M)) {\n             months += 12 * years;\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n-    if (!Token.containsTokenWithValue(tokens, M)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n         days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n         months = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, d)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n         hours += 24 * days;\n         days = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, H)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n         minutes += 60 * hours;\n         hours = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, m)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n         seconds += 60 * minutes;\n         minutes = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, s)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n         milliseconds += 1000 * seconds;\n         seconds = 0;\n     }\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -1,11 +1,10 @@\n static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n-    end.add(field, -1 * difference);\n+    end.add(field, -difference);\n     int endValue = end.get(field);\n     int startValue = start.get(field);\n     if (endValue < startValue) {\n-        int newdiff = startValue - endValue;\n-        end.add(field, newdiff);\n-        return newdiff;\n+        end.add(field, difference);\n+        return startValue - endValue;\n     } else {\n         return 0;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n        end.add(Calendar.MONTH, -1);\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that aren't requested.\n    // This allows the user to ask for the number of months\n    // and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            int startYear = start.get(Calendar.YEAR);\n            int endYear = end.get(Calendar.YEAR);\n            if (start.get(Calendar.MONTH) > end.get(Calendar.MONTH)) {\n                endYear--;\n            }\n            days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            days += end.get(Calendar.DAY_OF_YEAR);\n            if (startYear != endYear) {\n                days += (endYear - startYear - 1) * 365;\n                days += countLeapDays(startYear, endYear);\n            }\n            years = 0;\n        }\n    } else {\n        if (!Token.containsTokenWithValue(tokens, M) && !Token.containsTokenWithValue(tokens, d)) {\n            int startYear = start.get(Calendar.YEAR);\n            int endYear = end.get(Calendar.YEAR);\n            int startDayOfYear = start.get(Calendar.DAY_OF_YEAR);\n            int endDayOfYear = end.get(Calendar.DAY_OF_YEAR);\n            if (startYear != endYear) {\n                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - startDayOfYear;\n                days += endDayOfYear;\n                days += (endYear - startYear - 1) * 365;\n                days += countLeapDays(startYear, endYear);\n            } else {\n                days += endDayOfYear - startDayOfYear;\n            }\n            months = 0;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}\n\n// Helper function for fixing Bug 1\nprivate static int countLeapDays(int startYear, int endYear) {\n    int count = 0;\n    for (int i = startYear; i < endYear; i++) {\n        if (isLeap(i)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nprivate static boolean isLeap(int year) {\n    if (year % 400 == 0) {\n        return true;\n    } else if (year % 100 == 0) {\n        return false;\n    } else {\n        return year % 4 == 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,13 +36,9 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n+        end.add(Calendar.MONTH, -1);\n     }\n     while (months < 0) {\n         months += 12;\n@@ -55,16 +51,42 @@\n     days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n     months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n     years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n-    // This next block of code adds in values that\n-    // aren't requested. This allows the user to ask for the\n-    // number of months and get the real count and not just 0->11.\n+    // This next block of code adds in values that aren't requested.\n+    // This allows the user to ask for the number of months\n+    // and get the real count and not just 0->11.\n     if (!Token.containsTokenWithValue(tokens, y)) {\n         if (Token.containsTokenWithValue(tokens, M)) {\n             months += 12 * years;\n             years = 0;\n         } else {\n-            // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            int startYear = start.get(Calendar.YEAR);\n+            int endYear = end.get(Calendar.YEAR);\n+            if (start.get(Calendar.MONTH) > end.get(Calendar.MONTH)) {\n+                endYear--;\n+            }\n+            days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+            days += end.get(Calendar.DAY_OF_YEAR);\n+            if (startYear != endYear) {\n+                days += (endYear - startYear - 1) * 365;\n+                days += countLeapDays(startYear, endYear);\n+            }\n+            years = 0;\n+        }\n+    } else {\n+        if (!Token.containsTokenWithValue(tokens, M) && !Token.containsTokenWithValue(tokens, d)) {\n+            int startYear = start.get(Calendar.YEAR);\n+            int endYear = end.get(Calendar.YEAR);\n+            int startDayOfYear = start.get(Calendar.DAY_OF_YEAR);\n+            int endDayOfYear = end.get(Calendar.DAY_OF_YEAR);\n+            if (startYear != endYear) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - startDayOfYear;\n+                days += endDayOfYear;\n+                days += (endYear - startYear - 1) * 365;\n+                days += countLeapDays(startYear, endYear);\n+            } else {\n+                days += endDayOfYear - startDayOfYear;\n+            }\n+            months = 0;\n             years = 0;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        // days += 31;  <-- Remove this line\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH); // <-- Add this line\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    Calendar tempEnd = (Calendar) end.clone(); // create a new copy of end to avoid modifying the input parameter\n    tempEnd.add(field, -1 * difference);\n    int endValue = tempEnd.get(field); // get the value from the temporary end variable\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int maximum = tempEnd.getActualMaximum(field); // get the actual maximum value for the given field\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff + maximum); // add the maximum value\n        return newdiff + maximum;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,12 +36,8 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        // days += 31;  <-- Remove this line\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH); // <-- Add this line\n         months -= 1;\n     }\n     while (months < 0) {\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -1,11 +1,13 @@\n static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n-    end.add(field, -1 * difference);\n-    int endValue = end.get(field);\n+    Calendar tempEnd = (Calendar) end.clone(); // create a new copy of end to avoid modifying the input parameter\n+    tempEnd.add(field, -1 * difference);\n+    int endValue = tempEnd.get(field); // get the value from the temporary end variable\n     int startValue = start.get(field);\n     if (endValue < startValue) {\n+        int maximum = tempEnd.getActualMaximum(field); // get the actual maximum value for the given field\n         int newdiff = startValue - endValue;\n-        end.add(field, newdiff);\n-        return newdiff;\n+        end.add(field, newdiff + maximum); // add the maximum value\n+        return newdiff + maximum;\n     } else {\n         return 0;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n        if (Token.containsTokenWithValue(tokens, Token.M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,12 +36,7 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -58,33 +53,33 @@\n     // This next block of code adds in values that\n     // aren't requested. This allows the user to ask for the\n     // number of months and get the real count and not just 0->11.\n-    if (!Token.containsTokenWithValue(tokens, y)) {\n-        if (Token.containsTokenWithValue(tokens, M)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n+        if (Token.containsTokenWithValue(tokens, Token.M)) {\n             months += 12 * years;\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n-    if (!Token.containsTokenWithValue(tokens, M)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n         days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n         months = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, d)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n         hours += 24 * days;\n         days = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, H)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n         minutes += 60 * hours;\n         hours = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, m)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n         seconds += 60 * minutes;\n         minutes = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, s)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n         milliseconds += 1000 * seconds;\n         seconds = 0;\n     }\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -1,5 +1,5 @@\n static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n-    end.add(field, -1 * difference);\n+    end.add(field, -difference);\n     int endValue = end.get(field);\n     int startValue = start.get(field);\n     if (endValue < startValue) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        int daysInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        days += daysInMonth;\n        months -= 1;\n        end.add(Calendar.MONTH, -1);\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int max = end.getActualMaximum(field);\n        int newdiff = max - startValue + endValue + 1;\n        end.add(field, -newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,13 +36,10 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        int daysInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        days += daysInMonth;\n         months -= 1;\n+        end.add(Calendar.MONTH, -1);\n     }\n     while (months < 0) {\n         months += 12;\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -3,8 +3,9 @@\n     int endValue = end.get(field);\n     int startValue = start.get(field);\n     if (endValue < startValue) {\n-        int newdiff = startValue - endValue;\n-        end.add(field, newdiff);\n+        int max = end.getActualMaximum(field);\n+        int newdiff = max - startValue + endValue + 1;\n+        end.add(field, -newdiff);\n         return newdiff;\n     } else {\n         return 0;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        int maxDaysInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        days += maxDaysInMonth;\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        int maxDaysInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        days += maxDaysInMonth - start.get(Calendar.DAY_OF_MONTH) + 1;\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        if (field == Calendar.MONTH) {\n            end.add(Calendar.MONTH, newdiff);\n            if (end.get(Calendar.MONTH) < start.get(Calendar.MONTH)) {\n                int days = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n                end.set(Calendar.DAY_OF_MONTH, days);\n                return newdiff - 1;\n            }\n        } else {\n            end.add(field, newdiff);\n        }\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,12 +36,8 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        int maxDaysInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        days += maxDaysInMonth;\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -69,7 +65,8 @@\n         }\n     }\n     if (!Token.containsTokenWithValue(tokens, M)) {\n-        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+        int maxDaysInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        days += maxDaysInMonth - start.get(Calendar.DAY_OF_MONTH) + 1;\n         months = 0;\n     }\n     if (!Token.containsTokenWithValue(tokens, d)) {\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -1,10 +1,19 @@\n static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n-    end.add(field, -1 * difference);\n+    end.add(field, -difference);\n     int endValue = end.get(field);\n     int startValue = start.get(field);\n     if (endValue < startValue) {\n         int newdiff = startValue - endValue;\n-        end.add(field, newdiff);\n+        if (field == Calendar.MONTH) {\n+            end.add(Calendar.MONTH, newdiff);\n+            if (end.get(Calendar.MONTH) < start.get(Calendar.MONTH)) {\n+                int days = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                end.set(Calendar.DAY_OF_MONTH, days);\n+                return newdiff - 1;\n+            }\n+        } else {\n+            end.add(field, newdiff);\n+        }\n         return newdiff;\n     } else {\n         return 0;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        // days += 31;\n        // Fixed this line by using the right amount of days in the current month and also taking into account leap years.\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        start.add(Calendar.MONTH, 1);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        end.add(field, difference);\n        return difference;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,12 +36,10 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        // days += 31;\n+        // Fixed this line by using the right amount of days in the current month and also taking into account leap years.\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        start.add(Calendar.MONTH, 1);\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -64,8 +62,8 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n-            years = 0;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+            months = 0;\n         }\n     }\n     if (!Token.containsTokenWithValue(tokens, M)) {\n--- org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@reduceAndCorrect\n@@ -7,6 +7,7 @@\n         end.add(field, newdiff);\n         return newdiff;\n     } else {\n-        return 0;\n+        end.add(field, difference);\n+        return difference;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n    // ADDED to avoid months with different number of days\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        end.add(Calendar.MONTH, -1);\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -18,7 +18,8 @@\n     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n-    // each initial estimate is adjusted in case it is under 0\n+\n+    // ADDED to avoid months with different number of days\n     while (milliseconds < 0) {\n         milliseconds += 1000;\n         seconds -= 1;\n@@ -36,18 +37,15 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        end.add(Calendar.MONTH, -1);\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n         months += 12;\n         years -= 1;\n     }\n+\n     milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n     seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n     minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n@@ -55,6 +53,7 @@\n     days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n     months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n     years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n+\n     // This next block of code adds in values that\n     // aren't requested. This allows the user to ask for the\n     // number of months and get the real count and not just 0->11.\n@@ -64,7 +63,7 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n        end.add(Calendar.MONTH, -1);\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\n## Fixed Function 2\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,13 +36,9 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n+        end.add(Calendar.MONTH, -1);\n     }\n     while (months < 0) {\n         months += 12;\n@@ -64,7 +60,7 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}]