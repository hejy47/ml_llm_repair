[{"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            // Check if the type needs to be specialized\n            if ((_baseType != null) && !_baseType.hasRawClass(type.getRawClass())) {\n                // If so, construct the specialized type\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,11 +17,9 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n+            // Check if the type needs to be specialized\n+            if ((_baseType != null) && !_baseType.hasRawClass(type.getRawClass())) {\n+                // If so, construct the specialized type\n                 type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        synchronized(this) {\n            deser = _deserializers.get(typeId);\n            if (deser == null) { // double-checked locking\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n                if (type == null) {\n                    // As per [JACKSON-614], use the default impl if no type id available:\n                    deser = _findDefaultImplDeserializer(ctxt);\n                    if (deser == null) {\n                        // 10-May-2016, tatu: We may get some help...\n                        JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                        if (actual == null) {\n                            // what should this be taken to mean?\n                            // TODO: try to figure out something better\n                            return null;\n                        }\n                        // ... would this actually work?\n                        deser = ctxt.findContextualValueDeserializer(actual, _property);\n                    }\n                } else {\n                    if ((_baseType != null) && (_baseType.getClass().equals(type.getClass()))) {\n                        // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                        //   generic type with custom type resolvers. If so, should try to retain them.\n                        //  Whether this is sufficient to avoid problems remains to be seen, but for\n                        //  now it should improve things.\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                    }\n                    deser = ctxt.findContextualValueDeserializer(type, _property);\n                }\n                _deserializers.put(typeId, deser);\n            }\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,32 +1,37 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n+        synchronized(this) {\n+            deser = _deserializers.get(typeId);\n+            if (deser == null) { // double-checked locking\n                 JavaType type = _idResolver.typeFromId(ctxt, typeId);\n-        if (type == null) {\n-            // As per [JACKSON-614], use the default impl if no type id available:\n-            deser = _findDefaultImplDeserializer(ctxt);\n-            if (deser == null) {\n-                // 10-May-2016, tatu: We may get some help...\n-                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n-                if (actual == null) {\n-                    // what should this be taken to mean?\n-                    // TODO: try to figure out something better\n-                    return null;\n+                if (type == null) {\n+                    // As per [JACKSON-614], use the default impl if no type id available:\n+                    deser = _findDefaultImplDeserializer(ctxt);\n+                    if (deser == null) {\n+                        // 10-May-2016, tatu: We may get some help...\n+                        JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n+                        if (actual == null) {\n+                            // what should this be taken to mean?\n+                            // TODO: try to figure out something better\n+                            return null;\n+                        }\n+                        // ... would this actually work?\n+                        deser = ctxt.findContextualValueDeserializer(actual, _property);\n+                    }\n+                } else {\n+                    if ((_baseType != null) && (_baseType.getClass().equals(type.getClass()))) {\n+                        // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+                        //   generic type with custom type resolvers. If so, should try to retain them.\n+                        //  Whether this is sufficient to avoid problems remains to be seen, but for\n+                        //  now it should improve things.\n+                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+                    }\n+                    deser = ctxt.findContextualValueDeserializer(type, _property);\n                 }\n-                // ... would this actually work?\n-                deser = ctxt.findContextualValueDeserializer(actual, _property);\n+                _deserializers.put(typeId, deser);\n             }\n-        } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n-            }\n-            deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    synchronized(this) {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser != null) {\n            return deser;\n        }\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n        return deser;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,32 +1,19 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n-    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n-    if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+    synchronized(this) {\n+        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n+        if (deser != null) {\n+            return deser;\n+        }\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n-            // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n-            if (deser == null) {\n-                // 10-May-2016, tatu: We may get some help...\n-                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n-                if (actual == null) {\n-                    // what should this be taken to mean?\n-                    // TODO: try to figure out something better\n-                    return null;\n-                }\n-                // ... would this actually work?\n-                deser = ctxt.findContextualValueDeserializer(actual, _property);\n-            }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                 type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n         _deserializers.put(typeId, deser);\n+        return deser;\n     }\n-    return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JavaType type = _idResolver.typeFromId(ctxt, typeId);\n    if (type == null) {\n        // As per [JACKSON-614], use the default impl if no type id available:\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser == null) {\n            // 10-May-2016, tatu: We may get some help...\n            JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            if (actual == null) {\n                // what should this be taken to mean?\n                // TODO: try to figure out something better\n                return null;\n            }\n            // ... would this actually work?\n            deser = ctxt.findContextualValueDeserializer(actual, _property);\n        }\n        return deser;\n    }\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n            // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n            //   generic type with custom type resolvers. If so, should try to retain them.\n            //  Whether this is sufficient to avoid problems remains to be seen, but for\n            //  now it should improve things.\n            type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n        }\n        deser = ctxt.findContextualValueDeserializer(type, _property);\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,31 +1,31 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n+    JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+    if (type == null) {\n+        // As per [JACKSON-614], use the default impl if no type id available:\n+        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n+        if (deser == null) {\n+            // 10-May-2016, tatu: We may get some help...\n+            JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n+            if (actual == null) {\n+                // what should this be taken to mean?\n+                // TODO: try to figure out something better\n+                return null;\n+            }\n+            // ... would this actually work?\n+            deser = ctxt.findContextualValueDeserializer(actual, _property);\n+        }\n+        return deser;\n+    }\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n-        if (type == null) {\n-            // As per [JACKSON-614], use the default impl if no type id available:\n-            deser = _findDefaultImplDeserializer(ctxt);\n-            if (deser == null) {\n-                // 10-May-2016, tatu: We may get some help...\n-                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n-                if (actual == null) {\n-                    // what should this be taken to mean?\n-                    // TODO: try to figure out something better\n-                    return null;\n-                }\n-                // ... would this actually work?\n-                deser = ctxt.findContextualValueDeserializer(actual, _property);\n-            }\n-        } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n-            }\n-            deser = ctxt.findContextualValueDeserializer(type, _property);\n+        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+            // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            //   generic type with custom type resolvers. If so, should try to retain them.\n+            //  Whether this is sufficient to avoid problems remains to be seen, but for\n+            //  now it should improve things.\n+            type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n         }\n+        deser = ctxt.findContextualValueDeserializer(type, _property);\n         _deserializers.put(typeId, deser);\n     }\n     return deser;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if (_baseType != null && _baseType.getClass().equals(type.getClass())) {\n                // Check if the base type has a mismatch with the incoming type. If so, convert\n                // the incoming type.\n                if (_baseType.hasGenericTypes() != type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructParametricType(\n                        _baseType.getRawClass(), type.getBindings());\n                } else if (_baseType.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type);\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,12 +17,15 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+            if (_baseType != null && _baseType.getClass().equals(type.getClass())) {\n+                // Check if the base type has a mismatch with the incoming type. If so, convert\n+                // the incoming type.\n+                if (_baseType.hasGenericTypes() != type.hasGenericTypes()) {\n+                    type = ctxt.getTypeFactory().constructParametricType(\n+                        _baseType.getRawClass(), type.getBindings());\n+                } else if (_baseType.hasGenericTypes()) {\n+                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type);\n+                }\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if (_baseType != null && _baseType.getClass().equals(type.getClass())) {\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getBindings());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,12 +17,8 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+            if (_baseType != null && _baseType.getClass().equals(type.getClass())) {\n+                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getBindings());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && (_baseType.getClass() == type.getClass())) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                // generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            // fixing the bug where the wrong context was used\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        // fixing the bug where the deserializer was not added to the cache\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,16 +17,20 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n+            if ((_baseType != null) && (_baseType.getClass() == type.getClass())) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+                // generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n                 type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n             }\n+            // fixing the bug where the wrong context was used\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        // fixing the bug where the deserializer was not added to the cache\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    throw JsonMappingException.from(ctxt, \"No value type configured for type ID '\" +\n                            typeId + \"' (for instance because mapper directly extends `ObjectMapper` instead of `JsonMapper`): can not deserialize\");\n                }\n                if (_baseType != null && _baseType.getClass() == actual.getClass()) {\n                    type = actual.withStaticTyping();\n                } else {\n                    type = ctxt.getTypeFactory().constructType(actual, _baseType);\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n        } else {\n            if (_baseType != null && _baseType.getClass() == type.getClass()) {\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,17 +11,18 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // TODO: try to figure out something better\n-                    return null;\n+                    throw JsonMappingException.from(ctxt, \"No value type configured for type ID '\" +\n+                            typeId + \"' (for instance because mapper directly extends `ObjectMapper` instead of `JsonMapper`): can not deserialize\");\n                 }\n-                // ... would this actually work?\n-                deser = ctxt.findContextualValueDeserializer(actual, _property);\n+                if (_baseType != null && _baseType.getClass() == actual.getClass()) {\n+                    type = actual.withStaticTyping();\n+                } else {\n+                    type = ctxt.getTypeFactory().constructType(actual, _baseType);\n+                }\n+                deser = ctxt.findContextualValueDeserializer(type, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n+            if (_baseType != null && _baseType.getClass() == type.getClass()) {\n                 type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    throw new JsonMappingException(\"Can not find a deserializer for non-existent type id: \" + typeId);\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && (_baseType.getClass() == type.getClass())) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                // generic type with custom type resolvers. If so, should try to retain them.\n                // Whether this is sufficient to avoid problems remains to be seen, but for\n                // now it should improve things.\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,22 +11,24 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // TODO: try to figure out something better\n-                    return null;\n+                    throw new JsonMappingException(\"Can not find a deserializer for non-existent type id: \" + typeId);\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n+            if ((_baseType != null) && (_baseType.getClass() == type.getClass())) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+                // generic type with custom type resolvers. If so, should try to retain them.\n+                // Whether this is sufficient to avoid problems remains to be seen, but for\n+                // now it should improve things.\n                 type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if (_baseType != null && _baseType.getClass().equals(type.getClass())) {\n                // As per [databind#1270], we may actually get full\n                // generic type with custom type resolvers. If so, should try to retain them.\n                // Whether this is sufficient to avoid problems remains to be seen, but for\n                // now, it should improve things.\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,16 +17,18 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n+            if (_baseType != null && _baseType.getClass().equals(type.getClass())) {\n+                // As per [databind#1270], we may actually get full\n+                // generic type with custom type resolvers. If so, should try to retain them.\n+                // Whether this is sufficient to avoid problems remains to be seen, but for\n+                // now, it should improve things.\n                 type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findValueDeserializer(actual);\n            }\n        } else {\n            //resolved specific subtype for given typeId, use it for deserialization\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            //cache deserializer for future use\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -14,19 +14,16 @@\n                     return null;\n                 }\n                 // ... would this actually work?\n-                deser = ctxt.findContextualValueDeserializer(actual, _property);\n+                deser = ctxt.findValueDeserializer(actual);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n-            }\n+            //resolved specific subtype for given typeId, use it for deserialization\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            //cache deserializer for future use\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && (_baseType.getClass() == type.getClass())) {\n                type = _idResolver.typeFromId(ctxt, _idResolver.idFromValueAndType(null, _baseType));\n                type = ctxt.getTypeFactory().constructSpecializedType(type, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,12 +17,9 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+            if ((_baseType != null) && (_baseType.getClass() == type.getClass())) {\n+                type = _idResolver.typeFromId(ctxt, _idResolver.idFromValueAndType(null, _baseType));\n+                type = ctxt.getTypeFactory().constructSpecializedType(type, type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && (_baseType.getClass() == type.getClass())) {\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        // 18-Jul-2016, tatu: Let's cache the value (but not for the dynamic case tho)\n        if (_typeIdVisible) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,16 +17,15 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+            if ((_baseType != null) && (_baseType.getClass() == type.getClass())) {\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        // 18-Jul-2016, tatu: Let's cache the value (but not for the dynamic case tho)\n+        if (_typeIdVisible) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, null);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, null);\n        }\n        if (deser != null) { // sanity check, to avoid NPEs later on\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -14,19 +14,21 @@\n                     return null;\n                 }\n                 // ... would this actually work?\n-                deser = ctxt.findContextualValueDeserializer(actual, _property);\n+                deser = ctxt.findContextualValueDeserializer(actual, null);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n                 type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n             }\n-            deser = ctxt.findContextualValueDeserializer(type, _property);\n+            deser = ctxt.findContextualValueDeserializer(type, null);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) { // sanity check, to avoid NPEs later on\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && (_baseType.getRawClass() == type.getRawClass())) {\n                // If the base type is the same as the actual type, use the base type instead\n                // This avoids issues with custom type resolvers.\n                type = _baseType;\n            } else {\n                // Create a specialized type from the base type and the actual type.\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,11 +17,12 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n+            if ((_baseType != null) && (_baseType.getRawClass() == type.getRawClass())) {\n+                // If the base type is the same as the actual type, use the base type instead\n+                // This avoids issues with custom type resolvers.\n+                type = _baseType;\n+            } else {\n+                // Create a specialized type from the base type and the actual type.\n                 type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            // check if the type is subtype of baseType\n            if (_baseType != null && _baseType.getClass().equals(type.getClass())) {\n                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,12 +17,9 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+            // check if the type is subtype of baseType\n+            if (_baseType != null && _baseType.getClass().equals(type.getClass())) {\n+                type = _baseType.narrowBy(type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType == null) || !_baseType.hasGenericTypes()) {\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            } else {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                JavaType fullType = ctxt.getTypeFactory().constructSpecializedType(_baseType, type);\n                deser = ctxt.findContextualValueDeserializer(fullType, _property);\n            }\n        }\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,16 +17,20 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType == null) || !_baseType.hasGenericTypes()) {\n+                deser = ctxt.findContextualValueDeserializer(type, _property);\n+            } else {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n-                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+                JavaType fullType = ctxt.getTypeFactory().constructSpecializedType(_baseType, type);\n+                deser = ctxt.findContextualValueDeserializer(fullType, _property);\n             }\n-            deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if (_baseType != null && type.getRawClass() != null && _baseType.getRawClass() == type.getRawClass()) {\n                // If types are the same, set deserializer to base type deserializer \n                deserializer = ctxt.findContextualValueDeserializer(_baseType, _property);\n            } else {\n                // Using `constructSpecializedType` ensures that custom type resolvers aren't lost.\n                type = ctxt.constructSpecializedType(_baseType, type);\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,14 +17,14 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+            if (_baseType != null && type.getRawClass() != null && _baseType.getRawClass() == type.getRawClass()) {\n+                // If types are the same, set deserializer to base type deserializer \n+                deserializer = ctxt.findContextualValueDeserializer(_baseType, _property);\n+            } else {\n+                // Using `constructSpecializedType` ensures that custom type resolvers aren't lost.\n+                type = ctxt.constructSpecializedType(_baseType, type);\n+                deser = ctxt.findContextualValueDeserializer(type, _property);\n             }\n-            deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n         _deserializers.put(typeId, deser);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && (_baseType.getClass() == type.getClass())) {\n                // As per [databind#1270], we may actually get a full generic type with custom type resolvers.\n                // In such cases, the approach is to retain them.\n                // Whether this is sufficient to avoid problems remains to be seen, but for now it should improve things.\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,11 +17,10 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n+            if ((_baseType != null) && (_baseType.getClass() == type.getClass())) {\n+                // As per [databind#1270], we may actually get a full generic type with custom type resolvers.\n+                // In such cases, the approach is to retain them.\n+                // Whether this is sufficient to avoid problems remains to be seen, but for now it should improve things.\n                 type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if (_baseType != null && type.getRawClass() != null && _baseType.getClass() == type.getClass()) {\n                // Check to see if cached deserializer defined under _baseType -> clazz can be returned.\n                deser = _deserializers.get(_idResolver.idFromBaseType()) + type.getRawClass().getName());\n            }\n            if(deser == null){\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n                _deserializers.put(typeId, deser);\n            }\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // As per [JACKSON-614], use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,16 +17,15 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+            if (_baseType != null && type.getRawClass() != null && _baseType.getClass() == type.getClass()) {\n+                // Check to see if cached deserializer defined under _baseType -> clazz can be returned.\n+                deser = _deserializers.get(_idResolver.idFromBaseType()) + type.getRawClass().getName());\n             }\n-            deser = ctxt.findContextualValueDeserializer(type, _property);\n+            if(deser == null){\n+                deser = ctxt.findContextualValueDeserializer(type, _property);\n+                _deserializers.put(typeId, deser);\n+            }\n         }\n-        _deserializers.put(typeId, deser);\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]