[{"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        if (len > 0 && Character.isSurrogate(buf[len2 - 1])) {\n            len2--;\n            offset++;\n        }\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n        // yes, outside of BMP\n        // Do we have second part?\n        char c2 = cbuf[inputOffset];\n        if (Character.isSurrogatePair(ch, c2)) {\n            // Output the pair, using helper method that does bounds-checking:\n            _outputSurrogates(ch, c2);\n            return inputOffset + 1;\n        }\n        // No second part, report an error:\n        _reportError(\"Incomplete surrogate pair at end of String or char array\");\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,9 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        if (len > 0 && Character.isSurrogate(buf[len2 - 1])) {\n+            len2--;\n+            offset++;\n+        }\n     }\n }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,16 +1,16 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n+        // yes, outside of BMP\n+        // Do we have second part?\n+        char c2 = cbuf[inputOffset];\n+        if (Character.isSurrogatePair(ch, c2)) {\n+            // Output the pair, using helper method that does bounds-checking:\n+            _outputSurrogates(ch, c2);\n             return inputOffset + 1;\n         }\n+        // No second part, report an error:\n+        _reportError(\"Incomplete surrogate pair at end of String or char array\");\n     }\n     final byte[] bbuf = _outputBuffer;\n     bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    int offset2 = offset;\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset2, offset2 + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        offset2 += len2;\n        len -= len2;\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset + 1 < inputEnd) {\n        // outside of BMP, with another char after it\n        inputOffset++;\n        _outputSurrogates(ch, cbuf[inputOffset]);\n    } else {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    }\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -1,17 +1,12 @@\n @Override\n public void writeRaw(String text, int offset, int len) throws IOException {\n     final char[] buf = _charBuffer;\n-    // minor optimization: see if we can just get and copy\n-    // If not, need segmented approach. For speed, let's also use input buffer\n-    // size that is guaranteed to fit in output buffer; each char can expand to\n-    // at most 3 bytes, so at most 1/3 of buffer size.\n+    int offset2 = offset;\n     while (len > 0) {\n         int len2 = Math.min(buf.length, len);\n-        text.getChars(offset, offset + len2, buf, 0);\n+        text.getChars(offset2, offset2 + len2, buf, 0);\n         writeRaw(buf, 0, len2);\n-        // If this is NOT the last segment and if the last character looks like\n-        // split surrogate second half, drop it\n-        offset += len2;\n+        offset2 += len2;\n         len -= len2;\n     }\n }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,20 +1,14 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n-        }\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset + 1 < inputEnd) {\n+        // outside of BMP, with another char after it\n+        inputOffset++;\n+        _outputSurrogates(ch, cbuf[inputOffset]);\n+    } else {\n+        final byte[] bbuf = _outputBuffer;\n+        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n+        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n     }\n-    final byte[] bbuf = _outputBuffer;\n-    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n-    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n-    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n     return inputOffset;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        // fix: clear the character buffer after each iteration to avoid writing leftover characters\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = '\\0';\n        }\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST) {\n        if (ch <= SURR2_LAST) {\n            // yes, outside of BMP\n            // Do we have second part?\n            if (inputOffset >= inputEnd || cbuf == null) {\n                // nope... have to note down\n                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n            } else {\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset + 1;\n            }\n        }\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,9 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        // fix: clear the character buffer after each iteration to avoid writing leftover characters\n+        for (int i = 0; i < buf.length; i++) {\n+            buf[i] = '\\0';\n+        }\n     }\n }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -7,9 +7,10 @@\n             if (inputOffset >= inputEnd || cbuf == null) {\n                 // nope... have to note down\n                 _reportError(\"Split surrogate on writeRaw() input (last character)\");\n+            } else {\n+                _outputSurrogates(ch, cbuf[inputOffset]);\n+                return inputOffset + 1;\n             }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n         }\n     }\n     final byte[] bbuf = _outputBuffer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        // FIX: Clear the character buffer after each iteration\n        Arrays.fill(buf, '\\0');\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST) {\n        if (ch <= SURR2_LAST) {\n            // yes, outside of BMP\n            // Do we have second part?\n            if (inputOffset >= inputEnd || cbuf == null) {\n                // nope... have to note down\n                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n                // FIX: return inputOffset instead of throwing an error\n                return inputOffset;\n            }\n            _outputSurrogates(ch, cbuf[inputOffset]);\n            return inputOffset + 1;\n        }\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,7 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        // FIX: Clear the character buffer after each iteration\n+        Arrays.fill(buf, '\\0');\n     }\n }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -7,6 +7,8 @@\n             if (inputOffset >= inputEnd || cbuf == null) {\n                 // nope... have to note down\n                 _reportError(\"Split surrogate on writeRaw() input (last character)\");\n+                // FIX: return inputOffset instead of throwing an error\n+                return inputOffset;\n             }\n             _outputSurrogates(ch, cbuf[inputOffset]);\n             return inputOffset + 1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if (len2 < len && Character.isSurrogate(buf[len2 - 1])) {\n            len2--;\n        }\n        offset += len2;\n        len -= len2;\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n        // yes, outside of BMP\n        // Do we have second part?\n        char c2 = cbuf[inputOffset];\n        if (c2 >= SURR2_FIRST && c2 <= SURR2_LAST) {\n            // second part is valid\n            _outputSurrogates(ch, c2);\n            return inputOffset + 1;\n        }\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -11,6 +11,9 @@\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n+        if (len2 < len && Character.isSurrogate(buf[len2 - 1])) {\n+            len2--;\n+        }\n         offset += len2;\n         len -= len2;\n     }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,14 +1,12 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n+        // yes, outside of BMP\n+        // Do we have second part?\n+        char c2 = cbuf[inputOffset];\n+        if (c2 >= SURR2_FIRST && c2 <= SURR2_LAST) {\n+            // second part is valid\n+            _outputSurrogates(ch, c2);\n             return inputOffset + 1;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if (len2 < len && Character.isHighSurrogate(text.charAt(offset + len2 - 1))) {\n            len2--;\n        }\n        offset += len2;\n        len -= len2;\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n        // yes, outside of BMP\n        // Do we have second part?\n        final int ch2 = cbuf[inputOffset];\n        if (ch2 >= SURR2_FIRST && ch2 <= SURR2_LAST) {\n            if (inputOffset + 1 >= inputEnd) {\n                // nope... have to note down\n                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n            }\n            _outputSurrogates(ch, ch2);\n            return inputOffset + 2;\n        }\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -11,6 +11,9 @@\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n+        if (len2 < len && Character.isHighSurrogate(text.charAt(offset + len2 - 1))) {\n+            len2--;\n+        }\n         offset += len2;\n         len -= len2;\n     }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,15 +1,16 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n+        // yes, outside of BMP\n+        // Do we have second part?\n+        final int ch2 = cbuf[inputOffset];\n+        if (ch2 >= SURR2_FIRST && ch2 <= SURR2_LAST) {\n+            if (inputOffset + 1 >= inputEnd) {\n                 // nope... have to note down\n                 _reportError(\"Split surrogate on writeRaw() input (last character)\");\n             }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n+            _outputSurrogates(ch, ch2);\n+            return inputOffset + 2;\n         }\n     }\n     final byte[] bbuf = _outputBuffer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if (len2 < len) {\n            char lastChar = text.charAt(offset + len2 - 1);\n            if (Character.isSurrogate(lastChar)) {\n                len2--;\n            }\n        }\n        offset += len2;\n        len -= len2;\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST) {\n        // yes, outside of BMP\n        // Do we have second part?\n        if (inputOffset >= inputEnd || cbuf == null) {\n            // nope... have to note down\n            _reportError(\"Split surrogate on writeRaw() input (last character)\");\n        } else {\n            _outputSurrogates(ch, cbuf[inputOffset]);\n            return inputOffset + 1;\n        }\n    } else {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    }\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -2,15 +2,19 @@\n public void writeRaw(String text, int offset, int len) throws IOException {\n     final char[] buf = _charBuffer;\n     // minor optimization: see if we can just get and copy\n-    // If not, need segmented approach. For speed, let's also use input buffer\n-    // size that is guaranteed to fit in output buffer; each char can expand to\n-    // at most 3 bytes, so at most 1/3 of buffer size.\n+    // If not, need segmented approach.\n     while (len > 0) {\n         int len2 = Math.min(buf.length, len);\n         text.getChars(offset, offset + len2, buf, 0);\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n+        if (len2 < len) {\n+            char lastChar = text.charAt(offset + len2 - 1);\n+            if (Character.isSurrogate(lastChar)) {\n+                len2--;\n+            }\n+        }\n         offset += len2;\n         len -= len2;\n     }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,20 +1,20 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST) {\n+        // yes, outside of BMP\n+        // Do we have second part?\n+        if (inputOffset >= inputEnd || cbuf == null) {\n+            // nope... have to note down\n+            _reportError(\"Split surrogate on writeRaw() input (last character)\");\n+        } else {\n             _outputSurrogates(ch, cbuf[inputOffset]);\n             return inputOffset + 1;\n         }\n+    } else {\n+        final byte[] bbuf = _outputBuffer;\n+        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n+        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n     }\n-    final byte[] bbuf = _outputBuffer;\n-    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n-    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n-    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n     return inputOffset;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        if (len > 0 && Character.isSurrogate(buf[len2 - 1])) {\n            len2--;\n            writeRaw(buf, len2, 1);\n        }\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST) {\n        if (ch <= SURR2_LAST) {\n            // yes, outside of BMP\n            // Do we have second part?\n            if (inputOffset >= inputEnd || cbuf == null) {\n                // nope... have to note down\n                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n            } else {\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset + 1;\n            }\n        }\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,9 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        if (len > 0 && Character.isSurrogate(buf[len2 - 1])) {\n+            len2--;\n+            writeRaw(buf, len2, 1);\n+        }\n     }\n }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -7,9 +7,10 @@\n             if (inputOffset >= inputEnd || cbuf == null) {\n                 // nope... have to note down\n                 _reportError(\"Split surrogate on writeRaw() input (last character)\");\n+            } else {\n+                _outputSurrogates(ch, cbuf[inputOffset]);\n+                return inputOffset + 1;\n             }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n         }\n     }\n     final byte[] bbuf = _outputBuffer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n    }\n    // make sure to flush after writing all segments\n    flush();\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n        // yes, outside of BMP and we have second part\n        inputOffset++;\n        _outputSurrogates(ch, cbuf[inputOffset - 1]);\n    } else {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    }\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -14,4 +14,6 @@\n         offset += len2;\n         len -= len2;\n     }\n+    // make sure to flush after writing all segments\n+    flush();\n }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,20 +1,14 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n-        }\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n+        // yes, outside of BMP and we have second part\n+        inputOffset++;\n+        _outputSurrogates(ch, cbuf[inputOffset - 1]);\n+    } else {\n+        final byte[] bbuf = _outputBuffer;\n+        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n+        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n     }\n-    final byte[] bbuf = _outputBuffer;\n-    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n-    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n-    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n     return inputOffset;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR1_LAST && inputOffset < inputEnd) {\n        int ch2 = cbuf[inputOffset++];\n        if (ch2 >= SURR2_FIRST && ch2 <= SURR2_LAST) {\n            ch = _convertSurrogate(ch, ch2);\n        } else {\n            _reportError(\"Incomplete surrogate pair\");\n        }\n    }\n    final byte[] bbuf = _outputBuffer;\n    if (ch < 0x80) {\n        bbuf[_outputTail++] = (byte) ch;\n    } else if (ch < 0x800) {\n        bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    } else if (ch <= 0xffff) {\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    } else {\n        bbuf[_outputTail++] = (byte) (0xf0 | (ch >> 18));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    }\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,20 +1,28 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n+    if (ch >= SURR1_FIRST && ch <= SURR1_LAST && inputOffset < inputEnd) {\n+        int ch2 = cbuf[inputOffset++];\n+        if (ch2 >= SURR2_FIRST && ch2 <= SURR2_LAST) {\n+            ch = _convertSurrogate(ch, ch2);\n+        } else {\n+            _reportError(\"Incomplete surrogate pair\");\n         }\n     }\n     final byte[] bbuf = _outputBuffer;\n-    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n-    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n-    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n+    if (ch < 0x80) {\n+        bbuf[_outputTail++] = (byte) ch;\n+    } else if (ch < 0x800) {\n+        bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n+        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n+    } else if (ch <= 0xffff) {\n+        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n+        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n+    } else {\n+        bbuf[_outputTail++] = (byte) (0xf0 | (ch >> 18));\n+        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n+        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n+    }\n     return inputOffset;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        if (len > 0 && Character.isHighSurrogate(buf[len2 - 1])) {\n            // We have split surrogate; better just skip it now\n            --len;\n        }\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST) {\n        // yes, outside of BMP\n        // Do we have second part?\n        if (inputOffset >= inputEnd || cbuf == null) {\n            // nope... have to note down\n            _reportError(\"Split surrogate on writeRaw() input (last character)\");\n        }\n        _outputSurrogates(ch, cbuf[inputOffset]);\n        return inputOffset + 1;\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,9 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        if (len > 0 && Character.isHighSurrogate(buf[len2 - 1])) {\n+            // We have split surrogate; better just skip it now\n+            --len;\n+        }\n     }\n }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,16 +1,14 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST) {\n+        // yes, outside of BMP\n+        // Do we have second part?\n+        if (inputOffset >= inputEnd || cbuf == null) {\n+            // nope... have to note down\n+            _reportError(\"Split surrogate on writeRaw() input (last character)\");\n         }\n+        _outputSurrogates(ch, cbuf[inputOffset]);\n+        return inputOffset + 1;\n     }\n     final byte[] bbuf = _outputBuffer;\n     bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if (len2 < len) {\n            char lastChar = text.charAt(offset + len2 - 1);\n            if (Character.isHighSurrogate(lastChar)) {\n                // drop the last character\n                len2--;\n            }\n        }\n        offset += len2;\n        len -= len2;\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST) {\n        // yes, outside of BMP\n        // Do we have second part?\n        if (inputOffset >= inputEnd || cbuf == null) {\n            // nope... have to note down\n            _reportError(\"Split surrogate on writeRaw() input (last character)\");\n        } else {\n            _outputSurrogates(ch, cbuf[inputOffset]);\n            return inputOffset + 1;\n        }\n    } else {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    }\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -11,6 +11,13 @@\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n+        if (len2 < len) {\n+            char lastChar = text.charAt(offset + len2 - 1);\n+            if (Character.isHighSurrogate(lastChar)) {\n+                // drop the last character\n+                len2--;\n+            }\n+        }\n         offset += len2;\n         len -= len2;\n     }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,20 +1,20 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST) {\n+        // yes, outside of BMP\n+        // Do we have second part?\n+        if (inputOffset >= inputEnd || cbuf == null) {\n+            // nope... have to note down\n+            _reportError(\"Split surrogate on writeRaw() input (last character)\");\n+        } else {\n             _outputSurrogates(ch, cbuf[inputOffset]);\n             return inputOffset + 1;\n         }\n+    } else {\n+        final byte[] bbuf = _outputBuffer;\n+        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n+        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n     }\n-    final byte[] bbuf = _outputBuffer;\n-    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n-    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n-    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n     return inputOffset;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if (len2 < len && Character.isSurrogate(buf[len2 - 1])) {\n            --len2;\n        }\n        offset += len2;\n        len -= len2;\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n        // yes, outside of BMP\n        // Do we have second part?\n        int next = (int) cbuf[inputOffset++];\n        if (next < SURR2_FIRST || next > SURR2_LAST) {\n            _reportError(\"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(ch)+\", second 0x\"+Integer.toHexString(next));\n        }\n        ch = ((ch - SURR1_FIRST) << 10) + (next - SURR2_FIRST) + 0x10000;\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -11,6 +11,9 @@\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n+        if (len2 < len && Character.isSurrogate(buf[len2 - 1])) {\n+            --len2;\n+        }\n         offset += len2;\n         len -= len2;\n     }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,16 +1,13 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n+        // yes, outside of BMP\n+        // Do we have second part?\n+        int next = (int) cbuf[inputOffset++];\n+        if (next < SURR2_FIRST || next > SURR2_LAST) {\n+            _reportError(\"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(ch)+\", second 0x\"+Integer.toHexString(next));\n         }\n+        ch = ((ch - SURR1_FIRST) << 10) + (next - SURR2_FIRST) + 0x10000;\n     }\n     final byte[] bbuf = _outputBuffer;\n     bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR1_LAST) {\n        // Check if the second part is in the buffer\n        if (inputOffset + 1 >= inputEnd || cbuf == null) {\n            // nope... have to note down\n            _reportError(\"Split surrogate on writeRaw() input (last character)\");\n        } else {\n            char second = cbuf[inputOffset + 1];\n            // Is the second part a low surrogate?\n            if (second >= SURR2_FIRST && second <= SURR2_LAST) {\n                _outputSurrogates(ch, second);\n                return inputOffset + 2;\n            } else {\n                // Invalid surrogate pair\n                _reportError(\"Incomplete surrogate pair at writeRaw() input (last character)\");\n            }\n        }\n    } else if (ch >= SURR2_FIRST && ch <= SURR2_LAST) {\n        // Invalid second part in buffer\n        _reportError(\"Incomplete surrogate pair at writeRaw() input (first character)\");\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset + 1;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,20 +1,28 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n+    if (ch >= SURR1_FIRST && ch <= SURR1_LAST) {\n+        // Check if the second part is in the buffer\n+        if (inputOffset + 1 >= inputEnd || cbuf == null) {\n+            // nope... have to note down\n+            _reportError(\"Split surrogate on writeRaw() input (last character)\");\n+        } else {\n+            char second = cbuf[inputOffset + 1];\n+            // Is the second part a low surrogate?\n+            if (second >= SURR2_FIRST && second <= SURR2_LAST) {\n+                _outputSurrogates(ch, second);\n+                return inputOffset + 2;\n+            } else {\n+                // Invalid surrogate pair\n+                _reportError(\"Incomplete surrogate pair at writeRaw() input (last character)\");\n             }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n         }\n+    } else if (ch >= SURR2_FIRST && ch <= SURR2_LAST) {\n+        // Invalid second part in buffer\n+        _reportError(\"Incomplete surrogate pair at writeRaw() input (first character)\");\n     }\n     final byte[] bbuf = _outputBuffer;\n     bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n     bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n     bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n-    return inputOffset;\n+    return inputOffset + 1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        if (len > 0 && Character.isHighSurrogate(buf[len2 - 1])) {\n            len2--; // drop partial surrogate\n        }\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n        // yes, outside of BMP\n        // Do we have second part?\n        int ch2 = cbuf[inputOffset];\n        if (ch2 > SURR2_LAST || ch2 < SURR2_FIRST) {\n            // nope... have to note down\n            _reportError(\"Incomplete surrogate pair: first char 0x\" \n                    + Integer.toHexString(ch) \n                    + \", second 0x\" + Integer.toHexString(ch2));\n        }\n        inputOffset++;\n        _outputSurrogates(ch, ch2);\n    } else {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    }\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,8 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        if (len > 0 && Character.isHighSurrogate(buf[len2 - 1])) {\n+            len2--; // drop partial surrogate\n+        }\n     }\n }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,20 +1,22 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n+        // yes, outside of BMP\n+        // Do we have second part?\n+        int ch2 = cbuf[inputOffset];\n+        if (ch2 > SURR2_LAST || ch2 < SURR2_FIRST) {\n+            // nope... have to note down\n+            _reportError(\"Incomplete surrogate pair: first char 0x\" \n+                    + Integer.toHexString(ch) \n+                    + \", second 0x\" + Integer.toHexString(ch2));\n         }\n+        inputOffset++;\n+        _outputSurrogates(ch, ch2);\n+    } else {\n+        final byte[] bbuf = _outputBuffer;\n+        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n+        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n     }\n-    final byte[] bbuf = _outputBuffer;\n-    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n-    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n-    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n     return inputOffset;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR1_LAST && inputOffset + 1 < inputEnd) {\n        int ch2 = cbuf[inputOffset + 1];\n        if (ch2 >= SURR2_FIRST && ch2 <= SURR2_LAST) {\n            ch = _convertSurrogate(ch, ch2);\n            inputOffset += 2;\n            final byte[] bbuf = _outputBuffer;\n            bbuf[_outputTail++] = (byte) (0xf0 | (ch >> 18));\n            bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n            bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            return inputOffset;\n        } else {\n            _reportError(\"Incomplete surrogate pair\");\n        }\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}\n\nNote: The fixed version of Function 2 assumes the presence of some global constants, namely SURR1_FIRST, SURR1_LAST, SURR2_FIRST, and SURR2_LAST. These constants are used to check for incomplete surrogate pairs and to convert complete ones to UTF-8. The fixed version also assumes the presence of the private method _convertSurrogate, which converts a pair of surrogate characters to its corresponding UTF-8 code point.", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,15 +1,18 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n+    if (ch >= SURR1_FIRST && ch <= SURR1_LAST && inputOffset + 1 < inputEnd) {\n+        int ch2 = cbuf[inputOffset + 1];\n+        if (ch2 >= SURR2_FIRST && ch2 <= SURR2_LAST) {\n+            ch = _convertSurrogate(ch, ch2);\n+            inputOffset += 2;\n+            final byte[] bbuf = _outputBuffer;\n+            bbuf[_outputTail++] = (byte) (0xf0 | (ch >> 18));\n+            bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n+            bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n+            return inputOffset;\n+        } else {\n+            _reportError(\"Incomplete surrogate pair\");\n         }\n     }\n     final byte[] bbuf = _outputBuffer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        if (len > 0 && Character.isHighSurrogate(text.charAt(offset - 1))) {\n            --offset; // to include orphaned high surrogate into next chunk\n        }\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n        // Do we have second part?\n        char c2 = cbuf[inputOffset++];\n        if (c2 <= SURR2_LAST && c2 >= SURR2_FIRST) {\n            _outputSurrogates(ch, c2);\n            return inputOffset;\n        }\n        _reportError(\"Incomplete surrogate pair\");\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,8 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        if (len > 0 && Character.isHighSurrogate(text.charAt(offset - 1))) {\n+            --offset; // to include orphaned high surrogate into next chunk\n+        }\n     }\n }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,16 +1,13 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n-            return inputOffset + 1;\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n+        // Do we have second part?\n+        char c2 = cbuf[inputOffset++];\n+        if (c2 <= SURR2_LAST && c2 >= SURR2_FIRST) {\n+            _outputSurrogates(ch, c2);\n+            return inputOffset;\n         }\n+        _reportError(\"Incomplete surrogate pair\");\n     }\n     final byte[] bbuf = _outputBuffer;\n     bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if (len2 == buf.length && Character.isHighSurrogate(buf[len2 - 1])) {\n            --len2;\n        }\n        offset += len2;\n        len -= len2;\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST) {\n        // yes, outside of BMP\n        // Do we have second part?\n        if (inputOffset >= inputEnd || cbuf == null) {\n            // nope... have to note down\n            _reportError(\"Split surrogate on writeRaw() input (last character)\");\n        } else {\n            _outputSurrogates(ch, cbuf[inputOffset]);\n            return inputOffset + 1;\n        }\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -11,6 +11,9 @@\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n+        if (len2 == buf.length && Character.isHighSurrogate(buf[len2 - 1])) {\n+            --len2;\n+        }\n         offset += len2;\n         len -= len2;\n     }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,13 +1,12 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST) {\n+        // yes, outside of BMP\n+        // Do we have second part?\n+        if (inputOffset >= inputEnd || cbuf == null) {\n+            // nope... have to note down\n+            _reportError(\"Split surrogate on writeRaw() input (last character)\");\n+        } else {\n             _outputSurrogates(ch, cbuf[inputOffset]);\n             return inputOffset + 1;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        if (len > 0 && Character.isHighSurrogate(text.charAt(offset - 1))) {\n            // if we have another segment (len > 0) and the last character of previous\n            // segment is a high surrogate, drop it (incomplete surrogate pair)\n            --offset;\n        }\n    }\n}\n\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n        // yes, outside of BMP\n        // Do we have second part?\n        char ch2 = cbuf[inputOffset];\n        if (ch2 >= SURR2_FIRST && ch2 <= SURR2_LAST) {\n            _outputSurrogates(ch, ch2);\n            return inputOffset + 1;\n        }\n        else {\n            _reportError(\"Incomplete surrogate pair\");\n        }\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,10 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        if (len > 0 && Character.isHighSurrogate(text.charAt(offset - 1))) {\n+            // if we have another segment (len > 0) and the last character of previous\n+            // segment is a high surrogate, drop it (incomplete surrogate pair)\n+            --offset;\n+        }\n     }\n }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,15 +1,15 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n+        // yes, outside of BMP\n+        // Do we have second part?\n+        char ch2 = cbuf[inputOffset];\n+        if (ch2 >= SURR2_FIRST && ch2 <= SURR2_LAST) {\n+            _outputSurrogates(ch, ch2);\n             return inputOffset + 1;\n+        }\n+        else {\n+            _reportError(\"Incomplete surrogate pair\");\n         }\n     }\n     final byte[] bbuf = _outputBuffer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        if (len > 0 && Character.isHighSurrogate(text.charAt(offset))) {\n            if (len < 2) {\n                break;\n            }\n            char c2 = text.charAt(offset + 1);\n            if (!Character.isLowSurrogate(c2)) {\n                break;\n            }\n            len -= 2;\n            offset += 2;\n        }\n    }\n}\n\n## Fixed Function 2\nprivate final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n    // Let's handle surrogates gracefully (as 4 byte output):\n    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n        // Do we have second part?\n        char c2 = cbuf[inputOffset];\n        if (Character.isLowSurrogate(c2)) {\n            _outputSurrogates(ch, c2);\n            return inputOffset + 1;\n        } else {\n            _reportError(\"Unmatched surrogate pair on output\");\n        }\n    }\n    final byte[] bbuf = _outputBuffer;\n    bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n    bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n    bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n    return inputOffset;\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,16 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        if (len > 0 && Character.isHighSurrogate(text.charAt(offset))) {\n+            if (len < 2) {\n+                break;\n+            }\n+            char c2 = text.charAt(offset + 1);\n+            if (!Character.isLowSurrogate(c2)) {\n+                break;\n+            }\n+            len -= 2;\n+            offset += 2;\n+        }\n     }\n }\n--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@_outputRawMultiByteChar\n@@ -1,15 +1,13 @@\n private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {\n     // Let's handle surrogates gracefully (as 4 byte output):\n-    if (ch >= SURR1_FIRST) {\n-        if (ch <= SURR2_LAST) {\n-            // yes, outside of BMP\n-            // Do we have second part?\n-            if (inputOffset >= inputEnd || cbuf == null) {\n-                // nope... have to note down\n-                _reportError(\"Split surrogate on writeRaw() input (last character)\");\n-            }\n-            _outputSurrogates(ch, cbuf[inputOffset]);\n+    if (ch >= SURR1_FIRST && ch <= SURR2_LAST && inputOffset < inputEnd) {\n+        // Do we have second part?\n+        char c2 = cbuf[inputOffset];\n+        if (Character.isLowSurrogate(c2)) {\n+            _outputSurrogates(ch, c2);\n             return inputOffset + 1;\n+        } else {\n+            _reportError(\"Unmatched surrogate pair on output\");\n         }\n     }\n     final byte[] bbuf = _outputBuffer;\n", "finish_reason": "stop", "valid": false, "num": 1}]