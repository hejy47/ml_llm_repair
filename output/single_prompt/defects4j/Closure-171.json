[{"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n                if (NodeUtil.isLoopStructure(current)) {\n                    // Don't infer functions inside loops.\n                    return false;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    // Create a new syntactic scope for the object literal.\n    SyntacticScope objectScope = SyntacticScopeCreator.newObjectScope(n, scope.getSyntacticScope());\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope, objectScope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -17,6 +17,10 @@\n                 if (NodeUtil.isControlStructure(current)) {\n                     return true;\n                 }\n+                if (NodeUtil.isLoopStructure(current)) {\n+                    // Don't infer functions inside loops.\n+                    return false;\n+                }\n             }\n             // Check if this is assigned in an inner scope.\n             // Functions assigned in inner scopes are inferred.\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -1,8 +1,10 @@\n private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n     JSType type = n.getJSType();\n     Preconditions.checkNotNull(type);\n+    // Create a new syntactic scope for the object literal.\n+    SyntacticScope objectScope = SyntacticScopeCreator.newObjectScope(n, scope.getSyntacticScope());\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        scope = traverse(name.getFirstChild(), scope);\n+        scope = traverse(name.getFirstChild(), scope, objectScope);\n     }\n     // Object literals can be reflected on other types.\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!n.isFromExterns() && !scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        JSType valueType = name.getFirstChild().getJSType();\n        scope = traverse(name.getFirstChild(), scope);\n        if (name.isGetterDef() || name.isSetterDef()) {\n            continue;\n        }\n        String propName = NodeUtil.getObjectLitKeyName(name);\n        if (propName == null) {\n            continue;\n        }\n        ObjectType objType = ObjectType.cast(type);\n        // Object literals can be reflected on other types.\n        // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n        // Ignore these types of literals.\n        boolean hasLendsName = n.getJSDocInfo() != null &&\n            n.getJSDocInfo().getLendsName() != null;\n        if (objType != null && (objType.hasReferenceName() || hasLendsName)) {\n            objType.defineInferredProperty(propName, valueType, name);\n        }\n        if (!n.isFromExterns()) {\n            String qPropName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n)) + \".\" + propName;\n            Var var = syntacticScope.getVar(qPropName);\n            JSType oldType = var == null ? null : var.getType();\n            scope.inferQualifiedSlot(name, qPropName,\n                oldType == null ? unknownType : oldType, valueType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -10,7 +10,7 @@\n     if (inferred && rhsValue != null && rhsValue.isFunction()) {\n         if (info != null) {\n             return false;\n-        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n+        } else if (!n.isFromExterns() && !scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n             // Check if this is in a conditional block.\n             // Functions assigned in conditional blocks are inferred.\n             for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -2,41 +2,30 @@\n     JSType type = n.getJSType();\n     Preconditions.checkNotNull(type);\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n+        JSType valueType = name.getFirstChild().getJSType();\n         scope = traverse(name.getFirstChild(), scope);\n-    }\n-    // Object literals can be reflected on other types.\n-    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n-    // Ignore these types of literals.\n-    ObjectType objectType = ObjectType.cast(type);\n-    if (objectType == null) {\n-        return scope;\n-    }\n-    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n-    if (objectType.hasReferenceName() && !hasLendsName) {\n-        return scope;\n-    }\n-    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n-    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        String memberName = NodeUtil.getObjectLitKeyName(name);\n-        if (memberName != null) {\n-            JSType rawValueType = name.getFirstChild().getJSType();\n-            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n-            if (valueType == null) {\n-                valueType = unknownType;\n-            }\n-            objectType.defineInferredProperty(memberName, valueType, name);\n-            // Do normal flow inference if this is a direct property assignment.\n-            if (qObjName != null && name.isStringKey()) {\n-                String qKeyName = qObjName + \".\" + memberName;\n-                Var var = syntacticScope.getVar(qKeyName);\n-                JSType oldType = var == null ? null : var.getType();\n-                if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n-                }\n-                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n-            }\n-        } else {\n-            n.setJSType(unknownType);\n+        if (name.isGetterDef() || name.isSetterDef()) {\n+            continue;\n+        }\n+        String propName = NodeUtil.getObjectLitKeyName(name);\n+        if (propName == null) {\n+            continue;\n+        }\n+        ObjectType objType = ObjectType.cast(type);\n+        // Object literals can be reflected on other types.\n+        // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n+        // Ignore these types of literals.\n+        boolean hasLendsName = n.getJSDocInfo() != null &&\n+            n.getJSDocInfo().getLendsName() != null;\n+        if (objType != null && (objType.hasReferenceName() || hasLendsName)) {\n+            objType.defineInferredProperty(propName, valueType, name);\n+        }\n+        if (!n.isFromExterns()) {\n+            String qPropName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n)) + \".\" + propName;\n+            Var var = syntacticScope.getVar(qPropName);\n+            JSType oldType = var == null ? null : var.getType();\n+            scope.inferQualifiedSlot(name, qPropName,\n+                oldType == null ? unknownType : oldType, valueType);\n         }\n     }\n     return scope;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!NodeUtil.isNameReference(n) && !NodeUtil.isGetProp(n)) {\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    JSDocInfo jsdoc = n.getJSDocInfo();\n    boolean inferringProperties = !hasLendsName && (jsdoc == null || jsdoc.getSuppressions() == null || !jsdoc.getSuppressions().contains(\"infer\"));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            if (inferringProperties) {\n                objectType.defineInferredProperty(memberName, valueType, name);\n            }\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else if (inferringProperties) {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -10,14 +10,7 @@\n     if (inferred && rhsValue != null && rhsValue.isFunction()) {\n         if (info != null) {\n             return false;\n-        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n-            // Check if this is in a conditional block.\n-            // Functions assigned in conditional blocks are inferred.\n-            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n-                if (NodeUtil.isControlStructure(current)) {\n-                    return true;\n-                }\n-            }\n+        } else if (!NodeUtil.isNameReference(n) && !NodeUtil.isGetProp(n)) {\n             // Check if this is assigned in an inner scope.\n             // Functions assigned in inner scopes are inferred.\n             AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -16,6 +16,8 @@\n         return scope;\n     }\n     String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n+    JSDocInfo jsdoc = n.getJSDocInfo();\n+    boolean inferringProperties = !hasLendsName && (jsdoc == null || jsdoc.getSuppressions() == null || !jsdoc.getSuppressions().contains(\"infer\"));\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n         String memberName = NodeUtil.getObjectLitKeyName(name);\n         if (memberName != null) {\n@@ -24,7 +26,9 @@\n             if (valueType == null) {\n                 valueType = unknownType;\n             }\n-            objectType.defineInferredProperty(memberName, valueType, name);\n+            if (inferringProperties) {\n+                objectType.defineInferredProperty(memberName, valueType, name);\n+            }\n             // Do normal flow inference if this is a direct property assignment.\n             if (qObjName != null && name.isStringKey()) {\n                 String qKeyName = qObjName + \".\" + memberName;\n@@ -35,7 +39,7 @@\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n-        } else {\n+        } else if (inferringProperties) {\n             n.setJSType(unknownType);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null && info.hasType()) { // Added Info Has Type Check\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            propertyName = objectType.getReferenceName() == null ? memberName : objectType.getReferenceName() + \".\" + memberName;\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -8,7 +8,7 @@\n         inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n     }\n     if (inferred && rhsValue != null && rhsValue.isFunction()) {\n-        if (info != null) {\n+        if (info != null && info.hasType()) { // Added Info Has Type Check\n             return false;\n         } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n             // Check if this is in a conditional block.\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -24,6 +24,7 @@\n             if (valueType == null) {\n                 valueType = unknownType;\n             }\n+            propertyName = objectType.getReferenceName() == null ? memberName : objectType.getReferenceName() + \".\" + memberName;\n             objectType.defineInferredProperty(memberName, valueType, name);\n             // Do normal flow inference if this is a direct property assignment.\n             if (qObjName != null && name.isStringKey()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName() && !NodeUtil.isLValue(n)) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            scope = traverse(name.getFirstChild(), scope);\n        }\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -10,7 +10,7 @@\n     if (inferred && rhsValue != null && rhsValue.isFunction()) {\n         if (info != null) {\n             return false;\n-        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n+        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName() && !NodeUtil.isLValue(n)) {\n             // Check if this is in a conditional block.\n             // Functions assigned in conditional blocks are inferred.\n             for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -2,7 +2,10 @@\n     JSType type = n.getJSType();\n     Preconditions.checkNotNull(type);\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        scope = traverse(name.getFirstChild(), scope);\n+        String memberName = NodeUtil.getObjectLitKeyName(name);\n+        if (memberName != null) {\n+            scope = traverse(name.getFirstChild(), scope);\n+        }\n     }\n     // Object literals can be reflected on other types.\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n@@ -31,7 +34,7 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null && info.hasType()) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null) {\n                    if (var.isTypeInferred() && oldType != null) {\n                        var.setType(oldType.getLeastSupertype(valueType));\n                        scope.inferQualifiedSlot(name, qKeyName, oldType, valueType);\n                    } else {\n                        scope.inferQualifiedSlot(name, qKeyName, valueType, null);\n                    }\n                }\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -8,7 +8,7 @@\n         inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n     }\n     if (inferred && rhsValue != null && rhsValue.isFunction()) {\n-        if (info != null) {\n+        if (info != null && info.hasType()) {\n             return false;\n         } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n             // Check if this is in a conditional block.\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -30,10 +30,14 @@\n                 String qKeyName = qObjName + \".\" + memberName;\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n-                if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                if (var != null) {\n+                    if (var.isTypeInferred() && oldType != null) {\n+                        var.setType(oldType.getLeastSupertype(valueType));\n+                        scope.inferQualifiedSlot(name, qKeyName, oldType, valueType);\n+                    } else {\n+                        scope.inferQualifiedSlot(name, qKeyName, valueType, null);\n+                    }\n                 }\n-                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n         } else {\n             n.setJSType(unknownType);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!n.isQualifiedName() && !scope.isDeclared(qName, false)) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(n);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -10,7 +10,7 @@\n     if (inferred && rhsValue != null && rhsValue.isFunction()) {\n         if (info != null) {\n             return false;\n-        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n+        } else if (!n.isQualifiedName() && !scope.isDeclared(qName, false)) {\n             // Check if this is in a conditional block.\n             // Functions assigned in conditional blocks are inferred.\n             for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -15,7 +15,7 @@\n     if (objectType.hasReferenceName() && !hasLendsName) {\n         return scope;\n     }\n-    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n+    String qObjName = NodeUtil.getBestLValueName(n);\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n         String memberName = NodeUtil.getObjectLitKeyName(name);\n         if (memberName != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !current.isScript() && !current.isFunction(); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(current.getParent());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);    \n    // Name analysis on the object literal\n    // is only done if it really is an object literal.\n    if (!type.isSubtypeOf(getNativeObjectType(ARRAY_TYPE))) {\n        for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n            if (!name.isQuotedString()) {\n                scope = traverse(name.getFirstChild(), scope);\n            }\n        }\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (oldType == null || var.isTypeInferred()) {\n                    var = scope.getVar(qKeyName);\n                    oldType = var == null ? null : var.getType();\n                    if (var != null && var.isTypeInferred() && oldType != null) {\n                        var.setType(oldType.getLeastSupertype(valueType));\n                    }\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -13,14 +13,14 @@\n         } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n             // Check if this is in a conditional block.\n             // Functions assigned in conditional blocks are inferred.\n-            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n+            for (Node current = n.getParent(); !current.isScript() && !current.isFunction(); current = current.getParent()) {\n                 if (NodeUtil.isControlStructure(current)) {\n                     return true;\n                 }\n             }\n             // Check if this is assigned in an inner scope.\n             // Functions assigned in inner scopes are inferred.\n-            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n+            AstFunctionContents contents = getFunctionAnalysisResults(current.getParent());\n             if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                 return false;\n             }\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -1,8 +1,14 @@\n private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n     JSType type = n.getJSType();\n-    Preconditions.checkNotNull(type);\n-    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        scope = traverse(name.getFirstChild(), scope);\n+    Preconditions.checkNotNull(type);    \n+    // Name analysis on the object literal\n+    // is only done if it really is an object literal.\n+    if (!type.isSubtypeOf(getNativeObjectType(ARRAY_TYPE))) {\n+        for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n+            if (!name.isQuotedString()) {\n+                scope = traverse(name.getFirstChild(), scope);\n+            }\n+        }\n     }\n     // Object literals can be reflected on other types.\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n@@ -30,8 +36,12 @@\n                 String qKeyName = qObjName + \".\" + memberName;\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n-                if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                if (oldType == null || var.isTypeInferred()) {\n+                    var = scope.getVar(qKeyName);\n+                    oldType = var == null ? null : var.getType();\n+                    if (var != null && var.isTypeInferred() && oldType != null) {\n+                        var.setType(oldType.getLeastSupertype(valueType));\n+                    }\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current) && current != rhsValue.getParent()) {\n                    // Additional check to ensure that this is not a function expression assigned in the current conditional block.\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            scope = traverse(name.getFirstChild(), scope);\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -14,7 +14,8 @@\n             // Check if this is in a conditional block.\n             // Functions assigned in conditional blocks are inferred.\n             for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n-                if (NodeUtil.isControlStructure(current)) {\n+                if (NodeUtil.isControlStructure(current) && current != rhsValue.getParent()) {\n+                    // Additional check to ensure that this is not a function expression assigned in the current conditional block.\n                     return true;\n                 }\n             }\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -2,7 +2,12 @@\n     JSType type = n.getJSType();\n     Preconditions.checkNotNull(type);\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        scope = traverse(name.getFirstChild(), scope);\n+        String memberName = NodeUtil.getObjectLitKeyName(name);\n+        if (memberName != null) {\n+            scope = traverse(name.getFirstChild(), scope);\n+        } else {\n+            n.setJSType(unknownType);\n+        }\n     }\n     // Object literals can be reflected on other types.\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n@@ -35,8 +40,6 @@\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n-        } else {\n-            n.setJSType(unknownType);\n         }\n     }\n     return scope;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(n.getScopeRoot());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope = scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -20,7 +20,7 @@\n             }\n             // Check if this is assigned in an inner scope.\n             // Functions assigned in inner scopes are inferred.\n-            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n+            AstFunctionContents contents = getFunctionAnalysisResults(n.getScopeRoot());\n             if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                 return false;\n             }\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -33,7 +33,7 @@\n                 if (var != null && var.isTypeInferred()) {\n                     var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                 }\n-                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n+                scope = scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n         } else {\n             n.setJSType(unknownType);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null && info.getReturnType() != null && !info.getReturnType().isUnknownType()) {\n            // If we have a known return type, then the function's qualified name is inferred.\n            // Otherwise, we check if the function is assigned in a conditional block or inner scope.\n            return true;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            if (objectType.isPropertyInherited(memberName)) {\n                objectType = objectType.toMaybeObjectType().getPropertyInferredType(memberName);\n                if (objectType == null) {\n                    objectType = ObjectType.cast(type);\n                }\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -8,8 +8,10 @@\n         inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n     }\n     if (inferred && rhsValue != null && rhsValue.isFunction()) {\n-        if (info != null) {\n-            return false;\n+        if (info != null && info.getReturnType() != null && !info.getReturnType().isUnknownType()) {\n+            // If we have a known return type, then the function's qualified name is inferred.\n+            // Otherwise, we check if the function is assigned in a conditional block or inner scope.\n+            return true;\n         } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n             // Check if this is in a conditional block.\n             // Functions assigned in conditional blocks are inferred.\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -1,12 +1,6 @@\n private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n     JSType type = n.getJSType();\n     Preconditions.checkNotNull(type);\n-    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        scope = traverse(name.getFirstChild(), scope);\n-    }\n-    // Object literals can be reflected on other types.\n-    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n-    // Ignore these types of literals.\n     ObjectType objectType = ObjectType.cast(type);\n     if (objectType == null) {\n         return scope;\n@@ -24,6 +18,12 @@\n             if (valueType == null) {\n                 valueType = unknownType;\n             }\n+            if (objectType.isPropertyInherited(memberName)) {\n+                objectType = objectType.toMaybeObjectType().getPropertyInferredType(memberName);\n+                if (objectType == null) {\n+                    objectType = ObjectType.cast(type);\n+                }\n+            }\n             objectType.defineInferredProperty(memberName, valueType, name);\n             // Do normal flow inference if this is a direct property assignment.\n             if (qObjName != null && name.isStringKey()) {\n@@ -31,7 +31,7 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null || n.getJSDocInfo() != null && n.getJSDocInfo().isConstructor()) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild() == null ? null : name.getFirstChild().getJSType();\n            JSType knownValueType = null;\n            if (rawValueType != null) {\n                knownValueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType, n.getJSDocInfo());\n            }\n            JSType inferredValueType = null;\n            if (knownValueType == null || knownValueType.isUnknownType()) {\n                inferredValueType = getTypeFromFragments(name.getFirstChild(), scope);\n                if (inferredValueType != null && inferredValueType.isEnumElementType()) {\n                    inferredValueType = null;\n                }\n            }\n            JSType valueType = knownValueType != null ? knownValueType : inferredValueType;\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -1,26 +1,27 @@\n private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n     JSType type = n.getJSType();\n     Preconditions.checkNotNull(type);\n-    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        scope = traverse(name.getFirstChild(), scope);\n-    }\n-    // Object literals can be reflected on other types.\n-    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n-    // Ignore these types of literals.\n     ObjectType objectType = ObjectType.cast(type);\n-    if (objectType == null) {\n-        return scope;\n-    }\n-    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n-    if (objectType.hasReferenceName() && !hasLendsName) {\n+    if (objectType == null || n.getJSDocInfo() != null && n.getJSDocInfo().isConstructor()) {\n         return scope;\n     }\n     String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n         String memberName = NodeUtil.getObjectLitKeyName(name);\n         if (memberName != null) {\n-            JSType rawValueType = name.getFirstChild().getJSType();\n-            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n+            JSType rawValueType = name.getFirstChild() == null ? null : name.getFirstChild().getJSType();\n+            JSType knownValueType = null;\n+            if (rawValueType != null) {\n+                knownValueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType, n.getJSDocInfo());\n+            }\n+            JSType inferredValueType = null;\n+            if (knownValueType == null || knownValueType.isUnknownType()) {\n+                inferredValueType = getTypeFromFragments(name.getFirstChild(), scope);\n+                if (inferredValueType != null && inferredValueType.isEnumElementType()) {\n+                    inferredValueType = null;\n+                }\n+            }\n+            JSType valueType = knownValueType != null ? knownValueType : inferredValueType;\n             if (valueType == null) {\n                 valueType = unknownType;\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    } else if (rhsValue != null && rhsValue.isFunction()) {\n        // Functions assigned to variables without type information are inferred.\n        inferred = !scope.isDeclared(qName, false) && n.isUnscopedQualifiedName();\n        if (inferred) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    if (type == null || (!ObjectType.cast(type).hasReferenceName() && (n.getJSDocInfo() == null || n.getJSDocInfo().getLendsName() == null))) {\n        for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n            scope = traverse(name.getFirstChild(), scope);\n        }\n    }\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType != null && objectType.hasReferenceName()) {\n        String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n        for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n            String memberName = NodeUtil.getObjectLitKeyName(name);\n            if (memberName != null) {\n                JSType rawValueType = name.getFirstChild().getJSType();\n                JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n                if (valueType == null) {\n                    valueType = unknownType;\n                }\n                objectType.defineInferredProperty(memberName, valueType, name);\n                // Do normal flow inference if this is a direct property assignment.\n                if (qObjName != null && name.isStringKey()) {\n                    String qKeyName = qObjName + \".\" + memberName;\n                    Var var = syntacticScope.getVar(qKeyName);\n                    JSType oldType = var == null ? null : var.getType();\n                    if (var != null && var.isTypeInferred()) {\n                        var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                    }\n                    scope = scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n                }\n            } else {\n                n.setJSType(unknownType);\n            }\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -6,11 +6,10 @@\n     boolean inferred = true;\n     if (info != null) {\n         inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n-        if (info != null) {\n-            return false;\n-        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n+    } else if (rhsValue != null && rhsValue.isFunction()) {\n+        // Functions assigned to variables without type information are inferred.\n+        inferred = !scope.isDeclared(qName, false) && n.isUnscopedQualifiedName();\n+        if (inferred) {\n             // Check if this is in a conditional block.\n             // Functions assigned in conditional blocks are inferred.\n             for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -1,42 +1,35 @@\n private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n     JSType type = n.getJSType();\n-    Preconditions.checkNotNull(type);\n-    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        scope = traverse(name.getFirstChild(), scope);\n+    if (type == null || (!ObjectType.cast(type).hasReferenceName() && (n.getJSDocInfo() == null || n.getJSDocInfo().getLendsName() == null))) {\n+        for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n+            scope = traverse(name.getFirstChild(), scope);\n+        }\n     }\n-    // Object literals can be reflected on other types.\n-    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n-    // Ignore these types of literals.\n     ObjectType objectType = ObjectType.cast(type);\n-    if (objectType == null) {\n-        return scope;\n-    }\n-    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n-    if (objectType.hasReferenceName() && !hasLendsName) {\n-        return scope;\n-    }\n-    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n-    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        String memberName = NodeUtil.getObjectLitKeyName(name);\n-        if (memberName != null) {\n-            JSType rawValueType = name.getFirstChild().getJSType();\n-            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n-            if (valueType == null) {\n-                valueType = unknownType;\n+    if (objectType != null && objectType.hasReferenceName()) {\n+        String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n+        for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n+            String memberName = NodeUtil.getObjectLitKeyName(name);\n+            if (memberName != null) {\n+                JSType rawValueType = name.getFirstChild().getJSType();\n+                JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n+                if (valueType == null) {\n+                    valueType = unknownType;\n+                }\n+                objectType.defineInferredProperty(memberName, valueType, name);\n+                // Do normal flow inference if this is a direct property assignment.\n+                if (qObjName != null && name.isStringKey()) {\n+                    String qKeyName = qObjName + \".\" + memberName;\n+                    Var var = syntacticScope.getVar(qKeyName);\n+                    JSType oldType = var == null ? null : var.getType();\n+                    if (var != null && var.isTypeInferred()) {\n+                        var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n+                    }\n+                    scope = scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n+                }\n+            } else {\n+                n.setJSType(unknownType);\n             }\n-            objectType.defineInferredProperty(memberName, valueType, name);\n-            // Do normal flow inference if this is a direct property assignment.\n-            if (qObjName != null && name.isStringKey()) {\n-                String qKeyName = qObjName + \".\" + memberName;\n-                Var var = syntacticScope.getVar(qKeyName);\n-                JSType oldType = var == null ? null : var.getType();\n-                if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n-                }\n-                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n-            }\n-        } else {\n-            n.setJSType(unknownType);\n         }\n     }\n     return scope;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null && info.hasType()) { // additional condition to fix bug\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = null; // added line to fix bug\n    if (NodeUtil.isObjectLitObject(n)) { // added condition to fix bug\n        qObjName = NodeUtil.getObjectLitKeyName(n);\n    }\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -8,7 +8,7 @@\n         inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n     }\n     if (inferred && rhsValue != null && rhsValue.isFunction()) {\n-        if (info != null) {\n+        if (info != null && info.hasType()) { // additional condition to fix bug\n             return false;\n         } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n             // Check if this is in a conditional block.\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -15,7 +15,10 @@\n     if (objectType.hasReferenceName() && !hasLendsName) {\n         return scope;\n     }\n-    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n+    String qObjName = null; // added line to fix bug\n+    if (NodeUtil.isObjectLitObject(n)) { // added condition to fix bug\n+        qObjName = NodeUtil.getObjectLitKeyName(n);\n+    }\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n         String memberName = NodeUtil.getObjectLitKeyName(name);\n         if (memberName != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return true; // fixed\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n        if (name.isComputedProp()) {\n            scope = traverse(name.getLastChild(), scope);  // fixed\n        }\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -22,7 +22,7 @@\n             // Functions assigned in inner scopes are inferred.\n             AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n             if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n-                return false;\n+                return true; // fixed\n             }\n         }\n     }\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -3,6 +3,9 @@\n     Preconditions.checkNotNull(type);\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n         scope = traverse(name.getFirstChild(), scope);\n+        if (name.isComputedProp()) {\n+            scope = traverse(name.getLastChild(), scope);  // fixed\n+        }\n     }\n     // Object literals can be reflected on other types.\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return true; // change from false to true\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                // scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType); // comment out\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -22,7 +22,7 @@\n             // Functions assigned in inner scopes are inferred.\n             AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n             if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n-                return false;\n+                return true; // change from false to true\n             }\n         }\n     }\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -33,7 +33,7 @@\n                 if (var != null && var.isTypeInferred()) {\n                     var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                 }\n-                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n+                // scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType); // comment out\n             }\n         } else {\n             n.setJSType(unknownType);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(n);\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else if (n.getJSType() == null) {\n            // Only set the type of the object literal to unknown type if it hasn't already been set.\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -20,7 +20,7 @@\n             }\n             // Check if this is assigned in an inner scope.\n             // Functions assigned in inner scopes are inferred.\n-            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n+            AstFunctionContents contents = getFunctionAnalysisResults(n);\n             if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                 return false;\n             }\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -35,7 +35,8 @@\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n-        } else {\n+        } else if (n.getJSType() == null) {\n+            // Only set the type of the object literal to unknown type if it hasn't already been set.\n             n.setJSType(unknownType);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(n.getEnclosingFunction());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -20,7 +20,7 @@\n             }\n             // Check if this is assigned in an inner scope.\n             // Functions assigned in inner scopes are inferred.\n-            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n+            AstFunctionContents contents = getFunctionAnalysisResults(n.getEnclosingFunction());\n             if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                 return false;\n             }\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -31,7 +31,7 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            name.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -31,12 +31,12 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n         } else {\n-            n.setJSType(unknownType);\n+            name.setJSType(unknownType);\n         }\n     }\n     return scope;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n\n        if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        } else if(info != null){\n            return false;\n        }\n    }\n    return inferred;\n}\n\n## Fixed Function 2\nprivate FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        if(name.isStringKey() || name.isGetterDef() || name.isSetterDef()){\n            scope = traverse(name.getFirstChild(), scope);\n        }\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@isQualifiedNameInferred\n@@ -8,9 +8,8 @@\n         inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n     }\n     if (inferred && rhsValue != null && rhsValue.isFunction()) {\n-        if (info != null) {\n-            return false;\n-        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n+\n+        if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n             // Check if this is in a conditional block.\n             // Functions assigned in conditional blocks are inferred.\n             for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n@@ -24,6 +23,8 @@\n             if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                 return false;\n             }\n+        } else if(info != null){\n+            return false;\n         }\n     }\n     return inferred;\n--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -2,7 +2,9 @@\n     JSType type = n.getJSType();\n     Preconditions.checkNotNull(type);\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        scope = traverse(name.getFirstChild(), scope);\n+        if(name.isStringKey() || name.isGetterDef() || name.isSetterDef()){\n+            scope = traverse(name.getFirstChild(), scope);\n+        }\n     }\n     // Object literals can be reflected on other types.\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n", "finish_reason": "stop", "valid": false, "num": 1}]