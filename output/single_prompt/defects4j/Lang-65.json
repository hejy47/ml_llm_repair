[{"output": "The fixed function is too long to fit in the space provided. Please provide more space or specify which section you would like the fixed function to be placed.", "diff": "", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.getTimeInMillis() > 9223372036854775806L) { // Checking for Long overflow\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    // truncate milliseconds\n    // truncate seconds\n    // truncate minutes\n    // reset time\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -1,6 +1,6 @@\n //-----------------------------------------------------------------------\n private static void modify(Calendar val, int field, boolean round) {\n-    if (val.get(Calendar.YEAR) > 280000000) {\n+    if (val.getTimeInMillis() > 9223372036854775806L) { // Checking for Long overflow\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n     // ----------------- Fix for LANG-59 ---------------------- START ---------------\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    // truncate milliseconds\n    val.set(Calendar.MILLISECOND, 0);\n    // truncate seconds\n    val.set(Calendar.SECOND, 0);\n    // truncate minutes\n    val.set(Calendar.MINUTE, 0);\n    // reset time\n    val.set(Calendar.HOUR_OF_DAY, 0);\n    val.set(Calendar.AM_PM, Calendar.AM);\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -9,9 +9,14 @@\n     // Manually truncate milliseconds, seconds and minutes, rather than using\n     // Calendar methods.\n     // truncate milliseconds\n+    val.set(Calendar.MILLISECOND, 0);\n     // truncate seconds\n+    val.set(Calendar.SECOND, 0);\n     // truncate minutes\n+    val.set(Calendar.MINUTE, 0);\n     // reset time\n+    val.set(Calendar.HOUR_OF_DAY, 0);\n+    val.set(Calendar.AM_PM, Calendar.AM);\n     // ----------------- Fix for LANG-59 ----------------------- END ----------------\n     boolean roundUp = false;\n     for (int i = 0; i < fields.length; i++) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    val.set(Calendar.MILLISECOND, 0);\n    val.set(Calendar.SECOND, 0);\n    val.set(Calendar.MINUTE, 0);\n    val.set(Calendar.HOUR_OF_DAY, 0);\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -8,10 +8,10 @@\n     //\n     // Manually truncate milliseconds, seconds and minutes, rather than using\n     // Calendar methods.\n-    // truncate milliseconds\n-    // truncate seconds\n-    // truncate minutes\n-    // reset time\n+    val.set(Calendar.MILLISECOND, 0);\n+    val.set(Calendar.SECOND, 0);\n+    val.set(Calendar.MINUTE, 0);\n+    val.set(Calendar.HOUR_OF_DAY, 0);\n     // ----------------- Fix for LANG-59 ----------------------- END ----------------\n     boolean roundUp = false;\n     for (int i = 0; i < fields.length; i++) {\n", "finish_reason": "stop", "valid": false, "num": 4}, {"output": "# Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                // This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        // This is a special case that's hard to generalize\n                        // If the date is 1, we round up to 16, otherwise\n                        // we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        // We need to add one to this field since the\n                        // last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        // We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        // These are special types of fields that require different rounding rules\n        switch (field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    // If we're going to drop the DATE field's value,\n                    // we want to do this our own way.\n                    // We need to subtract 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    // If we're above 15 days adjustment, that means we're in the\n                    // bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    // Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    // If we're going to drop the HOUR field's value,\n                    // we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            // Calculate the offset from the actual minimum value\n            offset = val.get(fields[i][0]) - min;\n            // Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        // We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -3,26 +3,16 @@\n     if (val.get(Calendar.YEAR) > 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n-    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n-    // see http://issues.apache.org/jira/browse/LANG-59\n-    //\n-    // Manually truncate milliseconds, seconds and minutes, rather than using\n-    // Calendar methods.\n-    // truncate milliseconds\n-    // truncate seconds\n-    // truncate minutes\n-    // reset time\n-    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n     boolean roundUp = false;\n     for (int i = 0; i < fields.length; i++) {\n         for (int j = 0; j < fields[i].length; j++) {\n             if (fields[i][j] == field) {\n-                //This is our field... we stop looping\n+                // This is our field... we stop looping\n                 if (round && roundUp) {\n                     if (field == DateUtils.SEMI_MONTH) {\n-                        //This is a special case that's hard to generalize\n-                        //If the date is 1, we round up to 16, otherwise\n-                        //  we subtract 15 days and add 1 month\n+                        // This is a special case that's hard to generalize\n+                        // If the date is 1, we round up to 16, otherwise\n+                        // we subtract 15 days and add 1 month\n                         if (val.get(Calendar.DATE) == 1) {\n                             val.add(Calendar.DATE, 15);\n                         } else {\n@@ -30,39 +20,39 @@\n                             val.add(Calendar.MONTH, 1);\n                         }\n                     } else {\n-                        //We need at add one to this field since the\n-                        //  last number causes us to round up\n+                        // We need to add one to this field since the\n+                        // last number causes us to round up\n                         val.add(fields[i][0], 1);\n                     }\n                 }\n                 return;\n             }\n         }\n-        //We have various fields that are not easy roundings\n+        // We have various fields that are not easy roundings\n         int offset = 0;\n         boolean offsetSet = false;\n-        //These are special types of fields that require different rounding rules\n-        switch(field) {\n+        // These are special types of fields that require different rounding rules\n+        switch (field) {\n             case DateUtils.SEMI_MONTH:\n                 if (fields[i][0] == Calendar.DATE) {\n-                    //If we're going to drop the DATE field's value,\n-                    //  we want to do this our own way.\n-                    //We need to subtrace 1 since the date has a minimum of 1\n+                    // If we're going to drop the DATE field's value,\n+                    // we want to do this our own way.\n+                    // We need to subtract 1 since the date has a minimum of 1\n                     offset = val.get(Calendar.DATE) - 1;\n-                    //If we're above 15 days adjustment, that means we're in the\n-                    //  bottom half of the month and should stay accordingly.\n+                    // If we're above 15 days adjustment, that means we're in the\n+                    // bottom half of the month and should stay accordingly.\n                     if (offset >= 15) {\n                         offset -= 15;\n                     }\n-                    //Record whether we're in the top or bottom half of that range\n+                    // Record whether we're in the top or bottom half of that range\n                     roundUp = offset > 7;\n                     offsetSet = true;\n                 }\n                 break;\n             case Calendar.AM_PM:\n                 if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n-                    //If we're going to drop the HOUR field's value,\n-                    //  we want to do this our own way.\n+                    // If we're going to drop the HOUR field's value,\n+                    // we want to do this our own way.\n                     offset = val.get(Calendar.HOUR_OF_DAY);\n                     if (offset >= 12) {\n                         offset -= 12;\n@@ -75,12 +65,12 @@\n         if (!offsetSet) {\n             int min = val.getActualMinimum(fields[i][0]);\n             int max = val.getActualMaximum(fields[i][0]);\n-            //Calculate the offset from the minimum allowed value\n+            // Calculate the offset from the actual minimum value\n             offset = val.get(fields[i][0]) - min;\n-            //Set roundUp if this is more than half way between the minimum and maximum\n+            // Set roundUp if this is more than half way between the minimum and maximum\n             roundUp = offset > ((max - min) / 2);\n         }\n-        //We need to remove this field\n+        // We need to remove this field\n         val.set(fields[i][0], val.get(fields[i][0]) - offset);\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    // truncate milliseconds\n    val.set(Calendar.MILLISECOND, 0);\n    // truncate seconds\n    val.set(Calendar.SECOND, 0);\n    // truncate minutes\n    val.set(Calendar.MINUTE, 0);\n    // reset time\n    val.set(Calendar.HOUR_OF_DAY, 0);\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -9,9 +9,13 @@\n     // Manually truncate milliseconds, seconds and minutes, rather than using\n     // Calendar methods.\n     // truncate milliseconds\n+    val.set(Calendar.MILLISECOND, 0);\n     // truncate seconds\n+    val.set(Calendar.SECOND, 0);\n     // truncate minutes\n+    val.set(Calendar.MINUTE, 0);\n     // reset time\n+    val.set(Calendar.HOUR_OF_DAY, 0);\n     // ----------------- Fix for LANG-59 ----------------------- END ----------------\n     boolean roundUp = false;\n     for (int i = 0; i < fields.length; i++) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    // truncate milliseconds\n    // truncate seconds\n    // truncate minutes\n    // reset time\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    boolean roundUp = false;\n    int[][] fields = {\n            {Calendar.MILLISECOND},\n            {Calendar.SECOND},\n            {Calendar.MINUTE},\n            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM},\n            {Calendar.MONTH},\n            {Calendar.YEAR},\n            {Calendar.ERA}\n    };\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -14,6 +14,16 @@\n     // reset time\n     // ----------------- Fix for LANG-59 ----------------------- END ----------------\n     boolean roundUp = false;\n+    int[][] fields = {\n+            {Calendar.MILLISECOND},\n+            {Calendar.SECOND},\n+            {Calendar.MINUTE},\n+            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n+            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM},\n+            {Calendar.MONTH},\n+            {Calendar.YEAR},\n+            {Calendar.ERA}\n+    };\n     for (int i = 0; i < fields.length; i++) {\n         for (int j = 0; j < fields[i].length; j++) {\n             if (fields[i][j] == field) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    // truncate milliseconds\n    val.set(Calendar.MILLISECOND, 0);\n    // truncate seconds\n    val.set(Calendar.SECOND, 0);\n    // truncate minutes\n    val.set(Calendar.MINUTE, 0);\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -9,9 +9,11 @@\n     // Manually truncate milliseconds, seconds and minutes, rather than using\n     // Calendar methods.\n     // truncate milliseconds\n+    val.set(Calendar.MILLISECOND, 0);\n     // truncate seconds\n+    val.set(Calendar.SECOND, 0);\n     // truncate minutes\n-    // reset time\n+    val.set(Calendar.MINUTE, 0);\n     // ----------------- Fix for LANG-59 ----------------------- END ----------------\n     boolean roundUp = false;\n     for (int i = 0; i < fields.length; i++) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    // truncate milliseconds\n    val.set(Calendar.MILLISECOND, 0);\n    // truncate seconds\n    val.set(Calendar.SECOND, 0);\n    // truncate minutes\n    val.set(Calendar.MINUTE, 0);\n    // reset time\n    val.set(Calendar.HOUR_OF_DAY, 0);\n    val.set(Calendar.HOUR, 0);\n    val.set(Calendar.AM_PM, Calendar.AM);\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -9,9 +9,15 @@\n     // Manually truncate milliseconds, seconds and minutes, rather than using\n     // Calendar methods.\n     // truncate milliseconds\n+    val.set(Calendar.MILLISECOND, 0);\n     // truncate seconds\n+    val.set(Calendar.SECOND, 0);\n     // truncate minutes\n+    val.set(Calendar.MINUTE, 0);\n     // reset time\n+    val.set(Calendar.HOUR_OF_DAY, 0);\n+    val.set(Calendar.HOUR, 0);\n+    val.set(Calendar.AM_PM, Calendar.AM);\n     // ----------------- Fix for LANG-59 ----------------------- END ----------------\n     boolean roundUp = false;\n     for (int i = 0; i < fields.length; i++) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n            offsetSet = true;\n        }\n        //We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    // Managed to loop over all possible values without finding the field therefore it is not supported\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -3,16 +3,6 @@\n     if (val.get(Calendar.YEAR) > 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n-    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n-    // see http://issues.apache.org/jira/browse/LANG-59\n-    //\n-    // Manually truncate milliseconds, seconds and minutes, rather than using\n-    // Calendar methods.\n-    // truncate milliseconds\n-    // truncate seconds\n-    // truncate minutes\n-    // reset time\n-    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n     boolean roundUp = false;\n     for (int i = 0; i < fields.length; i++) {\n         for (int j = 0; j < fields[i].length; j++) {\n@@ -79,9 +69,11 @@\n             offset = val.get(fields[i][0]) - min;\n             //Set roundUp if this is more than half way between the minimum and maximum\n             roundUp = offset > ((max - min) / 2);\n+            offsetSet = true;\n         }\n         //We need to remove this field\n         val.set(fields[i][0], val.get(fields[i][0]) - offset);\n     }\n+    // Managed to loop over all possible values without finding the field therefore it is not supported\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    // truncate milliseconds\n    val.set(Calendar.MILLISECOND, 0);\n    // truncate seconds\n    val.set(Calendar.SECOND, 0);\n    // truncate minutes\n    val.set(Calendar.MINUTE, 0);\n    // reset time\n    val.set(Calendar.HOUR_OF_DAY, 0);\n    val.set(Calendar.HOUR, 0);\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -9,9 +9,14 @@\n     // Manually truncate milliseconds, seconds and minutes, rather than using\n     // Calendar methods.\n     // truncate milliseconds\n+    val.set(Calendar.MILLISECOND, 0);\n     // truncate seconds\n+    val.set(Calendar.SECOND, 0);\n     // truncate minutes\n+    val.set(Calendar.MINUTE, 0);\n     // reset time\n+    val.set(Calendar.HOUR_OF_DAY, 0);\n+    val.set(Calendar.HOUR, 0);\n     // ----------------- Fix for LANG-59 ----------------------- END ----------------\n     boolean roundUp = false;\n     for (int i = 0; i < fields.length; i++) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    val.set(Calendar.MILLISECOND, 0);\n    val.set(Calendar.SECOND, 0);\n    val.set(Calendar.MINUTE, 0);\n    val.set(Calendar.HOUR_OF_DAY, 0);\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -3,16 +3,18 @@\n     if (val.get(Calendar.YEAR) > 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n+\n     // ----------------- Fix for LANG-59 ---------------------- START ---------------\n     // see http://issues.apache.org/jira/browse/LANG-59\n     //\n     // Manually truncate milliseconds, seconds and minutes, rather than using\n     // Calendar methods.\n-    // truncate milliseconds\n-    // truncate seconds\n-    // truncate minutes\n-    // reset time\n+    val.set(Calendar.MILLISECOND, 0);\n+    val.set(Calendar.SECOND, 0);\n+    val.set(Calendar.MINUTE, 0);\n+    val.set(Calendar.HOUR_OF_DAY, 0);\n     // ----------------- Fix for LANG-59 ----------------------- END ----------------\n+\n     boolean roundUp = false;\n     for (int i = 0; i < fields.length; i++) {\n         for (int j = 0; j < fields[i].length; j++) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n    long time = val.getTimeInMillis();\n    boolean roundUp = false;\n    switch (field) {\n        case Calendar.MILLISECOND:\n            time = time / 1000 * 1000;\n            break;\n        case Calendar.SECOND:\n            time = time / 60000 * 60000;\n            break;\n        case Calendar.MINUTE:\n            time = time / 3600000 * 3600000;\n            break;\n        case DateUtils.SEMI_MONTH:\n            time = time / DateUtils.MILLIS_PER_DAY * DateUtils.MILLIS_PER_DAY;\n            val.setTimeInMillis(time);\n            if (val.get(Calendar.DATE) > 15) {\n                val.add(Calendar.DATE, -(val.get(Calendar.DATE) - 15));\n            } else {\n                val.add(Calendar.DATE, -val.get(Calendar.DATE));\n            }\n            return;\n    }\n    val.setTimeInMillis(time);\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    for (int[] fields : fields) {\n        for (int f : fields) {\n            if (f == field) {\n                int offset = 0;\n                if (round && (f == Calendar.HOUR_OF_DAY || f == Calendar.HOUR)) {\n                    offset = val.get(f);\n                    if (offset >= 12) {\n                        roundUp = true;\n                    }\n                    if (offset >= 13) {\n                        offset -= 12;\n                    }\n                    if (offset == 0) {\n                        offset = 12;\n                    }\n                } else {\n                    offset = val.get(f);\n                    roundUp = offset > val.getActualMaximum(f) / 2;\n                }\n                if (offset == 0) { // i.e. DST pushed us from 12 to 1\n                    offset = 1;\n                }\n                val.set(f, offset);\n                if (roundUp) {\n                    val.add(fields[0], 1);\n                }\n                return;\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -8,80 +8,59 @@\n     //\n     // Manually truncate milliseconds, seconds and minutes, rather than using\n     // Calendar methods.\n-    // truncate milliseconds\n-    // truncate seconds\n-    // truncate minutes\n-    // reset time\n+    long time = val.getTimeInMillis();\n+    boolean roundUp = false;\n+    switch (field) {\n+        case Calendar.MILLISECOND:\n+            time = time / 1000 * 1000;\n+            break;\n+        case Calendar.SECOND:\n+            time = time / 60000 * 60000;\n+            break;\n+        case Calendar.MINUTE:\n+            time = time / 3600000 * 3600000;\n+            break;\n+        case DateUtils.SEMI_MONTH:\n+            time = time / DateUtils.MILLIS_PER_DAY * DateUtils.MILLIS_PER_DAY;\n+            val.setTimeInMillis(time);\n+            if (val.get(Calendar.DATE) > 15) {\n+                val.add(Calendar.DATE, -(val.get(Calendar.DATE) - 15));\n+            } else {\n+                val.add(Calendar.DATE, -val.get(Calendar.DATE));\n+            }\n+            return;\n+    }\n+    val.setTimeInMillis(time);\n     // ----------------- Fix for LANG-59 ----------------------- END ----------------\n-    boolean roundUp = false;\n-    for (int i = 0; i < fields.length; i++) {\n-        for (int j = 0; j < fields[i].length; j++) {\n-            if (fields[i][j] == field) {\n-                //This is our field... we stop looping\n-                if (round && roundUp) {\n-                    if (field == DateUtils.SEMI_MONTH) {\n-                        //This is a special case that's hard to generalize\n-                        //If the date is 1, we round up to 16, otherwise\n-                        //  we subtract 15 days and add 1 month\n-                        if (val.get(Calendar.DATE) == 1) {\n-                            val.add(Calendar.DATE, 15);\n-                        } else {\n-                            val.add(Calendar.DATE, -15);\n-                            val.add(Calendar.MONTH, 1);\n-                        }\n-                    } else {\n-                        //We need at add one to this field since the\n-                        //  last number causes us to round up\n-                        val.add(fields[i][0], 1);\n+    for (int[] fields : fields) {\n+        for (int f : fields) {\n+            if (f == field) {\n+                int offset = 0;\n+                if (round && (f == Calendar.HOUR_OF_DAY || f == Calendar.HOUR)) {\n+                    offset = val.get(f);\n+                    if (offset >= 12) {\n+                        roundUp = true;\n                     }\n+                    if (offset >= 13) {\n+                        offset -= 12;\n+                    }\n+                    if (offset == 0) {\n+                        offset = 12;\n+                    }\n+                } else {\n+                    offset = val.get(f);\n+                    roundUp = offset > val.getActualMaximum(f) / 2;\n+                }\n+                if (offset == 0) { // i.e. DST pushed us from 12 to 1\n+                    offset = 1;\n+                }\n+                val.set(f, offset);\n+                if (roundUp) {\n+                    val.add(fields[0], 1);\n                 }\n                 return;\n             }\n         }\n-        //We have various fields that are not easy roundings\n-        int offset = 0;\n-        boolean offsetSet = false;\n-        //These are special types of fields that require different rounding rules\n-        switch(field) {\n-            case DateUtils.SEMI_MONTH:\n-                if (fields[i][0] == Calendar.DATE) {\n-                    //If we're going to drop the DATE field's value,\n-                    //  we want to do this our own way.\n-                    //We need to subtrace 1 since the date has a minimum of 1\n-                    offset = val.get(Calendar.DATE) - 1;\n-                    //If we're above 15 days adjustment, that means we're in the\n-                    //  bottom half of the month and should stay accordingly.\n-                    if (offset >= 15) {\n-                        offset -= 15;\n-                    }\n-                    //Record whether we're in the top or bottom half of that range\n-                    roundUp = offset > 7;\n-                    offsetSet = true;\n-                }\n-                break;\n-            case Calendar.AM_PM:\n-                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n-                    //If we're going to drop the HOUR field's value,\n-                    //  we want to do this our own way.\n-                    offset = val.get(Calendar.HOUR_OF_DAY);\n-                    if (offset >= 12) {\n-                        offset -= 12;\n-                    }\n-                    roundUp = offset > 6;\n-                    offsetSet = true;\n-                }\n-                break;\n-        }\n-        if (!offsetSet) {\n-            int min = val.getActualMinimum(fields[i][0]);\n-            int max = val.getActualMaximum(fields[i][0]);\n-            //Calculate the offset from the minimum allowed value\n-            offset = val.get(fields[i][0]) - min;\n-            //Set roundUp if this is more than half way between the minimum and maximum\n-            roundUp = offset > ((max - min) / 2);\n-        }\n-        //We need to remove this field\n-        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n     }\n     throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n//-----------------------------------------------------------------------\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch(field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE && round) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY && round) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n}", "diff": "--- org/apache/commons/lang/time/DateUtils.java@modify\n+++ org/apache/commons/lang/time/DateUtils.java@modify\n@@ -3,16 +3,6 @@\n     if (val.get(Calendar.YEAR) > 280000000) {\n         throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n     }\n-    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n-    // see http://issues.apache.org/jira/browse/LANG-59\n-    //\n-    // Manually truncate milliseconds, seconds and minutes, rather than using\n-    // Calendar methods.\n-    // truncate milliseconds\n-    // truncate seconds\n-    // truncate minutes\n-    // reset time\n-    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n     boolean roundUp = false;\n     for (int i = 0; i < fields.length; i++) {\n         for (int j = 0; j < fields[i].length; j++) {\n@@ -44,7 +34,7 @@\n         //These are special types of fields that require different rounding rules\n         switch(field) {\n             case DateUtils.SEMI_MONTH:\n-                if (fields[i][0] == Calendar.DATE) {\n+                if (fields[i][0] == Calendar.DATE && round) {\n                     //If we're going to drop the DATE field's value,\n                     //  we want to do this our own way.\n                     //We need to subtrace 1 since the date has a minimum of 1\n@@ -60,7 +50,7 @@\n                 }\n                 break;\n             case Calendar.AM_PM:\n-                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n+                if (fields[i][0] == Calendar.HOUR_OF_DAY && round) {\n                     //If we're going to drop the HOUR field's value,\n                     //  we want to do this our own way.\n                     offset = val.get(Calendar.HOUR_OF_DAY);\n", "finish_reason": "stop", "valid": false, "num": 1}]