[{"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.add(coloring); //change from push to add for clarity and future compatibility\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -18,5 +18,5 @@\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n-    colorings.push(coloring);\n+    colorings.add(coloring); //change from push to add for clarity and future compatibility\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nThe fixed function 1 remains the same as above.\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                /* Commented out to fix the bug. Instead of giving a free pass here, throw a warning if the statement falls through.\n                ignoreStar = true;\n                token = next();\n                continue;\n                */\n                break;  // Break instead of continuing to force a warning if the statement falls through.\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n        \n        // Add a warning if the statement falls through.\n        if (token != ANNOTATION && token != EOC && token != EOF) {\n            compiler.report(JSError.make(\"FALLTHROUGH_WARNING\", sourceName, stream.getLineno(), \"Switch statement fallthrough.\"));\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -31,9 +31,12 @@\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n+                /* Commented out to fix the bug. Instead of giving a free pass here, throw a warning if the statement falls through.\n                 ignoreStar = true;\n                 token = next();\n                 continue;\n+                */\n+                break;  // Break instead of continuing to force a warning if the statement falls through.\n             case ANNOTATION:\n             case EOC:\n             case EOF:\n@@ -64,5 +67,10 @@\n                 builder.append(line);\n                 token = next();\n         }\n+        \n+        // Add a warning if the statement falls through.\n+        if (token != ANNOTATION && token != EOC && token != EOF) {\n+            compiler.report(JSError.make(\"FALLTHROUGH_WARNING\", sourceName, stream.getLineno(), \"Switch statement fallthrough.\"));\n+        }\n     } while (true);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.add(coloring); // fixed: use add instead of push\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno() + stream.getRemainingJSDocLine().indexOf(token.getValue());\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -18,5 +18,5 @@\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n-    colorings.push(coloring);\n+    colorings.add(coloring); // fixed: use add instead of push\n }\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -44,7 +44,7 @@\n                     multilineText = multilineText.trim();\n                 }\n                 int endLineno = stream.getLineno();\n-                int endCharno = stream.getCharno();\n+                int endCharno = stream.getCharno() + stream.getRemainingJSDocLine().indexOf(token.getValue());\n                 if (multilineText.length() > 0) {\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    try {\n      coloring.color();\n    } catch (GraphColoring.GraphError e) {\n      throw new RuntimeException(\"Graph coloring failed: \" + e.getMessage(), e);\n    }\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    json = json + \"{\\\"\" + multilineText.replaceAll(\"\\n\", \"\\\\\\\\n\").replaceAll(\"\\\"\", \"\\\\\\\\\\\"\") + \"\\\"}, \";\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -17,6 +17,10 @@\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n+    try {\n+      coloring.color();\n+    } catch (GraphColoring.GraphError e) {\n+      throw new RuntimeException(\"Graph coloring failed: \" + e.getMessage(), e);\n+    }\n     colorings.push(coloring);\n }\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -46,6 +46,7 @@\n                 int endLineno = stream.getLineno();\n                 int endCharno = stream.getCharno();\n                 if (multilineText.length() > 0) {\n+                    json = json + \"{\\\"\" + multilineText.replaceAll(\"\\n\", \"\\\\\\\\n\").replaceAll(\"\\\"\", \"\\\\\\\\\\\"\") + \"\\\"}, \";\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    try {\n        coloring.color();\n    } catch (Exception e) {\n        // Print out the scope name if we fail to color the graph\n        if (scope != null) {\n            System.err.println(\"Failed to color scope \" + scope.getScopeName());\n        }\n        throw new RuntimeException(e);\n    }\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = line.trim();\n                } else {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -17,6 +17,14 @@\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n+    try {\n+        coloring.color();\n+    } catch (Exception e) {\n+        // Print out the scope name if we fail to color the graph\n+        if (scope != null) {\n+            System.err.println(\"Failed to color scope \" + scope.getScopeName());\n+        }\n+        throw new RuntimeException(e);\n+    }\n     colorings.push(coloring);\n }\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -59,6 +59,8 @@\n                 builder.append(toString(token));\n                 line = stream.getRemainingJSDocLine();\n                 if (option != WhitespaceOption.PRESERVE) {\n+                    line = line.trim();\n+                } else {\n                     line = trimEnd(line);\n                 }\n                 builder.append(line);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                }\n                builder.append('*');\n                ignoreStar = false;\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -1,15 +1,11 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    // TODO(user): We CAN do this in the global scope, just need to be\n-    // careful when something is exported. Liveness uses bit-vector for live\n-    // sets so I don't see compilation time will be a problem for running this\n-    // pass in the global scope.\n     Scope scope = t.getScope();\n     if (scope.isGlobal()) {\n         return;\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n-    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n+    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope);\n     // If the function has exactly 2 params, mark them as escaped. This is\n     // a work-around for an IE bug where it throws an exception if you\n     // write to the parameters of the callback in a sort(). See:\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -23,8 +23,9 @@\n                     if (builder.length() > 0) {\n                         builder.append(' ');\n                     }\n-                    builder.append('*');\n                 }\n+                builder.append('*');\n+                ignoreStar = false;\n                 token = next();\n                 continue;\n             case EOL:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    // Check if scope is global or function.\n    if (scope.isGlobal() || scope.isFunctionBlockScope()) {\n        UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n        GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n        coloring.color();\n        colorings.push(coloring);\n    }\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch (token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno() - 1; // Move back one in order to include the token\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -1,13 +1,6 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    // TODO(user): We CAN do this in the global scope, just need to be\n-    // careful when something is exported. Liveness uses bit-vector for live\n-    // sets so I don't see compilation time will be a problem for running this\n-    // pass in the global scope.\n     Scope scope = t.getScope();\n-    if (scope.isGlobal()) {\n-        return;\n-    }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n     LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n     // If the function has exactly 2 params, mark them as escaped. This is\n@@ -15,8 +8,11 @@\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n-    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n-    colorings.push(coloring);\n+    // Check if scope is global or function.\n+    if (scope.isGlobal() || scope.isFunctionBlockScope()) {\n+        UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+        GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n+        coloring.color();\n+        colorings.push(coloring);\n+    }\n }\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -17,7 +17,7 @@\n     token = next();\n     boolean ignoreStar = false;\n     do {\n-        switch(token) {\n+        switch (token) {\n             case STAR:\n                 if (!ignoreStar) {\n                     if (builder.length() > 0) {\n@@ -44,7 +44,7 @@\n                     multilineText = multilineText.trim();\n                 }\n                 int endLineno = stream.getLineno();\n-                int endCharno = stream.getCharno();\n+                int endCharno = stream.getCharno() - 1; // Move back one in order to include the token\n                 if (multilineText.length() > 0) {\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno() + stream.getConsumedTokens().length();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -15,7 +15,7 @@\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -44,7 +44,7 @@\n                     multilineText = multilineText.trim();\n                 }\n                 int endLineno = stream.getLineno();\n-                int endCharno = stream.getCharno();\n+                int endCharno = stream.getCharno() + stream.getConsumedTokens().length();\n                 if (multilineText.length() > 0) {\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses a bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has more than 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    if (t.getScope().getVarCount() > 2) {\n        liveness.setEscapedLocals(t.getScope().getVars());\n    }\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno() - 1; // Fix here\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     // TODO(user): We CAN do this in the global scope, just need to be\n-    // careful when something is exported. Liveness uses bit-vector for live\n+    // careful when something is exported. Liveness uses a bit-vector for live\n     // sets so I don't see compilation time will be a problem for running this\n     // pass in the global scope.\n     Scope scope = t.getScope();\n@@ -10,10 +10,13 @@\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n     LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n-    // If the function has exactly 2 params, mark them as escaped. This is\n+    // If the function has more than 2 params, mark them as escaped. This is\n     // a work-around for an IE bug where it throws an exception if you\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n+    if (t.getScope().getVarCount() > 2) {\n+        liveness.setEscapedLocals(t.getScope().getVars());\n+    }\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -44,7 +44,7 @@\n                     multilineText = multilineText.trim();\n                 }\n                 int endLineno = stream.getLineno();\n-                int endCharno = stream.getCharno();\n+                int endCharno = stream.getCharno() - 1; // Fix here\n                 if (multilineText.length() > 0) {\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.add(coloring); // push() is not supported in Java\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno() + 1; // Add 1 to compensate for the starting offset\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -18,5 +18,5 @@\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n-    colorings.push(coloring);\n+    colorings.add(coloring); // push() is not supported in Java\n }\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -44,7 +44,7 @@\n                     multilineText = multilineText.trim();\n                 }\n                 int endLineno = stream.getLineno();\n-                int endCharno = stream.getCharno();\n+                int endCharno = stream.getCharno() + 1; // Add 1 to compensate for the starting offset\n                 if (multilineText.length() > 0) {\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case AT:\n                state = State.CAPTURE_ANNOTATION;\n                // FALL THROUGH\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -15,7 +15,7 @@\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+    UndiGraph<Var, Void> interferenceGraph = computeVariableInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -34,6 +34,9 @@\n                 ignoreStar = true;\n                 token = next();\n                 continue;\n+            case AT:\n+                state = State.CAPTURE_ANNOTATION;\n+                // FALL THROUGH\n             case ANNOTATION:\n             case EOC:\n             case EOF:\n@@ -49,7 +52,6 @@\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    State state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -9,7 +9,7 @@\n         return;\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n-    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n+    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope);\n     // If the function has exactly 2 params, mark them as escaped. This is\n     // a work-around for an IE bug where it throws an exception if you\n     // write to the parameters of the callback in a sort(). See:\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -13,7 +13,7 @@\n     }\n     StringBuilder builder = new StringBuilder();\n     builder.append(line);\n-    state = State.SEARCHING_ANNOTATION;\n+    State state = State.SEARCHING_ANNOTATION;\n     token = next();\n     boolean ignoreStar = false;\n     do {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    boolean colored = coloring.color();\n    int count = 0;\n    while (!colored) {\n        ++count;\n        if (count > MAX_COLORING_PASSES) {\n            throw new RuntimeException(\"Too many coloring passes.\");\n        }\n        coloring.revert();\n        coloringTieBreaker.setPass(count);\n        coloring.preprocess();\n        GraphColoring<Var, Void> newColoring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n        colored = newColoring.color();\n        coloring = newColoring;\n    }\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                    ignoreStar = true;\n                }\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -17,6 +17,19 @@\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n+    boolean colored = coloring.color();\n+    int count = 0;\n+    while (!colored) {\n+        ++count;\n+        if (count > MAX_COLORING_PASSES) {\n+            throw new RuntimeException(\"Too many coloring passes.\");\n+        }\n+        coloring.revert();\n+        coloringTieBreaker.setPass(count);\n+        coloring.preprocess();\n+        GraphColoring<Var, Void> newColoring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n+        colored = newColoring.color();\n+        coloring = newColoring;\n+    }\n     colorings.push(coloring);\n }\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -30,8 +30,8 @@\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n+                    ignoreStar = true;\n                 }\n-                ignoreStar = true;\n                 token = next();\n                 continue;\n             case ANNOTATION:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    colorings.push(coloring);\n\n    // Fix: Reset the analysis state to allow the pass to run on nested scopes.\n    liveness.clearAnalysisState();\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // Fix: Add a break statement to exit the switch case in the FALL THROUGH case\n            case DEFAULT:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n                break;\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -17,6 +17,8 @@\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n     colorings.push(coloring);\n+\n+    // Fix: Reset the analysis state to allow the pass to run on nested scopes.\n+    liveness.clearAnalysisState();\n }\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -49,8 +49,8 @@\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n-            default:\n+            // Fix: Add a break statement to exit the switch case in the FALL THROUGH case\n+            case DEFAULT:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n                 if (builder.length() > 0) {\n@@ -63,6 +63,7 @@\n                 }\n                 builder.append(line);\n                 token = next();\n+                break;\n         }\n     } while (true);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}\n\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0 && !ignoreStar) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -49,11 +49,10 @@\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n-                if (builder.length() > 0) {\n+                if (builder.length() > 0 && !ignoreStar) {\n                     builder.append(' ');\n                 }\n                 builder.append(toString(token));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    VariableMap vars = liveness.getEscapedLocals();\n    if (vars != null) {\n        UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, vars);\n        GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n        coloring.color();\n        colorings.push(coloring);\n    }\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append('\\n');\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -15,8 +15,11 @@\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n-    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n-    colorings.push(coloring);\n+    VariableMap vars = liveness.getEscapedLocals();\n+    if (vars != null) {\n+        UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, vars);\n+        GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n+        coloring.color();\n+        colorings.push(coloring);\n+    }\n }\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -20,7 +20,7 @@\n         switch(token) {\n             case STAR:\n                 if (!ignoreStar) {\n-                    if (builder.length() > 0) {\n+                    if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                         builder.append(' ');\n                     }\n                     builder.append('*');\n@@ -29,7 +29,7 @@\n                 continue;\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n-                    builder.append(\"\\n\");\n+                    builder.append('\\n');\n                 }\n                 ignoreStar = true;\n                 token = next();\n@@ -53,7 +53,7 @@\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n-                if (builder.length() > 0) {\n+                if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                     builder.append(' ');\n                 }\n                 builder.append(toString(token));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    try {\n        coloring.color();\n    } catch (GraphColoring.TooManyColorsException ex) {\n        // If there are too many colors, disable color-coding and rerun the analysis.\n        coloring.disableColoring();\n        coloring.color();\n    }\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = line.trim();\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -1,22 +1,20 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    // TODO(user): We CAN do this in the global scope, just need to be\n-    // careful when something is exported. Liveness uses bit-vector for live\n-    // sets so I don't see compilation time will be a problem for running this\n-    // pass in the global scope.\n     Scope scope = t.getScope();\n     if (scope.isGlobal()) {\n         return;\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n     LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n-    // If the function has exactly 2 params, mark them as escaped. This is\n-    // a work-around for an IE bug where it throws an exception if you\n-    // write to the parameters of the callback in a sort(). See:\n-    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n+    try {\n+        coloring.color();\n+    } catch (GraphColoring.TooManyColorsException ex) {\n+        // If there are too many colors, disable color-coding and rerun the analysis.\n+        coloring.disableColoring();\n+        coloring.color();\n+    }\n     colorings.push(coloring);\n }\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -37,8 +37,6 @@\n             case ANNOTATION:\n             case EOC:\n             case EOF:\n-                // When we're capturing a license block, annotations\n-                // in the block are ok.\n                 String multilineText = builder.toString();\n                 if (option != WhitespaceOption.PRESERVE) {\n                     multilineText = multilineText.trim();\n@@ -49,7 +47,6 @@\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n@@ -59,7 +56,7 @@\n                 builder.append(toString(token));\n                 line = stream.getRemainingJSDocLine();\n                 if (option != WhitespaceOption.PRESERVE) {\n-                    line = trimEnd(line);\n+                    line = line.trim();\n                 }\n                 builder.append(line);\n                 token = next();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableInterferenceGraph(t, cfg, liveness.getEscapedLocals()); //changed method name\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0 && builder.charAt(builder.length()-1)!=' ') { //added check\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0 && builder.charAt(builder.length()-1)!=' ') { //added check\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -15,7 +15,7 @@\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+    UndiGraph<Var, Void> interferenceGraph = computeVariableInterferenceGraph(t, cfg, liveness.getEscapedLocals()); //changed method name\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -20,7 +20,7 @@\n         switch(token) {\n             case STAR:\n                 if (!ignoreStar) {\n-                    if (builder.length() > 0) {\n+                    if (builder.length() > 0 && builder.charAt(builder.length()-1)!=' ') { //added check\n                         builder.append(' ');\n                     }\n                     builder.append('*');\n@@ -53,7 +53,7 @@\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n-                if (builder.length() > 0) {\n+                if (builder.length() > 0 && builder.charAt(builder.length()-1)!=' ') { //added check\n                     builder.append(' ');\n                 }\n                 builder.append(toString(token));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    Set<Var> escapedVars = liveness.getEscapedLocals();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedVars);\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color(escapedVars);\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno() + 1;\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -15,8 +15,9 @@\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+    Set<Var> escapedVars = liveness.getEscapedLocals();\n+    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedVars);\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n+    coloring.color(escapedVars);\n     colorings.push(coloring);\n }\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -44,7 +44,7 @@\n                     multilineText = multilineText.trim();\n                 }\n                 int endLineno = stream.getLineno();\n-                int endCharno = stream.getCharno();\n+                int endCharno = stream.getCharno() + 1;\n                 if (multilineText.length() > 0) {\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableEscapesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}\n\n## Fixed Function 2\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case AT:\n                state = State.CAPTURE_ANNOTATION;\n                // FALL THROUGH\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -15,7 +15,7 @@\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+    UndiGraph<Var, Void> interferenceGraph = computeVariableEscapesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -34,6 +34,9 @@\n                 ignoreStar = true;\n                 token = next();\n                 continue;\n+            case AT:\n+                state = State.CAPTURE_ANNOTATION;\n+                // FALL THROUGH\n             case ANNOTATION:\n             case EOC:\n             case EOF:\n@@ -49,7 +52,6 @@\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n", "finish_reason": "stop", "valid": false, "num": 1}]