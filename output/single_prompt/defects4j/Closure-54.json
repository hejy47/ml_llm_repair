[{"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = t.getScope().getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == t.getScope()) {\n                t.getScope().undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = t.getScope().getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(t.getScope().getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        invalidateAllKeys();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -28,7 +28,7 @@\n     // So if F does not have an explicitly declared super type,\n     // allow F.prototype to be redefined arbitrarily.\n     if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n+        Var qVar = t.getScope().getVar(qName);\n         if (qVar != null) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to an object literal,\n@@ -43,8 +43,8 @@\n                 // what props are going to be on that prototype.\n                 return;\n             }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n+            if (qVar.getScope() == t.getScope()) {\n+                t.getScope().undeclare(qVar);\n             }\n         }\n     }\n@@ -61,10 +61,10 @@\n     }\n     if (inferred) {\n         // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n+        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n     }\n     if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n+        ObjectType ownerType = t.getScope().getObjectSlot(ownerName);\n         if (ownerType != null) {\n             // Only declare this as an official property if it has not been\n             // declared yet.\n@@ -79,7 +79,7 @@\n         defineSlot(n, parent, valueType, inferred);\n     } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n         // We declare these for delegate proxy method properties.\n-        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n+        FunctionType ownerType = JSType.toMaybeFunctionType(t.getScope().getObjectSlot(ownerName));\n         if (ownerType != null) {\n             JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n             String delegateName = codingConvention.getDelegateSuperclassName();\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -26,7 +26,7 @@\n         }\n     }\n     if (replacedPrototype) {\n-        clearCachedValues();\n+        invalidateAllKeys();\n     }\n     return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred() || !qName.startsWith(\"this.\")) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType) || getReferenceName() == null) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -35,7 +35,7 @@\n             // then they are responsible for making sure that the object literal's\n             // implicit prototype is set up appropriately. We just obey\n             // the @extends tag.\n-            if (!qVar.isTypeInferred()) {\n+            if (!qVar.isTypeInferred() || !qName.startsWith(\"this.\")) {\n                 // If the programmer has declared that F inherits from Super,\n                 // and they assign F.prototype to some arbitrary expression,\n                 // there's not much we can do. We just ignore the expression,\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -16,7 +16,7 @@\n     // later assigned to Bar will get inherited properly.\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n-    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n+    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType) || getReferenceName() == null) {\n         baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n     setPrototype((PrototypeObjectType) baseType);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue, TypedScope scope) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType,  null);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -17,7 +17,7 @@\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType,  null);\n     }\n     setPrototype((PrototypeObjectType) baseType);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = t.getScope().getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == t.getScope()) {\n                t.getScope().undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        t.getScope().declare(qName, n, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                t.getScope().declare(qName, n, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setInstanceType(new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType));\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    setInstanceType((PrototypeObjectType) prototype);\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -28,7 +28,7 @@\n     // So if F does not have an explicitly declared super type,\n     // allow F.prototype to be redefined arbitrarily.\n     if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n+        Var qVar = t.getScope().getVar(qName);\n         if (qVar != null) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to an object literal,\n@@ -43,8 +43,8 @@\n                 // what props are going to be on that prototype.\n                 return;\n             }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n+            if (qVar.getScope() == t.getScope()) {\n+                t.getScope().undeclare(qVar);\n             }\n         }\n     }\n@@ -61,7 +61,7 @@\n     }\n     if (inferred) {\n         // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n+        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n     }\n     if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n@@ -76,7 +76,7 @@\n         }\n         // If the property is already declared, the error will be\n         // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n+        t.getScope().declare(qName, n, valueType, inferred);\n     } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n         // We declare these for delegate proxy method properties.\n         FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n@@ -85,7 +85,7 @@\n             String delegateName = codingConvention.getDelegateSuperclassName();\n             JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n             if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n+                t.getScope().declare(qName, n, getNativeType(BOOLEAN_TYPE), true);\n             }\n         }\n     }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -19,5 +19,6 @@\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n         baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n+    setInstanceType(new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType));\n     setPrototype((PrototypeObjectType) baseType);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -6,6 +6,7 @@\n     if (isConstructor() && prototype == getInstanceType()) {\n         return false;\n     }\n+    setInstanceType((PrototypeObjectType) prototype);\n     boolean replacedPrototype = prototype != null;\n     this.prototype = prototype;\n     this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = t.getScope().getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == t.getScope()) {\n                t.getScope().undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(typeRegistry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -28,7 +28,7 @@\n     // So if F does not have an explicitly declared super type,\n     // allow F.prototype to be redefined arbitrarily.\n     if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n+        Var qVar = t.getScope().getVar(qName);\n         if (qVar != null) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to an object literal,\n@@ -43,8 +43,8 @@\n                 // what props are going to be on that prototype.\n                 return;\n             }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n+            if (qVar.getScope() == t.getScope()) {\n+                t.getScope().undeclare(qVar);\n             }\n         }\n     }\n@@ -61,7 +61,7 @@\n     }\n     if (inferred) {\n         // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n+        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n     }\n     if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -17,7 +17,7 @@\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+        baseType = new PrototypeObjectType(typeRegistry, this.getReferenceName() + \".prototype\", baseType);\n     }\n     setPrototype((PrototypeObjectType) baseType);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkNotNull(qName);\n    Preconditions.checkNotNull(ownerName);\n\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setInstanceType((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (!isInterface()) {\n        for (JSType subType : cachedTypes.getSubtypes()) {\n            if (subType instanceof FunctionType) {\n                FunctionType ctor = (FunctionType) subType;\n                if (ctor.getPrototype() == this.prototype || ctor.getInstanceType() == this.prototype) {\n                    cachedTypes.markInvalid();\n                    break;\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -3,7 +3,9 @@\n     String ownerName = ownerNode.getQualifiedName();\n     String qName = n.getQualifiedName();\n     String propName = n.getLastChild().getString();\n-    Preconditions.checkArgument(qName != null && ownerName != null);\n+    Preconditions.checkNotNull(qName);\n+    Preconditions.checkNotNull(ownerName);\n+\n     // Precedence of type information on GETPROPs:\n     // 1) @type annnotation / @enum annotation\n     // 2) ASSIGN to FUNCTION literal\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -19,5 +19,5 @@\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n         baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n-    setPrototype((PrototypeObjectType) baseType);\n+    setInstanceType((PrototypeObjectType) baseType);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -12,15 +12,13 @@\n     this.prototype.setOwnerFunction(this);\n     // Disassociating the old prototype makes this easier to debug--\n     // we don't have to worry about two prototypes running around.\n-    if (isConstructor() || isInterface()) {\n-        FunctionType superClass = getSuperClassConstructor();\n-        if (superClass != null) {\n-            superClass.addSubType(this);\n-        }\n-        if (isInterface()) {\n-            for (ObjectType interfaceType : getExtendedInterfaces()) {\n-                if (interfaceType.getConstructor() != null) {\n-                    interfaceType.getConstructor().addSubType(this);\n+    if (!isInterface()) {\n+        for (JSType subType : cachedTypes.getSubtypes()) {\n+            if (subType instanceof FunctionType) {\n+                FunctionType ctor = (FunctionType) subType;\n+                if (ctor.getPrototype() == this.prototype || ctor.getInstanceType() == this.prototype) {\n+                    cachedTypes.markInvalid();\n+                    break;\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n                qVar = null;\n            }\n        }\n        if (qVar == null) {\n            // If the variable is assigned a value later in the program,\n            // the current node will be rechecked and declared properly.\n            // Declare the variable as untyped, so that if it is assigned\n            // using an object literal, its type will be narrowed.\n            qVar = scope.declare(name, null, null, null);\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        prototype = new PrototypeObjectType(registry, getReferenceName() + \".prototype\", getId(), null, baseType);\n    } else {\n        prototype = (PrototypeObjectType) baseType;\n    }\n}\n\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = this.prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -45,7 +45,15 @@\n             }\n             if (qVar.getScope() == scope) {\n                 scope.undeclare(qVar);\n+                qVar = null;\n             }\n+        }\n+        if (qVar == null) {\n+            // If the variable is assigned a value later in the program,\n+            // the current node will be rechecked and declared properly.\n+            // Declare the variable as untyped, so that if it is assigned\n+            // using an object literal, its type will be narrowed.\n+            qVar = scope.declare(name, null, null, null);\n         }\n     }\n     if (valueType == null) {\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -17,7 +17,8 @@\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+        prototype = new PrototypeObjectType(registry, getReferenceName() + \".prototype\", getId(), null, baseType);\n+    } else {\n+        prototype = (PrototypeObjectType) baseType;\n     }\n-    setPrototype((PrototypeObjectType) baseType);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -6,7 +6,7 @@\n     if (isConstructor() && prototype == getInstanceType()) {\n         return false;\n     }\n-    boolean replacedPrototype = prototype != null;\n+    boolean replacedPrototype = this.prototype != null;\n     this.prototype = prototype;\n     this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n     this.prototype.setOwnerFunction(this);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = t.getScope().getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == t.getScope()) {\n                t.getScope().undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    if (baseType instanceof AnonymousObjectType) {\n        // If baseType is an anonymous object, then we set it as the prototype directly.\n        setPrototype((AnonymousObjectType) baseType);\n    } else {\n        PrototypeObjectType newPrototype = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", null);\n        newPrototype.setImplicitPrototype(baseType);\n        setPrototype(newPrototype);\n    }\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -28,7 +28,7 @@\n     // So if F does not have an explicitly declared super type,\n     // allow F.prototype to be redefined arbitrarily.\n     if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n+        Var qVar = t.getScope().getVar(qName);\n         if (qVar != null) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to an object literal,\n@@ -43,8 +43,8 @@\n                 // what props are going to be on that prototype.\n                 return;\n             }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n+            if (qVar.getScope() == t.getScope()) {\n+                t.getScope().undeclare(qVar);\n             }\n         }\n     }\n@@ -61,7 +61,7 @@\n     }\n     if (inferred) {\n         // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n+        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n     }\n     if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -19,5 +19,12 @@\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n         baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n-    setPrototype((PrototypeObjectType) baseType);\n+    if (baseType instanceof AnonymousObjectType) {\n+        // If baseType is an anonymous object, then we set it as the prototype directly.\n+        setPrototype((AnonymousObjectType) baseType);\n+    } else {\n+        PrototypeObjectType newPrototype = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", null);\n+        newPrototype.setImplicitPrototype(baseType);\n+        setPrototype(newPrototype);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n\n    if(valueType == null){\n        Node varNode = NodeUtil.getEnclosingNode(n, NodeUtil.MATCH_FUNCTION_STATEMENT);\n        if(varNode != null){\n            FunctionType functionType = varNode.getJSType().toMaybeFunctionType();\n            if(functionType != null){\n                Node parameters = varNode.getFirstChild().getNext();\n                for(Node param : parameters.children()){\n                    String paramStr = param.getString();\n                    functionType.getParameterType(paramStr).clearDeclaredType();\n                }\n            }\n        }\n        return;\n    }\n\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        if(getReferenceName() != null){\n            ObjectType currentPrototype = getPrototype();\n            PrototypeObjectType newPrototype = new PrototypeObjectType(registry, getReferenceName() + \".prototype\", currentPrototype);\n            newPrototype.setConstructor(this);\n            setPrototype(newPrototype);\n        } else {\n            setPrototype((PrototypeObjectType) baseType);\n        }\n    } else {\n        setPrototype((PrototypeObjectType) baseType);\n    }\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -22,6 +22,22 @@\n         // Determining type for #5\n         valueType = rhsValue.getJSType();\n     }\n+\n+    if(valueType == null){\n+        Node varNode = NodeUtil.getEnclosingNode(n, NodeUtil.MATCH_FUNCTION_STATEMENT);\n+        if(varNode != null){\n+            FunctionType functionType = varNode.getJSType().toMaybeFunctionType();\n+            if(functionType != null){\n+                Node parameters = varNode.getFirstChild().getNext();\n+                for(Node param : parameters.children()){\n+                    String paramStr = param.getString();\n+                    functionType.getParameterType(paramStr).clearDeclaredType();\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n     // Function prototypes are special.\n     // It's a common JS idiom to do:\n     // F.prototype = { ... };\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -17,7 +17,15 @@\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+        if(getReferenceName() != null){\n+            ObjectType currentPrototype = getPrototype();\n+            PrototypeObjectType newPrototype = new PrototypeObjectType(registry, getReferenceName() + \".prototype\", currentPrototype);\n+            newPrototype.setConstructor(this);\n+            setPrototype(newPrototype);\n+        } else {\n+            setPrototype((PrototypeObjectType) baseType);\n+        }\n+    } else {\n+        setPrototype((PrototypeObjectType) baseType);\n     }\n-    setPrototype((PrototypeObjectType) baseType);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null, \"Either qualified name or owner name is null\");\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor, or it's native\n    if (!isConstructor() || isNativeObjectType()) {\n        return false;\n    }\n    if (prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    FunctionType superClass = getSuperClassConstructor();\n    // We will only add the prototype tree to a superclass function if the\n    // prototype of the child has information, which will be used later in\n    // type inference and checking\n    if (superClass != null && prototype != null &&\n            prototype != superClass.getPrototype() && \n            !prototype.isEmptyType()) {\n        superClass.addSubType(this);\n    }\n    for (ObjectType interfaceType : getExtendedInterfaces()) {\n        if (interfaceType.getConstructor() != null) {\n        // We will only add a sub type to the interface if the\n        // prototype of the child has information, which will be\n        // used later in type inference and checking\n        if (prototype != null \n            && prototype != interfaceType.getConstructor().getPrototype()\n            && !prototype.isEmptyType()) {\n            interfaceType.getConstructor().addSubType(this);\n        }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -3,7 +3,7 @@\n     String ownerName = ownerNode.getQualifiedName();\n     String qName = n.getQualifiedName();\n     String propName = n.getLastChild().getString();\n-    Preconditions.checkArgument(qName != null && ownerName != null);\n+    Preconditions.checkArgument(qName != null && ownerName != null, \"Either qualified name or owner name is null\");\n     // Precedence of type information on GETPROPs:\n     // 1) @type annnotation / @enum annotation\n     // 2) ASSIGN to FUNCTION literal\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -17,7 +17,7 @@\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+        baseType = new PrototypeObjectType(registry, getReferenceName() + \".prototype\", baseType);\n     }\n     setPrototype((PrototypeObjectType) baseType);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -2,8 +2,11 @@\n     if (prototype == null) {\n         return false;\n     }\n-    // getInstanceType fails if the function is not a constructor\n-    if (isConstructor() && prototype == getInstanceType()) {\n+    // getInstanceType fails if the function is not a constructor, or it's native\n+    if (!isConstructor() || isNativeObjectType()) {\n+        return false;\n+    }\n+    if (prototype == getInstanceType()) {\n         return false;\n     }\n     boolean replacedPrototype = prototype != null;\n@@ -12,17 +15,25 @@\n     this.prototype.setOwnerFunction(this);\n     // Disassociating the old prototype makes this easier to debug--\n     // we don't have to worry about two prototypes running around.\n-    if (isConstructor() || isInterface()) {\n-        FunctionType superClass = getSuperClassConstructor();\n-        if (superClass != null) {\n-            superClass.addSubType(this);\n+    FunctionType superClass = getSuperClassConstructor();\n+    // We will only add the prototype tree to a superclass function if the\n+    // prototype of the child has information, which will be used later in\n+    // type inference and checking\n+    if (superClass != null && prototype != null &&\n+            prototype != superClass.getPrototype() && \n+            !prototype.isEmptyType()) {\n+        superClass.addSubType(this);\n+    }\n+    for (ObjectType interfaceType : getExtendedInterfaces()) {\n+        if (interfaceType.getConstructor() != null) {\n+        // We will only add a sub type to the interface if the\n+        // prototype of the child has information, which will be\n+        // used later in type inference and checking\n+        if (prototype != null \n+            && prototype != interfaceType.getConstructor().getPrototype()\n+            && !prototype.isEmptyType()) {\n+            interfaceType.getConstructor().addSubType(this);\n         }\n-        if (isInterface()) {\n-            for (ObjectType interfaceType : getExtendedInterfaces()) {\n-                if (interfaceType.getConstructor() != null) {\n-                    interfaceType.getConstructor().addSubType(this);\n-                }\n-            }\n         }\n     }\n     if (replacedPrototype) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = t.getScope().getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == t.getScope()) {\n                t.getScope().undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = t.getScope().getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        t.getScope().defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(t.getScope().getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                t.getScope().defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype != getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -28,7 +28,7 @@\n     // So if F does not have an explicitly declared super type,\n     // allow F.prototype to be redefined arbitrarily.\n     if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n+        Var qVar = t.getScope().getVar(qName);\n         if (qVar != null) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to an object literal,\n@@ -43,8 +43,8 @@\n                 // what props are going to be on that prototype.\n                 return;\n             }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n+            if (qVar.getScope() == t.getScope()) {\n+                t.getScope().undeclare(qVar);\n             }\n         }\n     }\n@@ -61,10 +61,10 @@\n     }\n     if (inferred) {\n         // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n+        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n     }\n     if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n+        ObjectType ownerType = t.getScope().getObjectSlot(ownerName);\n         if (ownerType != null) {\n             // Only declare this as an official property if it has not been\n             // declared yet.\n@@ -76,16 +76,16 @@\n         }\n         // If the property is already declared, the error will be\n         // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n+        t.getScope().defineSlot(n, parent, valueType, inferred);\n     } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n         // We declare these for delegate proxy method properties.\n-        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n+        FunctionType ownerType = JSType.toMaybeFunctionType(t.getScope().getObjectSlot(ownerName));\n         if (ownerType != null) {\n             JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n             String delegateName = codingConvention.getDelegateSuperclassName();\n             JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n             if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n+                t.getScope().defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n             }\n         }\n     }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -1,21 +1,4 @@\n public void setPrototypeBasedOn(ObjectType baseType) {\n-    // This is a bit weird. We need to successfully handle these\n-    // two cases:\n-    // Foo.prototype = new Bar();\n-    // and\n-    // Foo.prototype = {baz: 3};\n-    // In the first case, we do not want new properties to get\n-    // added to Bar. In the second case, we do want new properties\n-    // to get added to the type of the anonymous object.\n-    //\n-    // We handle this by breaking it into two cases:\n-    //\n-    // In the first case, we create a new PrototypeObjectType and set\n-    // its implicit prototype to the type being assigned. This ensures\n-    // that Bar will not get any properties of Foo.prototype, but properties\n-    // later assigned to Bar will get inherited properly.\n-    //\n-    // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n         baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -3,7 +3,7 @@\n         return false;\n     }\n     // getInstanceType fails if the function is not a constructor\n-    if (isConstructor() && prototype == getInstanceType()) {\n+    if (isConstructor() && prototype != getInstanceType()) {\n         return false;\n     }\n     boolean replacedPrototype = prototype != null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = t.getScope().getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == t.getScope()) {\n                t.getScope().undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubtype(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubtype(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -28,7 +28,7 @@\n     // So if F does not have an explicitly declared super type,\n     // allow F.prototype to be redefined arbitrarily.\n     if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n+        Var qVar = t.getScope().getVar(qName);\n         if (qVar != null) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to an object literal,\n@@ -43,8 +43,8 @@\n                 // what props are going to be on that prototype.\n                 return;\n             }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n+            if (qVar.getScope() == t.getScope()) {\n+                t.getScope().undeclare(qVar);\n             }\n         }\n     }\n@@ -61,7 +61,7 @@\n     }\n     if (inferred) {\n         // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n+        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n     }\n     if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -15,12 +15,12 @@\n     if (isConstructor() || isInterface()) {\n         FunctionType superClass = getSuperClassConstructor();\n         if (superClass != null) {\n-            superClass.addSubType(this);\n+            superClass.addSubtype(this);\n         }\n         if (isInterface()) {\n             for (ObjectType interfaceType : getExtendedInterfaces()) {\n                 if (interfaceType.getConstructor() != null) {\n-                    interfaceType.getConstructor().addSubType(this);\n+                    interfaceType.getConstructor().addSubtype(this);\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Scope scope = t.getScope();\n    Node ownerNode = n.getFirstChild(); \n    String ownerName = ownerNode.getQualifiedName(); \n    String qName = n.getQualifiedName(); \n    String propName = n.getLastChild().getString(); \n\n    // Using Preconditions.checkNotNull to clarify the intention.\n    Preconditions.checkNotNull(qName, \"The qualified name can't be null.\");\n    Preconditions.checkNotNull(ownerName, \"The owner name can't be null.\");\n\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n\n    // Updated to use the isTemplateLit method instead of getType\n    // which may return null\n    if (!n.isTemplateLit() && valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n    }\n\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null && !qVar.isExtern()) {\n            ObjectType ownerType = JSType.toMaybeObjectType(qVar.getType());\n            if (ownerType != null) {\n                ownerType.setPrototypeBasedOn(valueType);\n                return;\n            }\n        }\n    }\n    if (valueType != null) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName))\n                    && (!ownerType.isInstanceType() || t.getInput() != null && t.getInput().isExtern())) {\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n                return;\n            }\n        }\n    }\n    defineSlot(n, parent, valueType);\n}\n\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    Preconditions.checkNotNull(baseType);\n    if (baseType.isConstructor() || isNativeObjectType() || baseType.isFunctionPrototypeType()) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype = prototype;\n    this.prototype.setOwnerFunction(this);\n\n    if (isConstructor() || isInterface()) {\n        PrototypeObjectType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getOwnImplementedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n\n    clearCachedValues();\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -1,92 +1,41 @@\n void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode = n.getFirstChild();\n-    String ownerName = ownerNode.getQualifiedName();\n-    String qName = n.getQualifiedName();\n-    String propName = n.getLastChild().getString();\n-    Preconditions.checkArgument(qName != null && ownerName != null);\n-    // Precedence of type information on GETPROPs:\n-    // 1) @type annnotation / @enum annotation\n-    // 2) ASSIGN to FUNCTION literal\n-    // 3) @param/@return annotation (with no function literal)\n-    // 4) ASSIGN to something marked @const\n-    // 5) ASSIGN to anything else\n-    //\n-    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n-    // the function has jsdoc or has not been declared before.\n-    //\n-    // FUNCTION literals are special because TypedScopeCreator is very smart\n-    // about getting as much type information as possible for them.\n-    // Determining type for #1 + #2 + #3 + #4\n+    Scope scope = t.getScope();\n+    Node ownerNode = n.getFirstChild(); \n+    String ownerName = ownerNode.getQualifiedName(); \n+    String qName = n.getQualifiedName(); \n+    String propName = n.getLastChild().getString(); \n+\n+    // Using Preconditions.checkNotNull to clarify the intention.\n+    Preconditions.checkNotNull(qName, \"The qualified name can't be null.\");\n+    Preconditions.checkNotNull(ownerName, \"The owner name can't be null.\");\n+\n     JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n-    if (valueType == null && rhsValue != null) {\n-        // Determining type for #5\n+\n+    // Updated to use the isTemplateLit method instead of getType\n+    // which may return null\n+    if (!n.isTemplateLit() && valueType == null && rhsValue != null) {\n         valueType = rhsValue.getJSType();\n     }\n-    // Function prototypes are special.\n-    // It's a common JS idiom to do:\n-    // F.prototype = { ... };\n-    // So if F does not have an explicitly declared super type,\n-    // allow F.prototype to be redefined arbitrarily.\n+\n     if (\"prototype\".equals(propName)) {\n         Var qVar = scope.getVar(qName);\n-        if (qVar != null) {\n-            // If the programmer has declared that F inherits from Super,\n-            // and they assign F.prototype to an object literal,\n-            // then they are responsible for making sure that the object literal's\n-            // implicit prototype is set up appropriately. We just obey\n-            // the @extends tag.\n-            if (!qVar.isTypeInferred()) {\n-                // If the programmer has declared that F inherits from Super,\n-                // and they assign F.prototype to some arbitrary expression,\n-                // there's not much we can do. We just ignore the expression,\n-                // and hope they've annotated their code in a way to tell us\n-                // what props are going to be on that prototype.\n+        if (qVar != null && !qVar.isExtern()) {\n+            ObjectType ownerType = JSType.toMaybeObjectType(qVar.getType());\n+            if (ownerType != null) {\n+                ownerType.setPrototypeBasedOn(valueType);\n                 return;\n-            }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n             }\n         }\n     }\n-    if (valueType == null) {\n-        if (parent.getType() == Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred = true;\n-    if (info != null) {\n-        // Determining declaration for #1 + #3 + #4\n-        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n-    }\n-    if (!inferred) {\n+    if (valueType != null) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n-            // Only declare this as an official property if it has not been\n-            // declared yet.\n-            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                // If the property is undeclared or inferred, declare it now.\n+            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName))\n+                    && (!ownerType.isInstanceType() || t.getInput() != null && t.getInput().isExtern())) {\n                 ownerType.defineDeclaredProperty(propName, valueType, n);\n-            }\n-        }\n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n-        // We declare these for delegate proxy method properties.\n-        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n-        if (ownerType != null) {\n-            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n-            String delegateName = codingConvention.getDelegateSuperclassName();\n-            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n+                return;\n             }\n         }\n     }\n+    defineSlot(n, parent, valueType);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -1,22 +1,6 @@\n public void setPrototypeBasedOn(ObjectType baseType) {\n-    // This is a bit weird. We need to successfully handle these\n-    // two cases:\n-    // Foo.prototype = new Bar();\n-    // and\n-    // Foo.prototype = {baz: 3};\n-    // In the first case, we do not want new properties to get\n-    // added to Bar. In the second case, we do want new properties\n-    // to get added to the type of the anonymous object.\n-    //\n-    // We handle this by breaking it into two cases:\n-    //\n-    // In the first case, we create a new PrototypeObjectType and set\n-    // its implicit prototype to the type being assigned. This ensures\n-    // that Bar will not get any properties of Foo.prototype, but properties\n-    // later assigned to Bar will get inherited properly.\n-    //\n-    // In the second case, we just use the anonymous object as the prototype.\n-    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n+    Preconditions.checkNotNull(baseType);\n+    if (baseType.isConstructor() || isNativeObjectType() || baseType.isFunctionPrototypeType()) {\n         baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n     setPrototype((PrototypeObjectType) baseType);\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -2,31 +2,29 @@\n     if (prototype == null) {\n         return false;\n     }\n-    // getInstanceType fails if the function is not a constructor\n+\n     if (isConstructor() && prototype == getInstanceType()) {\n         return false;\n     }\n-    boolean replacedPrototype = prototype != null;\n+\n+    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n     this.prototype = prototype;\n-    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n     this.prototype.setOwnerFunction(this);\n-    // Disassociating the old prototype makes this easier to debug--\n-    // we don't have to worry about two prototypes running around.\n+\n     if (isConstructor() || isInterface()) {\n-        FunctionType superClass = getSuperClassConstructor();\n+        PrototypeObjectType superClass = getSuperClassConstructor();\n         if (superClass != null) {\n             superClass.addSubType(this);\n         }\n         if (isInterface()) {\n-            for (ObjectType interfaceType : getExtendedInterfaces()) {\n+            for (ObjectType interfaceType : getOwnImplementedInterfaces()) {\n                 if (interfaceType.getConstructor() != null) {\n                     interfaceType.getConstructor().addSubType(this);\n                 }\n             }\n         }\n     }\n-    if (replacedPrototype) {\n-        clearCachedValues();\n-    }\n+\n+    clearCachedValues();\n     return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    // Check if n is a GETPROP node\n    if (n.isGetProp()) {\n        Node ownerNode = n.getFirstChild();\n        String ownerName = ownerNode.getQualifiedName();\n        if (ownerName == null) {\n            // If the owner name is null, add a warning message to the compiler\n            // and return.\n            t.reportCodeChange(\"Warning: Owner name of GETPROP is null\");\n            return;\n        }\n        String propName = n.getLastChild().getString();\n        Preconditions.checkArgument(!propName.isEmpty());\n        // Get the declared type of the RHS value of the GETPROP node. If it is null,\n        // add the GETPROP node to the stub declarations and return.\n        JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n        if (valueType == null) {\n            if (parent.getType() == Token.EXPR_RESULT) {\n                stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n            }\n            return;\n        }\n        // Get the qualified name of the GETPROP node.\n        String qName = n.getQualifiedName();\n        Preconditions.checkNotNull(qName);\n        // Get the Object Type of the owner name and define the property on it.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if (!ownerType.getOwnPropertyNames().contains(propName) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        defineSlot(n, parent, valueType, true);\n    } else {\n        // Add a warning message to the compiler and return if n is not a GETPROP node.\n        t.reportCodeChange(\"Warning: Node is not a GETPROP\");\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // Use instanceof keyword to check if baseType is an instance of PrototypeObjectType\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        // Only create a new PrototypeObjectType with baseType as its implicit prototype if baseType is not an instance of PrototypeObjectType.\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // Change the order of conditions such that the isConstructor check comes after the instanceof check for PrototypeObjectType\n    if (!(prototype instanceof PrototypeObjectType) || prototype.isUnknownType() || isNativeObjectType()) {\n        return false;\n    }\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -1,92 +1,39 @@\n void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode = n.getFirstChild();\n-    String ownerName = ownerNode.getQualifiedName();\n-    String qName = n.getQualifiedName();\n-    String propName = n.getLastChild().getString();\n-    Preconditions.checkArgument(qName != null && ownerName != null);\n-    // Precedence of type information on GETPROPs:\n-    // 1) @type annnotation / @enum annotation\n-    // 2) ASSIGN to FUNCTION literal\n-    // 3) @param/@return annotation (with no function literal)\n-    // 4) ASSIGN to something marked @const\n-    // 5) ASSIGN to anything else\n-    //\n-    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n-    // the function has jsdoc or has not been declared before.\n-    //\n-    // FUNCTION literals are special because TypedScopeCreator is very smart\n-    // about getting as much type information as possible for them.\n-    // Determining type for #1 + #2 + #3 + #4\n-    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n-    if (valueType == null && rhsValue != null) {\n-        // Determining type for #5\n-        valueType = rhsValue.getJSType();\n-    }\n-    // Function prototypes are special.\n-    // It's a common JS idiom to do:\n-    // F.prototype = { ... };\n-    // So if F does not have an explicitly declared super type,\n-    // allow F.prototype to be redefined arbitrarily.\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n-        if (qVar != null) {\n-            // If the programmer has declared that F inherits from Super,\n-            // and they assign F.prototype to an object literal,\n-            // then they are responsible for making sure that the object literal's\n-            // implicit prototype is set up appropriately. We just obey\n-            // the @extends tag.\n-            if (!qVar.isTypeInferred()) {\n-                // If the programmer has declared that F inherits from Super,\n-                // and they assign F.prototype to some arbitrary expression,\n-                // there's not much we can do. We just ignore the expression,\n-                // and hope they've annotated their code in a way to tell us\n-                // what props are going to be on that prototype.\n-                return;\n+    // Check if n is a GETPROP node\n+    if (n.isGetProp()) {\n+        Node ownerNode = n.getFirstChild();\n+        String ownerName = ownerNode.getQualifiedName();\n+        if (ownerName == null) {\n+            // If the owner name is null, add a warning message to the compiler\n+            // and return.\n+            t.reportCodeChange(\"Warning: Owner name of GETPROP is null\");\n+            return;\n+        }\n+        String propName = n.getLastChild().getString();\n+        Preconditions.checkArgument(!propName.isEmpty());\n+        // Get the declared type of the RHS value of the GETPROP node. If it is null,\n+        // add the GETPROP node to the stub declarations and return.\n+        JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n+        if (valueType == null) {\n+            if (parent.getType() == Token.EXPR_RESULT) {\n+                stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n             }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n-            }\n+            return;\n         }\n-    }\n-    if (valueType == null) {\n-        if (parent.getType() == Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred = true;\n-    if (info != null) {\n-        // Determining declaration for #1 + #3 + #4\n-        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n-    }\n-    if (!inferred) {\n+        // Get the qualified name of the GETPROP node.\n+        String qName = n.getQualifiedName();\n+        Preconditions.checkNotNull(qName);\n+        // Get the Object Type of the owner name and define the property on it.\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n-            // Only declare this as an official property if it has not been\n-            // declared yet.\n             boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                // If the property is undeclared or inferred, declare it now.\n+            if (!ownerType.getOwnPropertyNames().contains(propName) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                 ownerType.defineDeclaredProperty(propName, valueType, n);\n             }\n         }\n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n-        // We declare these for delegate proxy method properties.\n-        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n-        if (ownerType != null) {\n-            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n-            String delegateName = codingConvention.getDelegateSuperclassName();\n-            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n+        defineSlot(n, parent, valueType, true);\n+    } else {\n+        // Add a warning message to the compiler and return if n is not a GETPROP node.\n+        t.reportCodeChange(\"Warning: Node is not a GETPROP\");\n     }\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -1,22 +1,7 @@\n public void setPrototypeBasedOn(ObjectType baseType) {\n-    // This is a bit weird. We need to successfully handle these\n-    // two cases:\n-    // Foo.prototype = new Bar();\n-    // and\n-    // Foo.prototype = {baz: 3};\n-    // In the first case, we do not want new properties to get\n-    // added to Bar. In the second case, we do want new properties\n-    // to get added to the type of the anonymous object.\n-    //\n-    // We handle this by breaking it into two cases:\n-    //\n-    // In the first case, we create a new PrototypeObjectType and set\n-    // its implicit prototype to the type being assigned. This ensures\n-    // that Bar will not get any properties of Foo.prototype, but properties\n-    // later assigned to Bar will get inherited properly.\n-    //\n-    // In the second case, we just use the anonymous object as the prototype.\n+    // Use instanceof keyword to check if baseType is an instance of PrototypeObjectType\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n+        // Only create a new PrototypeObjectType with baseType as its implicit prototype if baseType is not an instance of PrototypeObjectType.\n         baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n     setPrototype((PrototypeObjectType) baseType);\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -2,7 +2,10 @@\n     if (prototype == null) {\n         return false;\n     }\n-    // getInstanceType fails if the function is not a constructor\n+    // Change the order of conditions such that the isConstructor check comes after the instanceof check for PrototypeObjectType\n+    if (!(prototype instanceof PrototypeObjectType) || prototype.isUnknownType() || isNativeObjectType()) {\n+        return false;\n+    }\n     if (isConstructor() && prototype == getInstanceType()) {\n         return false;\n     }\n@@ -10,8 +13,6 @@\n     this.prototype = prototype;\n     this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n     this.prototype.setOwnerFunction(this);\n-    // Disassociating the old prototype makes this easier to debug--\n-    // we don't have to worry about two prototypes running around.\n     if (isConstructor() || isInterface()) {\n         FunctionType superClass = getSuperClassConstructor();\n         if (superClass != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = t.getScope().getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == t.getScope()) {\n                t.getScope().undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = t.getScope().getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(t.getScope().getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        // we need to reset the prototype of all instances\n        // to reflect the new prototype\n        List<Node> instances = getAllNameReferences();\n        for (Node instance : instances) {\n            ObjectType objectType = JSType.toMaybeObjectType(instance.getJSType());\n            if (objectType == null) {\n                continue;\n            }\n            // Native objects cannot have a new prototype\n            if (objectType.isNativeObjectType()) {\n                throw new IllegalStateException(\"Cannot set prototype on instances of built-in types\");\n            }\n            JSType instancePrototype = objectType.getPrototype();\n            if (instancePrototype instanceof PrototypeObjectType) {\n                PrototypeObjectType oldPrototype = (PrototypeObjectType) instancePrototype;\n                PrototypeObjectType newPrototype = PrototypeObjectType.join(registry,\n                        oldPrototype.getImplicitPrototype(),\n                        prototype,\n                        oldPrototype.getImplicitPrototype().getNormalizedPrototype(),\n                        prototype.getNormalizedPrototype());\n                if (!newPrototype.equals(oldPrototype)) {\n                    objectType.setPrototype(newPrototype);\n                }\n            }\n        }\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -5,7 +5,7 @@\n     String propName = n.getLastChild().getString();\n     Preconditions.checkArgument(qName != null && ownerName != null);\n     // Precedence of type information on GETPROPs:\n-    // 1) @type annnotation / @enum annotation\n+    // 1) @type annotation / @enum annotation\n     // 2) ASSIGN to FUNCTION literal\n     // 3) @param/@return annotation (with no function literal)\n     // 4) ASSIGN to something marked @const\n@@ -28,7 +28,7 @@\n     // So if F does not have an explicitly declared super type,\n     // allow F.prototype to be redefined arbitrarily.\n     if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n+        Var qVar = t.getScope().getVar(qName);\n         if (qVar != null) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to an object literal,\n@@ -43,8 +43,8 @@\n                 // what props are going to be on that prototype.\n                 return;\n             }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n+            if (qVar.getScope() == t.getScope()) {\n+                t.getScope().undeclare(qVar);\n             }\n         }\n     }\n@@ -61,10 +61,10 @@\n     }\n     if (inferred) {\n         // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n+        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n     }\n     if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n+        ObjectType ownerType = t.getScope().getObjectSlot(ownerName);\n         if (ownerType != null) {\n             // Only declare this as an official property if it has not been\n             // declared yet.\n@@ -79,7 +79,7 @@\n         defineSlot(n, parent, valueType, inferred);\n     } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n         // We declare these for delegate proxy method properties.\n-        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n+        FunctionType ownerType = JSType.toMaybeFunctionType(t.getScope().getObjectSlot(ownerName));\n         if (ownerType != null) {\n             JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n             String delegateName = codingConvention.getDelegateSuperclassName();\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -16,8 +16,8 @@\n     // later assigned to Bar will get inherited properly.\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n-    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n+        baseType = new PrototypeObjectType(registry, getReferenceName() + \".prototype\", baseType);\n     }\n     setPrototype((PrototypeObjectType) baseType);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -26,6 +26,31 @@\n         }\n     }\n     if (replacedPrototype) {\n+        // we need to reset the prototype of all instances\n+        // to reflect the new prototype\n+        List<Node> instances = getAllNameReferences();\n+        for (Node instance : instances) {\n+            ObjectType objectType = JSType.toMaybeObjectType(instance.getJSType());\n+            if (objectType == null) {\n+                continue;\n+            }\n+            // Native objects cannot have a new prototype\n+            if (objectType.isNativeObjectType()) {\n+                throw new IllegalStateException(\"Cannot set prototype on instances of built-in types\");\n+            }\n+            JSType instancePrototype = objectType.getPrototype();\n+            if (instancePrototype instanceof PrototypeObjectType) {\n+                PrototypeObjectType oldPrototype = (PrototypeObjectType) instancePrototype;\n+                PrototypeObjectType newPrototype = PrototypeObjectType.join(registry,\n+                        oldPrototype.getImplicitPrototype(),\n+                        prototype,\n+                        oldPrototype.getImplicitPrototype().getNormalizedPrototype(),\n+                        prototype.getNormalizedPrototype());\n+                if (!newPrototype.equals(oldPrototype)) {\n+                    objectType.setPrototype(newPrototype);\n+                }\n+            }\n+        }\n         clearCachedValues();\n     }\n     return true;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkNotNull(qName);\n    Preconditions.checkNotNull(ownerName);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(typeRegistry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.removeSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().removeSubType(this);\n                }\n            }\n        }\n    }\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = prototype.getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : prototype.getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -3,7 +3,8 @@\n     String ownerName = ownerNode.getQualifiedName();\n     String qName = n.getQualifiedName();\n     String propName = n.getLastChild().getString();\n-    Preconditions.checkArgument(qName != null && ownerName != null);\n+    Preconditions.checkNotNull(qName);\n+    Preconditions.checkNotNull(ownerName);\n     // Precedence of type information on GETPROPs:\n     // 1) @type annnotation / @enum annotation\n     // 2) ASSIGN to FUNCTION literal\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -17,7 +17,7 @@\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+        baseType = new PrototypeObjectType(typeRegistry, this.getReferenceName() + \".prototype\", baseType);\n     }\n     setPrototype((PrototypeObjectType) baseType);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -15,10 +15,23 @@\n     if (isConstructor() || isInterface()) {\n         FunctionType superClass = getSuperClassConstructor();\n         if (superClass != null) {\n+            superClass.removeSubType(this);\n+        }\n+        if (isInterface()) {\n+            for (ObjectType interfaceType : getExtendedInterfaces()) {\n+                if (interfaceType.getConstructor() != null) {\n+                    interfaceType.getConstructor().removeSubType(this);\n+                }\n+            }\n+        }\n+    }\n+    if (isConstructor() || isInterface()) {\n+        FunctionType superClass = prototype.getSuperClassConstructor();\n+        if (superClass != null) {\n             superClass.addSubType(this);\n         }\n         if (isInterface()) {\n-            for (ObjectType interfaceType : getExtendedInterfaces()) {\n+            for (ObjectType interfaceType : prototype.getExtendedInterfaces()) {\n                 if (interfaceType.getConstructor() != null) {\n                     interfaceType.getConstructor().addSubType(this);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue, TypedScope scope) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType, TypeRegistry registry, String referenceName) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName()\n            || baseType.isUnknownType()\n            || isNativeObjectType()\n            || baseType.isFunctionPrototypeType()\n            || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, referenceName + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = t.getScope().getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == t.getScope()) {\n                t.getScope().undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(getRegistry(), this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -28,7 +28,7 @@\n     // So if F does not have an explicitly declared super type,\n     // allow F.prototype to be redefined arbitrarily.\n     if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n+        Var qVar = t.getScope().getVar(qName);\n         if (qVar != null) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to an object literal,\n@@ -43,8 +43,8 @@\n                 // what props are going to be on that prototype.\n                 return;\n             }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n+            if (qVar.getScope() == t.getScope()) {\n+                t.getScope().undeclare(qVar);\n             }\n         }\n     }\n@@ -61,7 +61,7 @@\n     }\n     if (inferred) {\n         // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n+        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n     }\n     if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -17,7 +17,7 @@\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+        baseType = new PrototypeObjectType(getRegistry(), this.getReferenceName() + \".prototype\", baseType);\n     }\n     setPrototype((PrototypeObjectType) baseType);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = t.getScope().getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == t.getScope()) {\n                t.getScope().undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = t.getTypedScope().getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(t.getTypedScope().getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeObject() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructorFunction() != null) {\n                    interfaceType.getConstructorFunction().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -28,7 +28,7 @@\n     // So if F does not have an explicitly declared super type,\n     // allow F.prototype to be redefined arbitrarily.\n     if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n+        Var qVar = t.getScope().getVar(qName);\n         if (qVar != null) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to an object literal,\n@@ -43,8 +43,8 @@\n                 // what props are going to be on that prototype.\n                 return;\n             }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n+            if (qVar.getScope() == t.getScope()) {\n+                t.getScope().undeclare(qVar);\n             }\n         }\n     }\n@@ -61,10 +61,10 @@\n     }\n     if (inferred) {\n         // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n+        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n     }\n     if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n+        ObjectType ownerType = t.getTypedScope().getObjectSlot(ownerName);\n         if (ownerType != null) {\n             // Only declare this as an official property if it has not been\n             // declared yet.\n@@ -79,7 +79,7 @@\n         defineSlot(n, parent, valueType, inferred);\n     } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n         // We declare these for delegate proxy method properties.\n-        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n+        FunctionType ownerType = JSType.toMaybeFunctionType(t.getTypedScope().getObjectSlot(ownerName));\n         if (ownerType != null) {\n             JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n             String delegateName = codingConvention.getDelegateSuperclassName();\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -16,7 +16,7 @@\n     // later assigned to Bar will get inherited properly.\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n-    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n+    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeObject() || !(baseType instanceof PrototypeObjectType)) {\n         baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n     setPrototype((PrototypeObjectType) baseType);\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototype\n@@ -19,8 +19,8 @@\n         }\n         if (isInterface()) {\n             for (ObjectType interfaceType : getExtendedInterfaces()) {\n-                if (interfaceType.getConstructor() != null) {\n-                    interfaceType.getConstructor().addSubType(this);\n+                if (interfaceType.getConstructorFunction() != null) {\n+                    interfaceType.getConstructorFunction().addSubType(this);\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}]