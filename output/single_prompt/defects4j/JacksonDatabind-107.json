[{"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    throw new JsonMappingException(ctxt.getParser(), \"No suitable constructor found for type: \" + typeId);\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass().equals(type.getClass())) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,14 +11,14 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    throw new JsonMappingException(ctxt.getParser(), \"No suitable constructor found for type: \" + typeId);\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass().equals(type.getClass())) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n@@ -28,7 +28,9 @@\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    return _handleUnknownTypeId(ctxt, typeId); // return actual value or throw exception\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass().equals(type.getClass())) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -11,14 +11,14 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    return _handleUnknownTypeId(ctxt, typeId); // return actual value or throw exception\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass().equals(type.getClass())) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    throw JsonMappingException.from(ctxt.getParser(), \"No suitable deserializer found for type (\" + typeId + \")\"); // throw exception instead of returning null\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,14 +11,14 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    throw JsonMappingException.from(ctxt.getParser(), \"No suitable deserializer found for type (\" + typeId + \")\"); // throw exception instead of returning null\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // We cannot handle the unknown typeId here\n                throw InvalidTypeIdException.from(ctxt.getParser(),\n                        \"Could not resolve type id '\" + typeId + \"' into a subtype of \"\n                        + _baseType);\n            }\n        } else if (_baseType != null && _baseType.getClass() == type.getClass()) {\n            // As per [databind#1270], retain custom type resolvers if present\n            if (!type.hasGenericTypes()) {\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,31 +1,23 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n             if (deser == null) {\n-                // 10-May-2016, tatu: We may get some help...\n-                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n-                if (actual == null) {\n-                    // what should this be taken to mean?\n-                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n-                }\n-                // ... would this actually work?\n-                deser = ctxt.findContextualValueDeserializer(actual, _property);\n+                // We cannot handle the unknown typeId here\n+                throw InvalidTypeIdException.from(ctxt.getParser(),\n+                        \"Could not resolve type id '\" + typeId + \"' into a subtype of \"\n+                        + _baseType);\n             }\n+        } else if (_baseType != null && _baseType.getClass() == type.getClass()) {\n+            // As per [databind#1270], retain custom type resolvers if present\n+            if (!type.hasGenericTypes()) {\n+                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+            }\n+            deser = ctxt.findContextualValueDeserializer(type, _property);\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                if (!type.hasGenericTypes()) {\n-                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n-                }\n-            }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n         _deserializers.put(typeId, deser);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type;\n        try {\n            type = _idResolver.typeFromId(ctxt, typeId);\n        } catch (IllegalArgumentException e) {\n            // 07-Jan-2021, tatu: Should be passing \"type\" if and when it gets passed by context\n            type = _handleUnknownTypeId(ctxt, typeId, null, \"no such class found\");\n        }\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _baseType, \"no fallback deserializer found\");\n            }\n        } else {\n            if (_baseType != null && _baseType.getClass() == type.getClass()) {\n                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,34 +1,27 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type;\n+        try {\n+            type = _idResolver.typeFromId(ctxt, typeId);\n+        } catch (IllegalArgumentException e) {\n+            // 07-Jan-2021, tatu: Should be passing \"type\" if and when it gets passed by context\n+            type = _handleUnknownTypeId(ctxt, typeId, null, \"no such class found\");\n+        }\n         if (type == null) {\n-            // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n             if (deser == null) {\n-                // 10-May-2016, tatu: We may get some help...\n-                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n-                if (actual == null) {\n-                    // what should this be taken to mean?\n-                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n-                }\n-                // ... would this actually work?\n-                deser = ctxt.findContextualValueDeserializer(actual, _property);\n+                deser = _handleUnknownTypeId(ctxt, typeId, _baseType, \"no fallback deserializer found\");\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                if (!type.hasGenericTypes()) {\n-                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n-                }\n+            if (_baseType != null && _baseType.getClass() == type.getClass()) {\n+                type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                } else {\n                    // 17-Jan-2019, tatu: [databind#2221] avoid caching as-is from `_idResolver`,\n                    //    as that might leave dirty instance in the cache\n                    deser = ctxt.findContextualValueDeserializer(type, _property);\n                    return deser;\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -24,6 +24,11 @@\n                 //  now it should improve things.\n                 if (!type.hasGenericTypes()) {\n                     type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+                } else {\n+                    // 17-Jan-2019, tatu: [databind#2221] avoid caching as-is from `_idResolver`,\n+                    //    as that might leave dirty instance in the cache\n+                    deser = ctxt.findContextualValueDeserializer(type, _property);\n+                    return deser;\n                 }\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    throw ctxt.unknownTypeException(_baseType, typeId);\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if (_baseType != null && !_baseType.hasGenericTypes() && _baseType.getRawClass() == type.getRawClass()) {\n                type = _baseType;\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,24 +11,20 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    throw ctxt.unknownTypeException(_baseType, typeId);\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                if (!type.hasGenericTypes()) {\n-                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n-                }\n+            if (_baseType != null && !_baseType.hasGenericTypes() && _baseType.getRawClass() == type.getRawClass()) {\n+                type = _baseType;\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            // Check if deser is still null and throw an exception if so\n            if (deser == null) {\n                throw JsonMappingException.from(ctxt, \"No suitable constructor found for type, which doesn't have a default constructor\");\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n            // Check if deser is still null and throw an exception if so\n            if (deser == null) {\n                throw JsonMappingException.from(ctxt, \"Could not find serializer for type \" + type + \" and property '\" + _property.getName() + \"'\");\n            }\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,32 +1,25 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n+            // Check if deser is still null and throw an exception if so\n             if (deser == null) {\n-                // 10-May-2016, tatu: We may get some help...\n-                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n-                if (actual == null) {\n-                    // what should this be taken to mean?\n-                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n-                }\n-                // ... would this actually work?\n-                deser = ctxt.findContextualValueDeserializer(actual, _property);\n+                throw JsonMappingException.from(ctxt, \"No suitable constructor found for type, which doesn't have a default constructor\");\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                 if (!type.hasGenericTypes()) {\n                     type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                 }\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n+            // Check if deser is still null and throw an exception if so\n+            if (deser == null) {\n+                throw JsonMappingException.from(ctxt, \"Could not find serializer for type \" + type + \" and property '\" + _property.getName() + \"'\");\n+            }\n         }\n         _deserializers.put(typeId, deser);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    throw ctxt.unknownTypeException(_baseType, typeId);\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        // Add the new deserializer to the map\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,24 +11,25 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    throw ctxt.unknownTypeException(_baseType, typeId);\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n                 if (!type.hasGenericTypes()) {\n                     type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                 }\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        // Add the new deserializer to the map\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    return ctxt.handleUnknownTypeId(_baseType, typeId, _idResolver, _typeProperty);\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,14 +11,14 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    return ctxt.handleUnknownTypeId(_baseType, typeId, _idResolver, _typeProperty);\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    throw JsonMappingException.from(ctxt.getParser(),\n                            \"No suitable deserializer found for type (\" + typeId\n                                    + \") at [Source: UNKNOWN; line: -1, column: -1]\");\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) { // [databind#2841]: do not cache N/A\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,14 +11,16 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    throw JsonMappingException.from(ctxt.getParser(),\n+                            \"No suitable deserializer found for type (\" + typeId\n+                                    + \") at [Source: UNKNOWN; line: -1, column: -1]\");\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n@@ -28,7 +30,9 @@\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) { // [databind#2841]: do not cache N/A\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    return _handleDeserializationProblem(ctxt, Object.class, \"Invalid type id \" + typeId + \" (resolved to null)\");\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n## Fixed Function 2\nprivate JsonProcessingException _exception(IOException e) {\n    JsonProcessingException wrapped;\n    if (e instanceof JsonProcessingException) {\n        wrapped = (JsonProcessingException) e;\n    } else {\n        String msg = e.getMessage();\n        if (msg == null) {\n            msg = e.getClass().getSimpleName();\n        }\n        wrapped = new JsonMappingException(this, msg, e);\n    }\n    return wrapped;\n}\n\n## Fixed Function 3\nprivate <T> T _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, JavaType rootType,\n                JsonDeserializer<Object> deser) throws IOException {\n    Object result;\n    TokenBuffer buf = new TokenBuffer(p, ctxt);\n    buf.writeStartArray();\n    buf.writeToken(p.currentToken());\n    int depth = 1;\n\n    while (depth != 0) {\n        JsonToken t = p.nextToken();\n        if (t == null) {\n            throw ctxt.mappingException(\"Unexpected end-of-input when appending to Array\");\n            // never gets here\n            // break;\n        }\n        if (t.isStructStart()) {\n            depth++;\n        } else if (t.isStructEnd()) {\n            depth--;\n        }\n        buf.writeToken(t);\n    }\n\n    buf.writeEndArray();\n    JsonParser np = buf.asParser();\n    np.nextToken();\n    if (deser == null) {\n        result = _findRootDeserializer(ctxt, rootType).deserialize(np, ctxt);\n    } else {\n        result = deser.deserialize(np, ctxt);\n    }\n    return (T) result;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,14 +11,14 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    return _handleDeserializationProblem(ctxt, Object.class, \"Invalid type id \" + typeId + \" (resolved to null)\");\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    // Return an exception instead\n                    throw new JsonMappingException(\"Cannot find a deserializer for type id '\" + typeId + \"'\");\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) { // add deserializer to cache\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,14 +11,15 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    // Return an exception instead\n+                    throw new JsonMappingException(\"Cannot find a deserializer for type id '\" + typeId + \"'\");\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n@@ -28,7 +29,9 @@\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) { // add deserializer to cache\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    throw JsonMappingException.from(ctxt,\n\"Invalid typeId \" + typeId + \" (no such class found)\");\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,14 +11,15 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    throw JsonMappingException.from(ctxt,\n+\"Invalid typeId \" + typeId + \" (no such class found)\");\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n@@ -28,7 +29,9 @@\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    return null;\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                // generic type with custom type resolvers. If so, should try to retain them.\n                // Whether this is sufficient to avoid problems remains to be seen, but for\n                // now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) { // Add check for null to avoid NPE\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -17,18 +17,20 @@\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+                // generic type with custom type resolvers. If so, should try to retain them.\n+                // Whether this is sufficient to avoid problems remains to be seen, but for\n+                // now it should improve things.\n                 if (!type.hasGenericTypes()) {\n                     type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                 }\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) { // Add check for null to avoid NPE\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    throw new JsonMappingException(\"Could not resolve type id '\" + typeId + \"' into a subtype of \" + _baseType);\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) { // [databind#2744]: do not cache null deserializers\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,14 +11,14 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    throw new JsonMappingException(\"Could not resolve type id '\" + typeId + \"' into a subtype of \" + _baseType);\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n@@ -28,7 +28,9 @@\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) { // [databind#2744]: do not cache null deserializers\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        synchronized(_deserializers) { // added synchronization\n            deser = _deserializers.get(typeId); // double-checked locking\n            if (deser == null) {\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n                if (type == null) {\n                    deser = _findDefaultImplDeserializer(ctxt);\n                    if (deser == null) {\n                        JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                        if (actual == null) {\n                            // instead of returning null, throw an exception\n                            throw JsonMappingException.from(ctxt.getParser(),\n                                    \"No type found for \" + typeId);\n                        }\n                        deser = ctxt.findContextualValueDeserializer(actual, _property);\n                    }\n                } else {\n                    if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                        if (!type.hasGenericTypes()) {\n                            type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                        }\n                    }\n                    deser = ctxt.findContextualValueDeserializer(type, _property);\n                }\n                _deserializers.put(typeId, deser);\n            }\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,34 +1,32 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n+        synchronized(_deserializers) { // added synchronization\n+            deser = _deserializers.get(typeId); // double-checked locking\n+            if (deser == null) {\n                 JavaType type = _idResolver.typeFromId(ctxt, typeId);\n-        if (type == null) {\n-            // use the default impl if no type id available:\n-            deser = _findDefaultImplDeserializer(ctxt);\n-            if (deser == null) {\n-                // 10-May-2016, tatu: We may get some help...\n-                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n-                if (actual == null) {\n-                    // what should this be taken to mean?\n-                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                if (type == null) {\n+                    deser = _findDefaultImplDeserializer(ctxt);\n+                    if (deser == null) {\n+                        JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n+                        if (actual == null) {\n+                            // instead of returning null, throw an exception\n+                            throw JsonMappingException.from(ctxt.getParser(),\n+                                    \"No type found for \" + typeId);\n+                        }\n+                        deser = ctxt.findContextualValueDeserializer(actual, _property);\n+                    }\n+                } else {\n+                    if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                        if (!type.hasGenericTypes()) {\n+                            type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+                        }\n+                    }\n+                    deser = ctxt.findContextualValueDeserializer(type, _property);\n                 }\n-                // ... would this actually work?\n-                deser = ctxt.findContextualValueDeserializer(actual, _property);\n+                _deserializers.put(typeId, deser);\n             }\n-        } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n-                if (!type.hasGenericTypes()) {\n-                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n-                }\n-            }\n-            deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    throw new JsonMappingException(\"Could not find deserializer for id \" + typeId);\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,14 +11,14 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    throw new JsonMappingException(\"Could not find deserializer for id \" + typeId);\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    throw ctxt.unknownTypeException(_baseType, typeId);\n                }\n                // ... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass().equals(type.getClass())) {\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,7 +1,7 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n@@ -11,14 +11,14 @@\n                 if (actual == null) {\n                     // what should this be taken to mean?\n                     // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    throw ctxt.unknownTypeException(_baseType, typeId);\n                 }\n                 // ... would this actually work?\n                 deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n+            if ((_baseType != null) && _baseType.getClass().equals(type.getClass())) {\n+                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                 //   generic type with custom type resolvers. If so, should try to retain them.\n                 //  Whether this is sufficient to avoid problems remains to be seen, but for\n                 //  now it should improve things.\n@@ -28,7 +28,9 @@\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) {\n                    // Return \"null\" Object's deserializer to avoid NPE\n                    deser = ctxt.findRootValueDeserializer(ctxt.constructType(Object.class));\n                } else {\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            }\n        } else {\n            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        if (deser != null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java@_findDeserializer\n@@ -1,34 +1,30 @@\n protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n     JsonDeserializer<Object> deser = _deserializers.get(typeId);\n     if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n+        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n         if (type == null) {\n             // use the default impl if no type id available:\n             deser = _findDefaultImplDeserializer(ctxt);\n             if (deser == null) {\n-                // 10-May-2016, tatu: We may get some help...\n                 JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                 if (actual == null) {\n-                    // what should this be taken to mean?\n-                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                    return null;\n+                    // Return \"null\" Object's deserializer to avoid NPE\n+                    deser = ctxt.findRootValueDeserializer(ctxt.constructType(Object.class));\n+                } else {\n+                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n-                // ... would this actually work?\n-                deser = ctxt.findContextualValueDeserializer(actual, _property);\n             }\n         } else {\n-                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n-                                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n-                //   generic type with custom type resolvers. If so, should try to retain them.\n-                //  Whether this is sufficient to avoid problems remains to be seen, but for\n-                //  now it should improve things.\n+            if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                 if (!type.hasGenericTypes()) {\n                     type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                 }\n             }\n             deser = ctxt.findContextualValueDeserializer(type, _property);\n         }\n-        _deserializers.put(typeId, deser);\n+        if (deser != null) {\n+            _deserializers.put(typeId, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]