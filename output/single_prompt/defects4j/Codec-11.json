[{"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    String hex = String.format(\"%02X\", b);\n    buffer.write(hex.getBytes());\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n        // rule #2: \"soft\" line breaks must be added after every 76 characters, except\n        //           for the last line\n        if (buffer.size() % 76 == 0) {\n            buffer.write(CRLF);\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else if (b != CR && b != LF) {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n@@ -1,7 +1,5 @@\n private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n     buffer.write(ESCAPE_CHAR);\n-    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n-    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n-    buffer.write(hex1);\n-    buffer.write(hex2);\n+    String hex = String.format(\"%02X\", b);\n+    buffer.write(hex.getBytes());\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -21,6 +21,11 @@\n             // rule #5: soft line break\n             encodeQuotedPrintable(b, buffer);\n         }\n+        // rule #2: \"soft\" line breaks must be added after every 76 characters, except\n+        //           for the last line\n+        if (buffer.size() % 76 == 0) {\n+            buffer.write(CRLF);\n+        }\n     }\n     // rule #3: whitespace at the end of a line *must* be encoded\n     // if we would do a soft break line after this octet, encode whitespace\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -14,7 +14,7 @@\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n-        } else {\n+        } else if (b != CR && b != LF) {\n             // every other octet is appended except for CR & LF\n             buffer.write(b);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    String hex = String.format(\"%02X\", b);\n    buffer.write(hex.getBytes());\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else if (b == '\\r' || b == '\\n') {\n            continue;\n        } else {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n@@ -1,7 +1,5 @@\n private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n     buffer.write(ESCAPE_CHAR);\n-    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n-    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n-    buffer.write(hex1);\n-    buffer.write(hex2);\n+    String hex = String.format(\"%02X\", b);\n+    buffer.write(hex.getBytes());\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -14,6 +14,8 @@\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n+        } else if (b == '\\r' || b == '\\n') {\n+            continue;\n         } else {\n             // every other octet is appended except for CR & LF\n             buffer.write(b);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (int i = 0; i < bytes.length; i++) { // use indexed for loop instead of for-each loop to avoid ConcurrentModificationException\n        int b = bytes[i];\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n        // rule #3: whitespace at the end of a line *must* be encoded\n        // if we would do a soft break line after this octet, encode whitespace\n        // note #3: '=' *must not* be the ultimate or penultimate character\n        // simplification: if < 6 bytes left, do a soft line break as we may need\n        //                 exactly 6 bytes space for the last 2 bytes\n        if ((i + 1) % MAX_LINE_LEN == 0) {\n            buffer.write('=');\n            buffer.write('\\r');\n            buffer.write('\\n');\n        }\n    }\n    // rule #3: trailing whitespace shall be encoded\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else if (b != '\\r' && b != '\\n') { // exclude CR and LF from decoding\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -9,8 +9,8 @@\n     // encode up to buffer.length - 3, the last three octets will be treated\n     // separately for simplification of note #3\n     // up to this length it is safe to add any byte, encoded or not\n-    for (byte c : bytes) {\n-        int b = c;\n+    for (int i = 0; i < bytes.length; i++) { // use indexed for loop instead of for-each loop to avoid ConcurrentModificationException\n+        int b = bytes[i];\n         if (b < 0) {\n             b = 256 + b;\n         }\n@@ -21,12 +21,17 @@\n             // rule #5: soft line break\n             encodeQuotedPrintable(b, buffer);\n         }\n+        // rule #3: whitespace at the end of a line *must* be encoded\n+        // if we would do a soft break line after this octet, encode whitespace\n+        // note #3: '=' *must not* be the ultimate or penultimate character\n+        // simplification: if < 6 bytes left, do a soft line break as we may need\n+        //                 exactly 6 bytes space for the last 2 bytes\n+        if ((i + 1) % MAX_LINE_LEN == 0) {\n+            buffer.write('=');\n+            buffer.write('\\r');\n+            buffer.write('\\n');\n+        }\n     }\n-    // rule #3: whitespace at the end of a line *must* be encoded\n-    // if we would do a soft break line after this octet, encode whitespace\n-    // note #3: '=' *must not* be the ultimate or penultimate character\n-    // simplification: if < 6 bytes left, do a soft line break as we may need\n-    //                 exactly 6 bytes space for the last 2 bytes\n     // rule #3: trailing whitespace shall be encoded\n     return buffer.toByteArray();\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -14,7 +14,7 @@\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n-        } else {\n+        } else if (b != '\\r' && b != '\\n') { // exclude CR and LF from decoding\n             // every other octet is appended except for CR & LF\n             buffer.write(b);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    String hex = String.format(\"%02X\", b);\n    buffer.write(hex.getBytes());\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int lineLength = 0;\n    for (byte c : bytes) {\n        int b = c & 0xff;\n        if (printable.get(b)) {\n            if (lineLength >= MAX_LINE_LENGTH - 1) {\n                buffer.write('=');\n                buffer.write('\\r');\n                buffer.write('\\n');\n                lineLength = 0;\n            }\n            buffer.write(b);\n            lineLength++;\n        } else {\n            if (lineLength >= MAX_LINE_LENGTH - 3) {\n                buffer.write('=');\n                buffer.write('\\r');\n                buffer.write('\\n');\n                lineLength = 0;\n            }\n            encodeQuotedPrintable(b, buffer);\n            lineLength += 3;\n        }\n    }\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                if (bytes[i + 1] == '\\r') {\n                    i += 2;\n                    continue; // skip over the \\r\n                }\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n@@ -1,7 +1,5 @@\n private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n     buffer.write(ESCAPE_CHAR);\n-    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n-    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n-    buffer.write(hex1);\n-    buffer.write(hex2);\n+    String hex = String.format(\"%02X\", b);\n+    buffer.write(hex.getBytes());\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -6,27 +6,28 @@\n         printable = PRINTABLE_CHARS;\n     }\n     ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-    // encode up to buffer.length - 3, the last three octets will be treated\n-    // separately for simplification of note #3\n-    // up to this length it is safe to add any byte, encoded or not\n+    int lineLength = 0;\n     for (byte c : bytes) {\n-        int b = c;\n-        if (b < 0) {\n-            b = 256 + b;\n-        }\n+        int b = c & 0xff;\n         if (printable.get(b)) {\n+            if (lineLength >= MAX_LINE_LENGTH - 1) {\n+                buffer.write('=');\n+                buffer.write('\\r');\n+                buffer.write('\\n');\n+                lineLength = 0;\n+            }\n             buffer.write(b);\n+            lineLength++;\n         } else {\n-            // rule #3: whitespace at the end of a line *must* be encoded\n-            // rule #5: soft line break\n+            if (lineLength >= MAX_LINE_LENGTH - 3) {\n+                buffer.write('=');\n+                buffer.write('\\r');\n+                buffer.write('\\n');\n+                lineLength = 0;\n+            }\n             encodeQuotedPrintable(b, buffer);\n+            lineLength += 3;\n         }\n     }\n-    // rule #3: whitespace at the end of a line *must* be encoded\n-    // if we would do a soft break line after this octet, encode whitespace\n-    // note #3: '=' *must not* be the ultimate or penultimate character\n-    // simplification: if < 6 bytes left, do a soft line break as we may need\n-    //                 exactly 6 bytes space for the last 2 bytes\n-    // rule #3: trailing whitespace shall be encoded\n     return buffer.toByteArray();\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -8,6 +8,10 @@\n         if (b == ESCAPE_CHAR) {\n             try {\n                 // if the next octet is a CR we have found a soft line break\n+                if (bytes[i + 1] == '\\r') {\n+                    i += 2;\n+                    continue; // skip over the \\r\n+                }\n                 int u = Utils.digit16(bytes[++i]);\n                 int l = Utils.digit16(bytes[++i]);\n                 buffer.write((char) ((u << 4) + l));\n@@ -15,7 +19,6 @@\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n         } else {\n-            // every other octet is appended except for CR & LF\n             buffer.write(b);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            Utils.encodeQuotedPrintable(b, buffer);\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -19,7 +19,7 @@\n         } else {\n             // rule #3: whitespace at the end of a line *must* be encoded\n             // rule #5: soft line break\n-            encodeQuotedPrintable(b, buffer);\n+            Utils.encodeQuotedPrintable(b, buffer);\n         }\n     }\n     // rule #3: whitespace at the end of a line *must* be encoded\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else if (b == '\\r' || b == '\\n') {\n            // ignore CR and LF characters\n            continue;\n        } else {\n            // every other octet is appended\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -14,8 +14,11 @@\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n+        } else if (b == '\\r' || b == '\\n') {\n+            // ignore CR and LF characters\n+            continue;\n         } else {\n-            // every other octet is appended except for CR & LF\n+            // every other octet is appended\n             buffer.write(b);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    String hex = String.format(\"%02X\", b);\n    buffer.write(hex.getBytes());\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else if (b == '\\r' || b == '\\n') {\n            // do nothing for CR and LF\n        } else {\n            // every other octet is appended\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n@@ -1,7 +1,5 @@\n private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n     buffer.write(ESCAPE_CHAR);\n-    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n-    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n-    buffer.write(hex1);\n-    buffer.write(hex2);\n+    String hex = String.format(\"%02X\", b);\n+    buffer.write(hex.getBytes());\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -14,8 +14,10 @@\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n+        } else if (b == '\\r' || b == '\\n') {\n+            // do nothing for CR and LF\n         } else {\n-            // every other octet is appended except for CR & LF\n+            // every other octet is appended\n             buffer.write(b);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b & 0xFF, buffer); // Ensure b is an unsigned byte\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -19,7 +19,7 @@\n         } else {\n             // rule #3: whitespace at the end of a line *must* be encoded\n             // rule #5: soft line break\n-            encodeQuotedPrintable(b, buffer);\n+            encodeQuotedPrintable(b & 0xFF, buffer); // Ensure b is an unsigned byte\n         }\n     }\n     // rule #3: whitespace at the end of a line *must* be encoded\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n    \n    // FIXED: add explicit padding with \"=\" if the buffer length is not a multiple of 76\n    int remaining = buffer.size() % 76;\n    if (remaining != 0) {\n        for (int i = remaining; i < 76; i++) {\n            buffer.write('=');\n        }\n    }\n    \n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            \n            // FIXED: handle soft line breaks (CR immediately followed by LF)\n            if (b == 13 && i + 1 < bytes.length && bytes[i+1] == 10) {\n                i++; // skip LF\n            }\n            \n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -28,5 +28,14 @@\n     // simplification: if < 6 bytes left, do a soft line break as we may need\n     //                 exactly 6 bytes space for the last 2 bytes\n     // rule #3: trailing whitespace shall be encoded\n+    \n+    // FIXED: add explicit padding with \"=\" if the buffer length is not a multiple of 76\n+    int remaining = buffer.size() % 76;\n+    if (remaining != 0) {\n+        for (int i = remaining; i < 76; i++) {\n+            buffer.write('=');\n+        }\n+    }\n+    \n     return buffer.toByteArray();\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -16,6 +16,12 @@\n             }\n         } else {\n             // every other octet is appended except for CR & LF\n+            \n+            // FIXED: handle soft line breaks (CR immediately followed by LF)\n+            if (b == 13 && i + 1 < bytes.length && bytes[i+1] == 10) {\n+                i++; // skip LF\n+            }\n+            \n             buffer.write(b);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    String hex = Integer.toHexString(b).toUpperCase();\n    if (hex.length() < 2) {\n        buffer.write('0');\n    }\n    buffer.write(hex.getBytes());\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int lineLength = 0;\n    for (byte c : bytes) {\n        int b = c & 0xFF;\n        if (printable.get(b)) {\n            if (lineLength >= MAX_LINE_LENGTH - 1) {\n                buffer.write('=');\n                buffer.write(CRLF_BYTES);\n                lineLength = 0;\n            }\n            buffer.write(b);\n            lineLength++;\n        } else {\n            if (lineLength >= MAX_LINE_LENGTH - 3) {\n                buffer.write('=');\n                buffer.write(CRLF_BYTES);\n                lineLength = 0;\n            }\n            encodeQuotedPrintable(b, buffer);\n            lineLength += 3;\n        }\n    }\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i] & 0xFF;\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                if (bytes[i + 1] == 13) {\n                    i++; // skip LF\n                    continue; // ignore soft line break\n                }\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            if (b != 13 && b != 10) {\n                buffer.write(b);\n            }\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n@@ -1,7 +1,8 @@\n private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n     buffer.write(ESCAPE_CHAR);\n-    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n-    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n-    buffer.write(hex1);\n-    buffer.write(hex2);\n+    String hex = Integer.toHexString(b).toUpperCase();\n+    if (hex.length() < 2) {\n+        buffer.write('0');\n+    }\n+    buffer.write(hex.getBytes());\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -6,27 +6,26 @@\n         printable = PRINTABLE_CHARS;\n     }\n     ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-    // encode up to buffer.length - 3, the last three octets will be treated\n-    // separately for simplification of note #3\n-    // up to this length it is safe to add any byte, encoded or not\n+    int lineLength = 0;\n     for (byte c : bytes) {\n-        int b = c;\n-        if (b < 0) {\n-            b = 256 + b;\n-        }\n+        int b = c & 0xFF;\n         if (printable.get(b)) {\n+            if (lineLength >= MAX_LINE_LENGTH - 1) {\n+                buffer.write('=');\n+                buffer.write(CRLF_BYTES);\n+                lineLength = 0;\n+            }\n             buffer.write(b);\n+            lineLength++;\n         } else {\n-            // rule #3: whitespace at the end of a line *must* be encoded\n-            // rule #5: soft line break\n+            if (lineLength >= MAX_LINE_LENGTH - 3) {\n+                buffer.write('=');\n+                buffer.write(CRLF_BYTES);\n+                lineLength = 0;\n+            }\n             encodeQuotedPrintable(b, buffer);\n+            lineLength += 3;\n         }\n     }\n-    // rule #3: whitespace at the end of a line *must* be encoded\n-    // if we would do a soft break line after this octet, encode whitespace\n-    // note #3: '=' *must not* be the ultimate or penultimate character\n-    // simplification: if < 6 bytes left, do a soft line break as we may need\n-    //                 exactly 6 bytes space for the last 2 bytes\n-    // rule #3: trailing whitespace shall be encoded\n     return buffer.toByteArray();\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -4,10 +4,14 @@\n     }\n     ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n     for (int i = 0; i < bytes.length; i++) {\n-        final int b = bytes[i];\n+        final int b = bytes[i] & 0xFF;\n         if (b == ESCAPE_CHAR) {\n             try {\n                 // if the next octet is a CR we have found a soft line break\n+                if (bytes[i + 1] == 13) {\n+                    i++; // skip LF\n+                    continue; // ignore soft line break\n+                }\n                 int u = Utils.digit16(bytes[++i]);\n                 int l = Utils.digit16(bytes[++i]);\n                 buffer.write((char) ((u << 4) + l));\n@@ -16,7 +20,9 @@\n             }\n         } else {\n             // every other octet is appended except for CR & LF\n-            buffer.write(b);\n+            if (b != 13 && b != 10) {\n+                buffer.write(b);\n+            }\n         }\n     }\n     return buffer.toByteArray();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else if (b == ' ') {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // if we would do a soft break line after this octet, encode whitespace\n            // note #3: '=' *must not* be the ultimate or penultimate character\n            // simplification: if < 6 bytes left, do a soft line break as we may need\n            //                 exactly 6 bytes space for the last 2 bytes\n            // rule #3: trailing whitespace shall be encoded\n            encodeQuotedPrintable(b, buffer);\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                if (bytes[i + 1] == '\\r') {\n                    i++; // skip CR\n                    if (i < bytes.length - 2 && bytes[i + 1] == '\\n' && bytes[i + 2] == ' ') {\n                        // soft line break followed by whitespace, skip all three characters\n                        i += 2;\n                    } else {\n                        // soft line break not followed by whitespace, decode the escape sequence\n                        int u = Utils.digit16(bytes[++i]);\n                        int l = Utils.digit16(bytes[++i]);\n                        buffer.write((char) ((u << 4) + l));\n                    }\n                } else {\n                    // not a soft line break, decode the escape sequence\n                    int u = Utils.digit16(bytes[++i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            if (b != '\\r' && b != '\\n') {\n                buffer.write(b);\n            }\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -16,9 +16,17 @@\n         }\n         if (printable.get(b)) {\n             buffer.write(b);\n+        } else if (b == ' ') {\n+            // rule #3: whitespace at the end of a line *must* be encoded\n+            // rule #5: soft line break\n+            encodeQuotedPrintable(b, buffer);\n         } else {\n             // rule #3: whitespace at the end of a line *must* be encoded\n-            // rule #5: soft line break\n+            // if we would do a soft break line after this octet, encode whitespace\n+            // note #3: '=' *must not* be the ultimate or penultimate character\n+            // simplification: if < 6 bytes left, do a soft line break as we may need\n+            //                 exactly 6 bytes space for the last 2 bytes\n+            // rule #3: trailing whitespace shall be encoded\n             encodeQuotedPrintable(b, buffer);\n         }\n     }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -8,15 +8,31 @@\n         if (b == ESCAPE_CHAR) {\n             try {\n                 // if the next octet is a CR we have found a soft line break\n-                int u = Utils.digit16(bytes[++i]);\n-                int l = Utils.digit16(bytes[++i]);\n-                buffer.write((char) ((u << 4) + l));\n+                if (bytes[i + 1] == '\\r') {\n+                    i++; // skip CR\n+                    if (i < bytes.length - 2 && bytes[i + 1] == '\\n' && bytes[i + 2] == ' ') {\n+                        // soft line break followed by whitespace, skip all three characters\n+                        i += 2;\n+                    } else {\n+                        // soft line break not followed by whitespace, decode the escape sequence\n+                        int u = Utils.digit16(bytes[++i]);\n+                        int l = Utils.digit16(bytes[++i]);\n+                        buffer.write((char) ((u << 4) + l));\n+                    }\n+                } else {\n+                    // not a soft line break, decode the escape sequence\n+                    int u = Utils.digit16(bytes[++i]);\n+                    int l = Utils.digit16(bytes[++i]);\n+                    buffer.write((char) ((u << 4) + l));\n+                }\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n         } else {\n             // every other octet is appended except for CR & LF\n-            buffer.write(b);\n+            if (b != '\\r' && b != '\\n') {\n+                buffer.write(b);\n+            }\n         }\n     }\n     return buffer.toByteArray();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n        // rule #3: whitespace at the end of a line *must* be encoded\n        // if we would do a soft break line after this octet, encode whitespace\n        // note #3: '=' *must not* be the ultimate or penultimate character\n        // simplification: if < 6 bytes left, do a soft line break as we may need\n        //                 exactly 6 bytes space for the last 2 bytes\n        if (i < bytes.length - 1 && (i + 1) % MAX_LINE_LENGTH == 0) {\n            buffer.write('=');\n            buffer.write(CRLF);\n        }\n    }\n    // rule #3: trailing whitespace shall be encoded\n    if (bytes.length > 0 && bytes[bytes.length - 1] == ' ') {\n        buffer.write('=');\n        buffer.write('0');\n        buffer.write('D');\n        buffer.write('0');\n        buffer.write('A');\n    }\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                if (bytes[i + 1] == '0' && (bytes[i + 2] == 'D' || bytes[i + 2] == 'd') && (bytes[i + 3] == '0' && (bytes[i + 4] == 'A' || bytes[i + 4] == 'a'))) {\n                    i += 4; // Ignore soft line break\n                } else {\n                    int u = Utils.digit16(bytes[++i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -9,8 +9,8 @@\n     // encode up to buffer.length - 3, the last three octets will be treated\n     // separately for simplification of note #3\n     // up to this length it is safe to add any byte, encoded or not\n-    for (byte c : bytes) {\n-        int b = c;\n+    for (int i = 0; i < bytes.length; i++) {\n+        int b = bytes[i];\n         if (b < 0) {\n             b = 256 + b;\n         }\n@@ -21,12 +21,23 @@\n             // rule #5: soft line break\n             encodeQuotedPrintable(b, buffer);\n         }\n+        // rule #3: whitespace at the end of a line *must* be encoded\n+        // if we would do a soft break line after this octet, encode whitespace\n+        // note #3: '=' *must not* be the ultimate or penultimate character\n+        // simplification: if < 6 bytes left, do a soft line break as we may need\n+        //                 exactly 6 bytes space for the last 2 bytes\n+        if (i < bytes.length - 1 && (i + 1) % MAX_LINE_LENGTH == 0) {\n+            buffer.write('=');\n+            buffer.write(CRLF);\n+        }\n     }\n-    // rule #3: whitespace at the end of a line *must* be encoded\n-    // if we would do a soft break line after this octet, encode whitespace\n-    // note #3: '=' *must not* be the ultimate or penultimate character\n-    // simplification: if < 6 bytes left, do a soft line break as we may need\n-    //                 exactly 6 bytes space for the last 2 bytes\n     // rule #3: trailing whitespace shall be encoded\n+    if (bytes.length > 0 && bytes[bytes.length - 1] == ' ') {\n+        buffer.write('=');\n+        buffer.write('0');\n+        buffer.write('D');\n+        buffer.write('0');\n+        buffer.write('A');\n+    }\n     return buffer.toByteArray();\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -8,9 +8,13 @@\n         if (b == ESCAPE_CHAR) {\n             try {\n                 // if the next octet is a CR we have found a soft line break\n-                int u = Utils.digit16(bytes[++i]);\n-                int l = Utils.digit16(bytes[++i]);\n-                buffer.write((char) ((u << 4) + l));\n+                if (bytes[i + 1] == '0' && (bytes[i + 2] == 'D' || bytes[i + 2] == 'd') && (bytes[i + 3] == '0' && (bytes[i + 4] == 'A' || bytes[i + 4] == 'a'))) {\n+                    i += 4; // Ignore soft line break\n+                } else {\n+                    int u = Utils.digit16(bytes[++i]);\n+                    int l = Utils.digit16(bytes[++i]);\n+                    buffer.write((char) ((u << 4) + l));\n+                }\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            if (b == '\\r' || b == '\\n') {\n                // rule #5: soft line break\n                buffer.write(b);\n            } else {\n                // rule #3: whitespace at the end of a line *must* be encoded\n                // rule #3: trailing whitespace shall be encoded\n                // note #3: '=' *must not* be the ultimate or penultimate character\n                encodeQuotedPrintable(b, buffer);\n            }\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    if (buffer.size() >= 1 && buffer.toByteArray()[buffer.size() - 1] == ' ') {\n        buffer.write('=');\n    }\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                // rule #5: soft line break\n                if (bytes[i + 1] == '\\r' && bytes[i + 2] == '\\n') {\n                    i += 2;\n                } else {\n                    int u = Utils.digit16(bytes[++i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -17,9 +17,15 @@\n         if (printable.get(b)) {\n             buffer.write(b);\n         } else {\n-            // rule #3: whitespace at the end of a line *must* be encoded\n-            // rule #5: soft line break\n-            encodeQuotedPrintable(b, buffer);\n+            if (b == '\\r' || b == '\\n') {\n+                // rule #5: soft line break\n+                buffer.write(b);\n+            } else {\n+                // rule #3: whitespace at the end of a line *must* be encoded\n+                // rule #3: trailing whitespace shall be encoded\n+                // note #3: '=' *must not* be the ultimate or penultimate character\n+                encodeQuotedPrintable(b, buffer);\n+            }\n         }\n     }\n     // rule #3: whitespace at the end of a line *must* be encoded\n@@ -27,6 +33,8 @@\n     // note #3: '=' *must not* be the ultimate or penultimate character\n     // simplification: if < 6 bytes left, do a soft line break as we may need\n     //                 exactly 6 bytes space for the last 2 bytes\n-    // rule #3: trailing whitespace shall be encoded\n+    if (buffer.size() >= 1 && buffer.toByteArray()[buffer.size() - 1] == ' ') {\n+        buffer.write('=');\n+    }\n     return buffer.toByteArray();\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -8,9 +8,14 @@\n         if (b == ESCAPE_CHAR) {\n             try {\n                 // if the next octet is a CR we have found a soft line break\n-                int u = Utils.digit16(bytes[++i]);\n-                int l = Utils.digit16(bytes[++i]);\n-                buffer.write((char) ((u << 4) + l));\n+                // rule #5: soft line break\n+                if (bytes[i + 1] == '\\r' && bytes[i + 2] == '\\n') {\n+                    i += 2;\n+                } else {\n+                    int u = Utils.digit16(bytes[++i]);\n+                    int l = Utils.digit16(bytes[++i]);\n+                    buffer.write((char) ((u << 4) + l));\n+                }\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int remainingBytes = bytes.length;\n    for (byte c : bytes) {\n        int b = c & 0xFF;\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n        remainingBytes--;\n        if (remainingBytes <= 0) {\n            continue;\n        }\n        // rule #3: whitespace at the end of a line *must* be encoded\n        // if we would do a soft break line after this octet, encode whitespace\n        // note #3: '=' *must not* be the ultimate or penultimate character\n        // simplification: if < 6 bytes left, do a soft line break as we may need\n        //                 exactly 6 bytes space for the last 2 bytes\n        if (remainingBytes == 1 || (remainingBytes <= 2 && c == ' ')) {\n            buffer.write('=');\n            buffer.write(Character.toUpperCase(Character.forDigit((c >> 4) & 0xF, 16)));\n            buffer.write(Character.toUpperCase(Character.forDigit(c & 0xF, 16)));\n        }\n    }\n    // rule #3: trailing whitespace shall be encoded\n    if (bytes.length > 0 && bytes[bytes.length - 1] == ' ') {\n        buffer.write('=');\n        buffer.write('0');\n        buffer.write('D');\n        buffer.write('0');\n        buffer.write('A');\n    }\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                if (bytes[i + 1] == '0' && (bytes[i + 2] == 'D' || bytes[i + 2] == 'd') && bytes[i + 3] == '0' && (bytes[i + 4] == 'A' || bytes[i + 4] == 'a')) {\n                    // skip soft line break\n                    i += 4;\n                } else {\n                    int u = Utils.digit16(bytes[++i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -6,14 +6,9 @@\n         printable = PRINTABLE_CHARS;\n     }\n     ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-    // encode up to buffer.length - 3, the last three octets will be treated\n-    // separately for simplification of note #3\n-    // up to this length it is safe to add any byte, encoded or not\n+    int remainingBytes = bytes.length;\n     for (byte c : bytes) {\n-        int b = c;\n-        if (b < 0) {\n-            b = 256 + b;\n-        }\n+        int b = c & 0xFF;\n         if (printable.get(b)) {\n             buffer.write(b);\n         } else {\n@@ -21,12 +16,28 @@\n             // rule #5: soft line break\n             encodeQuotedPrintable(b, buffer);\n         }\n+        remainingBytes--;\n+        if (remainingBytes <= 0) {\n+            continue;\n+        }\n+        // rule #3: whitespace at the end of a line *must* be encoded\n+        // if we would do a soft break line after this octet, encode whitespace\n+        // note #3: '=' *must not* be the ultimate or penultimate character\n+        // simplification: if < 6 bytes left, do a soft line break as we may need\n+        //                 exactly 6 bytes space for the last 2 bytes\n+        if (remainingBytes == 1 || (remainingBytes <= 2 && c == ' ')) {\n+            buffer.write('=');\n+            buffer.write(Character.toUpperCase(Character.forDigit((c >> 4) & 0xF, 16)));\n+            buffer.write(Character.toUpperCase(Character.forDigit(c & 0xF, 16)));\n+        }\n     }\n-    // rule #3: whitespace at the end of a line *must* be encoded\n-    // if we would do a soft break line after this octet, encode whitespace\n-    // note #3: '=' *must not* be the ultimate or penultimate character\n-    // simplification: if < 6 bytes left, do a soft line break as we may need\n-    //                 exactly 6 bytes space for the last 2 bytes\n     // rule #3: trailing whitespace shall be encoded\n+    if (bytes.length > 0 && bytes[bytes.length - 1] == ' ') {\n+        buffer.write('=');\n+        buffer.write('0');\n+        buffer.write('D');\n+        buffer.write('0');\n+        buffer.write('A');\n+    }\n     return buffer.toByteArray();\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -8,9 +8,14 @@\n         if (b == ESCAPE_CHAR) {\n             try {\n                 // if the next octet is a CR we have found a soft line break\n-                int u = Utils.digit16(bytes[++i]);\n-                int l = Utils.digit16(bytes[++i]);\n-                buffer.write((char) ((u << 4) + l));\n+                if (bytes[i + 1] == '0' && (bytes[i + 2] == 'D' || bytes[i + 2] == 'd') && bytes[i + 3] == '0' && (bytes[i + 4] == 'A' || bytes[i + 4] == 'a')) {\n+                    // skip soft line break\n+                    i += 4;\n+                } else {\n+                    int u = Utils.digit16(bytes[++i]);\n+                    int l = Utils.digit16(bytes[++i]);\n+                    buffer.write((char) ((u << 4) + l));\n+                }\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n\n    // fix: add soft line break if the last byte is whitespace\n    if (buffer.size() >= 2 && buffer.toByteArray()[buffer.size()-1] == SPACE && buffer.toByteArray()[buffer.size()-2] != ESCAPE_CHAR) {\n        encodeQuotedPrintable(SPACE, buffer);\n    }\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // fix: also accept lowercase hexadecimal digits\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -28,5 +28,10 @@\n     // simplification: if < 6 bytes left, do a soft line break as we may need\n     //                 exactly 6 bytes space for the last 2 bytes\n     // rule #3: trailing whitespace shall be encoded\n+\n+    // fix: add soft line break if the last byte is whitespace\n+    if (buffer.size() >= 2 && buffer.toByteArray()[buffer.size()-1] == SPACE && buffer.toByteArray()[buffer.size()-2] != ESCAPE_CHAR) {\n+        encodeQuotedPrintable(SPACE, buffer);\n+    }\n     return buffer.toByteArray();\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -7,7 +7,7 @@\n         final int b = bytes[i];\n         if (b == ESCAPE_CHAR) {\n             try {\n-                // if the next octet is a CR we have found a soft line break\n+                // fix: also accept lowercase hexadecimal digits\n                 int u = Utils.digit16(bytes[++i]);\n                 int l = Utils.digit16(bytes[++i]);\n                 buffer.write((char) ((u << 4) + l));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n\n    // Fix: Check if the buffer has already ended with a whitespace character and, if so, encode it\n    int len = buffer.size();\n    if (len > 0 && buffer.toByteArray()[len - 1] == ' ') {\n        encodeQuotedPrintable(' ', buffer);\n    }\n\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n\n    // Fix: Remove trailing whitespace that was decoded\n    byte[] decodedBytes = buffer.toByteArray();\n    int len = decodedBytes.length;\n    while (len > 0 && decodedBytes[len - 1] == ' ') {\n        len--;\n    }\n    return Arrays.copyOfRange(decodedBytes, 0, len);\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -28,5 +28,12 @@\n     // simplification: if < 6 bytes left, do a soft line break as we may need\n     //                 exactly 6 bytes space for the last 2 bytes\n     // rule #3: trailing whitespace shall be encoded\n+\n+    // Fix: Check if the buffer has already ended with a whitespace character and, if so, encode it\n+    int len = buffer.size();\n+    if (len > 0 && buffer.toByteArray()[len - 1] == ' ') {\n+        encodeQuotedPrintable(' ', buffer);\n+    }\n+\n     return buffer.toByteArray();\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -19,5 +19,12 @@\n             buffer.write(b);\n         }\n     }\n-    return buffer.toByteArray();\n+\n+    // Fix: Remove trailing whitespace that was decoded\n+    byte[] decodedBytes = buffer.toByteArray();\n+    int len = decodedBytes.length;\n+    while (len > 0 && decodedBytes[len - 1] == ' ') {\n+        len--;\n+    }\n+    return Arrays.copyOfRange(decodedBytes, 0, len);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    String hex = String.format(\"%02X\", b);\n    buffer.write(hex.getBytes());\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n    }\n\n    // simplify the rule #3 based on note #3 (we can assume there will always be more than 2 bytes left)\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    final int left = buffer.size() % 76;\n    if (left > 72) {\n        encodeQuotedPrintable(' ', buffer);\n    }\n\n    // rule #3: trailing whitespace shall be encoded\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                if (bytes[i + 1] == '\\r' && bytes[i + 2] == '\\n') {\n                    i += 2;\n                } else {\n                    int u = Utils.digit16(bytes[++i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else if (b != '\\r' && b != '\\n') {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n@@ -1,7 +1,5 @@\n private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n     buffer.write(ESCAPE_CHAR);\n-    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n-    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n-    buffer.write(hex1);\n-    buffer.write(hex2);\n+    String hex = String.format(\"%02X\", b);\n+    buffer.write(hex.getBytes());\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -22,11 +22,15 @@\n             encodeQuotedPrintable(b, buffer);\n         }\n     }\n+\n+    // simplify the rule #3 based on note #3 (we can assume there will always be more than 2 bytes left)\n     // rule #3: whitespace at the end of a line *must* be encoded\n     // if we would do a soft break line after this octet, encode whitespace\n-    // note #3: '=' *must not* be the ultimate or penultimate character\n-    // simplification: if < 6 bytes left, do a soft line break as we may need\n-    //                 exactly 6 bytes space for the last 2 bytes\n+    final int left = buffer.size() % 76;\n+    if (left > 72) {\n+        encodeQuotedPrintable(' ', buffer);\n+    }\n+\n     // rule #3: trailing whitespace shall be encoded\n     return buffer.toByteArray();\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -8,13 +8,17 @@\n         if (b == ESCAPE_CHAR) {\n             try {\n                 // if the next octet is a CR we have found a soft line break\n-                int u = Utils.digit16(bytes[++i]);\n-                int l = Utils.digit16(bytes[++i]);\n-                buffer.write((char) ((u << 4) + l));\n+                if (bytes[i + 1] == '\\r' && bytes[i + 2] == '\\n') {\n+                    i += 2;\n+                } else {\n+                    int u = Utils.digit16(bytes[++i]);\n+                    int l = Utils.digit16(bytes[++i]);\n+                    buffer.write((char) ((u << 4) + l));\n+                }\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n-        } else {\n+        } else if (b != '\\r' && b != '\\n') {\n             // every other octet is appended except for CR & LF\n             buffer.write(b);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n    buffer.write(hex1);\n    buffer.write(hex2);\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c & 0xFF; // Mask off any sign-extension bits\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                if (bytes[i + 1] == '\\r') {\n                    i++; // Skip the LF\n                }\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            if (b != '\\r' && b != '\\n') {\n                buffer.write(b);\n            }\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -10,10 +10,7 @@\n     // separately for simplification of note #3\n     // up to this length it is safe to add any byte, encoded or not\n     for (byte c : bytes) {\n-        int b = c;\n-        if (b < 0) {\n-            b = 256 + b;\n-        }\n+        int b = c & 0xFF; // Mask off any sign-extension bits\n         if (printable.get(b)) {\n             buffer.write(b);\n         } else {\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -8,6 +8,9 @@\n         if (b == ESCAPE_CHAR) {\n             try {\n                 // if the next octet is a CR we have found a soft line break\n+                if (bytes[i + 1] == '\\r') {\n+                    i++; // Skip the LF\n+                }\n                 int u = Utils.digit16(bytes[++i]);\n                 int l = Utils.digit16(bytes[++i]);\n                 buffer.write((char) ((u << 4) + l));\n@@ -16,7 +19,9 @@\n             }\n         } else {\n             // every other octet is appended except for CR & LF\n-            buffer.write(b);\n+            if (b != '\\r' && b != '\\n') {\n+                buffer.write(b);\n+            }\n         }\n     }\n     return buffer.toByteArray();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    String hex = Integer.toHexString(b).toUpperCase();\n    if (hex.length() == 1) {\n        buffer.write('0');\n    }\n    buffer.write(hex.getBytes());\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            if (b == '\\r' || b == '\\n') {\n                // rule #4: encode CR or LF immediately followed by a CRLF sequence\n                // note #1: this also covers cases where a CRLF sequence is split\n                //          between two encoded words\n                if (b == '\\r' && buffer.size() < buffer.capacity() - 3 && i+1 < bytes.length && bytes[i+1] == '\\n') {\n                    buffer.write(b);\n                    buffer.write(bytes[++i]);\n                    buffer.write(bytes[++i]);\n                } else {\n                    // rule #3: whitespace at the end of a line *must* be encoded\n                    // rule #5: soft line break\n                    encodeQuotedPrintable(b, buffer);\n                }\n            } else {\n                // rule #3: whitespace at the end of a line *must* be encoded\n                // rule #5: soft line break\n                encodeQuotedPrintable(b, buffer);\n            }\n        }\n    }\n    // rule #3: trailing whitespace shall be encoded\n    // note: there is no need to check if the last octet is a CR or LF, because if it was it would've been handled\n    //       in the for loop and for any other octet the final rule #3 applies\n    while (buffer.size() > 0 && Utils.isWhitespace(buffer.toByteArray()[buffer.size() - 1])) {\n        encodeQuotedPrintable(buffer.toByteArray()[buffer.size() - 1], buffer);\n    }\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                if (i+2 < bytes.length && bytes[i+1] == '\\r' && bytes[i+2] == '\\n') {\n                    i += 2;\n                    continue;\n                }\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else {\n            // every other octet is appended except for CR & LF\n            if (b != '\\r' && b != '\\n') {\n                buffer.write(b);\n            }\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n@@ -1,7 +1,8 @@\n private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n     buffer.write(ESCAPE_CHAR);\n-    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n-    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n-    buffer.write(hex1);\n-    buffer.write(hex2);\n+    String hex = Integer.toHexString(b).toUpperCase();\n+    if (hex.length() == 1) {\n+        buffer.write('0');\n+    }\n+    buffer.write(hex.getBytes());\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable1\n@@ -6,9 +6,6 @@\n         printable = PRINTABLE_CHARS;\n     }\n     ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-    // encode up to buffer.length - 3, the last three octets will be treated\n-    // separately for simplification of note #3\n-    // up to this length it is safe to add any byte, encoded or not\n     for (byte c : bytes) {\n         int b = c;\n         if (b < 0) {\n@@ -17,16 +14,31 @@\n         if (printable.get(b)) {\n             buffer.write(b);\n         } else {\n-            // rule #3: whitespace at the end of a line *must* be encoded\n-            // rule #5: soft line break\n-            encodeQuotedPrintable(b, buffer);\n+            if (b == '\\r' || b == '\\n') {\n+                // rule #4: encode CR or LF immediately followed by a CRLF sequence\n+                // note #1: this also covers cases where a CRLF sequence is split\n+                //          between two encoded words\n+                if (b == '\\r' && buffer.size() < buffer.capacity() - 3 && i+1 < bytes.length && bytes[i+1] == '\\n') {\n+                    buffer.write(b);\n+                    buffer.write(bytes[++i]);\n+                    buffer.write(bytes[++i]);\n+                } else {\n+                    // rule #3: whitespace at the end of a line *must* be encoded\n+                    // rule #5: soft line break\n+                    encodeQuotedPrintable(b, buffer);\n+                }\n+            } else {\n+                // rule #3: whitespace at the end of a line *must* be encoded\n+                // rule #5: soft line break\n+                encodeQuotedPrintable(b, buffer);\n+            }\n         }\n     }\n-    // rule #3: whitespace at the end of a line *must* be encoded\n-    // if we would do a soft break line after this octet, encode whitespace\n-    // note #3: '=' *must not* be the ultimate or penultimate character\n-    // simplification: if < 6 bytes left, do a soft line break as we may need\n-    //                 exactly 6 bytes space for the last 2 bytes\n     // rule #3: trailing whitespace shall be encoded\n+    // note: there is no need to check if the last octet is a CR or LF, because if it was it would've been handled\n+    //       in the for loop and for any other octet the final rule #3 applies\n+    while (buffer.size() > 0 && Utils.isWhitespace(buffer.toByteArray()[buffer.size() - 1])) {\n+        encodeQuotedPrintable(buffer.toByteArray()[buffer.size() - 1], buffer);\n+    }\n     return buffer.toByteArray();\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -8,6 +8,10 @@\n         if (b == ESCAPE_CHAR) {\n             try {\n                 // if the next octet is a CR we have found a soft line break\n+                if (i+2 < bytes.length && bytes[i+1] == '\\r' && bytes[i+2] == '\\n') {\n+                    i += 2;\n+                    continue;\n+                }\n                 int u = Utils.digit16(bytes[++i]);\n                 int l = Utils.digit16(bytes[++i]);\n                 buffer.write((char) ((u << 4) + l));\n@@ -16,7 +20,9 @@\n             }\n         } else {\n             // every other octet is appended except for CR & LF\n-            buffer.write(b);\n+            if (b != '\\r' && b != '\\n') {\n+                buffer.write(b);\n+            }\n         }\n     }\n     return buffer.toByteArray();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n    buffer.write(ESCAPE_CHAR);\n    String hex = String.format(\"%02X\", b);\n    buffer.write(hex.getBytes());\n}\n\n## Fixed Function 2\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    if (printable == null) {\n        printable = PRINTABLE_CHARS;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    // encode up to buffer.length - 3, the last three octets will be treated\n    // separately for simplification of note #3\n    // up to this length it is safe to add any byte, encoded or not\n    for (byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (printable.get(b)) {\n            buffer.write(b);\n        } else {\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // rule #5: soft line break\n            encodeQuotedPrintable(b, buffer);\n        }\n    }\n    // rule #3: whitespace at the end of a line *must* be encoded\n    // if we would do a soft break line after this octet, encode whitespace\n    // note #3: '=' *must not* be the ultimate or penultimate character\n    // simplification: if < 6 bytes left, do a soft line break as we may need\n    //                 exactly 6 bytes space for the last 2 bytes\n    // rule #3: trailing whitespace shall be encoded\n    return buffer.toByteArray();\n}\n\n## Fixed Function 3\npublic static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n    if (bytes == null) {\n        return null;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else if (b != CR && b != LF) {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}", "diff": "--- org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@encodeQuotedPrintable\n@@ -1,7 +1,5 @@\n private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n     buffer.write(ESCAPE_CHAR);\n-    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n-    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n-    buffer.write(hex1);\n-    buffer.write(hex2);\n+    String hex = String.format(\"%02X\", b);\n+    buffer.write(hex.getBytes());\n }\n--- org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n+++ org/apache/commons/codec/net/QuotedPrintableCodec.java@decodeQuotedPrintable\n@@ -14,7 +14,7 @@\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n             }\n-        } else {\n+        } else if (b != CR && b != LF) {\n             // every other octet is appended except for CR & LF\n             buffer.write(b);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}]