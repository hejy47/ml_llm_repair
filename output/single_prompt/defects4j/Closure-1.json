[{"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    \n    // initialize referenced variables set\n    Set<Var> referenced = Sets.newHashSet();\n    AbstractCompiler compiler = callSiteOptimizer.getCompiler();\n    NodeTraversal.traverse(compiler, function, new GatherReferences(referenced));\n    \n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null) {\n            Var var = fnScope.getVar(lastArg.getString());\n            if (!referenced.contains(var)) {\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            } else {\n                break;\n            }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -16,6 +16,12 @@\n     }\n     Node argList = getFunctionArgList(function);\n     boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n+    \n+    // initialize referenced variables set\n+    Set<Var> referenced = Sets.newHashSet();\n+    AbstractCompiler compiler = callSiteOptimizer.getCompiler();\n+    NodeTraversal.traverse(compiler, function, new GatherReferences(referenced));\n+    \n     if (!modifyCallers) {\n         // Strip unreferenced args off the end of the function declaration.\n         Node lastArg;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null) {\n            Var var = fnScope.getVar(lastArg.getString());\n            if (!referenced.contains(var)) {\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            } else {\n                break;\n            }\n        }\n        // fix: check if the function has properties that require its original length\n        if (NodeUtil.isFunctionDeclaration(function)) {\n          if (function.getJSDocInfo() != null) {\n            ImmutableList<JSTypeExpression> params = function.getJSDocInfo().getParameterTypeExpressions();\n            int expectedParamCount = params == null ? 0 : params.size();\n            if (argList.getChildCount() != expectedParamCount) {\n              JSDocInfoBuilder info = JSDocInfoBuilder.copyFrom(function.getJSDocInfo());\n              info.recordParameterLength(argList.getChildCount());\n              function.setJSDocInfo(info.build());\n            }\n          }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -1,13 +1,4 @@\n private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Notice that removing unreferenced function args breaks\n-    // Function.prototype.length. In advanced mode, we don't really care\n-    // about this: we consider \"length\" the equivalent of reflecting on\n-    // the function's lexical source.\n-    //\n-    // Rather than create a new option for this, we assume that if the user\n-    // is removing globals, then it's OK to remove unused function args.\n-    //\n-    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n     Node function = fnScope.getRootNode();\n     Preconditions.checkState(function.isFunction());\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n@@ -28,6 +19,18 @@\n                 break;\n             }\n         }\n+        // fix: check if the function has properties that require its original length\n+        if (NodeUtil.isFunctionDeclaration(function)) {\n+          if (function.getJSDocInfo() != null) {\n+            ImmutableList<JSTypeExpression> params = function.getJSDocInfo().getParameterTypeExpressions();\n+            int expectedParamCount = params == null ? 0 : params.size();\n+            if (argList.getChildCount() != expectedParamCount) {\n+              JSDocInfoBuilder info = JSDocInfoBuilder.copyFrom(function.getJSDocInfo());\n+              info.recordParameterLength(argList.getChildCount());\n+              function.setJSDocInfo(info.build());\n+            }\n+          }\n+        }\n     } else {\n         callSiteOptimizer.optimize(fnScope, referenced);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg = argList.getLastChild();\n        while (lastArg != null) {\n            Node prev = lastArg.getPrevious();\n            Var var = fnScope.getVar(lastArg.getString());\n            if (!referenced.contains(var)) {\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            } else if (prev != null) {\n                // If we didn't remove the last argument, check if its predecessor is unreferenced.\n                // If so, remove it and iterate again.\n                Var prevVar = fnScope.getVar(prev.getString());\n                if (!referenced.contains(prevVar)) {\n                    argList.removeChild(prev);\n                    compiler.reportCodeChange();\n                    continue;\n                }\n            }\n            lastArg = prev;\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -1,13 +1,4 @@\n private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Notice that removing unreferenced function args breaks\n-    // Function.prototype.length. In advanced mode, we don't really care\n-    // about this: we consider \"length\" the equivalent of reflecting on\n-    // the function's lexical source.\n-    //\n-    // Rather than create a new option for this, we assume that if the user\n-    // is removing globals, then it's OK to remove unused function args.\n-    //\n-    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n     Node function = fnScope.getRootNode();\n     Preconditions.checkState(function.isFunction());\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n@@ -18,15 +9,24 @@\n     boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n     if (!modifyCallers) {\n         // Strip unreferenced args off the end of the function declaration.\n-        Node lastArg;\n-        while ((lastArg = argList.getLastChild()) != null) {\n+        Node lastArg = argList.getLastChild();\n+        while (lastArg != null) {\n+            Node prev = lastArg.getPrevious();\n             Var var = fnScope.getVar(lastArg.getString());\n             if (!referenced.contains(var)) {\n                 argList.removeChild(lastArg);\n                 compiler.reportCodeChange();\n-            } else {\n-                break;\n+            } else if (prev != null) {\n+                // If we didn't remove the last argument, check if its predecessor is unreferenced.\n+                // If so, remove it and iterate again.\n+                Var prevVar = fnScope.getVar(prev.getString());\n+                if (!referenced.contains(prevVar)) {\n+                    argList.removeChild(prev);\n+                    compiler.reportCodeChange();\n+                    continue;\n+                }\n             }\n+            lastArg = prev;\n         }\n     } else {\n         callSiteOptimizer.optimize(fnScope, referenced);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null) {\n            Var var = fnScope.getVar(lastArg.getString());\n            if (!referenced.contains(var)) {\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            } else {\n                break;\n            }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n    // Check the function's parameter list to make sure there are no unused function args.\n    NodeUtil.forEachChild(argList, new NodeUtil.MatchShallowStatement() {\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n            if (!n.isName()) {\n                return;\n            }\n            Var var = t.getScope().getVar(n.getString());\n            if (!referenced.contains(var)) {\n                n.getParent().removeChild(n);\n                compiler.reportCodeChange();\n            }\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -1,13 +1,4 @@\n private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Notice that removing unreferenced function args breaks\n-    // Function.prototype.length. In advanced mode, we don't really care\n-    // about this: we consider \"length\" the equivalent of reflecting on\n-    // the function's lexical source.\n-    //\n-    // Rather than create a new option for this, we assume that if the user\n-    // is removing globals, then it's OK to remove unused function args.\n-    //\n-    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n     Node function = fnScope.getRootNode();\n     Preconditions.checkState(function.isFunction());\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n@@ -31,4 +22,18 @@\n     } else {\n         callSiteOptimizer.optimize(fnScope, referenced);\n     }\n+    // Check the function's parameter list to make sure there are no unused function args.\n+    NodeUtil.forEachChild(argList, new NodeUtil.MatchShallowStatement() {\n+        @Override\n+        public void visit(NodeTraversal t, Node n, Node parent) {\n+            if (!n.isName()) {\n+                return;\n+            }\n+            Var var = t.getScope().getVar(n.getString());\n+            if (!referenced.contains(var)) {\n+                n.getParent().removeChild(n);\n+                compiler.reportCodeChange();\n+            }\n+        }\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(NodeUtil.isFunctionExpression(function) || NodeUtil.isArrowFunctionExpression(function)\n        || NodeUtil.isFunctionDeclaration(function));\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null) {\n            if (lastArg.isDefaultValue() || lastArg.isRest()) {\n                // Unreferenced default parameters and rest parameters can't be stripped.\n                break;\n            }\n            Var var = fnScope.getVar(lastArg.getString());\n            if (!referenced.contains(var)) {\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            } else {\n                break;\n            }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -9,7 +9,8 @@\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n     Node function = fnScope.getRootNode();\n-    Preconditions.checkState(function.isFunction());\n+    Preconditions.checkState(NodeUtil.isFunctionExpression(function) || NodeUtil.isArrowFunctionExpression(function)\n+        || NodeUtil.isFunctionDeclaration(function));\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n         // The parameters object literal setters can not be removed.\n         return;\n@@ -20,6 +21,10 @@\n         // Strip unreferenced args off the end of the function declaration.\n         Node lastArg;\n         while ((lastArg = argList.getLastChild()) != null) {\n+            if (lastArg.isDefaultValue() || lastArg.isRest()) {\n+                // Unreferenced default parameters and rest parameters can't be stripped.\n+                break;\n+            }\n             Var var = fnScope.getVar(lastArg.getString());\n             if (!referenced.contains(var)) {\n                 argList.removeChild(lastArg);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null) {\n            Var var = fnScope.getVar(lastArg.getString());\n            if (!referenced.contains(var)) {\n                Node name = lastArg.getFirstChild();\n                if (name.isName()) {\n                    fnScope.undeclare(name.getString());\n                }\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            } else {\n                break;\n            }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -22,6 +22,10 @@\n         while ((lastArg = argList.getLastChild()) != null) {\n             Var var = fnScope.getVar(lastArg.getString());\n             if (!referenced.contains(var)) {\n+                Node name = lastArg.getFirstChild();\n+                if (name.isName()) {\n+                    fnScope.undeclare(name.getString());\n+                }\n                 argList.removeChild(lastArg);\n                 compiler.reportCodeChange();\n             } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg = argList.getLastChild();\n        while (lastArg != null && !referenced.contains(fnScope.getVar(lastArg.getString()))) {\n            argList.removeChild(lastArg);\n            compiler.reportCodeChange();\n            lastArg = argList.getLastChild();\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -1,13 +1,4 @@\n private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Notice that removing unreferenced function args breaks\n-    // Function.prototype.length. In advanced mode, we don't really care\n-    // about this: we consider \"length\" the equivalent of reflecting on\n-    // the function's lexical source.\n-    //\n-    // Rather than create a new option for this, we assume that if the user\n-    // is removing globals, then it's OK to remove unused function args.\n-    //\n-    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n     Node function = fnScope.getRootNode();\n     Preconditions.checkState(function.isFunction());\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n@@ -18,15 +9,11 @@\n     boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n     if (!modifyCallers) {\n         // Strip unreferenced args off the end of the function declaration.\n-        Node lastArg;\n-        while ((lastArg = argList.getLastChild()) != null) {\n-            Var var = fnScope.getVar(lastArg.getString());\n-            if (!referenced.contains(var)) {\n-                argList.removeChild(lastArg);\n-                compiler.reportCodeChange();\n-            } else {\n-                break;\n-            }\n+        Node lastArg = argList.getLastChild();\n+        while (lastArg != null && !referenced.contains(fnScope.getVar(lastArg.getString()))) {\n+            argList.removeChild(lastArg);\n+            compiler.reportCodeChange();\n+            lastArg = argList.getLastChild();\n         }\n     } else {\n         callSiteOptimizer.optimize(fnScope, referenced);\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null) {\n            Var var = fnScope.getVar(lastArg.getString());\n            if (!referenced.contains(var)) {\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            } else {\n                break;\n            }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, new LinkedHashSet<>(referenced));\n        // create a new set to not modify referenced (passed as argument)\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -29,6 +29,7 @@\n             }\n         }\n     } else {\n-        callSiteOptimizer.optimize(fnScope, referenced);\n+        callSiteOptimizer.optimize(fnScope, new LinkedHashSet<>(referenced));\n+        // create a new set to not modify referenced (passed as argument)\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg = argList.getLastChild();\n        while (lastArg != null && !referenced.contains(fnScope.getVar(lastArg.getString()))) {\n            argList.removeChild(lastArg);\n            compiler.reportCodeChange();\n            lastArg = argList.getLastChild();\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -18,15 +18,11 @@\n     boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n     if (!modifyCallers) {\n         // Strip unreferenced args off the end of the function declaration.\n-        Node lastArg;\n-        while ((lastArg = argList.getLastChild()) != null) {\n-            Var var = fnScope.getVar(lastArg.getString());\n-            if (!referenced.contains(var)) {\n-                argList.removeChild(lastArg);\n-                compiler.reportCodeChange();\n-            } else {\n-                break;\n-            }\n+        Node lastArg = argList.getLastChild();\n+        while (lastArg != null && !referenced.contains(fnScope.getVar(lastArg.getString()))) {\n+            argList.removeChild(lastArg);\n+            compiler.reportCodeChange();\n+            lastArg = argList.getLastChild();\n         }\n     } else {\n         callSiteOptimizer.optimize(fnScope, referenced);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null) {\n            if (lastArg.isName()) {\n                Var var = fnScope.getVar(lastArg.getString());\n                if (!referenced.contains(var)) {\n                    argList.removeChild(lastArg);\n                    compiler.reportCodeChange();\n                } else {\n                    break;\n                }\n            } else { \n                // If we have a destructured argument we check each destructured name in the argument\n                for (Node child = lastArg.getFirstChild(); child != null; child = child.getNext()) {\n                    if (child.isName()) {\n                        Var var = fnScope.getVar(child.getString());\n                        if (!referenced.contains(var)) {\n                            child.detachFromParent();\n                            compiler.reportCodeChange();\n                        }\n                    }\n                }\n                break;\n            }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -20,11 +20,25 @@\n         // Strip unreferenced args off the end of the function declaration.\n         Node lastArg;\n         while ((lastArg = argList.getLastChild()) != null) {\n-            Var var = fnScope.getVar(lastArg.getString());\n-            if (!referenced.contains(var)) {\n-                argList.removeChild(lastArg);\n-                compiler.reportCodeChange();\n-            } else {\n+            if (lastArg.isName()) {\n+                Var var = fnScope.getVar(lastArg.getString());\n+                if (!referenced.contains(var)) {\n+                    argList.removeChild(lastArg);\n+                    compiler.reportCodeChange();\n+                } else {\n+                    break;\n+                }\n+            } else { \n+                // If we have a destructured argument we check each destructured name in the argument\n+                for (Node child = lastArg.getFirstChild(); child != null; child = child.getNext()) {\n+                    if (child.isName()) {\n+                        Var var = fnScope.getVar(child.getString());\n+                        if (!referenced.contains(var)) {\n+                            child.detachFromParent();\n+                            compiler.reportCodeChange();\n+                        }\n+                    }\n+                }\n                 break;\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null) {\n            Var var = fnScope.getVar(lastArg.getString());\n            if (!referenced.contains(var)) {\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            } else {\n                break;\n            }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced, compiler);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -29,6 +29,6 @@\n             }\n         }\n     } else {\n-        callSiteOptimizer.optimize(fnScope, referenced);\n+        callSiteOptimizer.optimize(fnScope, referenced, compiler);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n  \n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node toRemove = null;\n        for (Node arg : argList.children()) {\n            Var var = fnScope.getVar(arg.getString());\n            if (!referenced.contains(var)) {\n                if (toRemove == null) {\n                    toRemove = arg;\n                }\n            } else if (toRemove != null) {\n                argList.removeChildren(toRemove, arg);\n                compiler.reportCodeChange();\n                break;\n            }\n        }\n        if (toRemove != null) {\n            argList.removeChild(toRemove);\n            compiler.reportCodeChange();\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -1,32 +1,31 @@\n private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Notice that removing unreferenced function args breaks\n-    // Function.prototype.length. In advanced mode, we don't really care\n-    // about this: we consider \"length\" the equivalent of reflecting on\n-    // the function's lexical source.\n-    //\n-    // Rather than create a new option for this, we assume that if the user\n-    // is removing globals, then it's OK to remove unused function args.\n-    //\n-    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n     Node function = fnScope.getRootNode();\n     Preconditions.checkState(function.isFunction());\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n         // The parameters object literal setters can not be removed.\n         return;\n     }\n+  \n     Node argList = getFunctionArgList(function);\n     boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n     if (!modifyCallers) {\n         // Strip unreferenced args off the end of the function declaration.\n-        Node lastArg;\n-        while ((lastArg = argList.getLastChild()) != null) {\n-            Var var = fnScope.getVar(lastArg.getString());\n+        Node toRemove = null;\n+        for (Node arg : argList.children()) {\n+            Var var = fnScope.getVar(arg.getString());\n             if (!referenced.contains(var)) {\n-                argList.removeChild(lastArg);\n+                if (toRemove == null) {\n+                    toRemove = arg;\n+                }\n+            } else if (toRemove != null) {\n+                argList.removeChildren(toRemove, arg);\n                 compiler.reportCodeChange();\n-            } else {\n                 break;\n             }\n+        }\n+        if (toRemove != null) {\n+            argList.removeChild(toRemove);\n+            compiler.reportCodeChange();\n         }\n     } else {\n         callSiteOptimizer.optimize(fnScope, referenced);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "The buggy function does not have clear information on what the bug may be, and without a complete understanding of the codebase, it is difficult to provide a fix. Please provide more information about the bug in the function or the context in which it is used.", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null) {\n            Var var = fnScope.getVar(lastArg.getString());\n            if (!referenced.contains(var)) {\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            } else {\n                break;\n            }\n        }\n        // Fix: Adjust the function's length property\n        function.putProp(Node.LENGTH, Node.newNumber(argList.getChildCount()));\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -1,13 +1,4 @@\n private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Notice that removing unreferenced function args breaks\n-    // Function.prototype.length. In advanced mode, we don't really care\n-    // about this: we consider \"length\" the equivalent of reflecting on\n-    // the function's lexical source.\n-    //\n-    // Rather than create a new option for this, we assume that if the user\n-    // is removing globals, then it's OK to remove unused function args.\n-    //\n-    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n     Node function = fnScope.getRootNode();\n     Preconditions.checkState(function.isFunction());\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n@@ -28,6 +19,8 @@\n                 break;\n             }\n         }\n+        // Fix: Adjust the function's length property\n+        function.putProp(Node.LENGTH, Node.newNumber(argList.getChildCount()));\n     } else {\n         callSiteOptimizer.optimize(fnScope, referenced);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    // Create a list of referenced argument names\n    Set<String> referencedArgs = new HashSet<>();\n    for (Var var : fnScope.getVarIterable()) {\n        if (var.isParam() && referenced.contains(var)) {\n            referencedArgs.add(var.getName());\n        }\n    }\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null) {\n            String argName = lastArg.getString();\n            if (!referencedArgs.contains(argName)) {\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            } else {\n                break;\n            }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -1,13 +1,4 @@\n private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Notice that removing unreferenced function args breaks\n-    // Function.prototype.length. In advanced mode, we don't really care\n-    // about this: we consider \"length\" the equivalent of reflecting on\n-    // the function's lexical source.\n-    //\n-    // Rather than create a new option for this, we assume that if the user\n-    // is removing globals, then it's OK to remove unused function args.\n-    //\n-    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n     Node function = fnScope.getRootNode();\n     Preconditions.checkState(function.isFunction());\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n@@ -15,13 +6,20 @@\n         return;\n     }\n     Node argList = getFunctionArgList(function);\n+    // Create a list of referenced argument names\n+    Set<String> referencedArgs = new HashSet<>();\n+    for (Var var : fnScope.getVarIterable()) {\n+        if (var.isParam() && referenced.contains(var)) {\n+            referencedArgs.add(var.getName());\n+        }\n+    }\n     boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n     if (!modifyCallers) {\n         // Strip unreferenced args off the end of the function declaration.\n         Node lastArg;\n         while ((lastArg = argList.getLastChild()) != null) {\n-            Var var = fnScope.getVar(lastArg.getString());\n-            if (!referenced.contains(var)) {\n+            String argName = lastArg.getString();\n+            if (!referencedArgs.contains(argName)) {\n                 argList.removeChild(lastArg);\n                 compiler.reportCodeChange();\n             } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null && lastArg.getNext() != null) {\n            Var var = fnScope.getVar(lastArg.getString());\n            if (!referenced.contains(var)) {\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            } else {\n                break;\n            }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -1,13 +1,4 @@\n private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Notice that removing unreferenced function args breaks\n-    // Function.prototype.length. In advanced mode, we don't really care\n-    // about this: we consider \"length\" the equivalent of reflecting on\n-    // the function's lexical source.\n-    //\n-    // Rather than create a new option for this, we assume that if the user\n-    // is removing globals, then it's OK to remove unused function args.\n-    //\n-    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n     Node function = fnScope.getRootNode();\n     Preconditions.checkState(function.isFunction());\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n@@ -19,7 +10,7 @@\n     if (!modifyCallers) {\n         // Strip unreferenced args off the end of the function declaration.\n         Node lastArg;\n-        while ((lastArg = argList.getLastChild()) != null) {\n+        while ((lastArg = argList.getLastChild()) != null && lastArg.getNext() != null) {\n             Var var = fnScope.getVar(lastArg.getString());\n             if (!referenced.contains(var)) {\n                 argList.removeChild(lastArg);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Strip unreferenced args off the end of the function declaration.\n        Node lastArg;\n        while ((lastArg = argList.getLastChild()) != null) {\n            if (lastArg.isName()) {\n                Var var = fnScope.getVar(lastArg.getString());\n                if (!referenced.contains(var)) {\n                    argList.removeChild(lastArg);\n                    compiler.reportCodeChange();\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -20,10 +20,14 @@\n         // Strip unreferenced args off the end of the function declaration.\n         Node lastArg;\n         while ((lastArg = argList.getLastChild()) != null) {\n-            Var var = fnScope.getVar(lastArg.getString());\n-            if (!referenced.contains(var)) {\n-                argList.removeChild(lastArg);\n-                compiler.reportCodeChange();\n+            if (lastArg.isName()) {\n+                Var var = fnScope.getVar(lastArg.getString());\n+                if (!referenced.contains(var)) {\n+                    argList.removeChild(lastArg);\n+                    compiler.reportCodeChange();\n+                } else {\n+                    break;\n+                }\n             } else {\n                 break;\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    List<Node> toRemove = new ArrayList<>();\n    // Collect unreferenced args to remove.\n    for (Node arg : argList.children()) {\n        Var var = fnScope.getVar(arg.getString());\n        if (!referenced.contains(var)) {\n            toRemove.add(arg);\n        } else if (!toRemove.isEmpty()) {\n            // Stop at the first referenced arg after unreferenced args.\n            break;\n        }\n    }\n    // Remove collected args.\n    for (Node arg : toRemove) {\n        argList.removeChild(arg);\n        compiler.reportCodeChange();\n    }\n    if (modifyCallers) {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n+++ com/google/javascript/jscomp/RemoveUnusedVars.javaremoveUnreferencedFunctionArgs\n@@ -16,19 +16,23 @@\n     }\n     Node argList = getFunctionArgList(function);\n     boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n-    if (!modifyCallers) {\n-        // Strip unreferenced args off the end of the function declaration.\n-        Node lastArg;\n-        while ((lastArg = argList.getLastChild()) != null) {\n-            Var var = fnScope.getVar(lastArg.getString());\n-            if (!referenced.contains(var)) {\n-                argList.removeChild(lastArg);\n-                compiler.reportCodeChange();\n-            } else {\n-                break;\n-            }\n+    List<Node> toRemove = new ArrayList<>();\n+    // Collect unreferenced args to remove.\n+    for (Node arg : argList.children()) {\n+        Var var = fnScope.getVar(arg.getString());\n+        if (!referenced.contains(var)) {\n+            toRemove.add(arg);\n+        } else if (!toRemove.isEmpty()) {\n+            // Stop at the first referenced arg after unreferenced args.\n+            break;\n         }\n-    } else {\n+    }\n+    // Remove collected args.\n+    for (Node arg : toRemove) {\n+        argList.removeChild(arg);\n+        compiler.reportCodeChange();\n+    }\n+    if (modifyCallers) {\n         callSiteOptimizer.optimize(fnScope, referenced);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]