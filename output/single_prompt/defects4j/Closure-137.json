[{"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if (index >= name.length()) {\n        return name;\n    }\n    return name.substring(0, index);\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    if (index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length() >= name.length()) {\n        return \"\";\n    }\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                                // Check if the new name is valid and if it would cause conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    Node parentNameNode = var.getParentNode();\n                    if (parentNameNode.getType() == Token.NAME) {\n                        parentNameNode.setString(newName);\n                    }\n                    var.setName(newName);\n                    node.setString(newName);\n                    nameMap.put(var, newName);\n                    compiler.reportCodeChange();\n                }\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n            if (newName != null) {\n                reserveName(newName);\n            }\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setGlobalName(name, false);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,6 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    if (index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length() >= name.length()) {\n+        return \"\";\n+    }\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -4,7 +4,7 @@\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -27,17 +27,15 @@\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n+                    Node parentNameNode = var.getParentNode();\n+                    if (parentNameNode.getType() == Token.NAME) {\n+                        parentNameNode.setString(newName);\n                     }\n+                    var.setName(newName);\n                     node.setString(newName);\n+                    nameMap.put(var, newName);\n                     compiler.reportCodeChange();\n                 }\n-                nameMap.put(var, newName);\n             }\n             // Add all referenced names to the set so it is possible to check for\n             // conflicts.\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,45 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    Node parentNameNode = var.getParentNode();\n+                    if (parentNameNode.getType() == Token.NAME) {\n+                        parentNameNode.setString(newName);\n+                    }\n+                    var.setName(newName);\n+                    node.setString(newName);\n+                    nameMap.put(var, newName);\n+                    compiler.reportCodeChange();\n+                }\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,3 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    nameUsage.setGlobalName(name, false);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,45 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    Node parentNameNode = var.getParentNode();\n+                    if (parentNameNode.getType() == Token.NAME) {\n+                        parentNameNode.setString(newName);\n+                    }\n+                    var.setName(newName);\n+                    node.setString(newName);\n+                    nameMap.put(var, newName);\n+                    compiler.reportCodeChange();\n+                }\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    return name.substring(0, index) + name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    int endIndex = name.length();\n    if (index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length() < name.length()) {\n        endIndex = name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR, index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n        if (endIndex == -1) {\n            endIndex = name.length();\n        }\n    }\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), endIndex);\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.scope.declare(newName, var.nameNode, null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = name + ContextualRenamer.UNIQUE_ID_SEPARATOR + id;\n            declarations.put(name, newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setGlobal(name);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,10 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    int endIndex = name.length();\n+    if (index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length() < name.length()) {\n+        endIndex = name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR, index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n+        if (endIndex == -1) {\n+            endIndex = name.length();\n+        }\n+    }\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), endIndex);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,7 +23,7 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n+                // Check if the new name is valid and if it would cause conflicts.\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,3 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    nameUsage.setGlobal(name);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if (name == null || index < 0 || index > name.length()) {\n        return name;\n    }\n    return name.substring(0, index);\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    if (name == null || index < 0 || index >= name.length()) {\n        return \"\";\n    }\n    int endIndex = name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR, index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n    if (endIndex == -1) {\n        endIndex = name.length();\n    }\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), endIndex);\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    scope.declare(newName, var.getNameNode(), null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveGlobalName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveGlobalName(String name) {\n    int count = nameUsage.getUseCount(name, -1);\n    if (count == -1) {\n        // Never seen before.\n        nameUsage.addName(name);\n    }\n    nameUsage.setInferredImmutable(name, true);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n        scopeCreator = renamer.getScopeCreator();\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    new PropagateConstantAnnotations(compiler, assertOnChange, scopeCreator).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,10 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    if (name == null || index < 0 || index >= name.length()) {\n+        return \"\";\n+    }\n+    int endIndex = name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR, index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n+    if (endIndex == -1) {\n+        endIndex = name.length();\n+    }\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), endIndex);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,15 +23,15 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    scope.declare(newName, var.getNameNode(), null, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    return name.substring(0, index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME && containsSeparator(node.getString())) {\n        String oldName = node.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(oldName);\n        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n            int index = indexOfSeparator(oldName);\n            String newName = getOriginalNameInternal(oldName, index);\n            String suffix = getNameSuffix(oldName, index);\n            if (!suffix.matches(\"\\\\d+\")) {\n                // find all references to the old name and replace them with the new name\n                NodeTraversal.traverse(compiler, scope.getRootNode(), new NodeTraversal.AbstractPostOrderCallback() {\n                    @Override\n                    public void visit(NodeTraversal t, Node n, Node parent) {\n                        if (n.getType() == Token.NAME && n.getString().equals(oldName)) {\n                            n.setString(newName);\n                            compiler.reportCodeChange();\n                        }\n                    }\n                });\n            }\n            if (var.scope.isDeclared(newName, false) || !TokenStream.isJSIdentifier(newName)) {\n                return;\n            }\n            var.scope.declare(newName, var.nameNode, null, null);\n            nameMap.put(var, newName);\n            node.setString(newName);\n            compiler.reportCodeChange();\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n            } else {\n                newName = name;\n            }\n            declarations.put(name, newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setCount(name, 0, 1);\n    // Also set the count for the original name so that it doesn't get renamed.\n    int index = indexOfSeparator(name);\n    if (index != -1) {\n        String originalName = name.substring(0, index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n        nameUsage.setCount(originalName, 0, 1);\n    }\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    // Propagate constant annotations after removing duplicate declarations\n    // since removing duplicate declarations may affect whether certain nodes\n    // are constants or not.\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,3 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,32 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.getType() == Token.NAME && containsSeparator(node.getString())) {\n         String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            if (!suffix.matches(\"\\\\d+\")) {\n+                // find all references to the old name and replace them with the new name\n+                NodeTraversal.traverse(compiler, scope.getRootNode(), new NodeTraversal.AbstractPostOrderCallback() {\n+                    @Override\n+                    public void visit(NodeTraversal t, Node n, Node parent) {\n+                        if (n.getType() == Token.NAME && n.getString().equals(oldName)) {\n+                            n.setString(newName);\n+                            compiler.reportCodeChange();\n+                        }\n+                    }\n+                });\n+            }\n+            if (var.scope.isDeclared(newName, false) || !TokenStream.isJSIdentifier(newName)) {\n                 return;\n             }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n+            var.scope.declare(newName, var.nameNode, null, null);\n+            nameMap.put(var, newName);\n+            node.setString(newName);\n+            compiler.reportCodeChange();\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,32 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME && containsSeparator(node.getString())) {\n+        String oldName = node.getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            if (!suffix.matches(\"\\\\d+\")) {\n+                // find all references to the old name and replace them with the new name\n+                NodeTraversal.traverse(compiler, scope.getRootNode(), new NodeTraversal.AbstractPostOrderCallback() {\n+                    @Override\n+                    public void visit(NodeTraversal t, Node n, Node parent) {\n+                        if (n.getType() == Token.NAME && n.getString().equals(oldName)) {\n+                            n.setString(newName);\n+                            compiler.reportCodeChange();\n+                        }\n+                    }\n+                });\n             }\n-            declarations.put(name, newName);\n+            if (var.scope.isDeclared(newName, false) || !TokenStream.isJSIdentifier(newName)) {\n+                return;\n+            }\n+            var.scope.declare(newName, var.nameNode, null, null);\n+            nameMap.put(var, newName);\n+            node.setString(newName);\n+            compiler.reportCodeChange();\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,9 @@\n private void reserveName(String name) {\n     nameUsage.setCount(name, 0, 1);\n+    // Also set the count for the original name so that it doesn't get renamed.\n+    int index = indexOfSeparator(name);\n+    if (index != -1) {\n+        String originalName = name.substring(0, index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n+        nameUsage.setCount(originalName, 0, 1);\n+    }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,32 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME && containsSeparator(node.getString())) {\n+        String oldName = node.getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            if (!suffix.matches(\"\\\\d+\")) {\n+                // find all references to the old name and replace them with the new name\n+                NodeTraversal.traverse(compiler, scope.getRootNode(), new NodeTraversal.AbstractPostOrderCallback() {\n+                    @Override\n+                    public void visit(NodeTraversal t, Node n, Node parent) {\n+                        if (n.getType() == Token.NAME && n.getString().equals(oldName)) {\n+                            n.setString(newName);\n+                            compiler.reportCodeChange();\n+                        }\n+                    }\n+                });\n+            }\n+            if (var.scope.isDeclared(newName, false) || !TokenStream.isJSIdentifier(newName)) {\n+                return;\n+            }\n+            var.scope.declare(newName, var.nameNode, null, null);\n+            nameMap.put(var, newName);\n+            node.setString(newName);\n+            compiler.reportCodeChange();\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    // Rename the function to getOriginalName to match its purpose\n    return name.substring(0, index);\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) { // Use isName() instead of getType() == Token.NAME\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.getScope().isDeclared(newName, recurseScopes)\n                        || !TokenUtil.isValidSimpleName(newName, Mode.DEFAULT)) {\n                    newName = oldName;\n                } else {\n                    var.getScope().declare(newName, var.getNameNode(), null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getNameNode().getParent();\n                    if (parentNode.isFunction()) {\n                        if (parentNode.getParent() == var.getScope().getRootNode()) {\n                            var.getNameNode().setString(newName);\n                        }\n                    }\n                    node.setString(newName);\n                    compiler.reportChangeToEnclosingScope(node);\n                    var.setName(newName);\n                }\n                nameMap.put(var, newName);\n            }\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (name != null) { // Add null check to prevent NPE\n        if (global) {\n            reserveName(name);\n        } else {\n            // It hasn't been declared locally yet, so increment the count.\n            if (!declarations.containsKey(name)) {\n                int id = incrementNameCount(name);\n                String newName = null;\n                if (id != 0) {\n                    newName = getUniqueName(name, id);\n                }\n                declarations.put(name, newName);\n            }\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setGlobalSafeName(name);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,3 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,9 +1,8 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) { // Use isName() instead of getType() == Token.NAME\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n             Var var = t.getScope().getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n@@ -12,7 +11,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,25 +22,26 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.getScope().isDeclared(newName, recurseScopes)\n+                        || !TokenUtil.isValidSimpleName(newName, Mode.DEFAULT)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    var.getScope().declare(newName, var.getNameNode(), null, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n+                    Node parentNode = var.getNameNode().getParent();\n+                    if (parentNode.isFunction()) {\n+                        if (parentNode.getParent() == var.getScope().getRootNode()) {\n+                            var.getNameNode().setString(newName);\n+                        }\n                     }\n                     node.setString(newName);\n-                    compiler.reportCodeChange();\n+                    compiler.reportChangeToEnclosingScope(node);\n+                    var.setName(newName);\n                 }\n                 nameMap.put(var, newName);\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) { // Use isName() instead of getType() == Token.NAME\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.getScope().isDeclared(newName, recurseScopes)\n+                        || !TokenUtil.isValidSimpleName(newName, Mode.DEFAULT)) {\n+                    newName = oldName;\n+                } else {\n+                    var.getScope().declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getNameNode().getParent();\n+                    if (parentNode.isFunction()) {\n+                        if (parentNode.getParent() == var.getScope().getRootNode()) {\n+                            var.getNameNode().setString(newName);\n+                        }\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportChangeToEnclosingScope(node);\n+                    var.setName(newName);\n+                }\n+                nameMap.put(var, newName);\n+            }\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,3 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    nameUsage.setGlobalSafeName(name);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) { // Use isName() instead of getType() == Token.NAME\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.getScope().isDeclared(newName, recurseScopes)\n+                        || !TokenUtil.isValidSimpleName(newName, Mode.DEFAULT)) {\n+                    newName = oldName;\n+                } else {\n+                    var.getScope().declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getNameNode().getParent();\n+                    if (parentNode.isFunction()) {\n+                        if (parentNode.getParent() == var.getScope().getRootNode()) {\n+                            var.getNameNode().setString(newName);\n+                        }\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportChangeToEnclosingScope(node);\n+                    var.setName(newName);\n+                }\n+                nameMap.put(var, newName);\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    return name.substring(0, index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length()); // add length of separator\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length()); // add length of separator\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { // check scope not var.scope\n                    newName = oldName;\n                } else {\n                    scope.declare(newName, var.getNameNode(), null, null); // use var.getNameNode() to get the original name node\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        int id = incrementNameCount(name);\n        String newName = null;\n        if (id != 0) {\n            newName = getUniqueName(name, id);\n        }\n        declarations.put(name, newName);\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setGlobalCount(name, 0, 1); // use setGlobalCount to reserve a global name\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root); // swap order of removeDuplicateDeclarations and MakeDeclaredNamesUnique\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,3 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length()); // add length of separator\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,15 +23,15 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { // check scope not var.scope\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    scope.declare(newName, var.getNameNode(), null, null); // use var.getNameNode() to get the original name node\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { // check scope not var.scope\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), null, null); // use var.getNameNode() to get the original name node\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,3 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    nameUsage.setGlobalCount(name, 0, 1); // use setGlobalCount to reserve a global name\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) { // check scope not var.scope\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), null, null); // use var.getNameNode() to get the original name node\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if (index <= name.length()) {\n        return name.substring(0, index);\n    }\n    return name;\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    int length = name.length() - index - ContextualRenamer.UNIQUE_ID_SEPARATOR.length();\n    if (length >= 0) {\n        return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n    }\n    return \"\";\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.scope.declare(newName, var.nameNode, null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportChangeToEnclosingScope(node);\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n        } else {\n            // Reset the count if the name becomes declared again later.\n            resetNameCount(name);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setGlobalName(name);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeVerifyTypes(compiler, assertOnChange));\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    // function f() {\n    //    try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //    var e = 1; // f scope 'e'\n    // }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,7 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    int length = name.length() - index - ContextualRenamer.UNIQUE_ID_SEPARATOR.length();\n+    if (length >= 0) {\n+        return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    }\n+    return \"\";\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,6 +1,6 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,7 +23,7 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n+                // Check if the new name is valid and if it would cause conflicts.\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n@@ -31,11 +31,11 @@\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n-                    compiler.reportCodeChange();\n+                    compiler.reportChangeToEnclosingScope(node);\n                 }\n                 nameMap.put(var, newName);\n             }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportChangeToEnclosingScope(node);\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,3 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    nameUsage.setGlobalName(name);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportChangeToEnclosingScope(node);\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if (index >= 0) {\n        return name.substring(0, index);\n    } else {\n        return name;\n    }\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    if (index >= 0) {\n        return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n    } else {\n        return \"\";\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName() && containsSeparator(node.getString())) {\n        Scope scope = t.getScope();\n        String oldName = node.getString();\n        Var var = scope.getVar(oldName);\n        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n            int index = indexOfSeparator(oldName);\n            String newName = getOriginalNameInternal(oldName, index);\n            String suffix = getNameSuffix(oldName, index);\n            boolean recurseScopes = suffix.matches(\"\\\\d+\");\n            if (!var.getScope().isDeclared(newName, recurseScopes) && TokenStream.isJSIdentifier(newName)) {\n                var.getScope().declare(newName, var.getNameNode(), null, null);\n                if (var.getParentNode().isFunction() && var.getScope().getRootNode() == var.getParentNode()) {\n                    var.getNameNode().setString(newName);\n                }\n                node.setString(newName);\n                nameMap.put(var, newName);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (!global) {\n        if (declarations.containsKey(name)) {\n            nameUsage.setCount(name, 0, 1);\n        } else {\n            int id = incrementNameCount(name);\n            String newName = id == 0 ? null : getUniqueName(name, id);\n            declarations.put(name, newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    if (nameUsage.getCount(name, -1) == 0) {\n        nameUsage.add(name, 1);\n    }\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n    removeDuplicateDeclarations(root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,7 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    if (index >= 0) {\n+        return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    } else {\n+        return \"\";\n+    }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,23 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        Scope scope = t.getScope();\n         String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n+        Var var = scope.getVar(oldName);\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = suffix.matches(\"\\\\d+\");\n+            if (!var.getScope().isDeclared(newName, recurseScopes) && TokenStream.isJSIdentifier(newName)) {\n+                var.getScope().declare(newName, var.getNameNode(), null, null);\n+                if (var.getParentNode().isFunction() && var.getScope().getRootNode() == var.getParentNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                nameMap.put(var, newName);\n+                compiler.reportCodeChange();\n             }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,23 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        Scope scope = t.getScope();\n+        String oldName = node.getString();\n+        Var var = scope.getVar(oldName);\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = suffix.matches(\"\\\\d+\");\n+            if (!var.getScope().isDeclared(newName, recurseScopes) && TokenStream.isJSIdentifier(newName)) {\n+                var.getScope().declare(newName, var.getNameNode(), null, null);\n+                if (var.getParentNode().isFunction() && var.getScope().getRootNode() == var.getParentNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                nameMap.put(var, newName);\n+                compiler.reportCodeChange();\n             }\n-            declarations.put(name, newName);\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,5 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    if (nameUsage.getCount(name, -1) == 0) {\n+        nameUsage.add(name, 1);\n+    }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,23 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        Scope scope = t.getScope();\n+        String oldName = node.getString();\n+        Var var = scope.getVar(oldName);\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = suffix.matches(\"\\\\d+\");\n+            if (!var.getScope().isDeclared(newName, recurseScopes) && TokenStream.isJSIdentifier(newName)) {\n+                var.getScope().declare(newName, var.getNameNode(), null, null);\n+                if (var.getParentNode().isFunction() && var.getScope().getRootNode() == var.getParentNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                nameMap.put(var, newName);\n+                compiler.reportCodeChange();\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if (index < 0 || index >= name.length()) {\n        return name;\n    }\n    return name.substring(0, index);\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    if (index < 0 || index >= name.length() || !containsSeparator(name)) {\n        return \"\";\n    }\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n\n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.getScope().isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.getScope().declare(newName, var.getNameNode(), null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.getScope().getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n                declarations.put(name, newName);\n            }\n            else {\n                declarations.put(name, name);\n            }\n\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    if (nameUsage.getCount(name, -1) == 0) {\n        nameUsage.setCount(name, 0, 1);\n    }\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(compiler, nameGenerator);\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // removeDuplicateDeclarations must be after MakeDeclaredNamesUnique,\n    // with only unconstrained names to detect renames due\n    // to conflict resolution. The implementation\n    // relies on code being valid JS, that is, externs supplies the names\n    // used in the JS within the nullscope. removeDuplicateDeclarations's rename\n    // logic is source form aware and expects correct placement of name nodes.\n    if (fixDuplicates) {\n        new RemoveDuplicateDeclarations(compiler, assertOnChange).process(externs, root);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,6 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    if (index < 0 || index >= name.length() || !containsSeparator(name)) {\n+        return \"\";\n+    }\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -12,8 +12,9 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n+\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n                 // If there isn't anything left in the stack we will be going into the\n@@ -23,15 +24,16 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.getScope().isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    var.getScope().declare(newName, var.getNameNode(), null, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.getScope().getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n@@ -39,9 +41,6 @@\n                 }\n                 nameMap.put(var, newName);\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,46 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.getScope().isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.getScope().declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.getScope().getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,5 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    if (nameUsage.getCount(name, -1) == 0) {\n+        nameUsage.setCount(name, 0, 1);\n+    }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,46 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.getScope().isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.getScope().declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.getScope().getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if(name != null && index >= 0 && index < name.length()) {\n        return name.substring(0, index);\n    }\n    return \"\";\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    if(name != null && index >= 0 && index < name.length()) {\n        return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n    }\n    return \"\";\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    scope.declare(newName, var.getNameNode(), null, var.getJSDocInfo());\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportChangeToEnclosingScope(node);\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveGlobalName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count and store the unique name.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id > 0) {\n                newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveGlobalName(String name) {\n    if (name != null) {\n        if(nameUsage == null) {\n            nameUsage = new NameUsageMap();\n        }\n        nameUsage.reserve(name, -1, 1);\n    }\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    // MakeDeclaredNamesUnique must run before removeDuplicateDeclarations\n    // to handle cases where catch block exception names conflict with\n    // function scope variables.\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,6 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    if(name != null && index >= 0 && index < name.length()) {\n+        return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n+    }\n+    return \"\";\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,10 +1,10 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = t.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,19 +23,19 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    scope.declare(newName, var.getNameNode(), null, var.getJSDocInfo());\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n-                    compiler.reportCodeChange();\n+                    compiler.reportChangeToEnclosingScope(node);\n                 }\n                 nameMap.put(var, newName);\n             }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), null, var.getJSDocInfo());\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportChangeToEnclosingScope(node);\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), null, var.getJSDocInfo());\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportChangeToEnclosingScope(node);\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if (index <= 0) {\n        return \"\";\n    }\n    return name.substring(0, index);\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    int suffixIndex = index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length();\n    if (suffixIndex >= name.length()) {\n        return \"\";\n    }\n    return name.substring(suffixIndex);\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                if (index == -1) {\n                    return;\n                }\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.getScope().isDeclared(newName, recurseScopes) || !isValidName(newName)) {\n                    newName = oldName;\n                } else {\n                    var.getScope().declare(newName, var.getNameNode(), null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode == var.getScope().getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportChangeToEnclosingScope(node);\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reservedNames.add(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setGlobalName(name);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new Normalize(compiler));\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new PropagateConstantProperties(compiler).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,7 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    int suffixIndex = index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length();\n+    if (suffixIndex >= name.length()) {\n+        return \"\";\n+    }\n+    return name.substring(suffixIndex);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,6 +1,6 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n@@ -12,30 +12,30 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                if (index == -1) {\n+                    return;\n+                }\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n                 // If there isn't anything left in the stack we will be going into the\n                 // global scope: don't try to build a set of referenced names for the\n                 // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.getScope().isDeclared(newName, recurseScopes) || !isValidName(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    var.getScope().declare(newName, var.getNameNode(), null, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode == var.getScope().getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n-                    compiler.reportCodeChange();\n+                    compiler.reportChangeToEnclosingScope(node);\n                 }\n                 nameMap.put(var, newName);\n             }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                if (index == -1) {\n+                    return;\n+                }\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.getScope().isDeclared(newName, recurseScopes) || !isValidName(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.getScope().declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.getScope().getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportChangeToEnclosingScope(node);\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,3 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    nameUsage.setGlobalName(name);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                if (index == -1) {\n+                    return;\n+                }\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.getScope().isDeclared(newName, recurseScopes) || !isValidName(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.getScope().declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.getScope().getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportChangeToEnclosingScope(node);\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    return name.substring(0, index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.scope.declare(newName, var.nameNode, null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n            } else {\n                newName = name;\n            }\n            declarations.put(name, newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setGlobalName(name);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,3 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,7 +23,7 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n+                // Check if the new name is valid and if it would cause conflicts.\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,3 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    nameUsage.setGlobalName(name);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    return name.substring(0, index);\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName() && containsSeparator(node.getString())) {\n        String oldName = node.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(oldName);\n        if (var == null || var.isGlobal()) {\n            return;\n        }\n        if (nameMap.containsKey(var)) {\n            node.setString(nameMap.get(var));\n        } else {\n            int index = indexOfSeparator(oldName);\n            String newName = getOriginalNameInternal(oldName, index);\n            String suffix = getNameSuffix(oldName, index);\n            boolean recurseScopes = suffix.isEmpty() || !suffix.matches(\"\\\\d+\");\n            if (TokenStream.isJSIdentifier(newName) && !var.scope.isDeclared(newName, recurseScopes)) {\n                var.scope.declare(newName, var.nameNode, null, null);\n                // Adding a reference to the new name to prevent either the parent\n                // scopes or the current scope renaming another var to this new name.\n                Node parentNode = var.getParentNode();\n                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                    var.getNameNode().setString(newName);\n                }\n                nameMap.put(var, newName);\n                node.setString(newName);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (!global) {\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = id != 0 ? getUniqueName(name, id) : null;\n            declarations.put(name, newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setGlobalName(name);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,3 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,31 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n         String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n-            }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+        if (nameMap.containsKey(var)) {\n+            node.setString(nameMap.get(var));\n+        } else {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = suffix.isEmpty() || !suffix.matches(\"\\\\d+\");\n+            if (TokenStream.isJSIdentifier(newName) && !var.scope.isDeclared(newName, recurseScopes)) {\n+                var.scope.declare(newName, var.nameNode, null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n                 }\n                 nameMap.put(var, newName);\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,31 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        String oldName = node.getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+        if (nameMap.containsKey(var)) {\n+            node.setString(nameMap.get(var));\n+        } else {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = suffix.isEmpty() || !suffix.matches(\"\\\\d+\");\n+            if (TokenStream.isJSIdentifier(newName) && !var.scope.isDeclared(newName, recurseScopes)) {\n+                var.scope.declare(newName, var.nameNode, null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                nameMap.put(var, newName);\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n             }\n-            declarations.put(name, newName);\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,3 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    nameUsage.setGlobalName(name);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,31 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        String oldName = node.getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+        if (nameMap.containsKey(var)) {\n+            node.setString(nameMap.get(var));\n+        } else {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = suffix.isEmpty() || !suffix.matches(\"\\\\d+\");\n+            if (TokenStream.isJSIdentifier(newName) && !var.scope.isDeclared(newName, recurseScopes)) {\n+                var.scope.declare(newName, var.nameNode, null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                nameMap.put(var, newName);\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if (name.length() > index) {\n        return name.substring(0, index);\n    }\n    return name;\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    if (name.length() > index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length()) {\n        return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n    }\n    return \"\";\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME && containsSeparator(node.getString())) {\n        Scope scope = t.getScope();\n        Var var = scope.getVar(node.getString());\n        if (var == null || var.isGlobal() || nameMap.containsKey(var)) {\n            return;\n        }\n        int index = indexOfSeparator(node.getString());\n        String newName = getOriginalNameInternal(node.getString(), index);\n        String suffix = getNameSuffix(node.getString(), index);\n        // Merge any names that were referenced but not declared in the current\n        // scope.\n        // If there isn't anything left in the stack we will be going into the\n        // global scope: don't try to build a set of referenced names for the\n        // global scope.\n        boolean recurseScopes = false;\n        if (!suffix.matches(\"\\\\d+\")) {\n            recurseScopes = true;\n        }\n        // Check if the new name is valid and if it would cause conflicts.\n        if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n            newName = node.getString();\n        } else {\n            var.setName(newName);\n            nameMap.put(var, newName);\n            compiler.reportCodeChange();\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            declarations.put(name, 0);\n        }\n        int id = declarations.get(name) + 1;\n        declarations.put(name, id);\n        if (id != 0) {\n            String newName = getUniqueName(name, id);\n            namesInUse.add(newName);\n            markNameUsed(newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    if (!nameUsage.isUsed(name)) {\n        nameUsage.setCount(name, 0, 1);\n    }\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n    removeDuplicateDeclarations(root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,6 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    if (name.length() > index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length()) {\n+        return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    }\n+    return \"\";\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,30 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n-        String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n-            }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n+    if (node.getType() == Token.NAME && containsSeparator(node.getString())) {\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(node.getString());\n+        if (var == null || var.isGlobal() || nameMap.containsKey(var)) {\n+            return;\n+        }\n+        int index = indexOfSeparator(node.getString());\n+        String newName = getOriginalNameInternal(node.getString(), index);\n+        String suffix = getNameSuffix(node.getString(), index);\n+        // Merge any names that were referenced but not declared in the current\n+        // scope.\n+        // If there isn't anything left in the stack we will be going into the\n+        // global scope: don't try to build a set of referenced names for the\n+        // global scope.\n+        boolean recurseScopes = false;\n+        if (!suffix.matches(\"\\\\d+\")) {\n+            recurseScopes = true;\n+        }\n+        // Check if the new name is valid and if it would cause conflicts.\n+        if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+            newName = node.getString();\n+        } else {\n+            var.setName(newName);\n+            nameMap.put(var, newName);\n+            compiler.reportCodeChange();\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,30 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n-            }\n-            declarations.put(name, newName);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME && containsSeparator(node.getString())) {\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(node.getString());\n+        if (var == null || var.isGlobal() || nameMap.containsKey(var)) {\n+            return;\n+        }\n+        int index = indexOfSeparator(node.getString());\n+        String newName = getOriginalNameInternal(node.getString(), index);\n+        String suffix = getNameSuffix(node.getString(), index);\n+        // Merge any names that were referenced but not declared in the current\n+        // scope.\n+        // If there isn't anything left in the stack we will be going into the\n+        // global scope: don't try to build a set of referenced names for the\n+        // global scope.\n+        boolean recurseScopes = false;\n+        if (!suffix.matches(\"\\\\d+\")) {\n+            recurseScopes = true;\n+        }\n+        // Check if the new name is valid and if it would cause conflicts.\n+        if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+            newName = node.getString();\n+        } else {\n+            var.setName(newName);\n+            nameMap.put(var, newName);\n+            compiler.reportCodeChange();\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,5 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    if (!nameUsage.isUsed(name)) {\n+        nameUsage.setCount(name, 0, 1);\n+    }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,30 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME && containsSeparator(node.getString())) {\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(node.getString());\n+        if (var == null || var.isGlobal() || nameMap.containsKey(var)) {\n+            return;\n+        }\n+        int index = indexOfSeparator(node.getString());\n+        String newName = getOriginalNameInternal(node.getString(), index);\n+        String suffix = getNameSuffix(node.getString(), index);\n+        // Merge any names that were referenced but not declared in the current\n+        // scope.\n+        // If there isn't anything left in the stack we will be going into the\n+        // global scope: don't try to build a set of referenced names for the\n+        // global scope.\n+        boolean recurseScopes = false;\n+        if (!suffix.matches(\"\\\\d+\")) {\n+            recurseScopes = true;\n+        }\n+        // Check if the new name is valid and if it would cause conflicts.\n+        if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+            newName = node.getString();\n+        } else {\n+            var.setName(newName);\n+            nameMap.put(var, newName);\n+            compiler.reportCodeChange();\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    return name.substring(0, index - ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getOwnSlot(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    Node nameNode = var.getNameNode();\n                    scope.declare(newName, nameNode, var.input, null);\n                    if (nameNode != null && nameNode.getParent() != null) {\n                        Node enclosing = nameNode.getParent();\n                        if (NodeUtil.isFunctionDeclaration(enclosing) || NodeUtil.isClassDeclaration(enclosing)) {\n                            nameNode.setString(newName);\n                        } else {\n                            node.setString(newName);\n                        }\n                    } else {\n                        node.setString(newName);\n                    }\n                    nameMap.put(var, newName);\n                    compiler.reportCodeChange();\n                }\n            }\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n            } else {\n                newName = name;\n            }\n            declarations.put(name, newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setGlobalName(name);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements());\n    removeDuplicateDeclarations.process(externs, root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    new PropagateConstantAnnotations(compiler).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,3 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -4,7 +4,7 @@\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getOwnSlot(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -12,36 +12,31 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n                 boolean recurseScopes = false;\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n+                    Node nameNode = var.getNameNode();\n+                    scope.declare(newName, nameNode, var.input, null);\n+                    if (nameNode != null && nameNode.getParent() != null) {\n+                        Node enclosing = nameNode.getParent();\n+                        if (NodeUtil.isFunctionDeclaration(enclosing) || NodeUtil.isClassDeclaration(enclosing)) {\n+                            nameNode.setString(newName);\n+                        } else {\n+                            node.setString(newName);\n+                        }\n+                    } else {\n+                        node.setString(newName);\n                     }\n-                    node.setString(newName);\n+                    nameMap.put(var, newName);\n                     compiler.reportCodeChange();\n                 }\n-                nameMap.put(var, newName);\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,42 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getOwnSlot(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    Node nameNode = var.getNameNode();\n+                    scope.declare(newName, nameNode, var.input, null);\n+                    if (nameNode != null && nameNode.getParent() != null) {\n+                        Node enclosing = nameNode.getParent();\n+                        if (NodeUtil.isFunctionDeclaration(enclosing) || NodeUtil.isClassDeclaration(enclosing)) {\n+                            nameNode.setString(newName);\n+                        } else {\n+                            node.setString(newName);\n+                        }\n+                    } else {\n+                        node.setString(newName);\n+                    }\n+                    nameMap.put(var, newName);\n+                    compiler.reportCodeChange();\n+                }\n+            }\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,3 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    nameUsage.setGlobalName(name);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,42 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getOwnSlot(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    Node nameNode = var.getNameNode();\n+                    scope.declare(newName, nameNode, var.input, null);\n+                    if (nameNode != null && nameNode.getParent() != null) {\n+                        Node enclosing = nameNode.getParent();\n+                        if (NodeUtil.isFunctionDeclaration(enclosing) || NodeUtil.isClassDeclaration(enclosing)) {\n+                            nameNode.setString(newName);\n+                        } else {\n+                            node.setString(newName);\n+                        }\n+                    } else {\n+                        node.setString(newName);\n+                    }\n+                    nameMap.put(var, newName);\n+                    compiler.reportCodeChange();\n+                }\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if (index < 0 || index >= name.length()) {\n        return name;\n    }\n    return name.substring(0, index);\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    if (index < 0 || index >= name.length()) {\n        return \"\";\n    }\n    int endIndex = index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length();\n    if (endIndex >= name.length()) {\n        return \"\";\n    }\n    return name.substring(endIndex);\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.scope.declare(newName, var.nameNode, null, null);\n                    if (var.getParentNode().isFunction() && var.getParentNode() == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        int count = nameCounts.containsKey(name) ? nameCounts.get(name) : 0;\n        int id = count + 1;\n        nameCounts.put(name, id);\n        String newName = getUniqueName(name, id);\n        declarations.put(name, newName);\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    if (nameUsage.isUsed(name)) {\n        nameUsage.setCount(name, 0, 1);\n    }\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t1 = new NodeTraversal(compiler, renamer);\n        t1.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,10 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    if (index < 0 || index >= name.length()) {\n+        return \"\";\n+    }\n+    int endIndex = index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length();\n+    if (endIndex >= name.length()) {\n+        return \"\";\n+    }\n+    return name.substring(endIndex);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,10 +1,10 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -12,26 +12,14 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n                     var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (var.getParentNode().isFunction() && var.getParentNode() == var.scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n@@ -39,9 +27,6 @@\n                 }\n                 nameMap.put(var, newName);\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,32 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    if (var.getParentNode().isFunction() && var.getParentNode() == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,5 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    if (nameUsage.isUsed(name)) {\n+        nameUsage.setCount(name, 0, 1);\n+    }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,32 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    if (var.getParentNode().isFunction() && var.getParentNode() == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if (index >= name.length()) {\n        return name;\n    }\n    return name.substring(0, index);\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    if (index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length() >= name.length()) {\n        return \"\";\n    }\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n                // Check if the new name is valid and if it would cause conflicts.\n                if (newName.equals(oldName) || var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    Node nameNode = var.getNameNode();\n                    if (nameNode.isName()) {\n                        nameNode.setString(newName);\n                    } else if (nameNode.isGetProp()) {\n                        nameNode.getLastChild().setString(newName);\n                    }\n                    var.scope.declare(newName, var.nameNode, null, null);\n                    nameMap.put(var, newName);\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n            }\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        String newName = name;\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            if (id > 0) {\n                newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n        }\n        localNames.add(newName);\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    if (!nameUsage.isUsed(name, VarUsage.Type.NAME)) {\n        nameUsage.setCount(name, VarUsage.Type.NAME, 0);\n    }\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        VarRenamingVisitor renamer = new VarRenamingVisitor(compiler, nameIndex, idGenerator, classProperties);\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,6 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    if (index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length() >= name.length()) {\n+        return \"\";\n+    }\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,9 +1,8 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n             Var var = t.getScope().getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n@@ -12,36 +11,25 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (newName.equals(oldName) || var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n+                    Node nameNode = var.getNameNode();\n+                    if (nameNode.isName()) {\n+                        nameNode.setString(newName);\n+                    } else if (nameNode.isGetProp()) {\n+                        nameNode.getLastChild().setString(newName);\n+                    }\n                     var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n+                    nameMap.put(var, newName);\n                     node.setString(newName);\n                     compiler.reportCodeChange();\n                 }\n-                nameMap.put(var, newName);\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,35 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (newName.equals(oldName) || var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    Node nameNode = var.getNameNode();\n+                    if (nameNode.isName()) {\n+                        nameNode.setString(newName);\n+                    } else if (nameNode.isGetProp()) {\n+                        nameNode.getLastChild().setString(newName);\n+                    }\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    nameMap.put(var, newName);\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+            }\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,5 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    if (!nameUsage.isUsed(name, VarUsage.Type.NAME)) {\n+        nameUsage.setCount(name, VarUsage.Type.NAME, 0);\n+    }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,35 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (newName.equals(oldName) || var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    Node nameNode = var.getNameNode();\n+                    if (nameNode.isName()) {\n+                        nameNode.setString(newName);\n+                    } else if (nameNode.isGetProp()) {\n+                        nameNode.getLastChild().setString(newName);\n+                    }\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    nameMap.put(var, newName);\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    return name.substring(0, index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.scope.declare(newName, var.getNameNode(), null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName != null ? newName : name);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setGlobalNameUsed(name);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,3 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,10 +1,10 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,15 +23,15 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n+                // Check if the new name is valid and if it would cause conflicts.\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    var.scope.declare(newName, var.getNameNode(), null, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,3 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    nameUsage.setGlobalNameUsed(name);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if (index == -1) {\n        return name;\n    }\n    return name.substring(0, index);\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    if (index == -1) {\n        return \"\";\n    }\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                                // Check if the new name is valid and if it would cause conflicts.\n                if (!var.scope.isDeclared(newName, recurseScopes) && TokenStream.isJSIdentifier(newName)) {\n                    var.scope.declare(newName, var.nameNode, null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                    nameMap.put(var, newName);\n                }\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n            } else {\n                newName = name;\n            }\n            declarations.put(name, newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setGlobalCount(name, 0, 1);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflicts with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,6 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    if (index == -1) {\n+        return \"\";\n+    }\n+    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -24,9 +24,7 @@\n                     recurseScopes = true;\n                 }\n                                 // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n+                if (!var.scope.isDeclared(newName, recurseScopes) && TokenStream.isJSIdentifier(newName)) {\n                     var.scope.declare(newName, var.nameNode, null, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n@@ -36,8 +34,8 @@\n                     }\n                     node.setString(newName);\n                     compiler.reportCodeChange();\n+                    nameMap.put(var, newName);\n                 }\n-                nameMap.put(var, newName);\n             }\n             // Add all referenced names to the set so it is possible to check for\n             // conflicts.\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,45 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                                // Check if the new name is valid and if it would cause conflicts.\n+                if (!var.scope.isDeclared(newName, recurseScopes) && TokenStream.isJSIdentifier(newName)) {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                    nameMap.put(var, newName);\n+                }\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,3 @@\n private void reserveName(String name) {\n-    nameUsage.setCount(name, 0, 1);\n+    nameUsage.setGlobalCount(name, 0, 1);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,45 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                                // Check if the new name is valid and if it would cause conflicts.\n+                if (!var.scope.isDeclared(newName, recurseScopes) && TokenStream.isJSIdentifier(newName)) {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                    nameMap.put(var, newName);\n+                }\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate static String getOriginalNameInternal(String name, int index) {\n    if (index > 0) {\n        return name.substring(0, index);\n    }\n    return name;\n}\n\n## Fixed Function 2\nprivate static String getNameSuffix(String name, int index) {\n    if (index >= 0) {\n        return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n    }\n    return name;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.scope.declare(newName, var.getNameNode(), null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportChangeToEnclosingScope(node);\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}\n\n## Fixed Function 4\n@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n            } else {\n                newName = name;\n            }\n            declarations.put(name, newName);\n        }\n    }\n}\n\n## Fixed Function 5\nprivate void reserveName(String name) {\n    nameUsage.setCount(name, 0, 1);\n    nameUsage.reserve(name);\n}\n\n## Fixed Function 6\n@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // removeDuplicateDeclarations moved below MakeDeclaredNamesUnique\n    // so that catch variable names are handled properly.\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n    removeDuplicateDeclarations(root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@getNameSuffix\n@@ -1,3 +1,6 @@\n private static String getNameSuffix(String name, int index) {\n-    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n+    if (index >= 0) {\n+        return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length());\n+    }\n+    return name;\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -4,7 +4,7 @@\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,11 +23,11 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n+                // Check if the new name is valid and if it would cause conflicts.\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    var.scope.declare(newName, var.getNameNode(), null, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n@@ -35,7 +35,7 @@\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n-                    compiler.reportCodeChange();\n+                    compiler.reportChangeToEnclosingScope(node);\n                 }\n                 nameMap.put(var, newName);\n             }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportChangeToEnclosingScope(node);\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@reserveName\n@@ -1,3 +1,4 @@\n private void reserveName(String name) {\n     nameUsage.setCount(name, 0, 1);\n+    nameUsage.reserve(name);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportChangeToEnclosingScope(node);\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]