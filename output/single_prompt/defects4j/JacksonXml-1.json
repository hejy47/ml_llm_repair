[{"output": "// DEBUGGING\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                if (_namesToWrap != null && _namesToWrap.contains(_xmlTokens.getLocalName())) {\n                    return JsonToken.START_OBJECT;\n                }\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}", "diff": "--- com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n+++ com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n@@ -20,6 +20,9 @@\n                 break;\n             case FIELD_NAME:\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+                if (_namesToWrap != null && _namesToWrap.contains(_xmlTokens.getLocalName())) {\n+                    return JsonToken.START_OBJECT;\n+                }\n                 break;\n             // VALUE_STRING, VALUE_NULL\n             default:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// DEBUGGING\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.replayStartElement();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}", "diff": "--- com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n+++ com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n@@ -49,7 +49,7 @@\n         // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n         // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n         if (_namesToWrap != null && _namesToWrap.contains(name)) {\n-            _xmlTokens.repeatStartElement();\n+            _xmlTokens.replayStartElement();\n         }\n         _mayBeLeaf = true;\n         // Ok: in array context we need to skip reporting field names.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// DEBUGGING\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n                // Do nothing\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            } else {\n                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                return _currToken;\n            }\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if ((_currToken != JsonToken.FIELD_NAME) && _parsingContext.hasCurrentName() && _isEmpty(_currText)) {\n                    _currToken = _parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n        default:\n            throw new IllegalStateException(\"Unexpected token: \" + token);\n    }\n}", "diff": "--- com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n+++ com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n@@ -23,6 +23,7 @@\n                 break;\n             // VALUE_STRING, VALUE_NULL\n             default:\n+                // Do nothing\n         }\n         return t;\n     }\n@@ -65,11 +66,12 @@\n                 // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                 //    expose as empty Object, not null\n                 return (_currToken = JsonToken.VALUE_NULL);\n+            } else {\n+                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n+                _parsingContext = _parsingContext.getParent();\n+                _namesToWrap = _parsingContext.getNamesToWrap();\n+                return _currToken;\n             }\n-            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n-            _parsingContext = _parsingContext.getParent();\n-            _namesToWrap = _parsingContext.getNamesToWrap();\n-            return _currToken;\n         case XmlTokenStream.XML_ATTRIBUTE_NAME:\n             // If there was a chance of leaf node, no more...\n             if (_mayBeLeaf) {\n@@ -88,7 +90,7 @@\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n-                                // Also: must skip following END_ELEMENT\n+                // Also: must skip following END_ELEMENT\n                 _xmlTokens.skipEndElement();\n                 if (_parsingContext.inArray()) {\n                     if (_isEmpty(_currText)) {\n@@ -104,8 +106,8 @@\n                 return (_currToken = JsonToken.VALUE_STRING);\n             } else {\n                 // [dataformat-xml#177]: empty text may also need to be skipped\n-                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n-                    _currToken = JsonToken.END_OBJECT;\n+                if ((_currToken != JsonToken.FIELD_NAME) && _parsingContext.hasCurrentName() && _isEmpty(_currText)) {\n+                    _currToken = _parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n                     _parsingContext = _parsingContext.getParent();\n                     _namesToWrap = _parsingContext.getNamesToWrap();\n                     return _currToken;\n@@ -117,8 +119,7 @@\n             return (_currToken = JsonToken.FIELD_NAME);\n         case XmlTokenStream.XML_END:\n             return (_currToken = null);\n+        default:\n+            throw new IllegalStateException(\"Unexpected token: \" + token);\n     }\n-    // should never get here\n-    _throwInternal();\n-    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// FIXED\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 9}, {"output": "// DEBUGGING\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return null;\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}", "diff": "--- com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n+++ com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n@@ -116,7 +116,7 @@\n             _nextToken = JsonToken.VALUE_STRING;\n             return (_currToken = JsonToken.FIELD_NAME);\n         case XmlTokenStream.XML_END:\n-            return (_currToken = null);\n+            return null;\n     }\n     // should never get here\n     _throwInternal();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// DEBUGGING\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext != null ? _parsingContext.getNamesToWrap() : null; // added null check\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext != null ? _parsingContext.getNamesToWrap() : null; // added null check\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext != null ? _parsingContext.getNamesToWrap() : null; // added null check\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}", "diff": "--- com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n+++ com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n@@ -68,7 +68,7 @@\n             }\n             _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n             _parsingContext = _parsingContext.getParent();\n-            _namesToWrap = _parsingContext.getNamesToWrap();\n+            _namesToWrap = _parsingContext != null ? _parsingContext.getNamesToWrap() : null; // added null check\n             return _currToken;\n         case XmlTokenStream.XML_ATTRIBUTE_NAME:\n             // If there was a chance of leaf node, no more...\n@@ -97,7 +97,7 @@\n                         //    be done, by swallowing the token)\n                         _currToken = JsonToken.END_ARRAY;\n                         _parsingContext = _parsingContext.getParent();\n-                        _namesToWrap = _parsingContext.getNamesToWrap();\n+                        _namesToWrap = _parsingContext != null ? _parsingContext.getNamesToWrap() : null; // added null check\n                         return _currToken;\n                     }\n                 }\n@@ -107,7 +107,7 @@\n                 if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                     _currToken = JsonToken.END_OBJECT;\n                     _parsingContext = _parsingContext.getParent();\n-                    _namesToWrap = _parsingContext.getNamesToWrap();\n+                    _namesToWrap = _parsingContext != null ? _parsingContext.getNamesToWrap() : null; // added null check\n                     return _currToken;\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// DEBUGGING\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.VALUE_NULL;\n                        return _currToken;\n                    } else {\n                        return (_currToken = JsonToken.VALUE_STRING);\n                    }\n                } else {\n                    return (_currToken = JsonToken.VALUE_STRING);\n                }\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    if (!_xmlTokens.hasNext()) {\n                        _currToken = null;\n                        return _currToken;\n                    }\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                } else {\n                    // If not leaf, need to transform into property\n                    _parsingContext.setCurrentName(_cfgNameForTextElement);\n                    _nextToken = JsonToken.VALUE_STRING;\n                    return (_currToken = JsonToken.FIELD_NAME);\n                }\n            }\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}", "diff": "--- com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n+++ com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n@@ -6,7 +6,7 @@\n         JsonToken t = _nextToken;\n         _currToken = t;\n         _nextToken = null;\n-        switch(t) {\n+        switch (t) {\n             case START_OBJECT:\n                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                 break;\n@@ -57,7 +57,7 @@\n         return (_currToken = JsonToken.FIELD_NAME);\n     }\n     // Ok; beyond start element, what do we get?\n-    switch(token) {\n+    switch (token) {\n         case XmlTokenStream.XML_END_ELEMENT:\n             // Simple, except that if this is a leaf, need to suppress end:\n             if (_mayBeLeaf) {\n@@ -88,33 +88,39 @@\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n-                                // Also: must skip following END_ELEMENT\n+                // Also: must skip following END_ELEMENT\n                 _xmlTokens.skipEndElement();\n                 if (_parsingContext.inArray()) {\n                     if (_isEmpty(_currText)) {\n                         // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                         //    expose as empty Object, not null (or, worse, as used to\n                         //    be done, by swallowing the token)\n-                        _currToken = JsonToken.END_ARRAY;\n-                        _parsingContext = _parsingContext.getParent();\n-                        _namesToWrap = _parsingContext.getNamesToWrap();\n+                        _currToken = JsonToken.VALUE_NULL;\n                         return _currToken;\n+                    } else {\n+                        return (_currToken = JsonToken.VALUE_STRING);\n                     }\n+                } else {\n+                    return (_currToken = JsonToken.VALUE_STRING);\n                 }\n-                return (_currToken = JsonToken.VALUE_STRING);\n             } else {\n                 // [dataformat-xml#177]: empty text may also need to be skipped\n                 if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n+                    if (!_xmlTokens.hasNext()) {\n+                        _currToken = null;\n+                        return _currToken;\n+                    }\n                     _currToken = JsonToken.END_OBJECT;\n                     _parsingContext = _parsingContext.getParent();\n                     _namesToWrap = _parsingContext.getNamesToWrap();\n                     return _currToken;\n+                } else {\n+                    // If not leaf, need to transform into property\n+                    _parsingContext.setCurrentName(_cfgNameForTextElement);\n+                    _nextToken = JsonToken.VALUE_STRING;\n+                    return (_currToken = JsonToken.FIELD_NAME);\n                 }\n             }\n-            // If not a leaf (or otherwise ignorable), need to transform into property...\n-            _parsingContext.setCurrentName(_cfgNameForTextElement);\n-            _nextToken = JsonToken.VALUE_STRING;\n-            return (_currToken = JsonToken.FIELD_NAME);\n         case XmlTokenStream.XML_END:\n             return (_currToken = null);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// DEBUGGING\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.replayStartTag();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.VALUE_NULL;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}", "diff": "--- com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n+++ com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n@@ -49,7 +49,7 @@\n         // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n         // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n         if (_namesToWrap != null && _namesToWrap.contains(name)) {\n-            _xmlTokens.repeatStartElement();\n+            _xmlTokens.replayStartTag();\n         }\n         _mayBeLeaf = true;\n         // Ok: in array context we need to skip reporting field names.\n@@ -88,14 +88,14 @@\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n-                                // Also: must skip following END_ELEMENT\n-                _xmlTokens.skipEndElement();\n+                // Also: must skip following END_ELEMENT\n+                _xmlTokens.skipElement();\n                 if (_parsingContext.inArray()) {\n                     if (_isEmpty(_currText)) {\n                         // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                         //    expose as empty Object, not null (or, worse, as used to\n                         //    be done, by swallowing the token)\n-                        _currToken = JsonToken.END_ARRAY;\n+                        _currToken = JsonToken.VALUE_NULL;\n                         _parsingContext = _parsingContext.getParent();\n                         _namesToWrap = _parsingContext.getNamesToWrap();\n                         return _currToken;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// DEBUGGING\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n                break; // Add default case to suppress warnings\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.VALUE_NULL;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    } else {\n                        _nextToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return (_currToken = JsonToken.FIELD_NAME);\n                    }\n                } else {\n                    _nextToken = JsonToken.VALUE_STRING;\n                    return (_currToken = JsonToken.FIELD_NAME);\n                }\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n        default:\n            break; // Add default case to suppress warnings\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}", "diff": "--- com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n+++ com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n@@ -23,6 +23,7 @@\n                 break;\n             // VALUE_STRING, VALUE_NULL\n             default:\n+                break; // Add default case to suppress warnings\n         }\n         return t;\n     }\n@@ -95,13 +96,20 @@\n                         // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                         //    expose as empty Object, not null (or, worse, as used to\n                         //    be done, by swallowing the token)\n-                        _currToken = JsonToken.END_ARRAY;\n+                        _currToken = JsonToken.VALUE_NULL;\n                         _parsingContext = _parsingContext.getParent();\n                         _namesToWrap = _parsingContext.getNamesToWrap();\n                         return _currToken;\n+                    } else {\n+                        _nextToken = JsonToken.END_ARRAY;\n+                        _parsingContext = _parsingContext.getParent();\n+                        _namesToWrap = _parsingContext.getNamesToWrap();\n+                        return (_currToken = JsonToken.FIELD_NAME);\n                     }\n+                } else {\n+                    _nextToken = JsonToken.VALUE_STRING;\n+                    return (_currToken = JsonToken.FIELD_NAME);\n                 }\n-                return (_currToken = JsonToken.VALUE_STRING);\n             } else {\n                 // [dataformat-xml#177]: empty text may also need to be skipped\n                 if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n@@ -117,6 +125,8 @@\n             return (_currToken = JsonToken.FIELD_NAME);\n         case XmlTokenStream.XML_END:\n             return (_currToken = null);\n+        default:\n+            break; // Add default case to suppress warnings\n     }\n     // should never get here\n     _throwInternal();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// DEBUGGING\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                // Added a null check for getParent() method\n                if (_parsingContext.getParent() != null) {\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                }\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            // Added a null check for getParent() method\n            if (_parsingContext.getParent() != null) {\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n            }\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        // Added a null check for getParent() method\n                        if (_parsingContext.getParent() != null) {\n                            _parsingContext = _parsingContext.getParent();\n                            _namesToWrap = _parsingContext.getNamesToWrap();\n                        }\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    // Added a null check for getParent() method\n                    if (_parsingContext.getParent() != null) {\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                    }\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}", "diff": "--- com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n+++ com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n@@ -15,8 +15,11 @@\n                 break;\n             case END_OBJECT:\n             case END_ARRAY:\n-                _parsingContext = _parsingContext.getParent();\n-                _namesToWrap = _parsingContext.getNamesToWrap();\n+                // Added a null check for getParent() method\n+                if (_parsingContext.getParent() != null) {\n+                    _parsingContext = _parsingContext.getParent();\n+                    _namesToWrap = _parsingContext.getNamesToWrap();\n+                }\n                 break;\n             case FIELD_NAME:\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n@@ -67,8 +70,11 @@\n                 return (_currToken = JsonToken.VALUE_NULL);\n             }\n             _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n-            _parsingContext = _parsingContext.getParent();\n-            _namesToWrap = _parsingContext.getNamesToWrap();\n+            // Added a null check for getParent() method\n+            if (_parsingContext.getParent() != null) {\n+                _parsingContext = _parsingContext.getParent();\n+                _namesToWrap = _parsingContext.getNamesToWrap();\n+            }\n             return _currToken;\n         case XmlTokenStream.XML_ATTRIBUTE_NAME:\n             // If there was a chance of leaf node, no more...\n@@ -96,8 +102,11 @@\n                         //    expose as empty Object, not null (or, worse, as used to\n                         //    be done, by swallowing the token)\n                         _currToken = JsonToken.END_ARRAY;\n-                        _parsingContext = _parsingContext.getParent();\n-                        _namesToWrap = _parsingContext.getNamesToWrap();\n+                        // Added a null check for getParent() method\n+                        if (_parsingContext.getParent() != null) {\n+                            _parsingContext = _parsingContext.getParent();\n+                            _namesToWrap = _parsingContext.getNamesToWrap();\n+                        }\n                         return _currToken;\n                     }\n                 }\n@@ -106,8 +115,11 @@\n                 // [dataformat-xml#177]: empty text may also need to be skipped\n                 if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                     _currToken = JsonToken.END_OBJECT;\n-                    _parsingContext = _parsingContext.getParent();\n-                    _namesToWrap = _parsingContext.getNamesToWrap();\n+                    // Added a null check for getParent() method\n+                    if (_parsingContext.getParent() != null) {\n+                        _parsingContext = _parsingContext.getParent();\n+                        _namesToWrap = _parsingContext.getNamesToWrap();\n+                    }\n                     return _currToken;\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// DEBUGGING\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default: // Do nothing\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Check if _mayBeLeaf flag needs to be reset\n    if (_mayBeLeaf && token != XmlTokenStream.XML_START_ELEMENT) {\n        _mayBeLeaf = false;\n    }\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}", "diff": "--- com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n+++ com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n@@ -22,11 +22,15 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 break;\n             // VALUE_STRING, VALUE_NULL\n-            default:\n+            default: // Do nothing\n         }\n         return t;\n     }\n     int token = _xmlTokens.next();\n+    // Check if _mayBeLeaf flag needs to be reset\n+    if (_mayBeLeaf && token != XmlTokenStream.XML_START_ELEMENT) {\n+        _mayBeLeaf = false;\n+    }\n     // Need to have a loop just because we may have to eat/convert\n     // a start-element that indicates an array element.\n     while (token == XmlTokenStream.XML_START_ELEMENT) {\n@@ -88,7 +92,7 @@\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n-                                // Also: must skip following END_ELEMENT\n+                // Also: must skip following END_ELEMENT\n                 _xmlTokens.skipEndElement();\n                 if (_parsingContext.inArray()) {\n                     if (_isEmpty(_currText)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// DEBUGGING\n@Override\npublic JsonToken nextToken() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        switch(t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            // VALUE_STRING, VALUE_NULL\n            default:\n        }\n        return t;\n    }\n    int token = _xmlTokens.next();\n    // Need to have a loop just because we may have to eat/convert\n    // a start-element that indicates an array element.\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        // If we thought we might get leaf, no such luck\n        if (_mayBeLeaf) {\n            // leave _mayBeLeaf set, as we start a new context\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (_parsingContext.inArray()) {\n            // Yup: in array, so this element could be verified; but it won't be\n            // reported anyway, and we need to process following event.\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        // Ok: in array context we need to skip reporting field names.\n        // But what's the best way to find next token?\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n    // Ok; beyond start element, what do we get?\n    switch(token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            } else {\n                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                return _currToken;\n            }\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n    }\n    // should never get here\n    _throwInternal();\n    return null;\n}", "diff": "--- com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n+++ com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java@nextToken\n@@ -65,11 +65,12 @@\n                 // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                 //    expose as empty Object, not null\n                 return (_currToken = JsonToken.VALUE_NULL);\n+            } else {\n+                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n+                _parsingContext = _parsingContext.getParent();\n+                _namesToWrap = _parsingContext.getNamesToWrap();\n+                return _currToken;\n             }\n-            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n-            _parsingContext = _parsingContext.getParent();\n-            _namesToWrap = _parsingContext.getNamesToWrap();\n-            return _currToken;\n         case XmlTokenStream.XML_ATTRIBUTE_NAME:\n             // If there was a chance of leaf node, no more...\n             if (_mayBeLeaf) {\n", "finish_reason": "stop", "valid": false, "num": 1}]