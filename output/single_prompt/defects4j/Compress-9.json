[{"output": "@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n    }\n\n    int bufOffset = 0; // added variable to keep track of buffer offset\n    while (numToWrite > 0 || assemLen > 0) { // fixed condition to handle pending bytes in the assembly buffer\n        int remainingSpace = recordBuf.length - assemLen;\n        int bytesToWrite = Math.min(numToWrite, remainingSpace);\n        if (bytesToWrite > 0) {\n            System.arraycopy(wBuf, wOffset + bufOffset, recordBuf, assemLen, bytesToWrite);\n            bufOffset += bytesToWrite;\n            assemLen += bytesToWrite;\n            numToWrite -= bytesToWrite;\n        }\n\n        if (assemLen == recordBuf.length) {\n            buffer.writeRecord(recordBuf);\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n    }\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -2,47 +2,24 @@\n public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n     if ((currBytes + numToWrite) > currSize) {\n         throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n-        //\n-        // We have to deal with assembly!!!\n-        // The programmer can be writing little 32 byte chunks for all\n-        // we know, and we must assemble complete records for writing.\n-        // REVIEW Maybe this should be in TarBuffer? Could that help to\n-        // eliminate some of the buffer copying.\n-        //\n     }\n-    if (assemLen > 0) {\n-        if ((assemLen + numToWrite) >= recordBuf.length) {\n-            int aLen = recordBuf.length - assemLen;\n-            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n-            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n+\n+    int bufOffset = 0; // added variable to keep track of buffer offset\n+    while (numToWrite > 0 || assemLen > 0) { // fixed condition to handle pending bytes in the assembly buffer\n+        int remainingSpace = recordBuf.length - assemLen;\n+        int bytesToWrite = Math.min(numToWrite, remainingSpace);\n+        if (bytesToWrite > 0) {\n+            System.arraycopy(wBuf, wOffset + bufOffset, recordBuf, assemLen, bytesToWrite);\n+            bufOffset += bytesToWrite;\n+            assemLen += bytesToWrite;\n+            numToWrite -= bytesToWrite;\n+        }\n+\n+        if (assemLen == recordBuf.length) {\n             buffer.writeRecord(recordBuf);\n-            currBytes += recordBuf.length;\n-            wOffset += aLen;\n-            numToWrite -= aLen;\n+            currBytes += assemLen;\n             assemLen = 0;\n-        } else {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            wOffset += numToWrite;\n-            assemLen += numToWrite;\n-            numToWrite = 0;\n         }\n-    }\n-    //\n-    // When we get here we have EITHER:\n-    // o An empty \"assemble\" buffer.\n-    // o No bytes to write (numToWrite == 0)\n-    //\n-    while (numToWrite > 0) {\n-        if (numToWrite < recordBuf.length) {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            assemLen += numToWrite;\n-            break;\n-        }\n-        buffer.writeRecord(wBuf, wOffset);\n-        int num = recordBuf.length;\n-        currBytes += num;\n-        numToWrite -= num;\n-        wOffset += num;\n     }\n     count(numToWrite);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n        //\n        // We have to deal with assembly!!!\n        // The programmer can be writing little 32 byte chunks for all\n        // we know, and we must assemble complete records for writing.\n        // REVIEW Maybe this should be in TarBuffer? Could that help to\n        // eliminate some of the buffer copying.\n        //\n    }\n    if (assemLen > 0) {\n        if ((assemLen + numToWrite) >= recordBuf.length) {\n            int aLen = recordBuf.length - assemLen;\n            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n            buffer.writeRecord(recordBuf);\n            currBytes += recordBuf.length;\n            wOffset += aLen;\n            numToWrite -= aLen;\n            assemLen = 0;\n            // make sure to clear the record buffer after writing\n            Arrays.fill(recordBuf, (byte) 0);\n        } else {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            wOffset += numToWrite;\n            assemLen += numToWrite;\n            numToWrite = 0;\n        }\n    }\n    //\n    // When we get here we have EITHER:\n    // o An empty \"assemble\" buffer.\n    // o No bytes to write (numToWrite == 0)\n    //\n    while (numToWrite > 0) {\n        if (numToWrite < recordBuf.length) {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            assemLen += numToWrite;\n            break;\n        }\n        buffer.writeRecord(wBuf, wOffset);\n        int num = recordBuf.length;\n        currBytes += num;\n        numToWrite -= num;\n        wOffset += num;\n    }\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -20,6 +20,8 @@\n             wOffset += aLen;\n             numToWrite -= aLen;\n             assemLen = 0;\n+            // make sure to clear the record buffer after writing\n+            Arrays.fill(recordBuf, (byte) 0);\n         } else {\n             System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n             wOffset += numToWrite;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "There are no sufficient details available to answer this question. Please provide more context and information about the buggy function(s) in the Compress project.", "diff": "", "finish_reason": "stop", "valid": false, "num": 6}, {"output": "## Fixed Function 1\nThe fix for the function involves moving the code for dealing with assembly to a separate function and calling it from the write function whenever necessary.\n\n```\nprivate void writeAssembly(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((assemLen + numToWrite) >= recordBuf.length) {\n        int aLen = recordBuf.length - assemLen;\n        System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n        System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n        buffer.writeRecord(recordBuf);\n        currBytes += recordBuf.length;\n        wOffset += aLen;\n        numToWrite -= aLen;\n        assemLen = 0;\n    } else {\n        System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n        wOffset += numToWrite;\n        assemLen += numToWrite;\n        numToWrite = 0;\n    }\n}\n\n@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n    }\n    if (assemLen > 0) {\n        writeAssembly(wBuf, wOffset, numToWrite);\n    }\n    while (numToWrite > 0) {\n        if (numToWrite < recordBuf.length) {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            assemLen += numToWrite;\n            break;\n        }\n        buffer.writeRecord(wBuf, wOffset);\n        int num = recordBuf.length;\n        currBytes += num;\n        numToWrite -= num;\n        wOffset += num;\n    }\n    count(numToWrite);\n}\n```", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -2,36 +2,10 @@\n public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n     if ((currBytes + numToWrite) > currSize) {\n         throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n-        //\n-        // We have to deal with assembly!!!\n-        // The programmer can be writing little 32 byte chunks for all\n-        // we know, and we must assemble complete records for writing.\n-        // REVIEW Maybe this should be in TarBuffer? Could that help to\n-        // eliminate some of the buffer copying.\n-        //\n     }\n     if (assemLen > 0) {\n-        if ((assemLen + numToWrite) >= recordBuf.length) {\n-            int aLen = recordBuf.length - assemLen;\n-            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n-            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n-            buffer.writeRecord(recordBuf);\n-            currBytes += recordBuf.length;\n-            wOffset += aLen;\n-            numToWrite -= aLen;\n-            assemLen = 0;\n-        } else {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            wOffset += numToWrite;\n-            assemLen += numToWrite;\n-            numToWrite = 0;\n-        }\n+        writeAssembly(wBuf, wOffset, numToWrite);\n     }\n-    //\n-    // When we get here we have EITHER:\n-    // o An empty \"assemble\" buffer.\n-    // o No bytes to write (numToWrite == 0)\n-    //\n     while (numToWrite > 0) {\n         if (numToWrite < recordBuf.length) {\n             System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n        //\n        // We have to deal with assembly!!!\n        // The programmer can be writing little 32 byte chunks for all\n        // we know, and we must assemble complete records for writing.\n        // REVIEW Maybe this should be in TarBuffer? Could that help to\n        // eliminate some of the buffer copying.\n        //\n    }\n    if (assemLen > 0) {\n        if ((assemLen + numToWrite) >= recordBuf.length) {\n            int aLen = recordBuf.length - assemLen;\n            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n            buffer.writeRecord(recordBuf);\n            currBytes += recordBuf.length;\n            wOffset += aLen;\n            numToWrite -= aLen;\n            assemLen = 0;\n            if (numToWrite > 0) {\n                write(wBuf, wOffset, numToWrite);\n            }\n        } else {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            wOffset += numToWrite;\n            assemLen += numToWrite;\n            numToWrite = 0;\n        }\n    }\n    //\n    // When we get here we have EITHER:\n    // o An empty \"assemble\" buffer.\n    // o No bytes to write (numToWrite == 0)\n    //\n    while (numToWrite > 0) {\n        if (numToWrite < recordBuf.length) {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            assemLen += numToWrite;\n            break;\n        }\n        buffer.writeRecord(wBuf, wOffset);\n        int num = recordBuf.length;\n        currBytes += num;\n        numToWrite -= num;\n        wOffset += num;\n    }\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -20,6 +20,9 @@\n             wOffset += aLen;\n             numToWrite -= aLen;\n             assemLen = 0;\n+            if (numToWrite > 0) {\n+                write(wBuf, wOffset, numToWrite);\n+            }\n         } else {\n             System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n             wOffset += numToWrite;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n        //\n        // We have to deal with assembly!!!\n        // The programmer can be writing little 32 byte chunks for all\n        // we know, and we must assemble complete records for writing.\n        // REVIEW Maybe this should be in TarBuffer? Could that help to\n        // eliminate some of the buffer copying.\n        //\n    }\n    if (assemLen > 0) {\n        if ((assemLen + numToWrite) >= recordBuf.length) {\n            int aLen = recordBuf.length - assemLen;\n            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n            buffer.writeRecord(recordBuf);\n            currBytes += recordBuf.length;\n            wOffset += aLen;\n            numToWrite -= aLen;\n            assemLen = 0;\n        } else {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            wOffset += numToWrite;\n            assemLen += numToWrite;\n            numToWrite = 0;\n        }\n    }\n    //\n    // When we get here we have EITHER:\n    // o An empty \"assemble\" buffer.\n    // o No bytes to write (numToWrite == 0)\n    //\n    while (numToWrite > 0) {\n        if (numToWrite < recordBuf.length) {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            assemLen += numToWrite;\n            numToWrite = 0;\n            break;\n        }\n        buffer.writeRecord(wBuf, wOffset);\n        int num = recordBuf.length;\n        currBytes += num;\n        numToWrite -= num;\n        wOffset += num;\n    }\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -36,6 +36,7 @@\n         if (numToWrite < recordBuf.length) {\n             System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n             assemLen += numToWrite;\n+            numToWrite = 0;\n             break;\n         }\n         buffer.writeRecord(wBuf, wOffset);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n    }\n    int maxRecordSize = recordBuf.length - assemLen;\n    while (numToWrite > 0) {\n        if (assemLen >= maxRecordSize) {\n            buffer.writeRecord(recordBuf);\n            currBytes += recordBuf.length;\n            assemLen = 0;\n            maxRecordSize = recordBuf.length;\n            continue;\n        }\n        int chunkSize = Math.min(maxRecordSize - assemLen, numToWrite);\n        System.arraycopy(wBuf, wOffset, recordBuf, assemLen, chunkSize);\n        assemLen += chunkSize;\n        wOffset += chunkSize;\n        numToWrite -= chunkSize;\n    }\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -2,47 +2,21 @@\n public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n     if ((currBytes + numToWrite) > currSize) {\n         throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n-        //\n-        // We have to deal with assembly!!!\n-        // The programmer can be writing little 32 byte chunks for all\n-        // we know, and we must assemble complete records for writing.\n-        // REVIEW Maybe this should be in TarBuffer? Could that help to\n-        // eliminate some of the buffer copying.\n-        //\n     }\n-    if (assemLen > 0) {\n-        if ((assemLen + numToWrite) >= recordBuf.length) {\n-            int aLen = recordBuf.length - assemLen;\n-            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n-            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n+    int maxRecordSize = recordBuf.length - assemLen;\n+    while (numToWrite > 0) {\n+        if (assemLen >= maxRecordSize) {\n             buffer.writeRecord(recordBuf);\n             currBytes += recordBuf.length;\n-            wOffset += aLen;\n-            numToWrite -= aLen;\n             assemLen = 0;\n-        } else {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            wOffset += numToWrite;\n-            assemLen += numToWrite;\n-            numToWrite = 0;\n+            maxRecordSize = recordBuf.length;\n+            continue;\n         }\n-    }\n-    //\n-    // When we get here we have EITHER:\n-    // o An empty \"assemble\" buffer.\n-    // o No bytes to write (numToWrite == 0)\n-    //\n-    while (numToWrite > 0) {\n-        if (numToWrite < recordBuf.length) {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            assemLen += numToWrite;\n-            break;\n-        }\n-        buffer.writeRecord(wBuf, wOffset);\n-        int num = recordBuf.length;\n-        currBytes += num;\n-        numToWrite -= num;\n-        wOffset += num;\n+        int chunkSize = Math.min(maxRecordSize - assemLen, numToWrite);\n+        System.arraycopy(wBuf, wOffset, recordBuf, assemLen, chunkSize);\n+        assemLen += chunkSize;\n+        wOffset += chunkSize;\n+        numToWrite -= chunkSize;\n     }\n     count(numToWrite);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n        //\n        // We have to deal with assembly!!!\n        // The programmer can be writing little 32 byte chunks for all\n        // we know, and we must assemble complete records for writing.\n        // REVIEW Maybe this should be in TarBuffer? Could that help to\n        // eliminate some of the buffer copying.\n        //\n    }\n    if (assemLen > 0) {\n        if ((assemLen + numToWrite) >= recordBuf.length) {\n            int aLen = recordBuf.length - assemLen;\n            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n            buffer.writeRecord(recordBuf);\n            currBytes += recordBuf.length;\n            wOffset += aLen;\n            numToWrite -= aLen;\n            assemLen = 0;\n            if (numToWrite > 0) {\n                // There are still bytes left to write, write them directly.\n                write(wBuf, wOffset, numToWrite);\n            }\n        } else {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            wOffset += numToWrite;\n            assemLen += numToWrite;\n            numToWrite = 0;\n        }\n    }\n    //\n    // When we get here we have EITHER:\n    // o An empty \"assemble\" buffer.\n    // o No bytes to write (numToWrite == 0)\n    //\n    while (numToWrite > 0) {\n        if (numToWrite < recordBuf.length) {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            assemLen += numToWrite;\n            break;\n        }\n        buffer.writeRecord(wBuf, wOffset);\n        int num = recordBuf.length;\n        currBytes += num;\n        numToWrite -= num;\n        wOffset += num;\n    }\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -20,6 +20,10 @@\n             wOffset += aLen;\n             numToWrite -= aLen;\n             assemLen = 0;\n+            if (numToWrite > 0) {\n+                // There are still bytes left to write, write them directly.\n+                write(wBuf, wOffset, numToWrite);\n+            }\n         } else {\n             System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n             wOffset += numToWrite;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n    }\n    while (numToWrite > 0) {\n        if (assemLen == 0 && numToWrite >= recordBuf.length) {\n            buffer.writeRecord(wBuf, wOffset);\n            currBytes += recordBuf.length;\n            numToWrite -= recordBuf.length;\n            wOffset += recordBuf.length;\n        } else {\n            int aLen = Math.min(recordBuf.length - assemLen, numToWrite);\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, aLen);\n            assemLen += aLen;\n            wOffset += aLen;\n            numToWrite -= aLen;\n            if (assemLen == recordBuf.length) {\n                buffer.writeRecord(assemBuf, 0);\n                currBytes += recordBuf.length;\n                assemLen = 0;\n            }\n        }\n    }\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -2,47 +2,25 @@\n public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n     if ((currBytes + numToWrite) > currSize) {\n         throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n-        //\n-        // We have to deal with assembly!!!\n-        // The programmer can be writing little 32 byte chunks for all\n-        // we know, and we must assemble complete records for writing.\n-        // REVIEW Maybe this should be in TarBuffer? Could that help to\n-        // eliminate some of the buffer copying.\n-        //\n     }\n-    if (assemLen > 0) {\n-        if ((assemLen + numToWrite) >= recordBuf.length) {\n-            int aLen = recordBuf.length - assemLen;\n-            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n-            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n-            buffer.writeRecord(recordBuf);\n+    while (numToWrite > 0) {\n+        if (assemLen == 0 && numToWrite >= recordBuf.length) {\n+            buffer.writeRecord(wBuf, wOffset);\n             currBytes += recordBuf.length;\n+            numToWrite -= recordBuf.length;\n+            wOffset += recordBuf.length;\n+        } else {\n+            int aLen = Math.min(recordBuf.length - assemLen, numToWrite);\n+            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, aLen);\n+            assemLen += aLen;\n             wOffset += aLen;\n             numToWrite -= aLen;\n-            assemLen = 0;\n-        } else {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            wOffset += numToWrite;\n-            assemLen += numToWrite;\n-            numToWrite = 0;\n+            if (assemLen == recordBuf.length) {\n+                buffer.writeRecord(assemBuf, 0);\n+                currBytes += recordBuf.length;\n+                assemLen = 0;\n+            }\n         }\n-    }\n-    //\n-    // When we get here we have EITHER:\n-    // o An empty \"assemble\" buffer.\n-    // o No bytes to write (numToWrite == 0)\n-    //\n-    while (numToWrite > 0) {\n-        if (numToWrite < recordBuf.length) {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            assemLen += numToWrite;\n-            break;\n-        }\n-        buffer.writeRecord(wBuf, wOffset);\n-        int num = recordBuf.length;\n-        currBytes += num;\n-        numToWrite -= num;\n-        wOffset += num;\n     }\n     count(numToWrite);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n    }\n    //\n    // We have to deal with assembly!!!\n    // The programmer can be writing little 32 byte chunks for all\n    // we know, and we must assemble complete records for writing.\n    // REVIEW Maybe this should be in TarBuffer? Could that help to\n    // eliminate some of the buffer copying.\n    //\n    if (assemLen > 0) {\n        int aLen = Math.min(numToWrite, recordBuf.length - assemLen);\n        System.arraycopy(wBuf, wOffset, assemBuf, assemLen, aLen);\n        assemLen += aLen;\n        wOffset += aLen;\n        numToWrite -= aLen;\n        if (assemLen == recordBuf.length) {\n            buffer.writeRecord(recordBuf);\n            currBytes += recordBuf.length;\n            assemLen=0;\n        }\n    }\n    while (numToWrite >= recordBuf.length) {\n        buffer.writeRecord(wBuf, wOffset);\n        currBytes += recordBuf.length;\n        numToWrite -= recordBuf.length;\n        wOffset += recordBuf.length;\n    }\n    if (numToWrite > 0) {\n        System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n        assemLen += numToWrite;\n    }\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -2,47 +2,35 @@\n public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n     if ((currBytes + numToWrite) > currSize) {\n         throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n-        //\n-        // We have to deal with assembly!!!\n-        // The programmer can be writing little 32 byte chunks for all\n-        // we know, and we must assemble complete records for writing.\n-        // REVIEW Maybe this should be in TarBuffer? Could that help to\n-        // eliminate some of the buffer copying.\n-        //\n     }\n+    //\n+    // We have to deal with assembly!!!\n+    // The programmer can be writing little 32 byte chunks for all\n+    // we know, and we must assemble complete records for writing.\n+    // REVIEW Maybe this should be in TarBuffer? Could that help to\n+    // eliminate some of the buffer copying.\n+    //\n     if (assemLen > 0) {\n-        if ((assemLen + numToWrite) >= recordBuf.length) {\n-            int aLen = recordBuf.length - assemLen;\n-            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n-            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n+        int aLen = Math.min(numToWrite, recordBuf.length - assemLen);\n+        System.arraycopy(wBuf, wOffset, assemBuf, assemLen, aLen);\n+        assemLen += aLen;\n+        wOffset += aLen;\n+        numToWrite -= aLen;\n+        if (assemLen == recordBuf.length) {\n             buffer.writeRecord(recordBuf);\n             currBytes += recordBuf.length;\n-            wOffset += aLen;\n-            numToWrite -= aLen;\n-            assemLen = 0;\n-        } else {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            wOffset += numToWrite;\n-            assemLen += numToWrite;\n-            numToWrite = 0;\n+            assemLen=0;\n         }\n     }\n-    //\n-    // When we get here we have EITHER:\n-    // o An empty \"assemble\" buffer.\n-    // o No bytes to write (numToWrite == 0)\n-    //\n-    while (numToWrite > 0) {\n-        if (numToWrite < recordBuf.length) {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            assemLen += numToWrite;\n-            break;\n-        }\n+    while (numToWrite >= recordBuf.length) {\n         buffer.writeRecord(wBuf, wOffset);\n-        int num = recordBuf.length;\n-        currBytes += num;\n-        numToWrite -= num;\n-        wOffset += num;\n+        currBytes += recordBuf.length;\n+        numToWrite -= recordBuf.length;\n+        wOffset += recordBuf.length;\n+    }\n+    if (numToWrite > 0) {\n+        System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n+        assemLen += numToWrite;\n     }\n     count(numToWrite);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n    }\n\n    // Initialize variables to keep track of assembling\n    byte[] recordBuf = buffer.getRecordBuf();\n    int recordLength = recordBuf.length;\n    int numAssembled = 0;\n\n    // If there are bytes left over from a previous write, try to fill up recordBuf\n    if (assemLen > 0) {\n        numAssembled = Math.min(numToWrite, recordLength - assemLen);\n        System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numAssembled);\n        assemLen += numAssembled;\n        wOffset += numAssembled;\n        numToWrite -= numAssembled;\n        if (assemLen == recordLength) {\n            buffer.writeRecord(recordBuf);\n            currBytes += recordLength;\n            assemLen = 0;\n        }\n    }\n\n    // Write the remaining full records in the input byte array\n    while (numToWrite >= recordLength) {\n        buffer.writeRecord(wBuf, wOffset);\n        currBytes += recordLength;\n        numToWrite -= recordLength;\n        wOffset += recordLength;\n    }\n\n    // Assemble remaining partial record if there is any\n    if (numToWrite > 0) {\n        System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n        assemLen += numToWrite;\n    }\n\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -2,47 +2,40 @@\n public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n     if ((currBytes + numToWrite) > currSize) {\n         throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n-        //\n-        // We have to deal with assembly!!!\n-        // The programmer can be writing little 32 byte chunks for all\n-        // we know, and we must assemble complete records for writing.\n-        // REVIEW Maybe this should be in TarBuffer? Could that help to\n-        // eliminate some of the buffer copying.\n-        //\n     }\n+\n+    // Initialize variables to keep track of assembling\n+    byte[] recordBuf = buffer.getRecordBuf();\n+    int recordLength = recordBuf.length;\n+    int numAssembled = 0;\n+\n+    // If there are bytes left over from a previous write, try to fill up recordBuf\n     if (assemLen > 0) {\n-        if ((assemLen + numToWrite) >= recordBuf.length) {\n-            int aLen = recordBuf.length - assemLen;\n-            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n-            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n+        numAssembled = Math.min(numToWrite, recordLength - assemLen);\n+        System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numAssembled);\n+        assemLen += numAssembled;\n+        wOffset += numAssembled;\n+        numToWrite -= numAssembled;\n+        if (assemLen == recordLength) {\n             buffer.writeRecord(recordBuf);\n-            currBytes += recordBuf.length;\n-            wOffset += aLen;\n-            numToWrite -= aLen;\n+            currBytes += recordLength;\n             assemLen = 0;\n-        } else {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            wOffset += numToWrite;\n-            assemLen += numToWrite;\n-            numToWrite = 0;\n         }\n     }\n-    //\n-    // When we get here we have EITHER:\n-    // o An empty \"assemble\" buffer.\n-    // o No bytes to write (numToWrite == 0)\n-    //\n-    while (numToWrite > 0) {\n-        if (numToWrite < recordBuf.length) {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            assemLen += numToWrite;\n-            break;\n-        }\n+\n+    // Write the remaining full records in the input byte array\n+    while (numToWrite >= recordLength) {\n         buffer.writeRecord(wBuf, wOffset);\n-        int num = recordBuf.length;\n-        currBytes += num;\n-        numToWrite -= num;\n-        wOffset += num;\n+        currBytes += recordLength;\n+        numToWrite -= recordLength;\n+        wOffset += recordLength;\n     }\n+\n+    // Assemble remaining partial record if there is any\n+    if (numToWrite > 0) {\n+        System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n+        assemLen += numToWrite;\n+    }\n+\n     count(numToWrite);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n        //\n        // We have to deal with assembly!!!\n        // The programmer can be writing little 32 byte chunks for all\n        // we know, and we must assemble complete records for writing.\n        // REVIEW Maybe this should be in TarBuffer? Could that help to\n        // eliminate some of the buffer copying.\n        //\n    }\n    if (assemLen > 0) {\n        if ((assemLen + numToWrite) >= recordBuf.length) {\n            int aLen = recordBuf.length - assemLen;\n            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n            buffer.writeRecord(recordBuf);\n            currBytes += recordBuf.length;\n            wOffset += aLen;\n            numToWrite -= aLen;\n            assemLen = 0;\n        } else {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            wOffset += numToWrite;\n            assemLen += numToWrite;\n            numToWrite = 0;\n        }\n    }\n    //\n    // When we get here we have EITHER:\n    // o An empty \"assemble\" buffer.\n    // o No bytes to write (numToWrite == 0)\n    //\n    while (numToWrite > 0) {\n        if (numToWrite < recordBuf.length) {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            assemLen += numToWrite;\n            numToWrite = 0;\n        } else {\n            buffer.writeRecord(wBuf, wOffset);\n            int num = recordBuf.length;\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -36,13 +36,14 @@\n         if (numToWrite < recordBuf.length) {\n             System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n             assemLen += numToWrite;\n-            break;\n+            numToWrite = 0;\n+        } else {\n+            buffer.writeRecord(wBuf, wOffset);\n+            int num = recordBuf.length;\n+            currBytes += num;\n+            numToWrite -= num;\n+            wOffset += num;\n         }\n-        buffer.writeRecord(wBuf, wOffset);\n-        int num = recordBuf.length;\n-        currBytes += num;\n-        numToWrite -= num;\n-        wOffset += num;\n     }\n     count(numToWrite);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException{\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n        //\n        // We have to deal with assembly!!!\n        // The programmer can be writing little 32 byte chunks for all\n        // we know, and we must assemble complete records for writing.\n        // REVIEW Maybe this should be in TarBuffer? Could that help to\n        // eliminate some of the buffer copying.\n        //\n    }\n\n    while (numToWrite > 0) {\n        if (assemLen == 0 && numToWrite >= recordBuf.length) {\n            buffer.writeRecord(wBuf, wOffset);\n            int num = recordBuf.length;\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        } else {\n            int aLen = recordBuf.length - assemLen;\n            if (numToWrite < aLen) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n                assemLen += numToWrite;\n                break;\n            }\n            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n            buffer.writeRecord(recordBuf);\n            currBytes += recordBuf.length;\n            wOffset += aLen;\n            numToWrite -= aLen;\n            assemLen = 0;\n        }\n    }\n\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -1,5 +1,5 @@\n @Override\n-public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n+public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException{\n     if ((currBytes + numToWrite) > currSize) {\n         throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n         //\n@@ -10,39 +10,29 @@\n         // eliminate some of the buffer copying.\n         //\n     }\n-    if (assemLen > 0) {\n-        if ((assemLen + numToWrite) >= recordBuf.length) {\n+\n+    while (numToWrite > 0) {\n+        if (assemLen == 0 && numToWrite >= recordBuf.length) {\n+            buffer.writeRecord(wBuf, wOffset);\n+            int num = recordBuf.length;\n+            currBytes += num;\n+            numToWrite -= num;\n+            wOffset += num;\n+        } else {\n             int aLen = recordBuf.length - assemLen;\n-            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n+            if (numToWrite < aLen) {\n+                System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n+                assemLen += numToWrite;\n+                break;\n+            }\n             System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n             buffer.writeRecord(recordBuf);\n             currBytes += recordBuf.length;\n             wOffset += aLen;\n             numToWrite -= aLen;\n             assemLen = 0;\n-        } else {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            wOffset += numToWrite;\n-            assemLen += numToWrite;\n-            numToWrite = 0;\n         }\n     }\n-    //\n-    // When we get here we have EITHER:\n-    // o An empty \"assemble\" buffer.\n-    // o No bytes to write (numToWrite == 0)\n-    //\n-    while (numToWrite > 0) {\n-        if (numToWrite < recordBuf.length) {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            assemLen += numToWrite;\n-            break;\n-        }\n-        buffer.writeRecord(wBuf, wOffset);\n-        int num = recordBuf.length;\n-        currBytes += num;\n-        numToWrite -= num;\n-        wOffset += num;\n-    }\n+\n     count(numToWrite);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n        //\n        // We have to deal with assembly!!!\n        // The programmer can be writing little 32 byte chunks for all\n        // we know, and we must assemble complete records for writing.\n        // REVIEW Maybe this should be in TarBuffer? Could that help to\n        // eliminate some of the buffer copying.\n        //\n    }\n    if (assemLen > 0) {\n        if ((assemLen + numToWrite) >= recordBuf.length) {\n            int aLen = recordBuf.length - assemLen;\n            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n            buffer.writeRecord(recordBuf);\n            currBytes += recordBuf.length;\n            wOffset += aLen;\n            numToWrite -= aLen;\n            assemLen = 0;\n            if (numToWrite > 0) {\n                write(wBuf, wOffset, numToWrite); // recursively write remaining bytes\n            }\n        } else {\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n            assemLen += numToWrite;\n            numToWrite = 0;\n        }\n    } else {\n        while (numToWrite >= recordBuf.length) {\n            buffer.writeRecord(wBuf, wOffset);\n            int num = recordBuf.length;\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n        if (numToWrite > 0) {\n            System.arraycopy(wBuf, wOffset, assemBuf, 0, numToWrite);\n            assemLen = numToWrite;\n        }\n    }\n    count(numToWrite);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -20,29 +20,26 @@\n             wOffset += aLen;\n             numToWrite -= aLen;\n             assemLen = 0;\n+            if (numToWrite > 0) {\n+                write(wBuf, wOffset, numToWrite); // recursively write remaining bytes\n+            }\n         } else {\n             System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            wOffset += numToWrite;\n             assemLen += numToWrite;\n             numToWrite = 0;\n         }\n-    }\n-    //\n-    // When we get here we have EITHER:\n-    // o An empty \"assemble\" buffer.\n-    // o No bytes to write (numToWrite == 0)\n-    //\n-    while (numToWrite > 0) {\n-        if (numToWrite < recordBuf.length) {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            assemLen += numToWrite;\n-            break;\n+    } else {\n+        while (numToWrite >= recordBuf.length) {\n+            buffer.writeRecord(wBuf, wOffset);\n+            int num = recordBuf.length;\n+            currBytes += num;\n+            numToWrite -= num;\n+            wOffset += num;\n         }\n-        buffer.writeRecord(wBuf, wOffset);\n-        int num = recordBuf.length;\n-        currBytes += num;\n-        numToWrite -= num;\n-        wOffset += num;\n+        if (numToWrite > 0) {\n+            System.arraycopy(wBuf, wOffset, assemBuf, 0, numToWrite);\n+            assemLen = numToWrite;\n+        }\n     }\n     count(numToWrite);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n    if ((currBytes + numToWrite) > currSize) {\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n    }\n    //\n    // We have to deal with assembly!!!\n    // The programmer can be writing little 32 byte chunks for all\n    // we know, and we must assemble complete records for writing.\n    // REVIEW Maybe this should be in TarBuffer? Could that help to\n    // eliminate some of the buffer copying.\n    //\n    int wOffsetStart = wOffset;\n    int numToWriteStart = numToWrite;\n\n    while (numToWrite > 0) {\n        if (assemLen > 0) {\n            int n = Math.min(numToWrite, recordBuf.length - assemLen);\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, n);\n            wOffset += n;\n            numToWrite -= n;\n            assemLen += n;\n            if (assemLen == recordBuf.length){\n                buffer.writeRecord(recordBuf);\n                currBytes += recordBuf.length;\n                assemLen = 0;\n            }\n        } else {\n            if (numToWrite >= recordBuf.length) {\n                int n = (numToWrite / recordBuf.length) * recordBuf.length;\n                buffer.writeRecord(wBuf, wOffset, n);\n                currBytes += n;\n                wOffset += n;\n                numToWrite -= n;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n                assemLen += numToWrite;\n                break;\n            }\n        }\n    }\n    count(numToWriteStart);\n}", "diff": "--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@write\n@@ -2,47 +2,42 @@\n public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n     if ((currBytes + numToWrite) > currSize) {\n         throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\n-        //\n-        // We have to deal with assembly!!!\n-        // The programmer can be writing little 32 byte chunks for all\n-        // we know, and we must assemble complete records for writing.\n-        // REVIEW Maybe this should be in TarBuffer? Could that help to\n-        // eliminate some of the buffer copying.\n-        //\n     }\n-    if (assemLen > 0) {\n-        if ((assemLen + numToWrite) >= recordBuf.length) {\n-            int aLen = recordBuf.length - assemLen;\n-            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\n-            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\n-            buffer.writeRecord(recordBuf);\n-            currBytes += recordBuf.length;\n-            wOffset += aLen;\n-            numToWrite -= aLen;\n-            assemLen = 0;\n+    //\n+    // We have to deal with assembly!!!\n+    // The programmer can be writing little 32 byte chunks for all\n+    // we know, and we must assemble complete records for writing.\n+    // REVIEW Maybe this should be in TarBuffer? Could that help to\n+    // eliminate some of the buffer copying.\n+    //\n+    int wOffsetStart = wOffset;\n+    int numToWriteStart = numToWrite;\n+\n+    while (numToWrite > 0) {\n+        if (assemLen > 0) {\n+            int n = Math.min(numToWrite, recordBuf.length - assemLen);\n+            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, n);\n+            wOffset += n;\n+            numToWrite -= n;\n+            assemLen += n;\n+            if (assemLen == recordBuf.length){\n+                buffer.writeRecord(recordBuf);\n+                currBytes += recordBuf.length;\n+                assemLen = 0;\n+            }\n         } else {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            wOffset += numToWrite;\n-            assemLen += numToWrite;\n-            numToWrite = 0;\n+            if (numToWrite >= recordBuf.length) {\n+                int n = (numToWrite / recordBuf.length) * recordBuf.length;\n+                buffer.writeRecord(wBuf, wOffset, n);\n+                currBytes += n;\n+                wOffset += n;\n+                numToWrite -= n;\n+            } else {\n+                System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n+                assemLen += numToWrite;\n+                break;\n+            }\n         }\n     }\n-    //\n-    // When we get here we have EITHER:\n-    // o An empty \"assemble\" buffer.\n-    // o No bytes to write (numToWrite == 0)\n-    //\n-    while (numToWrite > 0) {\n-        if (numToWrite < recordBuf.length) {\n-            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\n-            assemLen += numToWrite;\n-            break;\n-        }\n-        buffer.writeRecord(wBuf, wOffset);\n-        int num = recordBuf.length;\n-        currBytes += num;\n-        numToWrite -= num;\n-        wOffset += num;\n-    }\n-    count(numToWrite);\n+    count(numToWriteStart);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]