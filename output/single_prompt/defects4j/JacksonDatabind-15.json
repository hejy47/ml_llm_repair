[{"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer<>(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer<>(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n        delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = provider.handleSecondaryContextualization(delSer, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    _delegateSerializer.serialize(delegateValue, gen, provider);\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(provider, delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType);\n                }\n                return new StdDelegatingSerializer<>(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -38,5 +38,5 @@\n     if (ser == null) {\n         ser = _createSerializer2(prov, delegateType, beanDesc, true);\n     }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n+    return new StdDelegatingSerializer<>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -1,15 +1,15 @@\n protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n     final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-    if (intr != null) {\n+    if (intr != null && prop != null) {\n         AnnotatedMember m = prop.getMember();\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n-                return new StdDelegatingSerializer(conv, delegateType, ser);\n+                return new StdDelegatingSerializer<>(conv, delegateType, ser);\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<>(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n                delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = provider.handleSecondaryContextualization(delSer, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    JsonSerializer<Object> delegateSerializer = (JsonSerializer<Object>) _delegateSerializer;\n    delegateSerializer.serialize(delegateValue, gen, provider);\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n        Object delegateValue = convertValue(value);\n    JsonSerializer<Object> delegateSerializer = (JsonSerializer<Object>) _delegateSerializer;\n    delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> delegateSerializer = (JsonSerializer<Object>) _delegateSerializer;\n    return delegateSerializer.isEmpty(delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> delegateSerializer = (JsonSerializer<Object>) _delegateSerializer;\n    return delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    JsonSerializer<Object> delegateSerializer = (JsonSerializer<Object>) _delegateSerializer;\n    delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType);\n                }\n                JsonSerializer<Object> delegateSerializer = (JsonSerializer<Object>) existingSerializer;\n                return new StdDelegatingSerializer(conv, delegateType, delegateSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // fixed\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n                delSer = provider.findValueSerializer(delegateType);\n        if (delSer instanceof ContextualSerializer) { // fixed\n            delSer = provider.handleSecondaryContextualization(delSer, property);\n        }\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    _delegateSerializer.serialize(delegateValue, gen, provider);\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n        Object delegateValue = convertValue(value);\n    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // fixed\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType);\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,7 +5,7 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // fixed\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.getRawClass().equals(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n        delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = provider.handleSecondaryContextualization(delSer, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    _delegateSerializer.serialize(delegateValue, gen, provider);\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(provider, delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType, prop);\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -17,7 +17,7 @@\n     } else {\n         // changes; assume static typing; plus, need to re-introspect if class differs\n         staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n             beanDesc = config.introspect(type);\n         }\n     }\n@@ -29,7 +29,7 @@\n     }\n     JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n     // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n         beanDesc = config.introspect(delegateType);\n         // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,7 +5,7 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n        delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = provider.handleSecondaryContextualization(delSer, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    JsonSerializer<Object> delegateSerializer = (JsonSerializer<Object>) _delegateSerializer;\n    delegateSerializer.serialize(delegateValue, gen, provider);\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> delegateSerializer = (JsonSerializer<Object>) _delegateSerializer;\n    delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> delegateSerializer = (JsonSerializer<Object>) _delegateSerializer;\n    return delegateSerializer.isEmpty(delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> delegateSerializer = (JsonSerializer<Object>) _delegateSerializer;\n    return delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    JsonSerializer<Object> delegateSerializer = (JsonSerializer<Object>) _delegateSerializer;\n    delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType);\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,7 +5,7 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser == null) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n        delSer = provider.findValueSerializer(delegateType);\n    } else if (delSer instanceof ResolvableSerializer) {\n        ((ResolvableSerializer) delSer).resolve(provider);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = ((ContextualSerializer) delSer).createContextual(provider, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null && provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    if (_delegateSerializer instanceof MapSerializer) {\n        ((MapSerializer) _delegateSerializer).serializeFields(Collections.singletonMap(value, delegateValue), gen, provider);\n    } else {\n        _delegateSerializer.serialize(delegateValue, gen, provider);\n    }\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n@Deprecated\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    if (_delegateSerializer != null) {\n        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n    } else {\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n        super.acceptJsonFormatVisitor(visitor, typeHint);\n    }\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType);\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -33,6 +33,10 @@\n         beanDesc = config.introspect(delegateType);\n         // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n     }\n     // [databind#731]: Should skip if nominally java.lang.Object\n     if (ser == null) {\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -1,6 +1,6 @@\n protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n     final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-    if (intr != null) {\n+    if (intr != null && prop != null) {\n         AnnotatedMember m = prop.getMember();\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,46 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,46 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,46 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,46 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,46 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,46 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nNo change needed.\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n                delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = ((ContextualSerializer) delSer).createContextual(provider, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    ((JsonSerializer<Object>) _delegateSerializer).serialize(delegateValue, gen, provider);\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n        Object delegateValue = convertValue(value);\n    ((JsonSerializer<Object>) _delegateSerializer).serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    return ((JsonSerializer<Object>) _delegateSerializer).isEmpty(delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return ((JsonSerializer<Object>) _delegateSerializer).isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    ((JsonSerializer<Object>) _delegateSerializer).acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType);\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,16 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    JsonSerializer<?> delSer = _delegateSerializer;\n+    JavaType delegateType = _delegateType;\n+    if (delSer == null) {\n+        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n+        if (delegateType == null) {\n+            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+        }\n+                delSer = provider.findValueSerializer(delegateType);\n     }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n-        }\n+    if (delSer instanceof ContextualSerializer) {\n+        delSer = ((ContextualSerializer) delSer).createContextual(provider, property);\n     }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n+    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,7 +5,7 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -10,7 +10,7 @@\n                 delSer = provider.findValueSerializer(delegateType);\n     }\n     if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+        delSer = ((ContextualSerializer) delSer).createContextual(provider, property);\n     }\n     return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,16 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    JsonSerializer<?> delSer = _delegateSerializer;\n+    JavaType delegateType = _delegateType;\n+    if (delSer == null) {\n+        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n+        if (delegateType == null) {\n+            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+        }\n+                delSer = provider.findValueSerializer(delegateType);\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    if (delSer instanceof ContextualSerializer) {\n+        delSer = ((ContextualSerializer) delSer).createContextual(provider, property);\n+    }\n+    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,16 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    JsonSerializer<?> delSer = _delegateSerializer;\n+    JavaType delegateType = _delegateType;\n+    if (delSer == null) {\n+        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n+        if (delegateType == null) {\n+            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+        }\n+                delSer = provider.findValueSerializer(delegateType);\n+    }\n+    if (delSer instanceof ContextualSerializer) {\n+        delSer = ((ContextualSerializer) delSer).createContextual(provider, property);\n+    }\n+    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,16 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    JsonSerializer<?> delSer = _delegateSerializer;\n+    JavaType delegateType = _delegateType;\n+    if (delSer == null) {\n+        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n+        if (delegateType == null) {\n+            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+        }\n+                delSer = provider.findValueSerializer(delegateType);\n+    }\n+    if (delSer instanceof ContextualSerializer) {\n+        delSer = ((ContextualSerializer) delSer).createContextual(provider, property);\n+    }\n+    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,16 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    JsonSerializer<?> delSer = _delegateSerializer;\n+    JavaType delegateType = _delegateType;\n+    if (delSer == null) {\n+        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n+        if (delegateType == null) {\n+            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+        }\n+                delSer = provider.findValueSerializer(delegateType);\n+    }\n+    if (delSer instanceof ContextualSerializer) {\n+        delSer = ((ContextualSerializer) delSer).createContextual(provider, property);\n+    }\n+    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,16 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    JsonSerializer<?> delSer = _delegateSerializer;\n+    JavaType delegateType = _delegateType;\n+    if (delSer == null) {\n+        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n+        if (delegateType == null) {\n+            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+        }\n+                delSer = provider.findValueSerializer(delegateType);\n+    }\n+    if (delSer instanceof ContextualSerializer) {\n+        delSer = ((ContextualSerializer) delSer).createContextual(provider, property);\n+    }\n+    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // Fix: use member instead of property\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n        delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = ((ContextualSerializer) delSer).createContextual(provider, property); // Fix: delegate to the contextual serializer's createContextual method\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    JsonSerializer<Object> delegateSerializer = _delegateSerializer.unwrappingSerializer(provider.getConfig()); // Fix: use unwrapping serializer to avoid wrapped values\n    delegateSerializer.serialize(delegateValue, gen, provider);\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> delegateSerializer = _delegateSerializer.unwrappingSerializer(provider.getConfig()); // Fix: use unwrapping serializer to avoid wrapped values\n    delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    JsonSerializer<Object> delegateSerializer = _delegateSerializer.unwrappingSerializer(visitor.getProvider().getConfig()); // Fix: use unwrapping serializer to avoid wrapped values\n    delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // Fix: use member instead of property\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType);\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,7 +5,7 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // Fix: use member instead of property\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n        delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = provider.handlePrimaryContextualization(delSer, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    _delegateSerializer.serialize(delegateValue, gen, provider);\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType, prop);\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -31,7 +31,6 @@\n     // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n     if (!delegateType.hasRawClass(type.getRawClass())) {\n         beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     }\n     // [databind#731]: Should skip if nominally java.lang.Object\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,7 +5,7 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,41 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,41 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,41 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,41 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,41 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,41 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) { // modified\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    ser = provider.findValueSerializer(delegateType, beanProperty);\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // modified\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType); // modified\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n                delSer = provider.findValueSerializer(delegateType, property);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = provider.handleSecondaryContextualization(delSer, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    _delegateSerializer.serialize(delegateValue, gen, provider, _delegateType); // modified\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer, _delegateType); // modified\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(delegateValue, _delegateType); // modified\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(delegateValue, _delegateType); // modified\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    _delegateSerializer.acceptJsonFormatVisitor(visitor, _delegateType); // modified\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // modified\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType, prop); // modified\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,7 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) { // modified\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n@@ -21,22 +21,13 @@\n             beanDesc = config.introspect(type);\n         }\n     }\n-    // Slight detour: do we have a Converter to consider?\n+\n     Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n     if (conv == null) {\n         // no, simple\n         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n     JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n+    ser = provider.findValueSerializer(delegateType, beanProperty);\n     return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,10 +5,9 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // modified\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n-                // [databind#731]: Should skip if nominally java.lang.Object\n-                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n+                JsonSerializer<?> ser = provider.findValueSerializer(delegateType); // modified\n                 return new StdDelegatingSerializer(conv, delegateType, ser);\n             }\n         }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,33 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // modified\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    ser = provider.findValueSerializer(delegateType, beanProperty);\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,33 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // modified\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    ser = provider.findValueSerializer(delegateType, beanProperty);\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,33 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // modified\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    ser = provider.findValueSerializer(delegateType, beanProperty);\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,33 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // modified\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    ser = provider.findValueSerializer(delegateType, beanProperty);\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,33 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // modified\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    ser = provider.findValueSerializer(delegateType, beanProperty);\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,33 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // modified\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    ser = provider.findValueSerializer(delegateType, beanProperty);\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) { // compare using equals instead of ==\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) { // add null check for prop\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n        delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = provider.handleSecondaryContextualization(delSer, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    JsonSerializer<Object> delSer = (JsonSerializer<Object>) _delegateSerializer; // cast serializer to avoid warning\n    delSer.serialize(delegateValue, gen, provider); // add type argument to avoid warning\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> delSer = (JsonSerializer<Object>) _delegateSerializer; // cast serializer to avoid warning\n    delSer.serializeWithType(delegateValue, gen, provider, typeSer); // add type argument to avoid warning\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> delSer = (JsonSerializer<Object>) _delegateSerializer; // cast serializer to avoid warning\n    return delSer.isEmpty(delegateValue); // add type argument to avoid warning\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> delSer = (JsonSerializer<Object>) _delegateSerializer; // cast serializer to avoid warning\n    return delSer.isEmpty(prov, delegateValue); // add type argument to avoid warning\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    JsonSerializer<Object> delSer = (JsonSerializer<Object>) _delegateSerializer; // cast serializer to avoid warning\n    delSer.acceptJsonFormatVisitor(visitor, typeHint); // add type argument to avoid warning\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) { // add null check for prop\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType);\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,7 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) { // compare using equals instead of ==\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n@@ -22,7 +22,7 @@\n         }\n     }\n     // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n     if (conv == null) {\n         // no, simple\n         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -1,6 +1,6 @@\n protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n     final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-    if (intr != null) {\n+    if (intr != null && prop != null) { // add null check for prop\n         AnnotatedMember m = prop.getMember();\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // compare using equals instead of ==\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // compare using equals instead of ==\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // compare using equals instead of ==\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // compare using equals instead of ==\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // compare using equals instead of ==\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // compare using equals instead of ==\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, staticTyping);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n        delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = ((ContextualSerializer) delSer).createContextual(provider, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    _delegateSerializer.serialize(delegateValue, gen, provider);\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(provider, delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType);\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,7 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) {\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n@@ -36,7 +36,7 @@\n     }\n     // [databind#731]: Should skip if nominally java.lang.Object\n     if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        ser = _createSerializer2(prov, delegateType, beanDesc, staticTyping);\n     }\n     return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,7 +5,7 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, staticTyping);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, staticTyping);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, staticTyping);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, staticTyping);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, staticTyping);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, staticTyping);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    JsonSerializer<Object> result = new StdDelegatingSerializer(conv, delegateType, ser);\n    // [databind#1215]: Allow post-processing\n    result = prov.handlePrimaryContextualization(result, null);\n    return result;\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<?, ?> conv = provider.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n                delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = provider.handlePrimaryContextualization(delSer, property);\n    }\n    JsonSerializer<Object> result = withDelegate(_converter, delegateType, delSer);\n    // [databind#1215]: Allow post-processing\n    result = provider.handlePrimaryContextualization(result, property);\n    return result;\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    JsonSerializer<Object> ser = _findSerializer(provider, delegateValue);\n    ser.serialize(delegateValue, gen, provider);\n}\n\nprivate JsonSerializer<Object> _findSerializer(SerializerProvider provider,\n        Object value) throws JsonMappingException\n{\n    Class<?> cls = value.getClass();\n    JsonSerializer<Object> ser = _dynamicSerializers.serializerFor(cls);\n    if (ser != null) {\n        return ser;\n    }\n    // Ok: bit more work, need to locate serializer\n    ser = provider.findValueSerializer(cls);\n    // 12-Jan-2012, tatu: If we have a content converter, we must make sure serializer supports it\n    Converter<Object,Object> conv = _converter;\n    if (conv != null) {\n        if (conv instanceof StdConverter) {\n            conv = null;\n        } else {\n            conv = provider.handlePrimaryContextualization(conv, null);\n        }\n    }\n    if (conv != null) {\n        ser = new StdDelegatingSerializer(conv, _delegateType, ser);\n    }\n    _dynamicSerializers = _dynamicSerializers.newWith(cls, ser);\n    return ser;\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> ser = _findSerializer(provider, delegateValue);\n    ser.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> ser = _findSerializer(SerializerProvider.instance(), delegateValue);\n    return ser.isEmpty(delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    JsonSerializer<Object> ser = _findSerializer(prov, delegateValue);\n    return ser.isEmpty(delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<?, ?> conv = provider.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType, prop);\n                }\n                JsonSerializer<Object> result = new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n                // [databind#1215]: Allow post-processing\n                result = provider.handlePrimaryContextualization(result, prop);\n                return result;\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -38,5 +38,8 @@\n     if (ser == null) {\n         ser = _createSerializer2(prov, delegateType, beanDesc, true);\n     }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n+    JsonSerializer<Object> result = new StdDelegatingSerializer(conv, delegateType, ser);\n+    // [databind#1215]: Allow post-processing\n+    result = prov.handlePrimaryContextualization(result, null);\n+    return result;\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,7 +5,7 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<?, ?> conv = provider.converterInstance(prop.getMember(), convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,45 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    JsonSerializer<Object> result = new StdDelegatingSerializer(conv, delegateType, ser);\n+    // [databind#1215]: Allow post-processing\n+    result = prov.handlePrimaryContextualization(result, null);\n+    return result;\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,45 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    JsonSerializer<Object> result = new StdDelegatingSerializer(conv, delegateType, ser);\n+    // [databind#1215]: Allow post-processing\n+    result = prov.handlePrimaryContextualization(result, null);\n+    return result;\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,45 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    JsonSerializer<Object> result = new StdDelegatingSerializer(conv, delegateType, ser);\n+    // [databind#1215]: Allow post-processing\n+    result = prov.handlePrimaryContextualization(result, null);\n+    return result;\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,45 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    JsonSerializer<Object> result = new StdDelegatingSerializer(conv, delegateType, ser);\n+    // [databind#1215]: Allow post-processing\n+    result = prov.handlePrimaryContextualization(result, null);\n+    return result;\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,45 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    JsonSerializer<Object> result = new StdDelegatingSerializer(conv, delegateType, ser);\n+    // [databind#1215]: Allow post-processing\n+    result = prov.handlePrimaryContextualization(result, null);\n+    return result;\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,45 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    JsonSerializer<Object> result = new StdDelegatingSerializer(conv, delegateType, ser);\n+    // [databind#1215]: Allow post-processing\n+    result = prov.handlePrimaryContextualization(result, null);\n+    return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser == null) { // hasNullable()?\n            if (isUnknownTypeSerializer(_delegateSerializer)) {\n                if (_contentTypeHasSerializer(config, beanDesc)) {\n                    return null;\n                }\n            }\n        }\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    if (ser == null && isUnknownTypeSerializer(_delegateSerializer)) {\n        if (_contentTypeHasSerializer(config, beanDesc)) {\n            return null;\n        }\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                JsonSerializer<?> ser = null;\n                if (_delegateSerializer == null) {\n                    ser = provider.findValueSerializer(delegateType, prop);\n                } else { // slight twist if already got a serializer (due to ordering)\n                    if ((delegateType.getRawClass() != _delegateType.getRawClass())\n                            || !_delegateType.hasGenericTypes()) {\n                        ser = provider.findValueSerializer(delegateType, prop);\n                    } else {\n                        ser = _delegateSerializer;\n                    }\n                }\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    if (property != null) {\n        JsonSerializer<?> ser = provider.handlePrimaryContextualization(_delegateSerializer, property);\n        final JavaType delegateType = _delegateType;\n        if (ser != _delegateSerializer) {\n            return withDelegate(_converter, delegateType, ser);\n        }\n    }\n    if (_delegateSerializer instanceof ContextualSerializer) {\n        JsonSerializer<?> ser = ((ContextualSerializer) _delegateSerializer).createContextual(provider, property);\n        if (ser != _delegateSerializer) {\n            return withDelegate(_converter, _delegateType, ser);\n        }\n    }\n    return this;\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue;\n\n    try {\n        delegateValue = convertValue(value);\n    } catch (Exception e) {\n        wrapAndThrow(provider, e, value, \"\");\n        return; // never gets here\n    }\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    JsonSerializer<Object> ser = _delegateSerializer;\n    if (ser == null) {\n        ser = provider.findValueSerializer(delegateValue.getClass());\n    }\n    ser.serialize(delegateValue, gen, provider);\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue;\n\n    try {\n        delegateValue = convertValue(value);\n    } catch (Exception e) {\n        wrapAndThrow(provider, e, value, \"\");\n        return; // never gets here\n    }\n    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue;\n\n    try {\n        delegateValue = convertValue(value);\n    } catch (Exception e) {\n        return false;\n    }\n    return _delegateSerializer.isEmpty(delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue;\n\n    try {\n        delegateValue = convertValue(value);\n    } catch (Exception e) {\n        return false;\n    }\n    return _delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                JsonSerializer<?> ser = null;\n                if (existingSerializer == null) {\n                    ser = provider.findValueSerializer(delegateType, prop);\n                } else { // slight twist, try existing serializer first (due to ordering)\n                    if ((delegateType.getRawClass() != _delegateType.getRawClass())\n                            || !_delegateType.hasGenericTypes()) {\n                        ser = provider.findValueSerializer(delegateType, prop);\n                    } else {\n                        ser = existingSerializer;\n                    }\n                }\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -33,10 +33,22 @@\n         beanDesc = config.introspect(delegateType);\n         // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) { // hasNullable()?\n+            if (isUnknownTypeSerializer(_delegateSerializer)) {\n+                if (_contentTypeHasSerializer(config, beanDesc)) {\n+                    return null;\n+                }\n+            }\n+        }\n     }\n     // [databind#731]: Should skip if nominally java.lang.Object\n     if (ser == null) {\n         ser = _createSerializer2(prov, delegateType, beanDesc, true);\n     }\n+    if (ser == null && isUnknownTypeSerializer(_delegateSerializer)) {\n+        if (_contentTypeHasSerializer(config, beanDesc)) {\n+            return null;\n+        }\n+    }\n     return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -7,8 +7,17 @@\n             if (convDef != null) {\n                 Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n-                // [databind#731]: Should skip if nominally java.lang.Object\n-                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n+                JsonSerializer<?> ser = null;\n+                if (_delegateSerializer == null) {\n+                    ser = provider.findValueSerializer(delegateType, prop);\n+                } else { // slight twist if already got a serializer (due to ordering)\n+                    if ((delegateType.getRawClass() != _delegateType.getRawClass())\n+                            || !_delegateType.hasGenericTypes()) {\n+                        ser = provider.findValueSerializer(delegateType, prop);\n+                    } else {\n+                        ser = _delegateSerializer;\n+                    }\n+                }\n                 return new StdDelegatingSerializer(conv, delegateType, ser);\n             }\n         }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,54 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) { // hasNullable()?\n+            if (isUnknownTypeSerializer(_delegateSerializer)) {\n+                if (_contentTypeHasSerializer(config, beanDesc)) {\n+                    return null;\n+                }\n+            }\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    if (ser == null && isUnknownTypeSerializer(_delegateSerializer)) {\n+        if (_contentTypeHasSerializer(config, beanDesc)) {\n+            return null;\n+        }\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,54 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) { // hasNullable()?\n+            if (isUnknownTypeSerializer(_delegateSerializer)) {\n+                if (_contentTypeHasSerializer(config, beanDesc)) {\n+                    return null;\n+                }\n+            }\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    if (ser == null && isUnknownTypeSerializer(_delegateSerializer)) {\n+        if (_contentTypeHasSerializer(config, beanDesc)) {\n+            return null;\n+        }\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,54 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) { // hasNullable()?\n+            if (isUnknownTypeSerializer(_delegateSerializer)) {\n+                if (_contentTypeHasSerializer(config, beanDesc)) {\n+                    return null;\n+                }\n+            }\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    if (ser == null && isUnknownTypeSerializer(_delegateSerializer)) {\n+        if (_contentTypeHasSerializer(config, beanDesc)) {\n+            return null;\n+        }\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,54 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) { // hasNullable()?\n+            if (isUnknownTypeSerializer(_delegateSerializer)) {\n+                if (_contentTypeHasSerializer(config, beanDesc)) {\n+                    return null;\n+                }\n+            }\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    if (ser == null && isUnknownTypeSerializer(_delegateSerializer)) {\n+        if (_contentTypeHasSerializer(config, beanDesc)) {\n+            return null;\n+        }\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,54 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) { // hasNullable()?\n+            if (isUnknownTypeSerializer(_delegateSerializer)) {\n+                if (_contentTypeHasSerializer(config, beanDesc)) {\n+                    return null;\n+                }\n+            }\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    if (ser == null && isUnknownTypeSerializer(_delegateSerializer)) {\n+        if (_contentTypeHasSerializer(config, beanDesc)) {\n+            return null;\n+        }\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,54 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) { // hasNullable()?\n+            if (isUnknownTypeSerializer(_delegateSerializer)) {\n+                if (_contentTypeHasSerializer(config, beanDesc)) {\n+                    return null;\n+                }\n+            }\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    if (ser == null && isUnknownTypeSerializer(_delegateSerializer)) {\n+        if (_contentTypeHasSerializer(config, beanDesc)) {\n+            return null;\n+        }\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) { // Use equals method instead of \"==\" operator\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // Use \"m\" instead of prop.getMember()\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n        delSer = provider.findValueSerializer(delegateType, property); // Include \"property\" in findValueSerializer() method call\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = provider.handleSecondaryContextualization(delSer, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    provider.findTypedValueSerializer(delegateValue.getClass(), true, null).serialize(delegateValue, gen, provider); // Use findTypedValueSerializer() instead of _delegateSerializer.serialize()\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    provider.findTypedValueSerializer(delegateValue.getClass(), true, null).serializeWithType(delegateValue, gen, provider, typeSer); // Use findTypedValueSerializer() instead of _delegateSerializer.serializeWithType()\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    return providerIsEmpty(delegateValue); // Use providerIsEmpty() method\n}\n\nprivate boolean providerIsEmpty(Object value) {\n    if (value == null) {\n        return true;\n    }\n    JsonSerializer<Object> ser = _delegateSerializer;\n    if (ser instanceof ContextualSerializer) {\n        ser = ((ContextualSerializer) ser).createContextual(provider, null); // Use \"provider\" instead of \"_serializerProvider\"\n    }\n    return ser.isEmpty(provider, value);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return providerIsEmpty2(prov, delegateValue); // Use providerIsEmpty2() method\n}\n\nprivate boolean providerIsEmpty2(SerializerProvider prov, Object value) {\n    if (value == null) {\n        return true;\n    }\n    JsonSerializer<Object> ser = _delegateSerializer;\n    if (ser instanceof ContextualSerializer) {\n        ser = ((ContextualSerializer) ser).createContextual(prov, null); // Use \"prov\" instead of \"_serializerProvider\"\n    }\n    return ser.isEmpty(prov, value);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // Use \"m\" instead of prop.getMember()\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType, prop); // Include \"prop\" in findValueSerializer() method call\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,7 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) { // Use equals method instead of \"==\" operator\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,7 +5,7 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, Object> conv = provider.converterInstance(m, convDef); // Use \"m\" instead of prop.getMember()\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // Use equals method instead of \"==\" operator\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // Use equals method instead of \"==\" operator\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // Use equals method instead of \"==\" operator\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // Use equals method instead of \"==\" operator\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // Use equals method instead of \"==\" operator\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // Use equals method instead of \"==\" operator\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser == null) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n        delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = provider.handleSecondaryContextualization(delSer, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    try {\n        _delegateSerializer.serialize(delegateValue, gen, provider);\n    } catch (Exception e) {\n        wrapAndThrow(provider, e, value, \"\");\n    }\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    try {\n        _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n    } catch (Exception e) {\n        wrapAndThrow(provider, e, value, \"\");\n    }\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType);\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -33,6 +33,10 @@\n         beanDesc = config.introspect(delegateType);\n         // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n     }\n     // [databind#731]: Should skip if nominally java.lang.Object\n     if (ser == null) {\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,7 +5,7 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, Object> conv = provider.converterInstance(m, convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,46 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,46 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,46 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,46 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,46 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,46 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}\n\n## Fixed Function 2\nprotected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationConverter(m);\n            if (convDef != null) {\n                Converter<Object, ?> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                return new StdDelegatingSerializer(conv, delegateType, ser);\n            }\n        }\n    }\n    return null;\n}\n\n## Fixed Function 3\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    JsonSerializer<?> delSer = _delegateSerializer;\n    JavaType delegateType = _delegateType;\n    if (delSer == null) {\n        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n        if (delegateType == null) {\n            delegateType = _converter.getOutputType(provider.getTypeFactory());\n        }\n                delSer = provider.findValueSerializer(delegateType);\n    }\n    if (delSer instanceof ContextualSerializer) {\n        delSer = provider.handleSecondaryContextualization(delSer, property);\n    }\n    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n}\n\n## Fixed Function 4\n@Override\npublic void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n    Object delegateValue = convertValue(value);\n    // should we accept nulls?\n    if (delegateValue == null) {\n        provider.defaultSerializeNull(gen);\n        return;\n    }\n    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n    _delegateSerializer.serialize(delegateValue, gen, provider);\n}\n\n## Fixed Function 5\n@Override\npublic void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n    Object delegateValue = convertValue(value);\n    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n}\n\n## Fixed Function 6\n@Override\n// since 2.5\n@Deprecated\npublic boolean isEmpty(Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(provider, delegateValue);\n}\n\n## Fixed Function 7\n@Override\npublic boolean isEmpty(SerializerProvider prov, Object value) {\n    Object delegateValue = convertValue(value);\n    return _delegateSerializer.isEmpty(prov, delegateValue);\n}\n\n## Fixed Function 8\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n}\n\n## Fixed Function 9\nprotected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    if (intr != null && prop != null) {\n        AnnotatedMember m = prop.getMember();\n        if (m != null) {\n            Object convDef = intr.findSerializationContentConverter(m);\n            if (convDef != null) {\n                Converter<Object, ?> conv = provider.converterInstance(m, convDef);\n                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                // [databind#731]: Should skip if nominally java.lang.Object\n                if (existingSerializer == null) {\n                    existingSerializer = provider.findValueSerializer(delegateType, prop);\n                }\n                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n            }\n        }\n    }\n    return existingSerializer;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -22,10 +22,10 @@\n         }\n     }\n     // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n     if (conv == null) {\n         // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+        return _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n     JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n     // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@findConvertingSerializer\n@@ -5,7 +5,7 @@\n         if (m != null) {\n             Object convDef = intr.findSerializationConverter(m);\n             if (convDef != null) {\n-                Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                Converter<Object, ?> conv = provider.converterInstance(m, convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 // [databind#731]: Should skip if nominally java.lang.Object\n                 JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]