[{"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z' && hasTimeZone(dateStr)) { // Fixed: check whether string has timezone before assuming it's a ISO8601 date\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}\n\n## Fixed Function 2\nprivate boolean hasTimeZone(String dateStr) { // Added: check whether string contains timezone indicator\n    return dateStr.endsWith(\"Z\") || dateStr.matches(\".+[\\\\+\\\\-]\\\\d\\\\d:\\\\d\\\\d$\");\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     // [JACKSON-200]: need to support \"plain\" date...\n@@ -8,7 +8,7 @@\n         if (df == null) {\n             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n         }\n-    } else if (c == 'Z') {\n+    } else if (c == 'Z' && hasTimeZone(dateStr)) { // Fixed: check whether string has timezone before assuming it's a ISO8601 date\n         df = _formatISO8601_z;\n         if (df == null) {\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n            len = dateStr.length(); // update the length\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // update the length\n                len -= 3;\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n                len = dateStr.length(); // update the length\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            // update the length\n            len -= 9;\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 1);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len + 3, \".000\");\n                dateStr = sb.toString();\n                len = dateStr.length(); // update the length\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n                len = sb.length(); // update the length\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    // Update the parse position based on the updated length\n    pos.setIndex(len);\n    return df.parse(dateStr.substring(0, len)); // parse exact valid length substr\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     // [JACKSON-200]: need to support \"plain\" date...\n@@ -18,6 +18,7 @@\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n+            len = dateStr.length(); // update the length\n         }\n     } else {\n         // Let's see if we have timezone indicator or not...\n@@ -25,6 +26,8 @@\n             c = dateStr.charAt(len - 3);\n             if (c == ':') {\n                 // remove optional colon\n+                // update the length\n+                len -= 3;\n                 // remove colon\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n@@ -33,15 +36,18 @@\n                 // missing minutes\n                 // let's just append '00'\n                 dateStr += \"00\";\n+                len = dateStr.length(); // update the length\n             }\n             // Milliseconds partial or missing; and even seconds are optional\n-            len = dateStr.length();\n+            // update the length\n+            len -= 9;\n             // remove 'T', '+'/'-' and 4-digit timezone-offset\n-            c = dateStr.charAt(len - 9);\n+            c = dateStr.charAt(len - 1);\n             if (Character.isDigit(c)) {\n                 StringBuilder sb = new StringBuilder(dateStr);\n-                sb.insert(len - 5, \".000\");\n+                sb.insert(len + 3, \".000\");\n                 dateStr = sb.toString();\n+                len = dateStr.length(); // update the length\n             }\n             df = _formatISO8601;\n             if (_formatISO8601 == null) {\n@@ -54,6 +60,7 @@\n             int timeLen = len - dateStr.lastIndexOf('T') - 1;\n             if (timeLen <= 8) {\n                 sb.append(\".000\");\n+                len = sb.length(); // update the length\n             }\n             sb.append('Z');\n             dateStr = sb.toString();\n@@ -63,5 +70,7 @@\n             }\n         }\n     }\n-    return df.parse(dateStr, pos);\n+    // Update the parse position based on the updated length\n+    pos.setIndex(len);\n+    return df.parse(dateStr.substring(0, len)); // parse exact valid length substr\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 2, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 4, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -16,7 +16,7 @@\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n         if (dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n-            sb.insert(len - 1, \".000\");\n+            sb.insert(len - 2, \".000\");\n             dateStr = sb.toString();\n         }\n     } else {\n@@ -40,7 +40,7 @@\n             c = dateStr.charAt(len - 9);\n             if (Character.isDigit(c)) {\n                 StringBuilder sb = new StringBuilder(dateStr);\n-                sb.insert(len - 5, \".000\");\n+                sb.insert(len - 4, \".000\");\n                 dateStr = sb.toString();\n             }\n             df = _formatISO8601;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n            len = dateStr.length(); // Update length of the string\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n                len = dateStr.length(); // Update length of the string\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n                len = dateStr.length(); // Update length of the string\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            // Check and add milliseconds to the string\n            if (len - dateStr.lastIndexOf('.') <= 4) {\n                int missingZeros = len - dateStr.lastIndexOf('.') - 1;\n                StringBuilder sb = new StringBuilder(dateStr);\n                for(int i = 0; i < 4-missingZeros; i++) {\n                    sb.append(\"0\");\n                }\n                dateStr = sb.toString();\n            }\n            // remove 'T', '+'/'-' and 4-digit timezone-offset, if present\n            len = dateStr.length(); // Update length of the string\n            c = dateStr.charAt(len - 9);\n            if (len > 9 && Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".\");\n                dateStr = sb.toString();\n                len = dateStr.length(); // Update length of the string\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".\");\n                for(int i = 0; i < 3; i++) {\n                    sb.append(\"0\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -18,6 +18,7 @@\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n+            len = dateStr.length(); // Update length of the string\n         }\n     } else {\n         // Let's see if we have timezone indicator or not...\n@@ -29,19 +30,31 @@\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n                 dateStr = sb.toString();\n+                len = dateStr.length(); // Update length of the string\n             } else if (c == '+' || c == '-') {\n                 // missing minutes\n                 // let's just append '00'\n                 dateStr += \"00\";\n+                len = dateStr.length(); // Update length of the string\n             }\n             // Milliseconds partial or missing; and even seconds are optional\n-            len = dateStr.length();\n-            // remove 'T', '+'/'-' and 4-digit timezone-offset\n+            // Check and add milliseconds to the string\n+            if (len - dateStr.lastIndexOf('.') <= 4) {\n+                int missingZeros = len - dateStr.lastIndexOf('.') - 1;\n+                StringBuilder sb = new StringBuilder(dateStr);\n+                for(int i = 0; i < 4-missingZeros; i++) {\n+                    sb.append(\"0\");\n+                }\n+                dateStr = sb.toString();\n+            }\n+            // remove 'T', '+'/'-' and 4-digit timezone-offset, if present\n+            len = dateStr.length(); // Update length of the string\n             c = dateStr.charAt(len - 9);\n-            if (Character.isDigit(c)) {\n+            if (len > 9 && Character.isDigit(c)) {\n                 StringBuilder sb = new StringBuilder(dateStr);\n-                sb.insert(len - 5, \".000\");\n+                sb.insert(len - 5, \".\");\n                 dateStr = sb.toString();\n+                len = dateStr.length(); // Update length of the string\n             }\n             df = _formatISO8601;\n             if (_formatISO8601 == null) {\n@@ -53,7 +66,10 @@\n             // And possible also millisecond part if missing\n             int timeLen = len - dateStr.lastIndexOf('T') - 1;\n             if (timeLen <= 8) {\n-                sb.append(\".000\");\n+                sb.append(\".\");\n+                for(int i = 0; i < 3; i++) {\n+                    sb.append(\"0\");\n+                }\n             }\n             sb.append('Z');\n             dateStr = sb.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n            len = dateStr.length(); // update length after modification\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n                len = dateStr.length(); // update length after modification\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n                len = dateStr.length(); // update length after modification\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            if (len > 9) {\n                c = dateStr.charAt(len - 9);\n                if (Character.isDigit(c)) {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.insert(len - 5, \".000\");\n                    dateStr = sb.toString();\n                    len = dateStr.length(); // update length after modification\n                }\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n                len = sb.length(); // update length after modification\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     // [JACKSON-200]: need to support \"plain\" date...\n@@ -18,6 +18,7 @@\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n+            len = dateStr.length(); // update length after modification\n         }\n     } else {\n         // Let's see if we have timezone indicator or not...\n@@ -29,19 +30,23 @@\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n                 dateStr = sb.toString();\n+                len = dateStr.length(); // update length after modification\n             } else if (c == '+' || c == '-') {\n                 // missing minutes\n                 // let's just append '00'\n                 dateStr += \"00\";\n+                len = dateStr.length(); // update length after modification\n             }\n             // Milliseconds partial or missing; and even seconds are optional\n-            len = dateStr.length();\n             // remove 'T', '+'/'-' and 4-digit timezone-offset\n-            c = dateStr.charAt(len - 9);\n-            if (Character.isDigit(c)) {\n-                StringBuilder sb = new StringBuilder(dateStr);\n-                sb.insert(len - 5, \".000\");\n-                dateStr = sb.toString();\n+            if (len > 9) {\n+                c = dateStr.charAt(len - 9);\n+                if (Character.isDigit(c)) {\n+                    StringBuilder sb = new StringBuilder(dateStr);\n+                    sb.insert(len - 5, \".000\");\n+                    dateStr = sb.toString();\n+                    len = dateStr.length(); // update length after modification\n+                }\n             }\n             df = _formatISO8601;\n             if (_formatISO8601 == null) {\n@@ -54,6 +59,7 @@\n             int timeLen = len - dateStr.lastIndexOf('T') - 1;\n             if (timeLen <= 8) {\n                 sb.append(\".000\");\n+                len = sb.length(); // update length after modification\n             }\n             sb.append('Z');\n             dateStr = sb.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 9) == '.') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.setCharAt(len - 9, '+');\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -14,9 +14,9 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 24 && dateStr.charAt(len - 9) == '.') {\n             StringBuilder sb = new StringBuilder(dateStr);\n-            sb.insert(len - 1, \".000\");\n+            sb.setCharAt(len - 9, '+');\n             dateStr = sb.toString();\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nThe buggy function is parsing ISO8601 date and time strings. There are several issues with the function which have been addressed in the updated code below. \n\n- The first issue is that the `DateFormat` `df` is not initialized properly and is `null` in some cases which causes a `NullPointerException` when calling the `parse` method. The solution is to always initialize `df` to either `_formatPlain`, `_formatISO8601_z`, or `_formatISO8601` depending on the input date string.\n- The second issue is related to parsing fractional seconds which may not be present in the input date string. If fractional seconds are missing or incomplete, the function will add `.000` to the end of the string. \n- The third issue is related to parsing timezones and handling offsets. The function will replace a missing colon in the timezone offset with `00` and add a trailing `Z` to the output if one is not present. \n\nHere is the updated function:\n\n```\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n\n    // check if string is a \"plain\" date (less than or equal to 10 digits and ends in a digit)\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain != null ? _formatPlain : _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n    } \n    // check for timezone offset 'Z'\n    else if (c == 'Z') {\n        // add .000 if fractional seconds are missing\n        if (len <= 20 && dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n        df = _formatISO8601_z != null ? _formatISO8601_z : _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n    } \n    // handle timezone offsets and missing or incomplete fractional seconds\n    else {\n        // check for timezone offset or missing timezone\n        int tzStart = hasTimeZone(dateStr);\n        if (tzStart > 0) {\n            // check for colon in timezone offset, add zero if missing\n            c = dateStr.charAt(tzStart + 2);\n            if (c == ':') {\n                dateStr = dateStr.substring(0, tzStart + 2) + dateStr.substring(tzStart + 3);\n            } else if (c == '+' || c == '-') {\n                dateStr += \"00\";\n            }\n            // add .000 if fractional seconds are missing\n            if (len <= tzStart + 13 && Character.isDigit(dateStr.charAt(tzStart + 2))) {\n                dateStr = dateStr.substring(0, tzStart + 2) + \".000\" + dateStr.substring(tzStart + 2);\n            }\n            // remove 'T', timezone offset, and trailing Z if present\n            len = dateStr.length();\n            if (dateStr.charAt(len - 1) == 'Z') {\n                dateStr = dateStr.substring(0, len - 1);\n            }\n            dateStr = dateStr.replace(\"T\", \" \").substring(0, tzStart - 1);\n            // add trailing Z\n            if (dateStr.charAt(dateStr.length()-1) != 'Z') {\n                dateStr += 'Z';\n            }\n            df = _formatISO8601 != null ? _formatISO8601 : _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n        } \n        // handle plain date format\n        else {\n            // add .000 if fractional seconds are missing\n            if (len <= 10) {\n                dateStr += \".000Z\";\n            } else {\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen <= 8) {\n                    dateStr += \".000Z\";\n                } else {\n                    dateStr += 'Z';\n                }\n            }\n            df = _formatISO8601_z != null ? _formatISO8601_z : _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n    }\n\n    return df.parse(dateStr, pos);\n}\n\nNote: The updated code assumes that the variables `_formatPlain`, `_formatISO8601`, and `_formatISO8601_z` are instance variables of the containing class. The `_cloneFormat` function is also assumed to be implemented and returns a new `DateFormat` instance cloned from one of the three standard format templates.", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,67 +1,66 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n-    // [JACKSON-200]: need to support \"plain\" date...\n+\n+    // check if string is a \"plain\" date (less than or equal to 10 digits and ends in a digit)\n     if (len <= 10 && Character.isDigit(c)) {\n-        df = _formatPlain;\n-        if (df == null) {\n-            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n-        }\n-    } else if (c == 'Z') {\n-        df = _formatISO8601_z;\n-        if (df == null) {\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n-        }\n-        // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        df = _formatPlain != null ? _formatPlain : _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n+    } \n+    // check for timezone offset 'Z'\n+    else if (c == 'Z') {\n+        // add .000 if fractional seconds are missing\n+        if (len <= 20 && dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n         }\n-    } else {\n-        // Let's see if we have timezone indicator or not...\n-        if (hasTimeZone(dateStr)) {\n-            c = dateStr.charAt(len - 3);\n+        df = _formatISO8601_z != null ? _formatISO8601_z : _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n+    } \n+    // handle timezone offsets and missing or incomplete fractional seconds\n+    else {\n+        // check for timezone offset or missing timezone\n+        int tzStart = hasTimeZone(dateStr);\n+        if (tzStart > 0) {\n+            // check for colon in timezone offset, add zero if missing\n+            c = dateStr.charAt(tzStart + 2);\n             if (c == ':') {\n-                // remove optional colon\n-                // remove colon\n-                StringBuilder sb = new StringBuilder(dateStr);\n-                sb.delete(len - 3, len - 2);\n-                dateStr = sb.toString();\n+                dateStr = dateStr.substring(0, tzStart + 2) + dateStr.substring(tzStart + 3);\n             } else if (c == '+' || c == '-') {\n-                // missing minutes\n-                // let's just append '00'\n                 dateStr += \"00\";\n             }\n-            // Milliseconds partial or missing; and even seconds are optional\n+            // add .000 if fractional seconds are missing\n+            if (len <= tzStart + 13 && Character.isDigit(dateStr.charAt(tzStart + 2))) {\n+                dateStr = dateStr.substring(0, tzStart + 2) + \".000\" + dateStr.substring(tzStart + 2);\n+            }\n+            // remove 'T', timezone offset, and trailing Z if present\n             len = dateStr.length();\n-            // remove 'T', '+'/'-' and 4-digit timezone-offset\n-            c = dateStr.charAt(len - 9);\n-            if (Character.isDigit(c)) {\n-                StringBuilder sb = new StringBuilder(dateStr);\n-                sb.insert(len - 5, \".000\");\n-                dateStr = sb.toString();\n+            if (dateStr.charAt(len - 1) == 'Z') {\n+                dateStr = dateStr.substring(0, len - 1);\n             }\n-            df = _formatISO8601;\n-            if (_formatISO8601 == null) {\n-                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n+            dateStr = dateStr.replace(\"T\", \" \").substring(0, tzStart - 1);\n+            // add trailing Z\n+            if (dateStr.charAt(dateStr.length()-1) != 'Z') {\n+                dateStr += 'Z';\n             }\n-        } else {\n-            // If not, plain date. Easiest to just patch 'Z' in the end?\n-            StringBuilder sb = new StringBuilder(dateStr);\n-            // And possible also millisecond part if missing\n-            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n-            if (timeLen <= 8) {\n-                sb.append(\".000\");\n+            df = _formatISO8601 != null ? _formatISO8601 : _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n+        } \n+        // handle plain date format\n+        else {\n+            // add .000 if fractional seconds are missing\n+            if (len <= 10) {\n+                dateStr += \".000Z\";\n+            } else {\n+                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n+                if (timeLen <= 8) {\n+                    dateStr += \".000Z\";\n+                } else {\n+                    dateStr += 'Z';\n+                }\n             }\n-            sb.append('Z');\n-            dateStr = sb.toString();\n-            df = _formatISO8601_z;\n-            if (df == null) {\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n-            }\n+            df = _formatISO8601_z != null ? _formatISO8601_z : _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n     }\n+\n     return df.parse(dateStr, pos);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     // [JACKSON-200]: need to support \"plain\" date...\n@@ -14,7 +14,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 24 && dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 24) == '.') {\n            dateStr = dateStr.substring(0, len - 1) + \"000\" + dateStr.substring(len - 1);\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     // [JACKSON-200]: need to support \"plain\" date...\n@@ -14,10 +14,8 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n-            StringBuilder sb = new StringBuilder(dateStr);\n-            sb.insert(len - 1, \".000\");\n-            dateStr = sb.toString();\n+        if (len >= 24 && dateStr.charAt(len - 24) == '.') {\n+            dateStr = dateStr.substring(0, len - 1) + \"000\" + dateStr.substring(len - 1);\n         }\n     } else {\n         // Let's see if we have timezone indicator or not...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        int idx = dateStr.indexOf(\".\");\n        if (dateStr.charAt(len - 4) == ':' && idx == -1) {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                if (dateStr.indexOf(\".\") == -1) {\n                    sb.insert(len - 5, \".000\");\n                    dateStr = sb.toString();\n                }\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            int idx = dateStr.indexOf(\".\");\n            if (timeLen <= 8 && idx == -1) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     // [JACKSON-200]: need to support \"plain\" date...\n@@ -14,7 +14,8 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        int idx = dateStr.indexOf(\".\");\n+        if (dateStr.charAt(len - 4) == ':' && idx == -1) {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n@@ -40,8 +41,10 @@\n             c = dateStr.charAt(len - 9);\n             if (Character.isDigit(c)) {\n                 StringBuilder sb = new StringBuilder(dateStr);\n-                sb.insert(len - 5, \".000\");\n-                dateStr = sb.toString();\n+                if (dateStr.indexOf(\".\") == -1) {\n+                    sb.insert(len - 5, \".000\");\n+                    dateStr = sb.toString();\n+                }\n             }\n             df = _formatISO8601;\n             if (_formatISO8601 == null) {\n@@ -52,7 +55,8 @@\n             StringBuilder sb = new StringBuilder(dateStr);\n             // And possible also millisecond part if missing\n             int timeLen = len - dateStr.lastIndexOf('T') - 1;\n-            if (timeLen <= 8) {\n+            int idx = dateStr.indexOf(\".\");\n+            if (timeLen <= 8 && idx == -1) {\n                 sb.append(\".000\");\n             }\n             sb.append('Z');\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (_formatISO8601_z == null) { // change\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (_formatISO8601_z == null) { // change\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     // [JACKSON-200]: need to support \"plain\" date...\n@@ -10,7 +10,7 @@\n         }\n     } else if (c == 'Z') {\n         df = _formatISO8601_z;\n-        if (df == null) {\n+        if (_formatISO8601_z == null) { // change\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n@@ -25,7 +25,6 @@\n             c = dateStr.charAt(len - 3);\n             if (c == ':') {\n                 // remove optional colon\n-                // remove colon\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n                 dateStr = sb.toString();\n@@ -58,7 +57,7 @@\n             sb.append('Z');\n             dateStr = sb.toString();\n             df = _formatISO8601_z;\n-            if (df == null) {\n+            if (_formatISO8601_z == null) { // change\n                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     // [JACKSON-200]: need to support \"plain\" date...\n@@ -14,7 +14,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 24 && dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n@@ -25,7 +25,6 @@\n             c = dateStr.charAt(len - 3);\n             if (c == ':') {\n                 // remove optional colon\n-                // remove colon\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n                 dateStr = sb.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 5) == '.') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.delete(len - 1, len);\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     // [JACKSON-200]: need to support \"plain\" date...\n@@ -14,9 +14,9 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 24 && dateStr.charAt(len - 5) == '.') {\n             StringBuilder sb = new StringBuilder(dateStr);\n-            sb.insert(len - 1, \".000\");\n+            sb.delete(len - 1, len);\n             dateStr = sb.toString();\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -14,7 +14,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 24 && dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.length() >= 24 && dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            // Check for colon in timezone offset\n            int timeZoneColonIndex = dateStr.lastIndexOf(':');\n            boolean timeZoneHasColon = timeZoneColonIndex > -1 && timeZoneColonIndex < dateStr.length() - 2;\n            boolean hasMillis = dateStr.contains(\".\");\n            int millisIndex = dateStr.indexOf(\".\");\n            boolean hasSeconds = dateStr.contains(\":\");\n            StringBuilder sb = new StringBuilder(dateStr);\n            if (!hasMillis && !hasSeconds && !timeZoneHasColon) {\n                sb.append(\"T00:00:00\").append(dateStr.charAt(len - 3)).append(\"00\");\n            } else if (!hasMillis && hasSeconds && !timeZoneHasColon) {\n                sb.append(\".000\").append(dateStr.charAt(len - 3)).append(\"00\");\n            } else if (!hasMillis && hasSeconds && timeZoneHasColon) {\n                sb.append(\".000\").deleteCharAt(timeZoneColonIndex + 3).append(dateStr.charAt(len - 3)).append(\"00\");\n            } else if (hasMillis && !hasSeconds && !timeZoneHasColon) {\n                if (millisIndex == len - 4) {\n                    sb.insert(len - 1, \"00\");\n                } else if (millisIndex == len - 5) {\n                    sb.insert(len - 1, \"0\");\n                }\n                sb.append(dateStr.charAt(len - 3)).append(\"00\");\n            } else if (hasMillis && hasSeconds && !timeZoneHasColon) {\n                if (millisIndex == len - 7) {\n                    sb.insert(len - 1, \"0\");\n                }\n                sb.deleteCharAt(millisIndex);\n                sb.append(dateStr.charAt(len - 3)).append(\"00\");\n            } else if (hasMillis && hasSeconds && timeZoneHasColon) {\n                if (millisIndex == timeZoneColonIndex - 3) {\n                    sb.insert(len - 1, \"0\");\n                }\n                sb.deleteCharAt(millisIndex);\n                sb.deleteCharAt(timeZoneColonIndex + 3);\n                sb.append(dateStr.charAt(len - 3)).append(\"00\");\n            } else if (hasMillis && !hasSeconds && timeZoneHasColon) {\n                if (millisIndex == timeZoneColonIndex - 3) {\n                    sb.insert(len - 6, \":00.000\");\n                } else if (millisIndex == timeZoneColonIndex - 4) {\n                    sb.insert(len - 6, \"0:00.000\");\n                } else if (millisIndex == timeZoneColonIndex - 5) {\n                    sb.insert(len - 6, \"00:00.000\");\n                }\n            }\n            dateStr = sb.toString();\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     // [JACKSON-200]: need to support \"plain\" date...\n@@ -14,7 +14,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (dateStr.length() >= 24 && dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n@@ -22,27 +22,49 @@\n     } else {\n         // Let's see if we have timezone indicator or not...\n         if (hasTimeZone(dateStr)) {\n-            c = dateStr.charAt(len - 3);\n-            if (c == ':') {\n-                // remove optional colon\n-                // remove colon\n-                StringBuilder sb = new StringBuilder(dateStr);\n-                sb.delete(len - 3, len - 2);\n-                dateStr = sb.toString();\n-            } else if (c == '+' || c == '-') {\n-                // missing minutes\n-                // let's just append '00'\n-                dateStr += \"00\";\n+            // Check for colon in timezone offset\n+            int timeZoneColonIndex = dateStr.lastIndexOf(':');\n+            boolean timeZoneHasColon = timeZoneColonIndex > -1 && timeZoneColonIndex < dateStr.length() - 2;\n+            boolean hasMillis = dateStr.contains(\".\");\n+            int millisIndex = dateStr.indexOf(\".\");\n+            boolean hasSeconds = dateStr.contains(\":\");\n+            StringBuilder sb = new StringBuilder(dateStr);\n+            if (!hasMillis && !hasSeconds && !timeZoneHasColon) {\n+                sb.append(\"T00:00:00\").append(dateStr.charAt(len - 3)).append(\"00\");\n+            } else if (!hasMillis && hasSeconds && !timeZoneHasColon) {\n+                sb.append(\".000\").append(dateStr.charAt(len - 3)).append(\"00\");\n+            } else if (!hasMillis && hasSeconds && timeZoneHasColon) {\n+                sb.append(\".000\").deleteCharAt(timeZoneColonIndex + 3).append(dateStr.charAt(len - 3)).append(\"00\");\n+            } else if (hasMillis && !hasSeconds && !timeZoneHasColon) {\n+                if (millisIndex == len - 4) {\n+                    sb.insert(len - 1, \"00\");\n+                } else if (millisIndex == len - 5) {\n+                    sb.insert(len - 1, \"0\");\n+                }\n+                sb.append(dateStr.charAt(len - 3)).append(\"00\");\n+            } else if (hasMillis && hasSeconds && !timeZoneHasColon) {\n+                if (millisIndex == len - 7) {\n+                    sb.insert(len - 1, \"0\");\n+                }\n+                sb.deleteCharAt(millisIndex);\n+                sb.append(dateStr.charAt(len - 3)).append(\"00\");\n+            } else if (hasMillis && hasSeconds && timeZoneHasColon) {\n+                if (millisIndex == timeZoneColonIndex - 3) {\n+                    sb.insert(len - 1, \"0\");\n+                }\n+                sb.deleteCharAt(millisIndex);\n+                sb.deleteCharAt(timeZoneColonIndex + 3);\n+                sb.append(dateStr.charAt(len - 3)).append(\"00\");\n+            } else if (hasMillis && !hasSeconds && timeZoneHasColon) {\n+                if (millisIndex == timeZoneColonIndex - 3) {\n+                    sb.insert(len - 6, \":00.000\");\n+                } else if (millisIndex == timeZoneColonIndex - 4) {\n+                    sb.insert(len - 6, \"0:00.000\");\n+                } else if (millisIndex == timeZoneColonIndex - 5) {\n+                    sb.insert(len - 6, \"00:00.000\");\n+                }\n             }\n-            // Milliseconds partial or missing; and even seconds are optional\n-            len = dateStr.length();\n-            // remove 'T', '+'/'-' and 4-digit timezone-offset\n-            c = dateStr.charAt(len - 9);\n-            if (Character.isDigit(c)) {\n-                StringBuilder sb = new StringBuilder(dateStr);\n-                sb.insert(len - 5, \".000\");\n-                dateStr = sb.toString();\n-            }\n+            dateStr = sb.toString();\n             df = _formatISO8601;\n             if (_formatISO8601 == null) {\n                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 4) == ':') {  //fix: check for length of 24\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            if (len >=23) {     //fix: check for length of 23 \n              c = dateStr.charAt(len - 9);\n            }\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -14,7 +14,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 24 && dateStr.charAt(len - 4) == ':') {  //fix: check for length of 24\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n@@ -37,7 +37,9 @@\n             // Milliseconds partial or missing; and even seconds are optional\n             len = dateStr.length();\n             // remove 'T', '+'/'-' and 4-digit timezone-offset\n-            c = dateStr.charAt(len - 9);\n+            if (len >=23) {     //fix: check for length of 23 \n+              c = dateStr.charAt(len - 9);\n+            }\n             if (Character.isDigit(c)) {\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.insert(len - 5, \".000\");\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 5) == '.') {\n            dateStr = dateStr.substring(0, len - 5) + dateStr.substring(len - 4);\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".\");\n                dateStr = sb.toString();\n                len = dateStr.length();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n\n            // Replace UTC timezone \"Z\" with \"+0000\" as expected by the SimpleDateFormat\n            if (dateStr.endsWith(\"Z\")) {\n                dateStr = dateStr.substring(0, dateStr.length() - 1) + \"+0000\";\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     // [JACKSON-200]: need to support \"plain\" date...\n@@ -14,10 +14,8 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n-            StringBuilder sb = new StringBuilder(dateStr);\n-            sb.insert(len - 1, \".000\");\n-            dateStr = sb.toString();\n+        if (len >= 24 && dateStr.charAt(len - 5) == '.') {\n+            dateStr = dateStr.substring(0, len - 5) + dateStr.substring(len - 4);\n         }\n     } else {\n         // Let's see if we have timezone indicator or not...\n@@ -40,12 +38,18 @@\n             c = dateStr.charAt(len - 9);\n             if (Character.isDigit(c)) {\n                 StringBuilder sb = new StringBuilder(dateStr);\n-                sb.insert(len - 5, \".000\");\n+                sb.insert(len - 5, \".\");\n                 dateStr = sb.toString();\n+                len = dateStr.length();\n             }\n             df = _formatISO8601;\n             if (_formatISO8601 == null) {\n                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n+            }\n+\n+            // Replace UTC timezone \"Z\" with \"+0000\" as expected by the SimpleDateFormat\n+            if (dateStr.endsWith(\"Z\")) {\n+                dateStr = dateStr.substring(0, dateStr.length() - 1) + \"+0000\";\n             }\n         } else {\n             // If not, plain date. Easiest to just patch 'Z' in the end?\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':' && (dateStr.charAt(len-9)=='T' || dateStr.charAt(len-10)=='T')) { //check if the T character is present for ISO8601 format\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -14,7 +14,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (dateStr.charAt(len - 4) == ':' && (dateStr.charAt(len-9)=='T' || dateStr.charAt(len-10)=='T')) { //check if the T character is present for ISO8601 format\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == '.') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \"000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                dateStr += \"00\";\n            }\n            len = dateStr.length();\n            c = dateStr.charAt(len - 10);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 6, \".\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,8 +1,7 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n-    // [JACKSON-200]: need to support \"plain\" date...\n     if (len <= 10 && Character.isDigit(c)) {\n         df = _formatPlain;\n         if (df == null) {\n@@ -14,33 +13,26 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n         }\n         // [JACKSON-334]: may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (dateStr.charAt(len - 4) == '.') {\n             StringBuilder sb = new StringBuilder(dateStr);\n-            sb.insert(len - 1, \".000\");\n+            sb.insert(len - 1, \"000\");\n             dateStr = sb.toString();\n         }\n     } else {\n-        // Let's see if we have timezone indicator or not...\n         if (hasTimeZone(dateStr)) {\n             c = dateStr.charAt(len - 3);\n             if (c == ':') {\n-                // remove optional colon\n-                // remove colon\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n                 dateStr = sb.toString();\n             } else if (c == '+' || c == '-') {\n-                // missing minutes\n-                // let's just append '00'\n                 dateStr += \"00\";\n             }\n-            // Milliseconds partial or missing; and even seconds are optional\n             len = dateStr.length();\n-            // remove 'T', '+'/'-' and 4-digit timezone-offset\n-            c = dateStr.charAt(len - 9);\n+            c = dateStr.charAt(len - 10);\n             if (Character.isDigit(c)) {\n                 StringBuilder sb = new StringBuilder(dateStr);\n-                sb.insert(len - 5, \".000\");\n+                sb.insert(len - 6, \".\");\n                 dateStr = sb.toString();\n             }\n             df = _formatISO8601;\n@@ -48,9 +40,7 @@\n                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n             }\n         } else {\n-            // If not, plain date. Easiest to just patch 'Z' in the end?\n             StringBuilder sb = new StringBuilder(dateStr);\n-            // And possible also millisecond part if missing\n             int timeLen = len - dateStr.lastIndexOf('T') - 1;\n             if (timeLen <= 8) {\n                 sb.append(\".000\");\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                int tzEndIndex = len - 1;\n                if (dateStr.indexOf('Z') > -1) {\n                    tzEndIndex = dateStr.indexOf('Z');\n                }\n                dateStr = dateStr.substring(0, tzEndIndex + 1) + \"00\" + dateStr.substring(tzEndIndex + 1);\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            c = dateStr.charAt(len - 9);\n            if (Character.isDigit(c)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 5, \".000\");\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 8) {\n                sb.append(\".000\");\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -32,7 +32,11 @@\n             } else if (c == '+' || c == '-') {\n                 // missing minutes\n                 // let's just append '00'\n-                dateStr += \"00\";\n+                int tzEndIndex = len - 1;\n+                if (dateStr.indexOf('Z') > -1) {\n+                    tzEndIndex = dateStr.indexOf('Z');\n+                }\n+                dateStr = dateStr.substring(0, tzEndIndex + 1) + \"00\" + dateStr.substring(tzEndIndex + 1);\n             }\n             // Milliseconds partial or missing; and even seconds are optional\n             len = dateStr.length();\n", "finish_reason": "stop", "valid": false, "num": 1}]