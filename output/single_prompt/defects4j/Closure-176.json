[{"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getToken()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.getParent().isVar();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -1,35 +1,11 @@\n private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n     Preconditions.checkNotNull(resultType);\n-    switch(left.getType()) {\n+    switch(left.getToken()) {\n         case Token.NAME:\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n-            boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n+            boolean isVarDeclaration = left.getParent().isVar();\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                if (oldType == null) {\n                    var.setType(resultType);\n                } else {\n                    var.setType(oldType.getLeastSupertype(resultType));\n                }\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                JSType inferredType = leftType == null ? unknownType : leftType;\n                scope.inferQualifiedSlot(left, qualifiedName, inferredType, resultType);\n                left.setJSType(inferredType);\n            }\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,46 +5,27 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n             left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n-                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n+                if (oldType == null) {\n+                    var.setType(resultType);\n+                } else {\n+                    var.setType(oldType.getLeastSupertype(resultType));\n+                }\n             }\n             break;\n         case Token.GETPROP:\n             String qualifiedName = left.getQualifiedName();\n             if (qualifiedName != null) {\n-                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n+                JSType inferredType = leftType == null ? unknownType : leftType;\n+                scope.inferQualifiedSlot(left, qualifiedName, inferredType, resultType);\n+                left.setJSType(inferredType);\n             }\n-            left.setJSType(resultType);\n             ensurePropertyDefined(left, resultType);\n             break;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(resultType);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -1,39 +1,15 @@\n private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n     Preconditions.checkNotNull(resultType);\n-    switch(left.getType()) {\n+    switch (left.getType()) {\n         case Token.NAME:\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n-            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n+            left.setJSType(resultType);\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n                 var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                if (oldType == null) {\n                    var.setType(resultType);\n                } else {\n                    var.setType(oldType.getLeastSupertype(resultType));\n                }\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                JSType typeToInfer = leftType == null ? unknownType : leftType.autobox();\n                scope.inferQualifiedSlot(left, qualifiedName, typeToInfer, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,44 +5,25 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n             left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n-                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n+                if (oldType == null) {\n+                    var.setType(resultType);\n+                } else {\n+                    var.setType(oldType.getLeastSupertype(resultType));\n+                }\n             }\n             break;\n         case Token.GETPROP:\n             String qualifiedName = left.getQualifiedName();\n             if (qualifiedName != null) {\n-                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n+                JSType typeToInfer = leftType == null ? unknownType : leftType.autobox();\n+                scope.inferQualifiedSlot(left, qualifiedName, typeToInfer, resultType);\n             }\n             left.setJSType(resultType);\n             ensurePropertyDefined(left, resultType);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            // Set the JSType even if it's not a var declaration\n            // or if leftType != null, because updateTypeAnnotations\n            // may have set it to a non-null value.\n            left.setJSType(resultType);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,35 +5,14 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n-            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n+            // Set the JSType even if it's not a var declaration\n+            // or if leftType != null, because updateTypeAnnotations\n+            // may have set it to a non-null value.\n+            left.setJSType(resultType);\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n                 var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.getType() == null || var.isTypeInferred() || leftType != null && leftType.isSubtype(var.getType());\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,31 +5,7 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n-            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n+            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.getType() == null || var.isTypeInferred() || leftType != null && leftType.isSubtype(var.getType());\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = false;\n            if (isVarDeclaration) {\n                // check if the declared var type is `unknownType` or `undefinedType`\n                JSType varType = leftType == null ? var == null || var.getType() == null ? unknownType : var.getType() : leftType;\n                if (varType.equals(unknownType) || varType.equals(undefinedType)) {\n                    isVarTypeBetter = true;\n                } else {\n                    // use the declared type over the inferred type, if the inferred type is wider\n                    isVarTypeBetter = resultType.isSubtype(varType);\n                }\n            } else {\n                // if the name is not a declared var, then consider inferred type only\n                isVarTypeBetter = leftType == null || resultType.isSubtype(leftType);\n            }\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,31 +5,20 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n-            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n+            boolean isVarTypeBetter = false;\n+            if (isVarDeclaration) {\n+                // check if the declared var type is `unknownType` or `undefinedType`\n+                JSType varType = leftType == null ? var == null || var.getType() == null ? unknownType : var.getType() : leftType;\n+                if (varType.equals(unknownType) || varType.equals(undefinedType)) {\n+                    isVarTypeBetter = true;\n+                } else {\n+                    // use the declared type over the inferred type, if the inferred type is wider\n+                    isVarTypeBetter = resultType.isSubtype(varType);\n+                }\n+            } else {\n+                // if the name is not a declared var, then consider inferred type only\n+                isVarTypeBetter = leftType == null || resultType.isSubtype(leftType);\n+            }\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = false;\n            if (isVarDeclaration) {\n                if (var != null) {\n                    if (var.isTypeInferred()) {\n                        // When looking at VAR initializers for declared VARs, we tend\n                        // to use the declared type over the type it's being\n                        // initialized to in the global scope.\n                        //\n                        // For example,\n                        // /** @param {number} */ var f = goog.abstractMethod;\n                        // it's obvious that the programmer wants you to use\n                        // the declared function signature, not the inferred signature.\n                        //\n                        // Or,\n                        // /** @type {Object.<string>} */ var x = {};\n                        // the one-time anonymous object on the right side\n                        // is as narrow as it can possibly be, but we need to make\n                        // sure we back-infer the <string> element constraint on\n                        // the left hand side, so we use the left hand side.\n                        isVarTypeBetter = true;\n                    }\n                } else {\n                    // New undeclared variable encountered, use resultType\n                    isVarTypeBetter = true;\n                }\n            } else {\n                // Assignment to existing variable, compare types\n                JSType oldType = leftType != null ? leftType : var != null ? var.getType() : null;\n                if (oldType != null) {\n                    isVarTypeBetter = resultType.isMoreSpecificThan(oldType);\n                }\n            }\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,31 +5,38 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n-            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n+            boolean isVarTypeBetter = false;\n+            if (isVarDeclaration) {\n+                if (var != null) {\n+                    if (var.isTypeInferred()) {\n+                        // When looking at VAR initializers for declared VARs, we tend\n+                        // to use the declared type over the type it's being\n+                        // initialized to in the global scope.\n+                        //\n+                        // For example,\n+                        // /** @param {number} */ var f = goog.abstractMethod;\n+                        // it's obvious that the programmer wants you to use\n+                        // the declared function signature, not the inferred signature.\n+                        //\n+                        // Or,\n+                        // /** @type {Object.<string>} */ var x = {};\n+                        // the one-time anonymous object on the right side\n+                        // is as narrow as it can possibly be, but we need to make\n+                        // sure we back-infer the <string> element constraint on\n+                        // the left hand side, so we use the left hand side.\n+                        isVarTypeBetter = true;\n+                    }\n+                } else {\n+                    // New undeclared variable encountered, use resultType\n+                    isVarTypeBetter = true;\n+                }\n+            } else {\n+                // Assignment to existing variable, compare types\n+                JSType oldType = leftType != null ? leftType : var != null ? var.getType() : null;\n+                if (oldType != null) {\n+                    isVarTypeBetter = resultType.isMoreSpecificThan(oldType);\n+                }\n+            }\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            break;\n    }\n    ensurePropertyDefined(left, resultType);\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,31 +5,7 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n@@ -45,7 +21,7 @@\n                 scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n             }\n             left.setJSType(resultType);\n-            ensurePropertyDefined(left, resultType);\n             break;\n     }\n+    ensurePropertyDefined(left, resultType);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            // Set JSType to resultType if isVarDeclaration is true or if leftType is null.\n            if (isVarDeclaration || leftType == null) {\n                left.setJSType(resultType);\n            }\n            // Update inferred type for var if applicable.\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,35 +5,15 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n-            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n+            // Set JSType to resultType if isVarDeclaration is true or if leftType is null.\n+            if (isVarDeclaration || leftType == null) {\n+                left.setJSType(resultType);\n+            }\n+            // Update inferred type for var if applicable.\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n                 var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n                left.setJSType(resultType);\n            } else {\n                left.setJSType(leftType);\n            }\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,35 +5,13 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n+                left.setJSType(resultType);\n+            } else {\n+                left.setJSType(leftType);\n             }\n-            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n                 var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                // redeclareSimpleVar is the fixed function\n                redeclareSimpleVar(scope, left, resultType);\n            } else {\n                // Don't overwrite left's type if it's worse.\n                if (left.getJSType() == null && leftType != null) {\n                    left.setJSType(leftType);\n                } else if (left.getJSType() != null && leftType != null) {\n                    left.setJSType(left.getJSType().getLeastSupertype(leftType));\n                }\n            }\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,35 +5,18 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n+                // redeclareSimpleVar is the fixed function\n                 redeclareSimpleVar(scope, left, resultType);\n+            } else {\n+                // Don't overwrite left's type if it's worse.\n+                if (left.getJSType() == null && leftType != null) {\n+                    left.setJSType(leftType);\n+                } else if (left.getJSType() != null && leftType != null) {\n+                    left.setJSType(left.getJSType().getLeastSupertype(leftType));\n+                }\n             }\n-            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n                 var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration\n                    || var == null\n                    || var.isTypeInferred()\n                    || var.getType().equals(unknownType);\n            if (isVarTypeBetter) {\n                JSType varType = isVarDeclaration ? resultType : leftType;\n                redeclareSimpleVar(scope, left, varType);\n                var = syntacticScope.getVar(varName);\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(var.getType().getLeastSupertype(varType));\n                }\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : var.getType());\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,39 +5,19 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n-            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n+            boolean isVarTypeBetter = !isVarDeclaration\n+                    || var == null\n+                    || var.isTypeInferred()\n+                    || var.getType().equals(unknownType);\n             if (isVarTypeBetter) {\n-                redeclareSimpleVar(scope, left, resultType);\n+                JSType varType = isVarDeclaration ? resultType : leftType;\n+                redeclareSimpleVar(scope, left, varType);\n+                var = syntacticScope.getVar(varName);\n+                if (var != null && var.isTypeInferred()) {\n+                    var.setType(var.getType().getLeastSupertype(varType));\n+                }\n             }\n-            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n-            if (var != null && var.isTypeInferred()) {\n-                JSType oldType = var.getType();\n-                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n-            }\n+            left.setJSType(isVarDeclaration || leftType == null ? resultType : var.getType());\n             break;\n         case Token.GETPROP:\n             String qualifiedName = left.getQualifiedName();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            // When looking at VAR initializers for declared VARs, we tend\n            // to use the declared type over the type it's being\n            // initialized to in the global scope.\n            //\n            // For example,\n            // /** @param {number} */ var f = goog.abstractMethod;\n            // it's obvious that the programmer wants you to use\n            // the declared function signature, not the inferred signature.\n            //\n            // Or,\n            // /** @type {Object.<string>} */ var x = {};\n            // the one-time anonymous object on the right side\n            // is as narrow as it can possibly be, but we need to make\n            // sure we back-infer the <string> element constraint on\n            // the left hand side, so we use the left hand side.\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            // Makes it easier to check for NPEs.\n            // TODO(nicksantos): This might be a better check once we have\n            // back-inference of object/array constraints.  It will probably\n            // introduce more type warnings.  It uses the result type iff it's\n            // strictly narrower than the declared var type.\n            //\n            //boolean isVarTypeBetter = isVarDeclaration &&\n            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n            //     || !resultType.isSubtype(varType));\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            if (isVarDeclaration) {\n                left.setJSType(resultType);\n            } else if (leftType == null) {\n                left.setJSType(resultType);\n            }\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -33,7 +33,11 @@\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n-            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n+            if (isVarDeclaration) {\n+                left.setJSType(resultType);\n+            } else if (leftType == null) {\n+                left.setJSType(resultType);\n+            }\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n                 var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            // When looking at VAR initializers for declared VARs, we tend\n            // to use the declared type over the type it's being\n            // initialized to in the global scope.\n            //\n            // For example,\n            // /** @param {number} */ var f = goog.abstractMethod;\n            // it's obvious that the programmer wants you to use\n            // the declared function signature, not the inferred signature.\n            //\n            // Or,\n            // /** @type {Object.<string>} */ var x = {};\n            // the one-time anonymous object on the right side\n            // is as narrow as it can possibly be, but we need to make\n            // sure we back-infer the <string> element constraint on\n            // the left hand side, so we use the left hand side.\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || (var.getType() == null && var.isTypeInferred());\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -20,16 +20,7 @@\n             // is as narrow as it can possibly be, but we need to make\n             // sure we back-infer the <string> element constraint on\n             // the left hand side, so we use the left hand side.\n-            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n+            boolean isVarTypeBetter = !isVarDeclaration || var == null || (var.getType() == null && var.isTypeInferred());\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = isVarDeclaration && (var == null || var.isTypeInferred());\n            // Compare the declared var type to the result type, and check if result type is\n            // strictly narrower than the var type.\n            if (isVarDeclaration && !isVarTypeBetter) {\n                JSType varType = var.getType();\n                if (varType != null && varType.restrictByNotNullOrUndefined().isSubtype(resultType)) {\n                    resultType = varType;\n                } else {\n                    scope.getWarnings().add(JSError.make(left, MISTYPED_ASSIGN_RHS), left);\n                }\n            }\n            redeclareSimpleVar(scope, left, resultType);\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,34 +5,18 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n-            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n-            if (isVarTypeBetter) {\n-                redeclareSimpleVar(scope, left, resultType);\n+            boolean isVarTypeBetter = isVarDeclaration && (var == null || var.isTypeInferred());\n+            // Compare the declared var type to the result type, and check if result type is\n+            // strictly narrower than the var type.\n+            if (isVarDeclaration && !isVarTypeBetter) {\n+                JSType varType = var.getType();\n+                if (varType != null && varType.restrictByNotNullOrUndefined().isSubtype(resultType)) {\n+                    resultType = varType;\n+                } else {\n+                    scope.getWarnings().add(JSError.make(left, MISTYPED_ASSIGN_RHS), left);\n+                }\n             }\n+            redeclareSimpleVar(scope, left, resultType);\n             left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            // fixed line - always set the JSType of the Node to resultType\n            left.setJSType(resultType);\n            // fixed line - remove unnecessary check for leftType being null\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, unknownType, resultType);\n            }\n            // fixed line - always set the JSType of the Node to resultType\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,35 +5,13 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n-            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n+            // fixed line - always set the JSType of the Node to resultType\n+            left.setJSType(resultType);\n+            // fixed line - remove unnecessary check for leftType being null\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n                 var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n@@ -42,8 +20,9 @@\n         case Token.GETPROP:\n             String qualifiedName = left.getQualifiedName();\n             if (qualifiedName != null) {\n-                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n+                scope.inferQualifiedSlot(left, qualifiedName, unknownType, resultType);\n             }\n+            // fixed line - always set the JSType of the Node to resultType\n             left.setJSType(resultType);\n             ensurePropertyDefined(left, resultType);\n             break;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren() && left.getFirstChild().getType() == Token.ASSIGN;\n            // When looking at VAR initializers for declared VARs, we tend\n            // to use the declared type over the type it's being\n            // initialized to in the global scope.\n            //\n            // For example,\n            // /** @param {number} */ var f = goog.abstractMethod;\n            // it's obvious that the programmer wants you to use\n            // the declared function signature, not the inferred signature.\n            //\n            // Or,\n            // /** @type {Object.<string>} */ var x = {};\n            // the one-time anonymous object on the right side\n            // is as narrow as it can possibly be, but we need to make\n            // sure we back-infer the <string> element constraint on\n            // the left hand side, so we use the left hand side.\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -4,7 +4,7 @@\n         case Token.NAME:\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n-            boolean isVarDeclaration = left.hasChildren();\n+            boolean isVarDeclaration = left.hasChildren() && left.getFirstChild().getType() == Token.ASSIGN;\n             // When looking at VAR initializers for declared VARs, we tend\n             // to use the declared type over the type it's being\n             // initialized to in the global scope.\n@@ -21,15 +21,6 @@\n             // sure we back-infer the <string> element constraint on\n             // the left hand side, so we use the left hand side.\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : leftType); // Fix typo\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -5,35 +5,11 @@\n             String varName = left.getString();\n             Var var = syntacticScope.getVar(varName);\n             boolean isVarDeclaration = left.hasChildren();\n-            // When looking at VAR initializers for declared VARs, we tend\n-            // to use the declared type over the type it's being\n-            // initialized to in the global scope.\n-            //\n-            // For example,\n-            // /** @param {number} */ var f = goog.abstractMethod;\n-            // it's obvious that the programmer wants you to use\n-            // the declared function signature, not the inferred signature.\n-            //\n-            // Or,\n-            // /** @type {Object.<string>} */ var x = {};\n-            // the one-time anonymous object on the right side\n-            // is as narrow as it can possibly be, but we need to make\n-            // sure we back-infer the <string> element constraint on\n-            // the left hand side, so we use the left hand side.\n             boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-            // TODO(nicksantos): This might be a better check once we have\n-            // back-inference of object/array constraints.  It will probably\n-            // introduce more type warnings.  It uses the result type iff it's\n-            // strictly narrower than the declared var type.\n-            //\n-            //boolean isVarTypeBetter = isVarDeclaration &&\n-            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-            //     || !resultType.isSubtype(varType));\n             if (isVarTypeBetter) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n-            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n+            left.setJSType(isVarDeclaration || leftType == null ? resultType : leftType); // Fix typo\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n                 var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName = left.getString();\n            Var var = syntacticScope.getVar(varName);\n            boolean isVarDeclaration = left.hasChildren();\n            // When looking at VAR initializers for declared VARs, we tend\n            // to use the declared type over the type it's being\n            // initialized to in the global scope.\n            //\n            // For example,\n            // /** @param {number} */ var f = goog.abstractMethod;\n            // it's obvious that the programmer wants you to use\n            // the declared function signature, not the inferred signature.\n            //\n            // Or,\n            // /** @type {Object.<string>} */ var x = {};\n            // the one-time anonymous object on the right side\n            // is as narrow as it can possibly be, but we need to make\n            // sure we back-infer the <string> element constraint on\n            // the left hand side, so we use the left hand side.\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            // Makes it easier to check for NPEs.\n            // TODO(nicksantos): This might be a better check once we have\n            // back-inference of object/array constraints.  It will probably\n            // introduce more type warnings.  It uses the result type iff it's\n            // strictly narrower than the declared var type.\n            //\n            //boolean isVarTypeBetter = isVarDeclaration &&\n            //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n            //     || !resultType.isSubtype(varType));\n            if (isVarTypeBetter) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n            if (var != null && var.isTypeInferred()) {\n                JSType oldType = var.getType();\n                // Fix: Check if old type is null to avoid NPEs.\n                if (oldType != null) {\n                    var.setType(oldType.getLeastSupertype(resultType));\n                } else {\n                    var.setType(resultType);\n                }\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName = left.getQualifiedName();\n            if (qualifiedName != null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n+++ com/google/javascript/jscomp/TypeInference.java@updateScopeForTypeChange\n@@ -36,7 +36,12 @@\n             left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n             if (var != null && var.isTypeInferred()) {\n                 JSType oldType = var.getType();\n-                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\n+                // Fix: Check if old type is null to avoid NPEs.\n+                if (oldType != null) {\n+                    var.setType(oldType.getLeastSupertype(resultType));\n+                } else {\n+                    var.setType(resultType);\n+                }\n             }\n             break;\n         case Token.GETPROP:\n", "finish_reason": "stop", "valid": false, "num": 1}]