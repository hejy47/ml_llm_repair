[{"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outPos + outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outPos + outAvail) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && len == b.length) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outPos + outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,9 +1,7 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n@@ -13,7 +11,7 @@\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n+                if (c > 0 && len == b.length) {\n                     base64.setInitialBuffer(b, offset, len);\n                 }\n                 if (doEncode) {\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outPos + outAvail) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && offset == 0 && len == buf.length) {\n                    base64.setInitialBuffer(buf, 0, buf.length);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length == outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n        return;\n    }\n    throw new IllegalArgumentException(\"Invalid buffer length.\");\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -13,8 +13,8 @@\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n-                    base64.setInitialBuffer(b, offset, len);\n+                if (c > 0 && offset == 0 && len == buf.length) {\n+                    base64.setInitialBuffer(buf, 0, buf.length);\n                 }\n                 if (doEncode) {\n                     base64.encode(buf, 0, c);\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -3,5 +3,7 @@\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n+        return;\n     }\n+    throw new IllegalArgumentException(\"Invalid buffer length.\");\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && offset == 0 && len == b.length) {\n                    base64.setInitialBuffer(buf, 0, buf.length);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail && outPos >= 0 && outPos < out.length) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,20 +1,18 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n-                    base64.setInitialBuffer(b, offset, len);\n+                if (c > 0 && offset == 0 && len == b.length) {\n+                    base64.setInitialBuffer(buf, 0, buf.length);\n                 }\n                 if (doEncode) {\n                     base64.encode(buf, 0, c);\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outAvail && outPos >= 0 && outPos < out.length) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) { // updated condition\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) { // updated condition\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) { // updated condition\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outAvail) { // updated condition\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail && outPos >= 0 && outPos + outAvail <= out.length) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outAvail && outPos >= 0 && outPos + outAvail <= out.length) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen < len) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen += base64.readResults(b, offset + readLen, len - readLen);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -9,7 +9,7 @@\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen < len) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n@@ -22,7 +22,7 @@\n                     base64.decode(buf, 0, c);\n                 }\n             }\n-            readLen = base64.readResults(b, offset, len);\n+            readLen += base64.readResults(b, offset + readLen, len - readLen);\n         }\n         return readLen;\n     }\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outAvail) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) { // fixed IndexOutOfBoundsException check\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length == outAvail && outPos >= 0 && outPos < out.length) { // added bounds check for outPos\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,9 +1,7 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) { // fixed IndexOutOfBoundsException check\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length == outAvail && outPos >= 0 && outPos < out.length) { // added bounds check for outPos\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && offset == 0 && len == buf.length) {\n                    base64.setInitialBuffer(buf, 0, buf.length);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length == outAvail && outPos >= 0) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -9,12 +9,12 @@\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n-                    base64.setInitialBuffer(b, offset, len);\n+                if (c > 0 && offset == 0 && len == buf.length) {\n+                    base64.setInitialBuffer(buf, 0, buf.length);\n                 }\n                 if (doEncode) {\n                     base64.encode(buf, 0, c);\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length == outAvail && outPos >= 0) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0) {\n                    if (b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    } else {\n                        byte[] temp = new byte[len];\n                        System.arraycopy(b, offset, temp, 0, len);\n                        base64.setInitialBuffer(temp, 0, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= (outPos + outAvail)) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -9,17 +9,23 @@\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n-                    base64.setInitialBuffer(b, offset, len);\n-                }\n-                if (doEncode) {\n-                    base64.encode(buf, 0, c);\n-                } else {\n-                    base64.decode(buf, 0, c);\n+                if (c > 0) {\n+                    if (b.length == len) {\n+                        base64.setInitialBuffer(b, offset, len);\n+                    } else {\n+                        byte[] temp = new byte[len];\n+                        System.arraycopy(b, offset, temp, 0, len);\n+                        base64.setInitialBuffer(temp, 0, len);\n+                    }\n+                    if (doEncode) {\n+                        base64.encode(buf, 0, c);\n+                    } else {\n+                        base64.decode(buf, 0, c);\n+                    }\n                 }\n             }\n             readLen = base64.readResults(b, offset, len);\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= (outPos + outAvail)) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null || offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,19 +1,15 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n-    if (b == null) {\n-        throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    if (b == null || offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n+                if (c > 0) {\n                     base64.setInitialBuffer(b, offset, len);\n                 }\n                 if (doEncode) {\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outAvail) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && len == b.length) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length == outAvail && outPos >= 0 && outPos < out.length) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,19 +1,17 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n+                if (c > 0 && len == b.length) {\n                     base64.setInitialBuffer(b, offset, len);\n                 }\n                 if (doEncode) {\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length == outAvail && outPos >= 0 && outPos < out.length) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,9 +1,7 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outAvail) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset + readLen, len - readLen);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length == outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos + outAvail; // fixed bug: setting readPos to the end of the buffer\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n@@ -22,7 +20,7 @@\n                     base64.decode(buf, 0, c);\n                 }\n             }\n-            readLen = base64.readResults(b, offset, len);\n+            readLen = base64.readResults(b, offset + readLen, len - readLen);\n         }\n         return readLen;\n     }\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -2,6 +2,6 @@\n     if (out != null && out.length == outAvail) {\n         buffer = out;\n         pos = outPos;\n-        readPos = outPos;\n+        readPos = outPos + outAvail; // fixed bug: setting readPos to the end of the buffer\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen < len) { // fixed: change from while (readLen == 0) to while (readLen < len)\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen += base64.readResults(b, offset + readLen, len - readLen); // fixed: add accumulated readLen and adjust offset\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) { // fixed: change from out.length == outAvail to out.length >= outAvail\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -9,7 +9,7 @@\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen < len) { // fixed: change from while (readLen == 0) to while (readLen < len)\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n@@ -22,7 +22,7 @@\n                     base64.decode(buf, 0, c);\n                 }\n             }\n-            readLen = base64.readResults(b, offset, len);\n+            readLen += base64.readResults(b, offset + readLen, len - readLen); // fixed: add accumulated readLen and adjust offset\n         }\n         return readLen;\n     }\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outAvail) { // fixed: change from out.length == outAvail to out.length >= outAvail\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset >= b.length || offset + len > b.length) { // Fixed the condition for index out of bounds check\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail && outPos >=0 && outAvail>=0) { // added null check, bounds check and condition for outPos\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -3,7 +3,7 @@\n         throw new NullPointerException();\n     } else if (offset < 0 || len < 0) {\n         throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset >= b.length || offset + len > b.length) { // Fixed the condition for index out of bounds check\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outAvail && outPos >=0 && outAvail>=0) { // added null check, bounds check and condition for outPos\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length == outAvail && outPos >= 0 && outPos < out.length) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length == outAvail && outPos >= 0 && outPos < out.length) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && offset == 0 && len == b.length) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && outAvail <= out.length - outPos) { // add check for available space in the buffer\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,19 +1,17 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n+                if (c > 0 && offset == 0 && len == b.length) {\n                     base64.setInitialBuffer(b, offset, len);\n                 }\n                 if (doEncode) {\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && outAvail <= out.length - outPos) { // add check for available space in the buffer\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) { // Fixed condition\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail && outPos + outAvail <= out.length) { // Fixed condition\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) { // Fixed condition\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outAvail && outPos + outAvail <= out.length) { // Fixed condition\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n            offset += readLen;\n            len -= readLen;\n        }\n        return readLen;\n    }\n}\n\n## Fixed Function 2\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outPos + outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n@@ -23,6 +21,8 @@\n                 }\n             }\n             readLen = base64.readResults(b, offset, len);\n+            offset += readLen;\n+            len -= readLen;\n         }\n         return readLen;\n     }\n--- org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n+++ org/apache/commons/codec/binary/Base64.java@setInitialBuffer\n@@ -1,5 +1,5 @@\n void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-    if (out != null && out.length == outAvail) {\n+    if (out != null && out.length >= outPos + outAvail) {\n         buffer = out;\n         pos = outPos;\n         readPos = outPos;\n", "finish_reason": "stop", "valid": false, "num": 1}]