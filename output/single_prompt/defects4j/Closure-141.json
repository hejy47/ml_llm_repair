[{"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n        default:\n            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n                if (canBeSideEffected(c, knownConstants)) {\n                    return true;\n                }\n            }\n            return false;\n    }\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n            result.add(current);\n        } else {\n            return null;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -13,11 +13,12 @@\n         case Token.GETPROP:\n         case Token.GETELEM:\n             return true;\n+        default:\n+            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+                if (canBeSideEffected(c, knownConstants)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n     }\n-    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-        if (canBeSideEffected(c, knownConstants)) {\n-            return true;\n-        }\n-    }\n-    return false;\n }\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -9,7 +9,7 @@\n     }\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n             result.add(current);\n         } else {\n             return null;\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // Check if it's a call to Object.freeze or Object.seal which indicates immutability.\n            Node callee = n.getFirstChild();\n            if (NodeUtil.isName(callee) && (\"freeze\".equals(callee.getString()) || \"seal\".equals(callee.getString()))) {\n                return false;\n            }\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();        \n        Node functionNode = null;\n        if (NodeUtil.isFunction(current.getDeclarationNode())) {\n            functionNode = current.getDeclarationNode();\n        } else if (rValue != null && NodeUtil.isFunction(rValue)) {\n            functionNode = rValue;\n        } else if (NodeUtil.isName(rValue) && definitionProvider.getDefinitionsReferencedAt(rValue).size() == 1) {\n            // Try to resolve the function's definition.\n            Collection<Definition> innerDecl = getCallableDefinitions(definitionProvider, rValue);\n            if (innerDecl != null && innerDecl.size() == 1) {\n                functionNode = innerDecl.iterator().next().getDeclarationNode();\n            }\n        }\n        \n        if (functionNode != null) {\n            result.add(new Definition(current.getName(), current.getNode(),\n                    functionNode));\n        } else {\n            return null;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -3,8 +3,11 @@\n         case Token.CALL:\n         case Token.NEW:\n             // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // Check if it's a call to Object.freeze or Object.seal which indicates immutability.\n+            Node callee = n.getFirstChild();\n+            if (NodeUtil.isName(callee) && (\"freeze\".equals(callee.getString()) || \"seal\".equals(callee.getString()))) {\n+                return false;\n+            }\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -8,9 +8,23 @@\n         return null;\n     }\n     for (Definition current : decls) {\n-        Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n-            result.add(current);\n+        Node rValue = current.getRValue();        \n+        Node functionNode = null;\n+        if (NodeUtil.isFunction(current.getDeclarationNode())) {\n+            functionNode = current.getDeclarationNode();\n+        } else if (rValue != null && NodeUtil.isFunction(rValue)) {\n+            functionNode = rValue;\n+        } else if (NodeUtil.isName(rValue) && definitionProvider.getDefinitionsReferencedAt(rValue).size() == 1) {\n+            // Try to resolve the function's definition.\n+            Collection<Definition> innerDecl = getCallableDefinitions(definitionProvider, rValue);\n+            if (innerDecl != null && innerDecl.size() == 1) {\n+                functionNode = innerDecl.iterator().next().getDeclarationNode();\n+            }\n+        }\n+        \n+        if (functionNode != null) {\n+            result.add(new Definition(current.getName(), current.getNode(),\n+                    functionNode));\n         } else {\n             return null;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructors can reference changed values.\n            // We assume that functions are Side-effect Free if they are known to be Pure (have no side effects)\n            if (NodeUtil.isFunctionExpression(n.getFirstChild())\n                    || NodeUtil.isFunctionDeclaration(n.getFirstChild())) {\n                return false;\n            }\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n            // We assume that functions are Side-effect Free if they are known to be Pure (have no side effects).\n            if (functionCanBeOptimized(rValue)) {\n                continue;\n            }\n            result.add(current);\n        } else {\n            return null;\n        }\n    }\n    return result;\n}\n\nprivate static boolean functionCanBeOptimized(Node fn) {\n    Preconditions.checkState(fn.isFunction());\n    if (fn.isArrowFunction()) {\n        return true;\n    }\n    int sideEffectMask = NodeUtil.getFunctionSideEffectFlags(fn);\n    if (sideEffectMask == 0 || sideEffectMask == NodeUtil.PURE_FUNCTION) {\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -2,9 +2,12 @@\n     switch(n.getType()) {\n         case Token.CALL:\n         case Token.NEW:\n-            // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // Function calls or constructors can reference changed values.\n+            // We assume that functions are Side-effect Free if they are known to be Pure (have no side effects)\n+            if (NodeUtil.isFunctionExpression(n.getFirstChild())\n+                    || NodeUtil.isFunctionDeclaration(n.getFirstChild())) {\n+                return false;\n+            }\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -10,6 +10,10 @@\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n         if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+            // We assume that functions are Side-effect Free if they are known to be Pure (have no side effects).\n+            if (functionCanBeOptimized(rValue)) {\n+                continue;\n+            }\n             result.add(current);\n         } else {\n             return null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            // return !NodeUtil.isConstantName(n) && !knownCStonstants.contains(n.getString());\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static List<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        // return null;\n        return result;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        // return null;\n        return result;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n            result.add(current);\n        } else {\n            // return null;\n            return result;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -8,6 +8,7 @@\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n+            // return !NodeUtil.isConstantName(n) && !knownCStonstants.contains(n.getString());\n             return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructors can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names are variables and their values may change.\n            // Constant names, however, are immutable and cannot be changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if (rValue == null) {\n            continue;\n        }\n        if ((rValue.isFunction() || rValue.isClass())) {\n            result.add(current);\n        } else if (rValue.isQualifiedName()) {\n            // If the definition is a qualified name, check if the parent is a function/class.\n            Node parent = rValue.getParent();\n            if (parent != null && (parent.isFunction() || parent.isClass())) {\n                result.add(current);\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n    // Return null if the result is empty.\n    return result.isEmpty() ? null : result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -2,12 +2,13 @@\n     switch(n.getType()) {\n         case Token.CALL:\n         case Token.NEW:\n-            // Function calls or constructor can reference changed values.\n+            // Function calls or constructors can reference changed values.\n             // TODO(johnlenz): Add some mechanism for determining that functions\n             // are unaffected by side effects.\n             return true;\n         case Token.NAME:\n-            // Non-constant names values may have been changed.\n+            // Non-constant names are variables and their values may change.\n+            // Constant names, however, are immutable and cannot be changed.\n             return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -9,11 +9,23 @@\n     }\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+        if (rValue == null) {\n+            continue;\n+        }\n+        if ((rValue.isFunction() || rValue.isClass())) {\n             result.add(current);\n+        } else if (rValue.isQualifiedName()) {\n+            // If the definition is a qualified name, check if the parent is a function/class.\n+            Node parent = rValue.getParent();\n+            if (parent != null && (parent.isFunction() || parent.isClass())) {\n+                result.add(current);\n+            } else {\n+                return null;\n+            }\n         } else {\n             return null;\n         }\n     }\n-    return result;\n+    // Return null if the result is empty.\n+    return result.isEmpty() ? null : result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // We assume that any function called from outside the current scope of\n            // the local variable knownConstants may have side-effects.\n            Scope scope = n.getScope();\n            if (scope != null && !scope.isDeclared(knownConstants)) {\n                return true;\n            }\n            break;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n            result.add(current);\n        } else {\n            return null;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -3,9 +3,13 @@\n         case Token.CALL:\n         case Token.NEW:\n             // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n-            return true;\n+            // We assume that any function called from outside the current scope of\n+            // the local variable knownConstants may have side-effects.\n+            Scope scope = n.getScope();\n+            if (scope != null && !scope.isDeclared(knownConstants)) {\n+                return true;\n+            }\n+            break;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n             return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -9,7 +9,7 @@\n     }\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n             result.add(current);\n         } else {\n             return null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch (n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // We assume that functions annotated with @nosideeffects are unaffected by side effects.\n            return !n.getBooleanProp(Node.NO_SIDE_EFFECTS);\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return !NodeUtil.isConstantName(n.getFirstChild());\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n            result.add(current);\n        } else {\n            return null;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -1,18 +1,17 @@\n static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n-    switch(n.getType()) {\n+    switch (n.getType()) {\n         case Token.CALL:\n         case Token.NEW:\n             // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n-            return true;\n+            // We assume that functions annotated with @nosideeffects are unaffected by side effects.\n+            return !n.getBooleanProp(Node.NO_SIDE_EFFECTS);\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n             return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n-            return true;\n+            return !NodeUtil.isConstantName(n.getFirstChild());\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -9,7 +9,7 @@\n     }\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n             result.add(current);\n         } else {\n             return null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Assume functions or constructors can reference changed values\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        case Token.GETPROP:\n        case Token.GETELEM:\n        case Token.OBJECTLIT:\n            // Properties on constant NAMEs and object literal keys can still be side-effected.\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if (NodeUtil.isFunctionExpression(rValue) || NodeUtil.isFunctionDeclaration(rValue)) {\n            result.add(current);\n        } else {\n            return null;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -2,16 +2,15 @@\n     switch(n.getType()) {\n         case Token.CALL:\n         case Token.NEW:\n-            // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // Assume functions or constructors can reference changed values\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n             return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n-        // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n+        case Token.OBJECTLIT:\n+            // Properties on constant NAMEs and object literal keys can still be side-effected.\n             return true;\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -9,7 +9,7 @@\n     }\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+        if (NodeUtil.isFunctionExpression(rValue) || NodeUtil.isFunctionDeclaration(rValue)) {\n             result.add(current);\n         } else {\n             return null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        case Token.GETPROP:\n            // Only properties on non-constant names can be side-effected.\n            return !NodeUtil.isConstantName(n.getFirstChild());\n        case Token.GETELEM:\n            // Elements on GETELEM can be side-effected.\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    boolean foundFunction = false;\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n            foundFunction = true;\n            result.add(current);\n        }\n    }\n    // Return null if no function definition is found.\n    return foundFunction ? result : null;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -9,9 +9,11 @@\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n             return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n-        // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n+            // Only properties on non-constant names can be side-effected.\n+            return !NodeUtil.isConstantName(n.getFirstChild());\n         case Token.GETELEM:\n+            // Elements on GETELEM can be side-effected.\n             return true;\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -7,13 +7,14 @@\n     if (decls == null) {\n         return null;\n     }\n+    boolean foundFunction = false;\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n         if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+            foundFunction = true;\n             result.add(current);\n-        } else {\n-            return null;\n         }\n     }\n-    return result;\n+    // Return null if no function definition is found.\n+    return foundFunction ? result : null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // function calls or constructor invocations can reference changed values.\n            // check if they are pure functions, i.e. do not have any side-effects.\n            if (NodeUtil.isImmutableValue(n.getFirstChild())) {\n              return false;\n            }\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {\n        Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n        if (decls != null) {\n            for (Definition current : decls) {\n                Node rValue = current.getRValue();\n                if (rValue != null && NodeUtil.isFunctionExpression(rValue)) {\n                    if (!rValue.getBooleanProp(Node.FUNCTION_PROPERTY_NOSIDEEFFECTS)) {\n                        // function has side effects\n                        return null;\n                    }\n                    result.add(current);\n                } else {\n                    // definition is not for a function expression\n                    return null;\n                }\n            }\n            return result;\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -2,9 +2,11 @@\n     switch(n.getType()) {\n         case Token.CALL:\n         case Token.NEW:\n-            // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // function calls or constructor invocations can reference changed values.\n+            // check if they are pure functions, i.e. do not have any side-effects.\n+            if (NodeUtil.isImmutableValue(n.getFirstChild())) {\n+              return false;\n+            }\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -1,19 +1,23 @@\n private static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n     List<Definition> result = Lists.newArrayList();\n-    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n-        return null;\n-    }\n-    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n-    if (decls == null) {\n-        return null;\n-    }\n-    for (Definition current : decls) {\n-        Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n-            result.add(current);\n-        } else {\n-            return null;\n+    if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {\n+        Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n+        if (decls != null) {\n+            for (Definition current : decls) {\n+                Node rValue = current.getRValue();\n+                if (rValue != null && NodeUtil.isFunctionExpression(rValue)) {\n+                    if (!rValue.getBooleanProp(Node.FUNCTION_PROPERTY_NOSIDEEFFECTS)) {\n+                        // function has side effects\n+                        return null;\n+                    }\n+                    result.add(current);\n+                } else {\n+                    // definition is not for a function expression\n+                    return null;\n+                }\n+            }\n+            return result;\n         }\n     }\n-    return result;\n+    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // assume all function calls or constructors can have side effects\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static List<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return result;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return result;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n            result.add(current);\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -2,9 +2,7 @@\n     switch(n.getType()) {\n         case Token.CALL:\n         case Token.NEW:\n-            // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // assume all function calls or constructors can have side effects\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n        default:\n            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n                if (canBeSideEffected(c, knownConstants)) {\n                    return true;\n                }\n            }\n            return false;\n    }\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!(NodeUtil.isGetProp(name) || NodeUtil.isName(name))) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n            result.add(current);\n        } else {\n            return null;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -13,11 +13,12 @@\n         case Token.GETPROP:\n         case Token.GETELEM:\n             return true;\n+        default:\n+            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+                if (canBeSideEffected(c, knownConstants)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n     }\n-    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-        if (canBeSideEffected(c, knownConstants)) {\n-            return true;\n-        }\n-    }\n-    return false;\n }\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -1,6 +1,6 @@\n private static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n     List<Definition> result = Lists.newArrayList();\n-    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n+    if (!(NodeUtil.isGetProp(name) || NodeUtil.isName(name))) {\n         return null;\n     }\n     Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n@@ -9,7 +9,7 @@\n     }\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n             result.add(current);\n         } else {\n             return null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n        default:\n            break;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    boolean allFunctions = true; // check if all declarations refer to functions\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && !NodeUtil.isFunction(rValue)) {\n            allFunctions = false;\n            break;\n        } else {\n            result.add(current);\n        }\n    }\n    if (!allFunctions) {\n        return null;\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -13,6 +13,8 @@\n         case Token.GETPROP:\n         case Token.GETELEM:\n             return true;\n+        default:\n+            break;\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -7,13 +7,18 @@\n     if (decls == null) {\n         return null;\n     }\n+    boolean allFunctions = true; // check if all declarations refer to functions\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+        if ((rValue != null) && !NodeUtil.isFunction(rValue)) {\n+            allFunctions = false;\n+            break;\n+        } else {\n             result.add(current);\n-        } else {\n-            return null;\n         }\n+    }\n+    if (!allFunctions) {\n+        return null;\n     }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // For now, assume all function calls or constructors have side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return result;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return result;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n            result.add(current);\n        } else {\n            result.clear();\n            break;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -3,8 +3,7 @@\n         case Token.CALL:\n         case Token.NEW:\n             // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // For now, assume all function calls or constructors have side effects.\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -1,18 +1,19 @@\n private static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n     List<Definition> result = Lists.newArrayList();\n     if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n-        return null;\n+        return result;\n     }\n     Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n     if (decls == null) {\n-        return null;\n+        return result;\n     }\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n         if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n             result.add(current);\n         } else {\n-            return null;\n+            result.clear();\n+            break;\n         }\n     }\n     return result;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n        default:\n            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n                if (canBeSideEffected(c, knownConstants)) {\n                    return true;\n                }\n            }\n            return false;\n    }\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return result;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return result;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n            result.add(current);\n        } else {\n            return result;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -13,11 +13,12 @@\n         case Token.GETPROP:\n         case Token.GETELEM:\n             return true;\n+        default:\n+            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+                if (canBeSideEffected(c, knownConstants)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n     }\n-    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-        if (canBeSideEffected(c, knownConstants)) {\n-            return true;\n-        }\n-    }\n-    return false;\n }\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -1,18 +1,18 @@\n private static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n     List<Definition> result = Lists.newArrayList();\n     if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n-        return null;\n+        return result;\n     }\n     Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n     if (decls == null) {\n-        return null;\n+        return result;\n     }\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n         if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n             result.add(current);\n         } else {\n-            return null;\n+            return result;\n         }\n     }\n     return result;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n            if (NodeUtil.isGetProp(n)) {\n                Node parent = n.getFirstChild();\n                if (parent != null && parent.isQualifiedName() && !parent.getLastChild().getString().equals(\"prototype\")) {\n                    return true;\n                }\n            }\n            return false;\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static List<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return result;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return result;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n            result.add(current);\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -3,14 +3,19 @@\n         case Token.CALL:\n         case Token.NEW:\n             // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n             return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n+            if (NodeUtil.isGetProp(n)) {\n+                Node parent = n.getFirstChild();\n+                if (parent != null && parent.isQualifiedName() && !parent.getLastChild().getString().equals(\"prototype\")) {\n+                    return true;\n+                }\n+            }\n+            return false;\n         case Token.GETELEM:\n             return true;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n        default:\n            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n                if (canBeSideEffected(c, knownConstants)) {\n                    return true;\n                }\n            }\n            return false;\n    }\n}\n\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return result;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return result;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n            result.add(current);\n        } else {\n            return result;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -13,11 +13,12 @@\n         case Token.GETPROP:\n         case Token.GETELEM:\n             return true;\n+        default:\n+            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+                if (canBeSideEffected(c, knownConstants)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n     }\n-    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-        if (canBeSideEffected(c, knownConstants)) {\n-            return true;\n-        }\n-    }\n-    return false;\n }\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -1,18 +1,18 @@\n private static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n     List<Definition> result = Lists.newArrayList();\n     if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n-        return null;\n+        return result;\n     }\n     Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n     if (decls == null) {\n-        return null;\n+        return result;\n     }\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue)) {\n             result.add(current);\n         } else {\n-            return null;\n+            return result;\n         }\n     }\n     return result;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructors can reference changed values.\n            // If function or constructor is annotated with @nosideeffects JSDoc,\n            // we can say for sure that there are no side effects.\n            JSDocInfo info = n.getJSDocInfo();\n            if (info != null && info.hasNoSideEffectsAnnotation()) {\n                return false;\n            }\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue) && !NodeUtil.isArrowFunction(rValue)) {\n            result.add(current);\n        } else if ((rValue != null) && NodeUtil.isFunctionDeclaration(rValue)) {\n            result.add(current);\n        } else {\n            return null;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -2,9 +2,13 @@\n     switch(n.getType()) {\n         case Token.CALL:\n         case Token.NEW:\n-            // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // Function calls or constructors can reference changed values.\n+            // If function or constructor is annotated with @nosideeffects JSDoc,\n+            // we can say for sure that there are no side effects.\n+            JSDocInfo info = n.getJSDocInfo();\n+            if (info != null && info.hasNoSideEffectsAnnotation()) {\n+                return false;\n+            }\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -9,7 +9,9 @@\n     }\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+        if ((rValue != null) && NodeUtil.isFunctionExpression(rValue) && !NodeUtil.isArrowFunction(rValue)) {\n+            result.add(current);\n+        } else if ((rValue != null) && NodeUtil.isFunctionDeclaration(rValue)) {\n             result.add(current);\n         } else {\n             return null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n        case Token.DELPROP: // added case for deleting properties\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n## Fixed Function 2\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\n    List<Definition> result = Lists.newArrayList();\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n        return null;\n    }\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\n    if (decls == null) {\n        return null;\n    }\n    for (Definition current : decls) {\n        Node rValue = current.getRValue();\n        if ((rValue != null) && (NodeUtil.isFunctionExpression(rValue) || NodeUtil.isFunctionDeclaration(rValue))) { // updated with NodeUtil method calls\n            result.add(current);\n        } else {\n            return null;\n        }\n    }\n    return result;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -2,6 +2,7 @@\n     switch(n.getType()) {\n         case Token.CALL:\n         case Token.NEW:\n+        case Token.DELPROP: // added case for deleting properties\n             // Function calls or constructor can reference changed values.\n             // TODO(johnlenz): Add some mechanism for determining that functions\n             // are unaffected by side effects.\n--- com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n+++ com/google/javascript/jscomp/PureFunctionIdentifier.java@getCallableDefinitions\n@@ -9,7 +9,7 @@\n     }\n     for (Definition current : decls) {\n         Node rValue = current.getRValue();\n-        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+        if ((rValue != null) && (NodeUtil.isFunctionExpression(rValue) || NodeUtil.isFunctionDeclaration(rValue))) { // updated with NodeUtil method calls\n             result.add(current);\n         } else {\n             return null;\n", "finish_reason": "stop", "valid": false, "num": 1}]