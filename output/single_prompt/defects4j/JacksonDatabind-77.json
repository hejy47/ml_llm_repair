[{"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    // not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,29 +6,37 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n-        return buildThrowableDeserializer(ctxt, type, beanDesc);\n-    }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n-    //    not something we could materialize anything for\n     if (type.isAbstract() && !type.isPrimitive()) {\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n+            beanDesc = config.introspect(concreteType);\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n         }\n     }\n-    // Otherwise, may want to check handlers for standard types, from superclass:\n+    if (type.isThrowable()) {\n+        return buildThrowableDeserializer(ctxt, type, beanDesc);\n+    }\n     @SuppressWarnings(\"unchecked\")\n     JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n     if (deser != null) {\n         return deser;\n     }\n-    // Otherwise: could the class be a Bean class? If not, bail out\n     if (!isPotentialBeanType(type.getRawClass())) {\n         return null;\n     }\n+\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // not something we could materialize anything for\n+    if (type.isAbstract() && !type.isPrimitive()) {\n+        // Let's make it possible to materialize abstract types.\n+        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n+        if (concreteType != null) {\n+            beanDesc = config.introspect(concreteType);\n+            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n+        }\n+    }\n+\n     // For checks like [databind#1599]\n     // Use generic bean introspection to build deserializer\n     return buildBeanDeserializer(ctxt, type, beanDesc);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    // not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make sure we are not dealing with JDK proxies that do not support introspection.\n        if (type.getSuperClass() == null || Object.class.equals(type.getSuperClass().getRawClass())) {\n            return null;\n        }\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,16 +6,20 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n+    if (type.isThrowable()) {\n         return buildThrowableDeserializer(ctxt, type, beanDesc);\n     }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n-    //    not something we could materialize anything for\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // not something we could materialize anything for\n     if (type.isAbstract() && !type.isPrimitive()) {\n+        // Let's make sure we are not dealing with JDK proxies that do not support introspection.\n+        if (type.getSuperClass() == null || Object.class.equals(type.getSuperClass().getRawClass())) {\n+            return null;\n+        }\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n+            beanDesc = config.introspect(concreteType);\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            BeanDescription concreteBeanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, concreteBeanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,17 +6,17 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n+    if (type.isThrowable()) {\n         return buildThrowableDeserializer(ctxt, type, beanDesc);\n     }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n     //    not something we could materialize anything for\n     if (type.isAbstract() && !type.isPrimitive()) {\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n-            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n+            BeanDescription concreteBeanDesc = config.introspect(concreteType);\n+            return buildBeanDeserializer(ctxt, concreteType, concreteBeanDesc);\n         }\n     }\n     // Otherwise, may want to check handlers for standard types, from superclass:\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            // Use introspected concrete type instead of original abstract type\n            beanDesc = ctxt.introspect(concreteType);\n            return ctxt.findRootValueDeserializer(concreteType);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    JsonDeserializer<Object> deser = ctxt.findRootValueDeserializer(type);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,22 +6,22 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n+    if (type.isThrowable()) {\n         return buildThrowableDeserializer(ctxt, type, beanDesc);\n     }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n     //    not something we could materialize anything for\n     if (type.isAbstract() && !type.isPrimitive()) {\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n-            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n+            // Use introspected concrete type instead of original abstract type\n+            beanDesc = ctxt.introspect(concreteType);\n+            return ctxt.findRootValueDeserializer(concreteType);\n         }\n     }\n     // Otherwise, may want to check handlers for standard types, from superclass:\n-    @SuppressWarnings(\"unchecked\")\n-    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n+    JsonDeserializer<Object> deser = ctxt.findRootValueDeserializer(type);\n     if (deser != null) {\n         return deser;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (type.isJavaLangObject()) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,16 +6,16 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n+    if (type.isThrowable()) {\n         return buildThrowableDeserializer(ctxt, type, beanDesc);\n     }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n     //    not something we could materialize anything for\n     if (type.isAbstract() && !type.isPrimitive()) {\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n+            beanDesc = config.introspect(concreteType);\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n         }\n     }\n@@ -26,7 +26,7 @@\n         return deser;\n     }\n     // Otherwise: could the class be a Bean class? If not, bail out\n-    if (!isPotentialBeanType(type.getRawClass())) {\n+    if (type.isJavaLangObject()) {\n         return null;\n     }\n     // For checks like [databind#1599]\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,16 +6,16 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n+    if (type.isThrowable()) {\n         return buildThrowableDeserializer(ctxt, type, beanDesc);\n     }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n     //    not something we could materialize anything for\n-    if (type.isAbstract() && !type.isPrimitive()) {\n+    if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n+            beanDesc = config.introspect(concreteType);\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    // Fixed: Also include void type\n    if (type.isAbstract() && !type.isPrimitive() && !type.isVoid()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,16 +6,17 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n+    if (type.isThrowable()) {\n         return buildThrowableDeserializer(ctxt, type, beanDesc);\n     }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n     //    not something we could materialize anything for\n-    if (type.isAbstract() && !type.isPrimitive()) {\n+    // Fixed: Also include void type\n+    if (type.isAbstract() && !type.isPrimitive() && !type.isVoid()) {\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n+            beanDesc = config.introspect(concreteType);\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n        if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n                        beanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        } else {\n                        return null;  // fixed here; return null if concrete type cannot be found\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -17,6 +17,8 @@\n         if (concreteType != null) {\n                         beanDesc = config.introspect(concreteType);\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n+        } else {\n+                        return null;  // fixed here; return null if concrete type cannot be found\n         }\n     }\n     // Otherwise, may want to check handlers for standard types, from superclass:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    JsonDeserializer<Object> deser = findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,22 +6,21 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n+    if (type.isThrowable()) {\n         return buildThrowableDeserializer(ctxt, type, beanDesc);\n     }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n     //    not something we could materialize anything for\n     if (type.isAbstract() && !type.isPrimitive()) {\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n+            beanDesc = config.introspect(concreteType);\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n         }\n     }\n     // Otherwise, may want to check handlers for standard types, from superclass:\n-    @SuppressWarnings(\"unchecked\")\n-    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n+    JsonDeserializer<Object> deser = findStdDeserializer(ctxt, type, beanDesc);\n     if (deser != null) {\n         return deser;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        } else {\n            // If we can't materialize the abstract type, return null\n            return null;\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,17 +6,20 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n+    if (type.isThrowable()) {\n         return buildThrowableDeserializer(ctxt, type, beanDesc);\n     }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n     //    not something we could materialize anything for\n     if (type.isAbstract() && !type.isPrimitive()) {\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n+            beanDesc = config.introspect(concreteType);\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n+        } else {\n+            // If we can't materialize the abstract type, return null\n+            return null;\n         }\n     }\n     // Otherwise, may want to check handlers for standard types, from superclass:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) { //fix for ignoring abstract enum types\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,16 +6,16 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n+    if (type.isThrowable()) {\n         return buildThrowableDeserializer(ctxt, type, beanDesc);\n     }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n     //    not something we could materialize anything for\n-    if (type.isAbstract() && !type.isPrimitive()) {\n+    if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) { //fix for ignoring abstract enum types\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n+            beanDesc = config.introspect(concreteType);\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n        if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = ctxt.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return new BeanDeserializer(this, type, ctxt.introspectBeanDescription(type), ctxt.getConfig().getBeanPropertyBinding(JavaTypeResolver.constructAny(), null));\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -15,7 +15,7 @@\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n+            beanDesc = ctxt.introspect(concreteType);\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n         }\n     }\n@@ -31,5 +31,5 @@\n     }\n     // For checks like [databind#1599]\n     // Use generic bean introspection to build deserializer\n-    return buildBeanDeserializer(ctxt, type, beanDesc);\n+    return new BeanDeserializer(this, type, ctxt.introspectBeanDescription(type), ctxt.getConfig().getBeanPropertyBinding(JavaTypeResolver.constructAny(), null));\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nOverride\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    // not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            BeanDescription concreteBeanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, concreteBeanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n        if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            // FIXED: Recursively call createBeanDeserializer with concreteType\n            return createBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -15,8 +15,9 @@\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n-            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n+            beanDesc = config.introspect(concreteType);\n+            // FIXED: Recursively call createBeanDeserializer with concreteType\n+            return createBeanDeserializer(ctxt, concreteType, beanDesc);\n         }\n     }\n     // Otherwise, may want to check handlers for standard types, from superclass:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    // not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        throw new JsonMappingException(\"Cannot deserialize into a Bean class: \" + type);\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,16 +6,16 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n+    if (type.isThrowable()) {\n         return buildThrowableDeserializer(ctxt, type, beanDesc);\n     }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n-    //    not something we could materialize anything for\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // not something we could materialize anything for\n     if (type.isAbstract() && !type.isPrimitive()) {\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n+            beanDesc = config.introspect(concreteType);\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n         }\n     }\n@@ -27,7 +27,7 @@\n     }\n     // Otherwise: could the class be a Bean class? If not, bail out\n     if (!isPotentialBeanType(type.getRawClass())) {\n-        return null;\n+        throw new JsonMappingException(\"Cannot deserialize into a Bean class: \" + type);\n     }\n     // For checks like [databind#1599]\n     // Use generic bean introspection to build deserializer\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n        if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            beanDesc = config.introspect(concreteType);\n            if (beanDesc == null) {\n                throw new JsonMappingException(\"Cannot construct BeanDescription for type \" + concreteType);\n            }\n            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -15,7 +15,10 @@\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n+            beanDesc = config.introspect(concreteType);\n+            if (beanDesc == null) {\n+                throw new JsonMappingException(\"Cannot construct BeanDescription for type \" + concreteType);\n+            }\n             return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // We may also have custom overrides:\n    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n    if (custom != null) {\n        return custom;\n    }\n    if (type.isThrowable()) {\n        return buildThrowableDeserializer(ctxt, type, beanDesc);\n    }\n    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n    //    not something we could materialize anything for\n    if (type.isAbstract() && !type.isPrimitive()) {\n        // Let's make it possible to materialize abstract types.\n        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n        if (concreteType != null) {\n            BeanDescription concreteDesc = config.introspect(concreteType);\n            return buildBeanDeserializer(ctxt, concreteType, concreteDesc);\n        }\n    }\n    // Otherwise, may want to check handlers for standard types, from superclass:\n    @SuppressWarnings(\"unchecked\")\n    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n    if (deser != null) {\n        return deser;\n    }\n    // Otherwise: could the class be a Bean class? If not, bail out\n    if (!isPotentialBeanType(type.getRawClass())) {\n        return null;\n    }\n    // For checks like [databind#1599]\n    // Use generic bean introspection to build deserializer\n    return buildBeanDeserializer(ctxt, type, beanDesc);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@createBeanDeserializer\n@@ -6,17 +6,17 @@\n     if (custom != null) {\n         return custom;\n     }\n-        if (type.isThrowable()) {\n+    if (type.isThrowable()) {\n         return buildThrowableDeserializer(ctxt, type, beanDesc);\n     }\n-        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n+    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n     //    not something we could materialize anything for\n     if (type.isAbstract() && !type.isPrimitive()) {\n         // Let's make it possible to materialize abstract types.\n         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n         if (concreteType != null) {\n-                        beanDesc = config.introspect(concreteType);\n-            return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n+            BeanDescription concreteDesc = config.introspect(concreteType);\n+            return buildBeanDeserializer(ctxt, concreteType, concreteDesc);\n         }\n     }\n     // Otherwise, may want to check handlers for standard types, from superclass:\n", "finish_reason": "stop", "valid": false, "num": 2}]