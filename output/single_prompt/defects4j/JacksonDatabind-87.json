[{"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = new SimpleDateFormat(DATE_FORMAT_PLAIN, Locale.US);\n            df.setTimeZone(_timezone);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            // must use UTC, not whatever is configured as default timezone\n            // (because we know `Z` identifier is used)\n            df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, Locale.US);\n            df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch (timeLen) {\n                case 11:\n                    sb.insert(offset, '0');\n                    break;\n                case 10:\n                    sb.insert(offset, \"00\");\n                    break;\n                case // is this legal? (just second fraction marker)\n                9:\n                    sb.insert(offset, \"000\");\n                    break;\n                case 8:\n                    sb.insert(offset, \".000\");\n                    break;\n                case // not legal to have single-digit second\n                7:\n                    break;\n                case // probably not legal, but let's allow\n                6:\n                    sb.insert(offset, \"00.000\");\n                case // is legal to omit seconds\n                5:\n                    sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = new SimpleDateFormat(DATE_FORMAT_ISO8601, Locale.US);\n                df.setTimeZone(_timezone);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch (timeLen) {\n                case 11:\n                    sb.append('0');\n                case 10:\n                    sb.append('0');\n                case 9:\n                    sb.append('0');\n                    break;\n                default:\n                    sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                // must use UTC, not whatever is configured as default timezone\n                // (because we know `Z` identifier is used)\n                df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, Locale.US);\n                df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(\n                String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n                        dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(format, loc);\n    } else {\n        df = (DateFormat) df.clone();\n    }\n    df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -8,16 +8,18 @@\n         df = _formatPlain;\n         formatStr = DATE_FORMAT_STR_PLAIN;\n         if (df == null) {\n-            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n+            df = _formatPlain = new SimpleDateFormat(DATE_FORMAT_PLAIN, Locale.US);\n+            df.setTimeZone(_timezone);\n         }\n     } else if (c == 'Z') {\n         df = _formatISO8601_z;\n         formatStr = DATE_FORMAT_STR_ISO8601_Z;\n         if (df == null) {\n             // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-            //    must use UTC, not whatever is configured as default timezone\n-            //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+            // must use UTC, not whatever is configured as default timezone\n+            // (because we know `Z` identifier is used)\n+            df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, Locale.US);\n+            df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n         }\n         // may be missing milliseconds... if so, add\n         if (dateStr.charAt(len - 4) == ':') {\n@@ -49,36 +51,37 @@\n                 // insertion offset, before tz-offset\n                 int offset = len - 5;\n                 StringBuilder sb = new StringBuilder(dateStr);\n-                switch(timeLen) {\n-                    case 11:\n-                        sb.insert(offset, '0');\n-                        break;\n-                    case 10:\n-                        sb.insert(offset, \"00\");\n-                        break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n-                        sb.insert(offset, \"000\");\n-                        break;\n-                    case 8:\n-                        sb.insert(offset, \".000\");\n-                        break;\n-                    case // not legal to have single-digit second\n-                    7:\n-                        break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n+                switch (timeLen) {\n+                case 11:\n+                    sb.insert(offset, '0');\n+                    break;\n+                case 10:\n+                    sb.insert(offset, \"00\");\n+                    break;\n+                case // is this legal? (just second fraction marker)\n+                9:\n+                    sb.insert(offset, \"000\");\n+                    break;\n+                case 8:\n+                    sb.insert(offset, \".000\");\n+                    break;\n+                case // not legal to have single-digit second\n+                7:\n+                    break;\n+                case // probably not legal, but let's allow\n+                6:\n+                    sb.insert(offset, \"00.000\");\n+                case // is legal to omit seconds\n+                5:\n+                    sb.insert(offset, \":00.000\");\n                 }\n                 dateStr = sb.toString();\n             }\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n             if (_formatISO8601 == null) {\n-                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n+                df = _formatISO8601 = new SimpleDateFormat(DATE_FORMAT_ISO8601, Locale.US);\n+                df.setTimeZone(_timezone);\n             }\n         } else {\n             // If not, plain date, no timezone\n@@ -87,16 +90,16 @@\n             // And possible also millisecond part if missing\n             if (timeLen < 12) {\n                 // missing, or partial\n-                switch(timeLen) {\n-                    case 11:\n-                        sb.append('0');\n-                    case 10:\n-                        sb.append('0');\n-                    case 9:\n-                        sb.append('0');\n-                        break;\n-                    default:\n-                        sb.append(\".000\");\n+                switch (timeLen) {\n+                case 11:\n+                    sb.append('0');\n+                case 10:\n+                    sb.append('0');\n+                case 9:\n+                    sb.append('0');\n+                    break;\n+                default:\n+                    sb.append(\".000\");\n                 }\n             }\n             sb.append('Z');\n@@ -105,16 +108,19 @@\n             formatStr = DATE_FORMAT_STR_ISO8601_Z;\n             if (df == null) {\n                 // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-                //    must use UTC, not whatever is configured as default timezone\n-                //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+                // must use UTC, not whatever is configured as default timezone\n+                // (because we know `Z` identifier is used)\n+                df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, Locale.US);\n+                df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n             }\n         }\n     }\n     Date dt = df.parse(dateStr, pos);\n     // 22-Dec-2015, tatu: With non-lenient, may get null\n     if (dt == null) {\n-        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n+        throw new ParseException(\n+                String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n+                        dateStr, formatStr, _lenient), pos.getErrorIndex());\n     }\n     return dt;\n }\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,13 +1,10 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n     if (!loc.equals(DEFAULT_LOCALE)) {\n         df = new SimpleDateFormat(format, loc);\n-        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n     } else {\n         df = (DateFormat) df.clone();\n-        if (tz != null) {\n-            df.setTimeZone(tz);\n-        }\n     }\n+    df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n     if (lenient != null) {\n         df.setLenient(lenient.booleanValue());\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(format, loc);\n        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n} \n\nThe fix for the first function involves changing the timezone used for ISO8601 format from the system timezone to UTC timezone. In the second function, the fix is minor where `TimeZone.getTimeZone(\"UTC\")` is changed to `DEFAULT_TIMEZONE` to match the variable earlier defined in the class.", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -17,7 +17,7 @@\n             // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n             //    must use UTC, not whatever is configured as default timezone\n             //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n         if (dateStr.charAt(len - 4) == ':') {\n@@ -107,7 +107,7 @@\n                 // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                 //    must use UTC, not whatever is configured as default timezone\n                 //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (len >= 19 && dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static ThreadLocal<Map<String, DateFormat>> _localDateFormat = new ThreadLocal<Map<String, DateFormat>>() {\n        @Override\n        protected Map<String, DateFormat> initialValue() {\n            return new HashMap<String, DateFormat>();\n        }\n};\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    Map<String, DateFormat> formatsMap = _localDateFormat.get();\n    DateFormat dfClone = formatsMap.get(format);\n    if (dfClone == null) {\n        if (loc.equals(DEFAULT_LOCALE)) {\n            dfClone = (DateFormat) df.clone();\n        } else {\n            dfClone = new SimpleDateFormat(format, loc);\n            dfClone.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        }\n        formatsMap.put(format, dfClone);\n    }\n    if (tz != null) {\n        dfClone.setTimeZone(tz);\n    }\n    if (lenient != null) {\n        dfClone.setLenient(lenient.booleanValue());\n    }\n    return dfClone;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -20,7 +20,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 19 && dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,15 +1,20 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n-    if (!loc.equals(DEFAULT_LOCALE)) {\n-        df = new SimpleDateFormat(format, loc);\n-        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n-    } else {\n-        df = (DateFormat) df.clone();\n-        if (tz != null) {\n-            df.setTimeZone(tz);\n+    Map<String, DateFormat> formatsMap = _localDateFormat.get();\n+    DateFormat dfClone = formatsMap.get(format);\n+    if (dfClone == null) {\n+        if (loc.equals(DEFAULT_LOCALE)) {\n+            dfClone = (DateFormat) df.clone();\n+        } else {\n+            dfClone = new SimpleDateFormat(format, loc);\n+            dfClone.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n         }\n+        formatsMap.put(format, dfClone);\n+    }\n+    if (tz != null) {\n+        dfClone.setTimeZone(tz);\n     }\n     if (lenient != null) {\n-        df.setLenient(lenient.booleanValue());\n+        dfClone.setLenient(lenient.booleanValue());\n     }\n-    return df;\n+    return dfClone;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE) || tz != null) {\n        df = new SimpleDateFormat(format, loc);\n        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n    } else {\n        df = (DateFormat) df.clone();\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -17,10 +17,10 @@\n             // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n             //    must use UTC, not whatever is configured as default timezone\n             //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 24 && dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n@@ -107,7 +107,7 @@\n                 // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                 //    must use UTC, not whatever is configured as default timezone\n                 //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,12 +1,9 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n-    if (!loc.equals(DEFAULT_LOCALE)) {\n+    if (!loc.equals(DEFAULT_LOCALE) || tz != null) {\n         df = new SimpleDateFormat(format, loc);\n         df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n     } else {\n         df = (DateFormat) df.clone();\n-        if (tz != null) {\n-            df.setTimeZone(tz);\n-        }\n     }\n     if (lenient != null) {\n         df.setLenient(lenient.booleanValue());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            char checkChar = dateStr.charAt(len - 3);\n            if(checkChar == ':' || checkChar == '+' || checkChar == '-') {\n                // remove optional colon\n                if(checkChar == ':') {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len - 3, len - 2);\n                    dateStr = sb.toString();\n                }\n                // missing minutes\n                else if(checkChar == '+' || checkChar == '-') {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.insert(len - 2, \"00\");\n                    dateStr = sb.toString();\n                }\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(format, loc);\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -28,17 +28,20 @@\n     } else {\n         // Let's see if we have timezone indicator or not...\n         if (hasTimeZone(dateStr)) {\n-            c = dateStr.charAt(len - 3);\n-            if (c == ':') {\n+            char checkChar = dateStr.charAt(len - 3);\n+            if(checkChar == ':' || checkChar == '+' || checkChar == '-') {\n                 // remove optional colon\n-                // remove colon\n-                StringBuilder sb = new StringBuilder(dateStr);\n-                sb.delete(len - 3, len - 2);\n-                dateStr = sb.toString();\n-            } else if (c == '+' || c == '-') {\n+                if(checkChar == ':') {\n+                    StringBuilder sb = new StringBuilder(dateStr);\n+                    sb.delete(len - 3, len - 2);\n+                    dateStr = sb.toString();\n+                }\n                 // missing minutes\n-                // let's just append '00'\n-                dateStr += \"00\";\n+                else if(checkChar == '+' || checkChar == '-') {\n+                    StringBuilder sb = new StringBuilder(dateStr);\n+                    sb.insert(len - 2, \"00\");\n+                    dateStr = sb.toString();\n+                }\n             }\n             // Milliseconds partial or missing; and even seconds are optional\n             len = dateStr.length();\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,7 +1,9 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n     if (!loc.equals(DEFAULT_LOCALE)) {\n         df = new SimpleDateFormat(format, loc);\n-        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n+        if (tz != null) {\n+            df.setTimeZone(tz);\n+        }\n     } else {\n         df = (DateFormat) df.clone();\n         if (tz != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = new SimpleDateFormat(DATE_FORMAT_PLAIN, DEFAULT_LOCALE);\n            df.setTimeZone(DEFAULT_TIMEZONE);\n            df.setLenient(false);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, DEFAULT_LOCALE);\n            df.setTimeZone(DEFAULT_TIMEZONE);\n            df.setLenient(false);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = new SimpleDateFormat(DATE_FORMAT_ISO8601, DEFAULT_LOCALE);\n                df.setTimeZone(DEFAULT_TIMEZONE);\n                df.setLenient(false);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, DEFAULT_LOCALE);\n                df.setTimeZone(DEFAULT_TIMEZONE);\n                df.setLenient(false);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, false), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(format, loc);\n    } else {\n        df = (DateFormat) df.clone();\n    }\n    if (tz != null) {\n        df.setTimeZone(tz);\n    } else {\n        df.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    } else {\n        df.setLenient(false);\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -8,16 +8,17 @@\n         df = _formatPlain;\n         formatStr = DATE_FORMAT_STR_PLAIN;\n         if (df == null) {\n-            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n+            df = _formatPlain = new SimpleDateFormat(DATE_FORMAT_PLAIN, DEFAULT_LOCALE);\n+            df.setTimeZone(DEFAULT_TIMEZONE);\n+            df.setLenient(false);\n         }\n     } else if (c == 'Z') {\n         df = _formatISO8601_z;\n         formatStr = DATE_FORMAT_STR_ISO8601_Z;\n         if (df == null) {\n-            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-            //    must use UTC, not whatever is configured as default timezone\n-            //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+            df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, DEFAULT_LOCALE);\n+            df.setTimeZone(DEFAULT_TIMEZONE);\n+            df.setLenient(false);\n         }\n         // may be missing milliseconds... if so, add\n         if (dateStr.charAt(len - 4) == ':') {\n@@ -78,7 +79,9 @@\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n             if (_formatISO8601 == null) {\n-                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n+                df = _formatISO8601 = new SimpleDateFormat(DATE_FORMAT_ISO8601, DEFAULT_LOCALE);\n+                df.setTimeZone(DEFAULT_TIMEZONE);\n+                df.setLenient(false);\n             }\n         } else {\n             // If not, plain date, no timezone\n@@ -104,17 +107,16 @@\n             df = _formatISO8601_z;\n             formatStr = DATE_FORMAT_STR_ISO8601_Z;\n             if (df == null) {\n-                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-                //    must use UTC, not whatever is configured as default timezone\n-                //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+                df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, DEFAULT_LOCALE);\n+                df.setTimeZone(DEFAULT_TIMEZONE);\n+                df.setLenient(false);\n             }\n         }\n     }\n     Date dt = df.parse(dateStr, pos);\n     // 22-Dec-2015, tatu: With non-lenient, may get null\n     if (dt == null) {\n-        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n+        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, false), pos.getErrorIndex());\n     }\n     return dt;\n }\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,15 +1,18 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n     if (!loc.equals(DEFAULT_LOCALE)) {\n         df = new SimpleDateFormat(format, loc);\n-        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n     } else {\n         df = (DateFormat) df.clone();\n-        if (tz != null) {\n-            df.setTimeZone(tz);\n-        }\n+    }\n+    if (tz != null) {\n+        df.setTimeZone(tz);\n+    } else {\n+        df.setTimeZone(DEFAULT_TIMEZONE);\n     }\n     if (lenient != null) {\n         df.setLenient(lenient.booleanValue());\n+    } else {\n+        df.setLenient(false);\n     }\n     return df;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = new SimpleDateFormat(formatStr, _locale);\n            df.setTimeZone(_timezone);\n            df.setLenient(_lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = new SimpleDateFormat(formatStr, _locale);\n            df.setTimeZone(DEFAULT_TIMEZONE);\n            df.setLenient(_lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = new SimpleDateFormat(formatStr, _locale);\n                df.setTimeZone(_timezone);\n                df.setLenient(_lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = new SimpleDateFormat(formatStr, _locale);\n                df.setTimeZone(DEFAULT_TIMEZONE);\n                df.setLenient(_lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(format, loc);\n        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        df.setLenient((lenient == null) ? true : lenient);\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n        if (lenient != null) {\n            df.setLenient(lenient.booleanValue());\n        }\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -8,7 +8,9 @@\n         df = _formatPlain;\n         formatStr = DATE_FORMAT_STR_PLAIN;\n         if (df == null) {\n-            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n+            df = _formatPlain = new SimpleDateFormat(formatStr, _locale);\n+            df.setTimeZone(_timezone);\n+            df.setLenient(_lenient);\n         }\n     } else if (c == 'Z') {\n         df = _formatISO8601_z;\n@@ -17,7 +19,9 @@\n             // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n             //    must use UTC, not whatever is configured as default timezone\n             //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+            df = _formatISO8601_z = new SimpleDateFormat(formatStr, _locale);\n+            df.setTimeZone(DEFAULT_TIMEZONE);\n+            df.setLenient(_lenient);\n         }\n         // may be missing milliseconds... if so, add\n         if (dateStr.charAt(len - 4) == ':') {\n@@ -78,7 +82,9 @@\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n             if (_formatISO8601 == null) {\n-                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n+                df = _formatISO8601 = new SimpleDateFormat(formatStr, _locale);\n+                df.setTimeZone(_timezone);\n+                df.setLenient(_lenient);\n             }\n         } else {\n             // If not, plain date, no timezone\n@@ -107,7 +113,9 @@\n                 // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                 //    must use UTC, not whatever is configured as default timezone\n                 //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+                df = _formatISO8601_z = new SimpleDateFormat(formatStr, _locale);\n+                df.setTimeZone(DEFAULT_TIMEZONE);\n+                df.setLenient(_lenient);\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -2,14 +2,15 @@\n     if (!loc.equals(DEFAULT_LOCALE)) {\n         df = new SimpleDateFormat(format, loc);\n         df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n+        df.setLenient((lenient == null) ? true : lenient);\n     } else {\n         df = (DateFormat) df.clone();\n         if (tz != null) {\n             df.setTimeZone(tz);\n         }\n-    }\n-    if (lenient != null) {\n-        df.setLenient(lenient.booleanValue());\n+        if (lenient != null) {\n+            df.setLenient(lenient.booleanValue());\n+        }\n     }\n     return df;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 4) == ':') { \n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (df instanceof SimpleDateFormat && !loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(format, loc);\n        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -20,7 +20,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 24 && dateStr.charAt(len - 4) == ':') { \n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,5 +1,5 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n-    if (!loc.equals(DEFAULT_LOCALE)) {\n+    if (df instanceof SimpleDateFormat && !loc.equals(DEFAULT_LOCALE)) {\n         df = new SimpleDateFormat(format, loc);\n         df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 4) == ':') {  // fixed this condition\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(format, loc);\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        df.setTimeZone(tz);  // fixed the argument order\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -20,7 +20,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 24 && dateStr.charAt(len - 4) == ':') {  // fixed this condition\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,7 +1,10 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n     if (!loc.equals(DEFAULT_LOCALE)) {\n         df = new SimpleDateFormat(format, loc);\n-        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n+        if (tz == null) {\n+            tz = DEFAULT_TIMEZONE;\n+        }\n+        df.setTimeZone(tz);  // fixed the argument order\n     } else {\n         df = (DateFormat) df.clone();\n         if (tz != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_PLAIN, Locale.US), _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, Locale.US), DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                dateStr += \"00\";\n            }\n            len = dateStr.length();\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case 9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case 5:\n                        sb.insert(offset, \":00.000\");\n                        break;\n                    case 6:\n                        sb.insert(offset, \"00.000\");\n                        break;\n                    default:\n                        break;\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601, Locale.US), _timezone, _locale, _lenient);\n            }\n        } else {\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen < 12) {\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, Locale.US), DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(((SimpleDateFormat) df).toPattern(), loc);\n        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,52 +1,39 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n-    // Need to support \"plain\" date...\n+\n     if (len <= 10 && Character.isDigit(c)) {\n         df = _formatPlain;\n         formatStr = DATE_FORMAT_STR_PLAIN;\n         if (df == null) {\n-            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n+            df = _formatPlain = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_PLAIN, Locale.US), _timezone, _locale, _lenient);\n         }\n     } else if (c == 'Z') {\n         df = _formatISO8601_z;\n         formatStr = DATE_FORMAT_STR_ISO8601_Z;\n         if (df == null) {\n-            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-            //    must use UTC, not whatever is configured as default timezone\n-            //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+            df = _formatISO8601_z = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, Locale.US), DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n-        // may be missing milliseconds... if so, add\n         if (dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n         }\n     } else {\n-        // Let's see if we have timezone indicator or not...\n         if (hasTimeZone(dateStr)) {\n             c = dateStr.charAt(len - 3);\n             if (c == ':') {\n-                // remove optional colon\n-                // remove colon\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n                 dateStr = sb.toString();\n             } else if (c == '+' || c == '-') {\n-                // missing minutes\n-                // let's just append '00'\n                 dateStr += \"00\";\n             }\n-            // Milliseconds partial or missing; and even seconds are optional\n             len = dateStr.length();\n-            // remove 'T', '+'/'-' and 4-digit timezone-offset\n             int timeLen = len - dateStr.lastIndexOf('T') - 6;\n             if (timeLen < 12) {\n-                // 8 for hh:mm:ss, 4 for .sss\n-                // insertion offset, before tz-offset\n                 int offset = len - 5;\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 switch(timeLen) {\n@@ -56,37 +43,32 @@\n                     case 10:\n                         sb.insert(offset, \"00\");\n                         break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n+                    case 9:\n                         sb.insert(offset, \"000\");\n                         break;\n                     case 8:\n                         sb.insert(offset, \".000\");\n                         break;\n-                    case // not legal to have single-digit second\n-                    7:\n+                    case 5:\n+                        sb.insert(offset, \":00.000\");\n                         break;\n-                    case // probably not legal, but let's allow\n-                    6:\n+                    case 6:\n                         sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n+                        break;\n+                    default:\n+                        break;\n                 }\n                 dateStr = sb.toString();\n             }\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n             if (_formatISO8601 == null) {\n-                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n+                df = _formatISO8601 = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601, Locale.US), _timezone, _locale, _lenient);\n             }\n         } else {\n-            // If not, plain date, no timezone\n             StringBuilder sb = new StringBuilder(dateStr);\n             int timeLen = len - dateStr.lastIndexOf('T') - 1;\n-            // And possible also millisecond part if missing\n             if (timeLen < 12) {\n-                // missing, or partial\n                 switch(timeLen) {\n                     case 11:\n                         sb.append('0');\n@@ -104,15 +86,11 @@\n             df = _formatISO8601_z;\n             formatStr = DATE_FORMAT_STR_ISO8601_Z;\n             if (df == null) {\n-                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-                //    must use UTC, not whatever is configured as default timezone\n-                //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+                df = _formatISO8601_z = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, Locale.US), DEFAULT_TIMEZONE, _locale, _lenient);\n             }\n         }\n     }\n     Date dt = df.parse(dateStr, pos);\n-    // 22-Dec-2015, tatu: With non-lenient, may get null\n     if (dt == null) {\n         throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = new SimpleDateFormat(DATE_FORMAT_PLAIN, _locale);\n            df.setTimeZone(_timezone);\n            df.setLenient(_lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, _locale);\n            df.setTimeZone(DEFAULT_TIMEZONE);\n            df.setLenient(_lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = new SimpleDateFormat(DATE_FORMAT_ISO8601, _locale);\n                df.setTimeZone(_timezone);\n                df.setLenient(_lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, _locale);\n                df.setTimeZone(DEFAULT_TIMEZONE);\n                df.setLenient(_lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(format, loc);\n        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        df.setLenient(lenient);\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n        if (lenient != null) {\n            df.setLenient(lenient);\n        }\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -8,7 +8,9 @@\n         df = _formatPlain;\n         formatStr = DATE_FORMAT_STR_PLAIN;\n         if (df == null) {\n-            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n+            df = _formatPlain = new SimpleDateFormat(DATE_FORMAT_PLAIN, _locale);\n+            df.setTimeZone(_timezone);\n+            df.setLenient(_lenient);\n         }\n     } else if (c == 'Z') {\n         df = _formatISO8601_z;\n@@ -17,7 +19,9 @@\n             // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n             //    must use UTC, not whatever is configured as default timezone\n             //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+            df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, _locale);\n+            df.setTimeZone(DEFAULT_TIMEZONE);\n+            df.setLenient(_lenient);\n         }\n         // may be missing milliseconds... if so, add\n         if (dateStr.charAt(len - 4) == ':') {\n@@ -78,7 +82,9 @@\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n             if (_formatISO8601 == null) {\n-                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n+                df = _formatISO8601 = new SimpleDateFormat(DATE_FORMAT_ISO8601, _locale);\n+                df.setTimeZone(_timezone);\n+                df.setLenient(_lenient);\n             }\n         } else {\n             // If not, plain date, no timezone\n@@ -107,7 +113,9 @@\n                 // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                 //    must use UTC, not whatever is configured as default timezone\n                 //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+                df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, _locale);\n+                df.setTimeZone(DEFAULT_TIMEZONE);\n+                df.setLenient(_lenient);\n             }\n         }\n     }\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -2,14 +2,15 @@\n     if (!loc.equals(DEFAULT_LOCALE)) {\n         df = new SimpleDateFormat(format, loc);\n         df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n+        df.setLenient(lenient);\n     } else {\n         df = (DateFormat) df.clone();\n         if (tz != null) {\n             df.setTimeZone(tz);\n         }\n-    }\n-    if (lenient != null) {\n-        df.setLenient(lenient.booleanValue());\n+        if (lenient != null) {\n+            df.setLenient(lenient);\n+        }\n     }\n     return df;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (len > 5 && dateStr.charAt(len - 5) == '.') { // check for a dot before timezone offset\n            StringBuilder sb = new StringBuilder(dateStr);\n            // make sure there are 3 digits after the dot\n            if (len - dateStr.lastIndexOf('.') <= 4) {\n                sb.insert(len - 1, \"000\");\n            } else {\n                sb.setCharAt(len - 2, sb.charAt(len - 3));\n            }\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            String tzStr = getTimeZone(dateStr);\n            dateStr = dateStr.substring(0, len - tzStr.length());\n            len = dateStr.length();\n            // Milliseconds partial or missing; and even seconds are optional\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen <= 0) {\n                timeLen = 0;\n                dateStr += \"T00:00:00\";\n                len = dateStr.length();\n            } else if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - tzStr.length() - 2;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11: sb.insert(offset, '0');\n                    case 10: sb.insert(offset, '0');\n                    case 9: sb.insert(offset, '0'); break;\n                    // is this legal? (just second fraction marker)\n                    case 8: sb.insert(offset, \"00\");\n                    case 7: break; // not legal to have single-digit second\n                    case 6: sb.insert(offset, \"00\");\n                    // is legal to omit seconds\n                    case 5: sb.insert(offset, \":00\"); break;\n                    case 4: case 3: case 2: sb.insert(offset + 1, \"00:00\"); break;\n                }\n                dateStr = sb.toString();\n                len = dateStr.length();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n            df.setTimeZone(TimeZone.getTimeZone(tzStr));\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen <= 0) {\n                timeLen = 0;\n                sb.append(\"T00:00:00\");\n                len = sb.length();\n            } else if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11: sb.append('0');\n                    case 10: sb.append('0');\n                    case 9: sb.append('0'); break;\n                    default: sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE) || (tz != null && !tz.equals(DEFAULT_TIMEZONE))) {\n        df = new SimpleDateFormat(format, loc);\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n    } else {\n        df = (DateFormat) df.clone();\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -20,83 +20,70 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len > 5 && dateStr.charAt(len - 5) == '.') { // check for a dot before timezone offset\n             StringBuilder sb = new StringBuilder(dateStr);\n-            sb.insert(len - 1, \".000\");\n+            // make sure there are 3 digits after the dot\n+            if (len - dateStr.lastIndexOf('.') <= 4) {\n+                sb.insert(len - 1, \"000\");\n+            } else {\n+                sb.setCharAt(len - 2, sb.charAt(len - 3));\n+            }\n             dateStr = sb.toString();\n         }\n     } else {\n         // Let's see if we have timezone indicator or not...\n         if (hasTimeZone(dateStr)) {\n-            c = dateStr.charAt(len - 3);\n-            if (c == ':') {\n-                // remove optional colon\n-                // remove colon\n-                StringBuilder sb = new StringBuilder(dateStr);\n-                sb.delete(len - 3, len - 2);\n-                dateStr = sb.toString();\n-            } else if (c == '+' || c == '-') {\n-                // missing minutes\n-                // let's just append '00'\n-                dateStr += \"00\";\n-            }\n+            String tzStr = getTimeZone(dateStr);\n+            dateStr = dateStr.substring(0, len - tzStr.length());\n+            len = dateStr.length();\n             // Milliseconds partial or missing; and even seconds are optional\n-            len = dateStr.length();\n-            // remove 'T', '+'/'-' and 4-digit timezone-offset\n-            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n-            if (timeLen < 12) {\n+            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n+            if (timeLen <= 0) {\n+                timeLen = 0;\n+                dateStr += \"T00:00:00\";\n+                len = dateStr.length();\n+            } else if (timeLen < 12) {\n                 // 8 for hh:mm:ss, 4 for .sss\n                 // insertion offset, before tz-offset\n-                int offset = len - 5;\n+                int offset = len - tzStr.length() - 2;\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 switch(timeLen) {\n-                    case 11:\n-                        sb.insert(offset, '0');\n-                        break;\n-                    case 10:\n-                        sb.insert(offset, \"00\");\n-                        break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n-                        sb.insert(offset, \"000\");\n-                        break;\n-                    case 8:\n-                        sb.insert(offset, \".000\");\n-                        break;\n-                    case // not legal to have single-digit second\n-                    7:\n-                        break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n+                    case 11: sb.insert(offset, '0');\n+                    case 10: sb.insert(offset, '0');\n+                    case 9: sb.insert(offset, '0'); break;\n+                    // is this legal? (just second fraction marker)\n+                    case 8: sb.insert(offset, \"00\");\n+                    case 7: break; // not legal to have single-digit second\n+                    case 6: sb.insert(offset, \"00\");\n+                    // is legal to omit seconds\n+                    case 5: sb.insert(offset, \":00\"); break;\n+                    case 4: case 3: case 2: sb.insert(offset + 1, \"00:00\"); break;\n                 }\n                 dateStr = sb.toString();\n+                len = dateStr.length();\n             }\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n             if (_formatISO8601 == null) {\n                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n             }\n+            df.setTimeZone(TimeZone.getTimeZone(tzStr));\n         } else {\n             // If not, plain date, no timezone\n             StringBuilder sb = new StringBuilder(dateStr);\n             int timeLen = len - dateStr.lastIndexOf('T') - 1;\n             // And possible also millisecond part if missing\n-            if (timeLen < 12) {\n+            if (timeLen <= 0) {\n+                timeLen = 0;\n+                sb.append(\"T00:00:00\");\n+                len = sb.length();\n+            } else if (timeLen < 12) {\n                 // missing, or partial\n                 switch(timeLen) {\n-                    case 11:\n-                        sb.append('0');\n-                    case 10:\n-                        sb.append('0');\n-                    case 9:\n-                        sb.append('0');\n-                        break;\n-                    default:\n-                        sb.append(\".000\");\n+                    case 11: sb.append('0');\n+                    case 10: sb.append('0');\n+                    case 9: sb.append('0'); break;\n+                    default: sb.append(\".000\");\n                 }\n             }\n             sb.append('Z');\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,12 +1,11 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n-    if (!loc.equals(DEFAULT_LOCALE)) {\n+    if (!loc.equals(DEFAULT_LOCALE) || (tz != null && !tz.equals(DEFAULT_TIMEZONE))) {\n         df = new SimpleDateFormat(format, loc);\n-        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n-    } else {\n-        df = (DateFormat) df.clone();\n         if (tz != null) {\n             df.setTimeZone(tz);\n         }\n+    } else {\n+        df = (DateFormat) df.clone();\n     }\n     if (lenient != null) {\n         df.setLenient(lenient.booleanValue());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_PLAIN, _locale), _timezone, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, _locale), DEFAULT_TIMEZONE, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601, _locale), _timezone, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch (timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, _locale), DEFAULT_TIMEZONE, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null && throwErrors) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, TimeZone tz, Boolean lenient) {\n    df = (DateFormat) df.clone();\n    if (tz != null) {\n        df.setTimeZone(tz);\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -8,7 +8,7 @@\n         df = _formatPlain;\n         formatStr = DATE_FORMAT_STR_PLAIN;\n         if (df == null) {\n-            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n+            df = _formatPlain = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_PLAIN, _locale), _timezone, _lenient);\n         }\n     } else if (c == 'Z') {\n         df = _formatISO8601_z;\n@@ -17,7 +17,7 @@\n             // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n             //    must use UTC, not whatever is configured as default timezone\n             //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+            df = _formatISO8601_z = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, _locale), DEFAULT_TIMEZONE, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n         if (dateStr.charAt(len - 4) == ':') {\n@@ -49,7 +49,7 @@\n                 // insertion offset, before tz-offset\n                 int offset = len - 5;\n                 StringBuilder sb = new StringBuilder(dateStr);\n-                switch(timeLen) {\n+                switch (timeLen) {\n                     case 11:\n                         sb.insert(offset, '0');\n                         break;\n@@ -78,7 +78,7 @@\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n             if (_formatISO8601 == null) {\n-                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n+                df = _formatISO8601 = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601, _locale), _timezone, _lenient);\n             }\n         } else {\n             // If not, plain date, no timezone\n@@ -87,7 +87,7 @@\n             // And possible also millisecond part if missing\n             if (timeLen < 12) {\n                 // missing, or partial\n-                switch(timeLen) {\n+                switch (timeLen) {\n                     case 11:\n                         sb.append('0');\n                     case 10:\n@@ -107,13 +107,13 @@\n                 // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                 //    must use UTC, not whatever is configured as default timezone\n                 //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+                df = _formatISO8601_z = _cloneFormat(new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, _locale), DEFAULT_TIMEZONE, _lenient);\n             }\n         }\n     }\n     Date dt = df.parse(dateStr, pos);\n     // 22-Dec-2015, tatu: With non-lenient, may get null\n-    if (dt == null) {\n+    if (dt == null && throwErrors) {\n         throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n     }\n     return dt;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n        int len = dateStr.length();\n        char c = dateStr.charAt(len - 1);\n        DateFormat df;\n        String formatStr;\n        // Need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            formatStr = DATE_FORMAT_STR_PLAIN;\n            if (df == null) {\n                df = _formatPlain = new SimpleDateFormat(DATE_FORMAT_PLAIN, DEFAULT_LOCALE);\n                df.setTimeZone(DEFAULT_TIMEZONE);\n                df.setLenient(_lenient);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, DEFAULT_LOCALE);\n                df.setTimeZone(DEFAULT_TIMEZONE);\n                df.setLenient(_lenient);\n            }\n            // may be missing milliseconds... if so, add\n            if (dateStr.charAt(len - 4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            // Let's see if we have timezone indicator or not...\n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len - 3);\n                if (c == ':') {\n                    // remove optional colon\n                    // remove colon\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len - 3, len - 2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') {\n                    // missing minutes\n                    // let's just append '00'\n                    dateStr += \"00\";\n                }\n                // Milliseconds partial or missing; and even seconds are optional\n                len = dateStr.length();\n                // remove 'T', '+'/'-' and 4-digit timezone-offset\n                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n                if (timeLen < 12) {\n                    // 8 for hh:mm:ss, 4 for .sss\n                    // insertion offset, before tz-offset\n                    int offset = len - 5;\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch(timeLen) {\n                        case 11:\n                            sb.insert(offset, '0');\n                            break;\n                        case 10:\n                            sb.insert(offset, \"00\");\n                            break;\n                        case // is this legal? (just second fraction marker)\n                        9:\n                            sb.insert(offset, \"000\");\n                            break;\n                        case 8:\n                            sb.insert(offset, \".000\");\n                            break;\n                        case // not legal to have single-digit second\n                        7:\n                            throw new ParseException(\n                                    String.format(\"Cannot parse date \\\"%s\\\": Timezone section has more than three zeros not separated by ':' \", dateStr),\n                                    pos.getIndex());\n                        case // probably not legal, but let's allow\n                        6:\n                            sb.insert(offset, \"00.000\");\n                        case // is legal to omit seconds\n                        5:\n                            sb.insert(offset, \":00.000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                formatStr = DATE_FORMAT_STR_ISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = new SimpleDateFormat(DATE_FORMAT_ISO8601, DEFAULT_LOCALE);\n                    df.setTimeZone(DEFAULT_TIMEZONE);\n                    df.setLenient(_lenient);\n                }\n            } else {\n                // If not, plain date, no timezone\n                StringBuilder sb = new StringBuilder(dateStr);\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                // And possible also millisecond part if missing\n                if (timeLen < 12) {\n                    // missing, or partial\n                    switch(timeLen) {\n                        case 11:\n                            sb.append('0');\n                        case 10:\n                            sb.append('0');\n                        case 9:\n                            sb.append('0');\n                            break;\n                        default:\n                            sb.append(\".000\");\n                    }\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                formatStr = DATE_FORMAT_STR_ISO8601_Z;\n                if (df == null) {\n                    // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                    //    must use UTC, not whatever is configured as default timezone\n                    //    (because we know `Z` identifier is used)\n                    df = _formatISO8601_z = new SimpleDateFormat(DATE_FORMAT_ISO8601_Z, DEFAULT_LOCALE);\n                    df.setTimeZone(DEFAULT_TIMEZONE);\n                    df.setLenient(_lenient);\n                }\n            }\n        }\n        Date dt = df.parse(dateStr, pos);\n        // 22-Dec-2015, tatu: With non-lenient, may get null\n        if (dt == null) {\n            throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n        }\n        return dt;\n    }\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        if (lenient != null) {\n            df.setLenient(lenient.booleanValue());\n        }\n        return df;\n    }", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (len >= 20 && dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE) || (tz != null && !tz.equals(DEFAULT_TIMEZONE))) {\n        df = new SimpleDateFormat(format, loc);\n        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -20,7 +20,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 20 && dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,5 +1,5 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n-    if (!loc.equals(DEFAULT_LOCALE)) {\n+    if (!loc.equals(DEFAULT_LOCALE) || (tz != null && !tz.equals(DEFAULT_TIMEZONE))) {\n         df = new SimpleDateFormat(format, loc);\n         df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, null, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n            len = dateStr.length();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case 9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case 5:\n                        sb.insert(offset, \":00.000\");\n                        break;\n                    default:\n                        break;\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, null, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        df = (SimpleDateFormat) df.clone();\n        ((SimpleDateFormat)df).applyPattern(format);\n        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        df.setLenient(lenient != null && lenient);\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n        df.setLenient(lenient != null && lenient);\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -8,15 +8,12 @@\n         df = _formatPlain;\n         formatStr = DATE_FORMAT_STR_PLAIN;\n         if (df == null) {\n-            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n+            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, null, _locale, _lenient);\n         }\n     } else if (c == 'Z') {\n         df = _formatISO8601_z;\n         formatStr = DATE_FORMAT_STR_ISO8601_Z;\n         if (df == null) {\n-            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-            //    must use UTC, not whatever is configured as default timezone\n-            //    (because we know `Z` identifier is used)\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n@@ -24,6 +21,7 @@\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n+            len = dateStr.length();\n         }\n     } else {\n         // Let's see if we have timezone indicator or not...\n@@ -56,29 +54,24 @@\n                     case 10:\n                         sb.insert(offset, \"00\");\n                         break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n+                    case 9:\n                         sb.insert(offset, \"000\");\n                         break;\n                     case 8:\n                         sb.insert(offset, \".000\");\n                         break;\n-                    case // not legal to have single-digit second\n-                    7:\n+                    case 5:\n+                        sb.insert(offset, \":00.000\");\n                         break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n+                    default:\n+                        break;\n                 }\n                 dateStr = sb.toString();\n             }\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n             if (_formatISO8601 == null) {\n-                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n+                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, null, _locale, _lenient);\n             }\n         } else {\n             // If not, plain date, no timezone\n@@ -104,15 +97,11 @@\n             df = _formatISO8601_z;\n             formatStr = DATE_FORMAT_STR_ISO8601_Z;\n             if (df == null) {\n-                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-                //    must use UTC, not whatever is configured as default timezone\n-                //    (because we know `Z` identifier is used)\n                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n             }\n         }\n     }\n     Date dt = df.parse(dateStr, pos);\n-    // 22-Dec-2015, tatu: With non-lenient, may get null\n     if (dt == null) {\n         throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n     }\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,15 +1,15 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n     if (!loc.equals(DEFAULT_LOCALE)) {\n-        df = new SimpleDateFormat(format, loc);\n+        df = (SimpleDateFormat) df.clone();\n+        ((SimpleDateFormat)df).applyPattern(format);\n         df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n+        df.setLenient(lenient != null && lenient);\n     } else {\n         df = (DateFormat) df.clone();\n         if (tz != null) {\n             df.setTimeZone(tz);\n         }\n-    }\n-    if (lenient != null) {\n-        df.setLenient(lenient.booleanValue());\n+        df.setLenient(lenient != null && lenient);\n     }\n     return df;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = null;\n    if (df instanceof SimpleDateFormat) {\n        // 25-Sep-2020, tatu: [databind#2895] handle \"empty\" input in stricter way\n        String input = dateStr.trim();\n        if (\"\".equals(input)) {\n            // return null if no leniency; 01-Jan-1970 if lenient\n            if (!_lenient) {\n                throw new ParseException(\"Cannot parse date \\\"\"+dateStr+\"\\\": leniency not enabled\",pos.getErrorIndex());\n            }\n            dt = new Date(0L);\n        } else {\n            dt = df.parse(input, pos);\n        }\n    } else {\n        dt = df.parse(dateStr, pos);\n    }\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (loc != null && !loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(format, loc);\n        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -111,7 +111,22 @@\n             }\n         }\n     }\n-    Date dt = df.parse(dateStr, pos);\n+    Date dt = null;\n+    if (df instanceof SimpleDateFormat) {\n+        // 25-Sep-2020, tatu: [databind#2895] handle \"empty\" input in stricter way\n+        String input = dateStr.trim();\n+        if (\"\".equals(input)) {\n+            // return null if no leniency; 01-Jan-1970 if lenient\n+            if (!_lenient) {\n+                throw new ParseException(\"Cannot parse date \\\"\"+dateStr+\"\\\": leniency not enabled\",pos.getErrorIndex());\n+            }\n+            dt = new Date(0L);\n+        } else {\n+            dt = df.parse(input, pos);\n+        }\n+    } else {\n+        dt = df.parse(dateStr, pos);\n+    }\n     // 22-Dec-2015, tatu: With non-lenient, may get null\n     if (dt == null) {\n         throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,5 +1,5 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n-    if (!loc.equals(DEFAULT_LOCALE)) {\n+    if (loc != null && !loc.equals(DEFAULT_LOCALE)) {\n         df = new SimpleDateFormat(format, loc);\n         df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z' || c == 'z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null && throwErrors) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    DateFormat clonedDf;\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        clonedDf = new SimpleDateFormat(format, loc);\n        clonedDf.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n    } else {\n        clonedDf = (DateFormat) df.clone();\n        if (tz != null) {\n            clonedDf.setTimeZone(tz);\n        }\n    }\n    if (lenient != null) {\n        clonedDf.setLenient(lenient.booleanValue());\n    }\n    return clonedDf;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -10,7 +10,7 @@\n         if (df == null) {\n             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n         }\n-    } else if (c == 'Z') {\n+    } else if (c == 'Z' || c == 'z') {\n         df = _formatISO8601_z;\n         formatStr = DATE_FORMAT_STR_ISO8601_Z;\n         if (df == null) {\n@@ -113,7 +113,7 @@\n     }\n     Date dt = df.parse(dateStr, pos);\n     // 22-Dec-2015, tatu: With non-lenient, may get null\n-    if (dt == null) {\n+    if (dt == null && throwErrors) {\n         throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n     }\n     return dt;\n--- com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@_cloneFormat\n@@ -1,15 +1,16 @@\n private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n+    DateFormat clonedDf;\n     if (!loc.equals(DEFAULT_LOCALE)) {\n-        df = new SimpleDateFormat(format, loc);\n-        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n+        clonedDf = new SimpleDateFormat(format, loc);\n+        clonedDf.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n     } else {\n-        df = (DateFormat) df.clone();\n+        clonedDf = (DateFormat) df.clone();\n         if (tz != null) {\n-            df.setTimeZone(tz);\n+            clonedDf.setTimeZone(tz);\n         }\n     }\n     if (lenient != null) {\n-        df.setLenient(lenient.booleanValue());\n+        clonedDf.setLenient(lenient.booleanValue());\n     }\n-    return df;\n+    return clonedDf;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = new SimpleDateFormat(formatStr, Locale.US);\n            df.setTimeZone(DEFAULT_TIMEZONE); // Set UTC as the default timezone\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            df = _formatISO8601_z = new SimpleDateFormat(formatStr, Locale.US);\n            df.setTimeZone(DEFAULT_TIMEZONE); // Set UTC as the default timezone\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = new SimpleDateFormat(formatStr, Locale.US);\n                df.setTimeZone(DEFAULT_TIMEZONE); // Set UTC as the default timezone\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                df = _formatISO8601_z = new SimpleDateFormat(formatStr, Locale.US);\n                df.setTimeZone(DEFAULT_TIMEZONE); // Set UTC as the default timezone\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}\n\n## Fixed Function 2\nprivate final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(format, loc);\n        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -8,16 +8,15 @@\n         df = _formatPlain;\n         formatStr = DATE_FORMAT_STR_PLAIN;\n         if (df == null) {\n-            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n+            df = _formatPlain = new SimpleDateFormat(formatStr, Locale.US);\n+            df.setTimeZone(DEFAULT_TIMEZONE); // Set UTC as the default timezone\n         }\n     } else if (c == 'Z') {\n         df = _formatISO8601_z;\n         formatStr = DATE_FORMAT_STR_ISO8601_Z;\n         if (df == null) {\n-            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-            //    must use UTC, not whatever is configured as default timezone\n-            //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+            df = _formatISO8601_z = new SimpleDateFormat(formatStr, Locale.US);\n+            df.setTimeZone(DEFAULT_TIMEZONE); // Set UTC as the default timezone\n         }\n         // may be missing milliseconds... if so, add\n         if (dateStr.charAt(len - 4) == ':') {\n@@ -78,7 +77,8 @@\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n             if (_formatISO8601 == null) {\n-                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n+                df = _formatISO8601 = new SimpleDateFormat(formatStr, Locale.US);\n+                df.setTimeZone(DEFAULT_TIMEZONE); // Set UTC as the default timezone\n             }\n         } else {\n             // If not, plain date, no timezone\n@@ -104,10 +104,8 @@\n             df = _formatISO8601_z;\n             formatStr = DATE_FORMAT_STR_ISO8601_Z;\n             if (df == null) {\n-                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-                //    must use UTC, not whatever is configured as default timezone\n-                //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+                df = _formatISO8601_z = new SimpleDateFormat(formatStr, Locale.US);\n+                df.setTimeZone(DEFAULT_TIMEZONE); // Set UTC as the default timezone\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}]