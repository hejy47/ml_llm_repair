[{"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && (b.length - offset) == len) {\n                base64.setInitialBuffer(b, offset, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,19 +1,17 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n-            if (c > 0 && b.length == len) {\n+            if (c > 0 && (b.length - offset) == len) {\n                 base64.setInitialBuffer(b, offset, len);\n             }\n             if (doEncode) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            if (c > 0 && offset == 0 && len == buf.length) { // Check if entire buffer is read\n                base64.setInitialBuffer(buf, 0, c); // Use buf directly instead of copying to b\n                return base64.readResults(b, offset, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -8,13 +8,12 @@\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n-            // A little optimization to avoid System.arraycopy()\n-            // when possible.\n-            if (c > 0 && b.length == len) {\n-                base64.setInitialBuffer(b, offset, len);\n+            if (c > 0 && offset == 0 && len == buf.length) { // Check if entire buffer is read\n+                base64.setInitialBuffer(buf, 0, c); // Use buf directly instead of copying to b\n+                return base64.readResults(b, offset, len);\n             }\n             if (doEncode) {\n                 base64.encode(buf, 0, c);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && len == b.length) {\n                base64.setInitialBuffer(b, 0, len);\n            } else {\n                base64.setInitialBuffer(new byte[len], 0, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,20 +1,20 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n-            if (c > 0 && b.length == len) {\n-                base64.setInitialBuffer(b, offset, len);\n+            if (c > 0 && len == b.length) {\n+                base64.setInitialBuffer(b, 0, len);\n+            } else {\n+                base64.setInitialBuffer(new byte[len], 0, len);\n             }\n             if (doEncode) {\n                 base64.encode(buf, 0, c);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && (len - offset) >= c) { // fixed condition to check if enough space is available in given array b.\n                base64.setInitialBuffer(b, offset, len);\n            } else {\n                byte[] temp = new byte[len - offset];\n                base64.setInitialBuffer(temp, 0, len - offset);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -8,13 +8,16 @@\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n-            if (c > 0 && b.length == len) {\n+            if (c > 0 && (len - offset) >= c) { // fixed condition to check if enough space is available in given array b.\n                 base64.setInitialBuffer(b, offset, len);\n+            } else {\n+                byte[] temp = new byte[len - offset];\n+                base64.setInitialBuffer(temp, 0, len - offset);\n             }\n             if (doEncode) {\n                 base64.encode(buf, 0, c);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        while (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c == -1) {\n                break;\n            }\n            if (c > 0 && b.length == len) {\n                base64.setInitialBuffer(b, offset, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -8,11 +8,14 @@\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        while (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n+            if (c == -1) {\n+                break;\n+            }\n             if (c > 0 && b.length == len) {\n                 base64.setInitialBuffer(b, offset, len);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) { // Fixed condition\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && b.length == len) {\n                base64.setInitialBuffer(b, offset, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,14 +1,12 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) { // Fixed condition\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && offset == 0 && len == buf.length) {\n                // If read buffer is exactly the same as the output buffer,\n                // then directly return the read buffer.\n                base64.setInitialBuffer(buf, 0, c);\n            } else {\n                // Otherwise set the initial buffer and encode/decode it.\n                base64.setInitialBuffer(b, offset, len);\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -8,18 +8,23 @@\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n-            if (c > 0 && b.length == len) {\n+            if (c > 0 && offset == 0 && len == buf.length) {\n+                // If read buffer is exactly the same as the output buffer,\n+                // then directly return the read buffer.\n+                base64.setInitialBuffer(buf, 0, c);\n+            } else {\n+                // Otherwise set the initial buffer and encode/decode it.\n                 base64.setInitialBuffer(b, offset, len);\n-            }\n-            if (doEncode) {\n-                base64.encode(buf, 0, c);\n-            } else {\n-                base64.decode(buf, 0, c);\n+                if (doEncode) {\n+                    base64.encode(buf, 0, c);\n+                } else {\n+                    base64.decode(buf, 0, c);\n+                }\n             }\n         }\n         return base64.readResults(b, offset, len);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n                if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && b.length == len) {\n                base64.setInitialBuffer(b, offset, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,9 +1,7 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && offset == 0 && len == b.length) {\n                // If the input buffer is large enough to hold all the data\n                // that was read, use it directly.\n                return doEncode ? base64.encode(buf, b) : base64.decode(buf, b);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -8,13 +8,15 @@\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n-            if (c > 0 && b.length == len) {\n-                base64.setInitialBuffer(b, offset, len);\n+            if (c > 0 && offset == 0 && len == b.length) {\n+                // If the input buffer is large enough to hold all the data\n+                // that was read, use it directly.\n+                return doEncode ? base64.encode(buf, b) : base64.decode(buf, b);\n             }\n             if (doEncode) {\n                 base64.encode(buf, 0, c);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && len == c) {\n                base64.setInitialBuffer(b, offset, len);\n            } else if (c > 0) {\n                byte[] sizedBuf = Arrays.copyOf(buf, c);\n                if (doEncode) {\n                    base64.encode(sizedBuf, 0, c);\n                } else {\n                    base64.decode(sizedBuf, 0, c);\n                }\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,25 +1,25 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n-            if (c > 0 && b.length == len) {\n+            if (c > 0 && len == c) {\n                 base64.setInitialBuffer(b, offset, len);\n-            }\n-            if (doEncode) {\n-                base64.encode(buf, 0, c);\n-            } else {\n-                base64.decode(buf, 0, c);\n+            } else if (c > 0) {\n+                byte[] sizedBuf = Arrays.copyOf(buf, c);\n+                if (doEncode) {\n+                    base64.encode(sizedBuf, 0, c);\n+                } else {\n+                    base64.decode(sizedBuf, 0, c);\n+                }\n             }\n         }\n         return base64.readResults(b, offset, len);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            int bufSize = doEncode ? 4096 : 8192;\n            byte[] buf = new byte[bufSize];\n            int bytesRead = in.read(buf);\n            if (bytesRead > 0) {\n                base64.setInitialBuffer(buf, 0, bytesRead);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, bytesRead);\n            } else {\n                base64.decode(buf, 0, bytesRead);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,25 +1,22 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n-            byte[] buf = new byte[doEncode ? 4096 : 8192];\n-            int c = in.read(buf);\n-            // A little optimization to avoid System.arraycopy()\n-            // when possible.\n-            if (c > 0 && b.length == len) {\n-                base64.setInitialBuffer(b, offset, len);\n+        if (!base64.hasData()) {\n+            int bufSize = doEncode ? 4096 : 8192;\n+            byte[] buf = new byte[bufSize];\n+            int bytesRead = in.read(buf);\n+            if (bytesRead > 0) {\n+                base64.setInitialBuffer(buf, 0, bytesRead);\n             }\n             if (doEncode) {\n-                base64.encode(buf, 0, c);\n+                base64.encode(buf, 0, bytesRead);\n             } else {\n-                base64.decode(buf, 0, c);\n+                base64.decode(buf, 0, bytesRead);\n             }\n         }\n         return base64.readResults(b, offset, len);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && len == c) {\n                base64.setInitialBuffer(buf, 0, c);\n            } else {\n                base64.setInitialBuffer(b, offset, len);\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,25 +1,25 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n-            if (c > 0 && b.length == len) {\n+            if (c > 0 && len == c) {\n+                base64.setInitialBuffer(buf, 0, c);\n+            } else {\n                 base64.setInitialBuffer(b, offset, len);\n-            }\n-            if (doEncode) {\n-                base64.encode(buf, 0, c);\n-            } else {\n-                base64.decode(buf, 0, c);\n+                if (doEncode) {\n+                    base64.encode(buf, 0, c);\n+                } else {\n+                    base64.decode(buf, 0, c);\n+                }\n             }\n         }\n         return base64.readResults(b, offset, len);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            if (c > 0 && b.length == len) {\n                base64.setInitialBuffer(b, offset, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,18 +1,14 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n-            // A little optimization to avoid System.arraycopy()\n-            // when possible.\n             if (c > 0 && b.length == len) {\n                 base64.setInitialBuffer(b, offset, len);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && len == buf.length) {\n                base64.setInitialBuffer(buf, 0, c);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,20 +1,18 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n-            if (c > 0 && b.length == len) {\n-                base64.setInitialBuffer(b, offset, len);\n+            if (c > 0 && len == buf.length) {\n+                base64.setInitialBuffer(buf, 0, c);\n             }\n             if (doEncode) {\n                 base64.encode(buf, 0, c);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        byte[] buf = new byte[doEncode ? 4096 : 8192];\n        int c = in.read(buf);\n        if (c > 0) {\n            base64.setInitialBuffer(b, offset, len);\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n            return base64.readResults(b, offset, len);\n        } else {\n            return -1;\n        }\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -8,20 +8,18 @@\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n-            byte[] buf = new byte[doEncode ? 4096 : 8192];\n-            int c = in.read(buf);\n-            // A little optimization to avoid System.arraycopy()\n-            // when possible.\n-            if (c > 0 && b.length == len) {\n-                base64.setInitialBuffer(b, offset, len);\n-            }\n+        byte[] buf = new byte[doEncode ? 4096 : 8192];\n+        int c = in.read(buf);\n+        if (c > 0) {\n+            base64.setInitialBuffer(b, offset, len);\n             if (doEncode) {\n                 base64.encode(buf, 0, c);\n             } else {\n                 base64.decode(buf, 0, c);\n             }\n+            return base64.readResults(b, offset, len);\n+        } else {\n+            return -1;\n         }\n-        return base64.readResults(b, offset, len);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && len == c) {\n                base64.setInitialBuffer(b, offset, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,19 +1,17 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n-            if (c > 0 && b.length == len) {\n+            if (c > 0 && len == c) {\n                 base64.setInitialBuffer(b, offset, len);\n             }\n             if (doEncode) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && len == c) {\n                base64.setInitialBuffer(buf, 0, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,20 +1,18 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n-            if (c > 0 && b.length == len) {\n-                base64.setInitialBuffer(b, offset, len);\n+            if (c > 0 && len == c) {\n+                base64.setInitialBuffer(buf, 0, len);\n             }\n             if (doEncode) {\n                 base64.encode(buf, 0, c);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n                if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && len == buf.length) {\n                base64.setInitialBuffer(buf, 0, c);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,9 +1,7 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n@@ -13,8 +11,8 @@\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n-            if (c > 0 && b.length == len) {\n-                base64.setInitialBuffer(b, offset, len);\n+            if (c > 0 && len == buf.length) {\n+                base64.setInitialBuffer(buf, 0, c);\n             }\n             if (doEncode) {\n                 base64.encode(buf, 0, c);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            if (c > 0) {\n                base64.setInitialBuffer(b, offset, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,19 +1,15 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n-            // A little optimization to avoid System.arraycopy()\n-            // when possible.\n-            if (c > 0 && b.length == len) {\n+            if (c > 0) {\n                 base64.setInitialBuffer(b, offset, len);\n             }\n             if (doEncode) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy()\n            // when possible.\n            if (c > 0 && b.length == len) {\n                base64.setInitialBuffer();\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        return base64.readResults(b, offset, len);\n    }\n}\n\n### Changes Made\nIn line #20, `base64.setInitialBuffer(b, offset, len);` is replaced by `base64.setInitialBuffer();`. The method `setInitialBuffer()` no longer needs any arguments as the buffer is already set in the constructor of the `Base64` object.", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -8,13 +8,13 @@\n     } else if (len == 0) {\n         return 0;\n     } else {\n-                if (!base64.hasData()) {\n+        if (!base64.hasData()) {\n             byte[] buf = new byte[doEncode ? 4096 : 8192];\n             int c = in.read(buf);\n             // A little optimization to avoid System.arraycopy()\n             // when possible.\n             if (c > 0 && b.length == len) {\n-                base64.setInitialBuffer(b, offset, len);\n+                base64.setInitialBuffer();\n             }\n             if (doEncode) {\n                 base64.encode(buf, 0, c);\n", "finish_reason": "stop", "valid": false, "num": 1}]