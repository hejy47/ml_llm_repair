[{"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            // Fix: Set c value to null character instead of INT_NULL to break loop\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    \n    // Fix: Convert INT_PERIOD to '.' character\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = '.';\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == INT_e || c == INT_E) {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -23,6 +23,7 @@\n         outBuf[outPtr++] = c;\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n             // EOF is legal for main level int values\n+            // Fix: Set c value to null character instead of INT_NULL to break loop\n             c = CHAR_NULL;\n             eof = true;\n             break int_loop;\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -2,9 +2,11 @@\n     int fractLen = 0;\n     boolean eof = false;\n     // And then see if we get other parts\n-    if (c == INT_PERIOD) {\n+    \n+    // Fix: Convert INT_PERIOD to '.' character\n+    if (c == '.') {\n         // yes, fraction\n-        outBuf[outPtr++] = (char) c;\n+        outBuf[outPtr++] = '.';\n         fract_loop: while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 eof = true;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= '9' && c >= '0') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= '9' && c >= '0') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -23,7 +23,6 @@\n         outBuf[outPtr++] = c;\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n             // EOF is legal for main level int values\n-            c = CHAR_NULL;\n             eof = true;\n             break int_loop;\n         }\n@@ -44,7 +43,7 @@\n                 break fract_loop;\n             }\n             c = _inputBuffer[_inputPtr++];\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -79,7 +78,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -2,7 +2,7 @@\n     int fractLen = 0;\n     boolean eof = false;\n     // And then see if we get other parts\n-    if (c == INT_PERIOD) {\n+    if (c == '.') {\n         // yes, fraction\n         outBuf[outPtr++] = (char) c;\n         fract_loop: while (true) {\n@@ -11,7 +11,7 @@\n                 break fract_loop;\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -27,7 +27,7 @@\n         }\n     }\n     int expLen = 0;\n-    if (c == INT_e || c == INT_E) {\n+    if (c == 'e' || c == 'E') {\n         // exponent?\n         if (outPtr >= outBuf.length) {\n             outBuf = _textBuffer.finishCurrentSegment();\n@@ -52,7 +52,7 @@\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= '9' && c >= '0') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == INT_PERIOD) {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == INT_e || c == INT_E) {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= '9' && c >= '0') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -44,7 +44,7 @@\n                 break fract_loop;\n             }\n             c = _inputBuffer[_inputPtr++];\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -79,7 +79,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -11,7 +11,7 @@\n                 break fract_loop;\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -52,7 +52,7 @@\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == INT_PERIOD) {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == INT_e || c == INT_E) {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace();\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -23,7 +23,6 @@\n         outBuf[outPtr++] = c;\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n             // EOF is legal for main level int values\n-            c = CHAR_NULL;\n             eof = true;\n             break int_loop;\n         }\n@@ -101,7 +100,7 @@\n     if (!eof) {\n         --_inputPtr;\n         if (_parsingContext.inRoot()) {\n-            _verifyRootSpace(c);\n+            _verifyRootSpace();\n         }\n     }\n     _textBuffer.setCurrentLength(outPtr);\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -75,7 +75,7 @@\n         --_inputPtr;\n         // As per [core#105], need separating space between root values; check here\n         if (_parsingContext.inRoot()) {\n-            _verifyRootSpace(c);\n+            _verifyRootSpace();\n         }\n     }\n     _textBuffer.setCurrentLength(outPtr);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == INT_PERIOD) {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == INT_e || c == INT_E) {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 7}, {"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == INT_PERIOD) {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == INT_e || c == INT_E) {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -23,7 +23,6 @@\n         outBuf[outPtr++] = c;\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n             // EOF is legal for main level int values\n-            c = CHAR_NULL;\n             eof = true;\n             break int_loop;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c >= '0' && c <= '9') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c >= '0' && c <= '9') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -44,7 +44,7 @@\n                 break fract_loop;\n             }\n             c = _inputBuffer[_inputPtr++];\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -79,7 +79,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c >= '0' && c <= '9') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -2,7 +2,7 @@\n     int fractLen = 0;\n     boolean eof = false;\n     // And then see if we get other parts\n-    if (c == INT_PERIOD) {\n+    if (c == '.') {\n         // yes, fraction\n         outBuf[outPtr++] = (char) c;\n         fract_loop: while (true) {\n@@ -11,7 +11,7 @@\n                 break fract_loop;\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -27,7 +27,7 @@\n         }\n     }\n     int expLen = 0;\n-    if (c == INT_e || c == INT_E) {\n+    if (c == 'e' || c == 'E') {\n         // exponent?\n         if (outPtr >= outBuf.length) {\n             outBuf = _textBuffer.finishCurrentSegment();\n@@ -52,7 +52,7 @@\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c >= '0' && c <= '9') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= '9' && c >= '0') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= '9' && c >= '0') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -44,7 +44,7 @@\n                 break fract_loop;\n             }\n             c = _inputBuffer[_inputPtr++];\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -79,7 +79,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -2,7 +2,7 @@\n     int fractLen = 0;\n     boolean eof = false;\n     // And then see if we get other parts\n-    if (c == INT_PERIOD) {\n+    if (c == '.') {\n         // yes, fraction\n         outBuf[outPtr++] = (char) c;\n         fract_loop: while (true) {\n@@ -11,7 +11,7 @@\n                 break fract_loop;\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -27,7 +27,7 @@\n         }\n     }\n     int expLen = 0;\n-    if (c == INT_e || c == INT_E) {\n+    if (c == 'e' || c == 'E') {\n         // exponent?\n         if (outPtr >= outBuf.length) {\n             outBuf = _textBuffer.finishCurrentSegment();\n@@ -52,7 +52,7 @@\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == INT_PERIOD) {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == INT_e || c == INT_E) {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent part\");\n            }\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent part\");\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -36,7 +36,9 @@\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            if (!loadMore()) {\n+                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent part\");\n+            }\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -48,7 +50,9 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                if (!loadMore()) {\n+                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent part\");\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == INT_PERIOD) {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == INT_e || c == INT_E) {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                reportUnexpectedNumberChar(c, \"Unexpected EOF while parsing exponent\");\n            }\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    reportUnexpectedNumberChar(c, \"Unexpected EOF while parsing exponent\");\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -36,7 +36,9 @@\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            if (!loadMore()) {\n+                reportUnexpectedNumberChar(c, \"Unexpected EOF while parsing exponent\");\n+            }\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -48,7 +50,9 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                if (!loadMore()) {\n+                    reportUnexpectedNumberChar(c, \"Unexpected EOF while parsing exponent\");\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == INT_PERIOD) {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == INT_e || c == INT_E) {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c & 0xFF);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -75,7 +75,7 @@\n         --_inputPtr;\n         // As per [core#105], need separating space between root values; check here\n         if (_parsingContext.inRoot()) {\n-            _verifyRootSpace(c);\n+            _verifyRootSpace(c & 0xFF);\n         }\n     }\n     _textBuffer.setCurrentLength(outPtr);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}\n\n## Fixed Function 2\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == INT_PERIOD) {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == INT_e || c == INT_E) {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        c = getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            c = getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -8,7 +8,7 @@\n     }\n     // This is the place to do leading-zero check(s) too:\n     int intLen = 0;\n-    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n+    char c = getNextChar(\"No digit following minus sign\");\n     if (c == '0') {\n         c = _verifyNoLeadingZeroes();\n     }\n@@ -68,7 +68,7 @@\n         }\n         outBuf[outPtr++] = c;\n         // Not optional, can require that we get one more char\n-        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+        c = getNextChar(\"expected a digit for number exponent\");\n         // Sign indicator?\n         if (c == '-' || c == '+') {\n             if (outPtr >= outBuf.length) {\n@@ -77,7 +77,7 @@\n             }\n             outBuf[outPtr++] = c;\n             // Likewise, non optional:\n-            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+            c = getNextChar(\"expected a digit for number exponent\");\n         }\n         exp_loop: while (c <= INT_9 && c >= INT_0) {\n             ++expLen;\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -35,10 +35,7 @@\n         }\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n-        if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n-        }\n-        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+        c = getNextChar(\"expected a digit for number exponent\");\n         // Sign indicator?\n         if (c == '-' || c == '+') {\n             if (outPtr >= outBuf.length) {\n@@ -47,10 +44,7 @@\n             }\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n-            if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n-            }\n-            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            c = getNextChar(\"expected a digit for number exponent\");\n         }\n         exp_loop: while (c <= INT_9 && c >= INT_0) {\n             ++expLen;\n", "finish_reason": "stop", "valid": false, "num": 1}]