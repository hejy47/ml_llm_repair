[{"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // use currentToken() instead of getCurrentTokenId()\n        case START_OBJECT: // use enum name instead of ID constant\n        case FIELD_NAME:\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // use enum name instead of ID constant\n            return p.getEmbeddedObject();\n        case VALUE_STRING: // use enum name instead of ID constant\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT: // use enum name instead of ID constant\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n                return _parseFloatAsInt(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getLongValue();\n        case VALUE_NUMBER_FLOAT: // use enum name instead of ID constant\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE: // use enum name instead of ID constant\n            return Boolean.TRUE;\n        case VALUE_FALSE: // use enum name instead of ID constant\n            return Boolean.FALSE;\n        case VALUE_NULL: // use enum name instead of ID constant\n            return null;\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // use currentToken() instead of getCurrentTokenId()\n        case START_OBJECT: // use enum name instead of ID constant\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n        case FIELD_NAME: // add missing break statement\n            return mapObject(p, ctxt);\n        case START_ARRAY: // use enum name instead of ID constant\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // use enum name instead of ID constant\n            return p.getEmbeddedObject();\n        case VALUE_STRING: // use enum name instead of ID constant\n            return p.getText();\n        case VALUE_NUMBER_INT: // use enum name instead of ID constant\n            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n                return _parseFloatAsInt(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getLongValue();\n        case VALUE_NUMBER_FLOAT: // use enum name instead of ID constant\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case VALUE_TRUE: // use enum name instead of ID constant\n            return Boolean.TRUE;\n        case VALUE_FALSE: // use enum name instead of ID constant\n            return Boolean.FALSE;\n        case VALUE_NULL: // use enum name instead of ID constant\n            return null;\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,13 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n+    switch(p.currentToken()) { // use currentToken() instead of getCurrentTokenId()\n+        case START_OBJECT: // use enum name instead of ID constant\n+        case FIELD_NAME:\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,38 +15,38 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // use enum name instead of ID constant\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // use enum name instead of ID constant\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // use enum name instead of ID constant\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n+                return _parseFloatAsInt(p, ctxt);\n+            }\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n-            // should be optimal, whatever it is\n-            return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+            return p.getLongValue();\n+        case VALUE_NUMBER_FLOAT: // use enum name instead of ID constant\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE: // use enum name instead of ID constant\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // use enum name instead of ID constant\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // use enum name instead of ID constant\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,53 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) { // use currentToken() instead of getCurrentTokenId()\n+        case START_OBJECT: // use enum name instead of ID constant\n+        case FIELD_NAME:\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // use enum name instead of ID constant\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // use enum name instead of ID constant\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // use enum name instead of ID constant\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n+                return _parseFloatAsInt(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n-            // should be optimal, whatever it is\n-            return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+            return p.getLongValue();\n+        case VALUE_NUMBER_FLOAT: // use enum name instead of ID constant\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE: // use enum name instead of ID constant\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // use enum name instead of ID constant\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // use enum name instead of ID constant\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t != null && t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            // fall through case:\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t != null && t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -2,44 +2,45 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+        case JsonTokenId.ID_FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n+            }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n+            return p.getDoubleValue();\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -47,10 +48,8 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // Changed method from getCurrentTokenId() to currentToken()\n        case START_OBJECT: // Changed token IDs to token types\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // Changed token ID to token type\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT: // Changed token ID to token type\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT: // Changed token ID to token type\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE: // Changed token ID to token type\n            return Boolean.TRUE;\n        case VALUE_FALSE: // Changed token ID to token type\n            return Boolean.FALSE;\n        case VALUE_NULL: // Changed token ID to token type\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // Commented out invalid token ID\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // Changed method from getCurrentTokenId() to currentToken()\n        case START_OBJECT: // Changed token IDs to token types\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n        case FIELD_NAME:\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // Changed token ID to token type\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT: // Changed token ID to token type\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT: // Changed token ID to token type\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case VALUE_TRUE: // Changed token ID to token type\n            return Boolean.TRUE;\n        case VALUE_FALSE: // Changed token ID to token type\n            return Boolean.FALSE;\n        case VALUE_NULL: // Changed token ID to token type\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // Commented out invalid token ID\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) { // Changed method from getCurrentTokenId() to currentToken()\n+        case START_OBJECT: // Changed token IDs to token types\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,38 +17,37 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // Changed token ID to token type\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // Changed token ID to token type\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT: // Changed token ID to token type\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE: // Changed token ID to token type\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // Changed token ID to token type\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // Changed token ID to token type\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // Commented out invalid token ID\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,54 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) { // Changed method from getCurrentTokenId() to currentToken()\n+        case START_OBJECT: // Changed token IDs to token types\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // Changed token ID to token type\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // Changed token ID to token type\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT: // Changed token ID to token type\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE: // Changed token ID to token type\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // Changed token ID to token type\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // Changed token ID to token type\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // Commented out invalid token ID\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n                // Must return the token to the parser so that one more call to p.nextToken() gets the first member of the object\n                p.back();\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n                // Must return the token to the parser so that one more call to p.nextToken() gets the first element in the array\n                p.back();\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -28,7 +28,7 @@\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n@@ -37,7 +37,7 @@\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n@@ -50,6 +50,6 @@\n             return null;\n         //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -2,44 +2,45 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+        case JsonTokenId.ID_FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n+            }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n+            return p.getDoubleValue();\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -47,9 +48,7 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            // fall through\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -28,7 +28,7 @@\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n@@ -37,7 +37,7 @@\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -2,44 +2,45 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+        case JsonTokenId.ID_FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n+            }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n+            return p.getDoubleValue();\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -47,10 +48,8 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 6}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -45,6 +45,7 @@\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n+\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -2,55 +2,55 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+        case JsonTokenId.ID_FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n+            }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n+            return p.getDoubleValue();\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n+\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // changed getCurrentTokenId() to currentToken()\n        case START_OBJECT: // changed JsonTokenId.ID_START_OBJECT to START_OBJECT\n        case FIELD_NAME: // changed JsonTokenId.ID_FIELD_NAME to FIELD_NAME\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY: // changed JsonTokenId.ID_START_ARRAY to START_ARRAY\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // changed JsonTokenId.ID_EMBEDDED_OBJECT to VALUE_EMBEDDED_OBJECT\n            return p.getEmbeddedObject();\n        case VALUE_STRING: // changed JsonTokenId.ID_STRING to VALUE_STRING\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT: // changed JsonTokenId.ID_NUMBER_INT to VALUE_NUMBER_INT\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT: // changed JsonTokenId.ID_NUMBER_FLOAT to VALUE_NUMBER_FLOAT\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue(); // removed Double.valueOf()\n        case VALUE_TRUE: // changed JsonTokenId.ID_TRUE to VALUE_TRUE\n            return Boolean.TRUE;\n        case VALUE_FALSE: // changed JsonTokenId.ID_FALSE to VALUE_FALSE\n            return Boolean.FALSE;\n        case VALUE_NULL: // changed JsonTokenId.ID_NULL to VALUE_NULL\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // changed getCurrentTokenId() to currentToken()\n        case START_OBJECT: // changed JsonTokenId.ID_START_OBJECT to START_OBJECT\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n        case FIELD_NAME: // changed JsonTokenId.ID_FIELD_NAME to FIELD_NAME\n            return mapObject(p, ctxt);\n        case START_ARRAY: // changed JsonTokenId.ID_START_ARRAY to START_ARRAY\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // changed JsonTokenId.ID_EMBEDDED_OBJECT to VALUE_EMBEDDED_OBJECT\n            return p.getEmbeddedObject();\n        case VALUE_STRING: // changed JsonTokenId.ID_STRING to VALUE_STRING\n            return p.getText();\n        case VALUE_NUMBER_INT: // changed JsonTokenId.ID_NUMBER_INT to VALUE_NUMBER_INT\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT: // changed JsonTokenId.ID_NUMBER_FLOAT to VALUE_NUMBER_FLOAT\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue(); // removed Double.valueOf()\n        case VALUE_TRUE: // changed JsonTokenId.ID_TRUE to VALUE_TRUE\n            return Boolean.TRUE;\n        case VALUE_FALSE: // changed JsonTokenId.ID_FALSE to VALUE_FALSE\n            return Boolean.FALSE;\n        case VALUE_NULL: // changed JsonTokenId.ID_NULL to VALUE_NULL\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) { // changed getCurrentTokenId() to currentToken()\n+        case START_OBJECT: // changed JsonTokenId.ID_START_OBJECT to START_OBJECT\n+        case FIELD_NAME: // changed JsonTokenId.ID_FIELD_NAME to FIELD_NAME\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY: // changed JsonTokenId.ID_START_ARRAY to START_ARRAY\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,36 +17,35 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // changed JsonTokenId.ID_EMBEDDED_OBJECT to VALUE_EMBEDDED_OBJECT\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // changed JsonTokenId.ID_STRING to VALUE_STRING\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // changed JsonTokenId.ID_NUMBER_INT to VALUE_NUMBER_INT\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT: // changed JsonTokenId.ID_NUMBER_FLOAT to VALUE_NUMBER_FLOAT\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue(); // removed Double.valueOf()\n+        case VALUE_TRUE: // changed JsonTokenId.ID_TRUE to VALUE_TRUE\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // changed JsonTokenId.ID_FALSE to VALUE_FALSE\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // changed JsonTokenId.ID_NULL to VALUE_NULL\n             return null;\n         //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,54 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) { // changed getCurrentTokenId() to currentToken()\n+        case START_OBJECT: // changed JsonTokenId.ID_START_OBJECT to START_OBJECT\n+        case FIELD_NAME: // changed JsonTokenId.ID_FIELD_NAME to FIELD_NAME\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY: // changed JsonTokenId.ID_START_ARRAY to START_ARRAY\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // changed JsonTokenId.ID_EMBEDDED_OBJECT to VALUE_EMBEDDED_OBJECT\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // changed JsonTokenId.ID_STRING to VALUE_STRING\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // changed JsonTokenId.ID_NUMBER_INT to VALUE_NUMBER_INT\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT: // changed JsonTokenId.ID_NUMBER_FLOAT to VALUE_NUMBER_FLOAT\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue(); // removed Double.valueOf()\n+        case VALUE_TRUE: // changed JsonTokenId.ID_TRUE to VALUE_TRUE\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // changed JsonTokenId.ID_FALSE to VALUE_FALSE\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // changed JsonTokenId.ID_NULL to VALUE_NULL\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // updated to use currentToken()\n        case START_OBJECT:\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_STRING: // updated to use VALUE_* constants\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        case VALUE_EMBEDDED_OBJECT: // updated to use VALUE_* constant\n            return p.getEmbeddedObject();\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // updated to use currentToken()\n        case START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n        case FIELD_NAME:\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_STRING: // updated to use VALUE_* constants\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        case VALUE_EMBEDDED_OBJECT: // updated to use VALUE_* constant\n            return p.getEmbeddedObject();\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) { // updated to use currentToken()\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,39 +17,37 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n-            return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // updated to use VALUE_* constants\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        case VALUE_EMBEDDED_OBJECT: // updated to use VALUE_* constant\n+            return p.getEmbeddedObject();\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,55 +1,52 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) { // updated to use currentToken()\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n-            return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // updated to use VALUE_* constants\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        case VALUE_EMBEDDED_OBJECT: // updated to use VALUE_* constant\n+            return p.getEmbeddedObject();\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -50,6 +50,6 @@\n             return null;\n         //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -2,44 +2,45 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+        case JsonTokenId.ID_FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n+            }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n+            return p.getDoubleValue();\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -47,9 +48,7 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // updated method call to currentToken()\n        case START_OBJECT: // updated to use enum values instead of deprecated ID constants\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // updated to use enum value instead of deprecated ID constant\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getLongValue(); // updated to use getLongValue for integral types\n        case VALUE_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE: // updated to use enum value instead of deprecated ID constant\n            return Boolean.TRUE;\n        case VALUE_FALSE: // updated to use enum value instead of deprecated ID constant\n            return Boolean.FALSE;\n        case VALUE_NULL: // updated to use enum value instead of deprecated ID constant\n            return null;\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // updated method call to currentToken()\n        case START_OBJECT:\n            {\n                JsonToken t = p.nextToken(); // updated to use nextToken() method\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            // fall through to FIELD_NAME case\n        case FIELD_NAME:\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            {\n                JsonToken t = p.nextToken(); // updated to use nextToken() method\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // updated to use enum value instead of deprecated ID constant\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getLongValue(); // updated to use getLongValue for integral types\n        case VALUE_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue()); // updated to use valueOf instead of constructor\n        case VALUE_TRUE: // updated to use enum value instead of deprecated ID constant\n            return Boolean.TRUE;\n        case VALUE_FALSE: // updated to use enum value instead of deprecated ID constant\n            return Boolean.FALSE;\n        case VALUE_NULL: // updated to use enum value instead of deprecated ID constant\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case END_ARRAY: // commented out case that is unlikely to be used\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) { // updated method call to currentToken()\n+        case START_OBJECT: // updated to use enum values instead of deprecated ID constants\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,38 +17,36 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // updated to use enum value instead of deprecated ID constant\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n-            return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+            return p.getLongValue(); // updated to use getLongValue for integral types\n+        case VALUE_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE: // updated to use enum value instead of deprecated ID constant\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // updated to use enum value instead of deprecated ID constant\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // updated to use enum value instead of deprecated ID constant\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,53 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) { // updated method call to currentToken()\n+        case START_OBJECT: // updated to use enum values instead of deprecated ID constants\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // updated to use enum value instead of deprecated ID constant\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n-            return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+            return p.getLongValue(); // updated to use getLongValue for integral types\n+        case VALUE_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE: // updated to use enum value instead of deprecated ID constant\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // updated to use enum value instead of deprecated ID constant\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // updated to use enum value instead of deprecated ID constant\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // use currentToken() instead of getCurrentTokenId()\n        case START_OBJECT: // use enums instead of numeric ids\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // use VALUE_ prefix instead of ID_ prefix\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE: // use VALUE_ prefix instead of ID_ prefix\n            return Boolean.TRUE;\n        case VALUE_FALSE: // use VALUE_ prefix instead of ID_ prefix\n            return Boolean.FALSE;\n        case VALUE_NULL: // use VALUE_ prefix instead of ID_ prefix\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // use currentToken() instead of getCurrentTokenId()\n        case START_OBJECT: // use enums instead of numeric ids\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n        case FIELD_NAME:\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // use VALUE_ prefix instead of ID_ prefix\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case VALUE_TRUE: // use VALUE_ prefix instead of ID_ prefix\n            return Boolean.TRUE;\n        case VALUE_FALSE: // use VALUE_ prefix instead of ID_ prefix\n            return Boolean.FALSE;\n        case VALUE_NULL: // use VALUE_ prefix instead of ID_ prefix\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) { // use currentToken() instead of getCurrentTokenId()\n+        case START_OBJECT: // use enums instead of numeric ids\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,36 +17,35 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // use VALUE_ prefix instead of ID_ prefix\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE: // use VALUE_ prefix instead of ID_ prefix\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // use VALUE_ prefix instead of ID_ prefix\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // use VALUE_ prefix instead of ID_ prefix\n             return null;\n         //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,54 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) { // use currentToken() instead of getCurrentTokenId()\n+        case START_OBJECT: // use enums instead of numeric ids\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // use VALUE_ prefix instead of ID_ prefix\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE: // use VALUE_ prefix instead of ID_ prefix\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // use VALUE_ prefix instead of ID_ prefix\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // use VALUE_ prefix instead of ID_ prefix\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) {\n        case START_OBJECT:\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        //        case JsonToken.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) {\n        case START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n        case FIELD_NAME:\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,14 +17,14 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n@@ -33,7 +33,7 @@\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n@@ -41,14 +41,13 @@\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonToken.ID_END_ARRAY: // invalid\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,54 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+        case VALUE_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+        case VALUE_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonToken.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) {\n        case START_OBJECT:\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}\n\n## Fixed Function 2\n@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) {\n        case START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n        case FIELD_NAME:\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,14 +17,14 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n@@ -33,7 +33,7 @@\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n@@ -41,12 +41,11 @@\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n         //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,54 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+        case VALUE_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+        case VALUE_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]