{"org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.writeLocalFileHeader": {"buggy_content": "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}", "method_range": "1024-1038", "fault_locations": "1034"}, "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.createLocalFileHeader": {"buggy_content": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "method_range": "1041-1127", "fault_locations": "1073,1074,1075"}, "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.writeDataDescriptor": {"buggy_content": "protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}", "method_range": "1170-1183", "fault_locations": "1171"}, "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.versionNeededToExtract": {"buggy_content": "private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}", "method_range": "1482-1490", "fault_locations": "1488,1489"}, "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.usesDataDescriptor": {"buggy_content": "private boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && channel == null;\n}", "method_range": "1492-1494", "fault_locations": "1492,1493"}}