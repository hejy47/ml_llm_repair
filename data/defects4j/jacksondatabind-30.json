{"com.fasterxml.jackson.databind.ObjectMapper.valueToTree": {"buggy_content": "@SuppressWarnings({ \"unchecked\", \"resource\" })\npublic <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {\n    if (fromValue == null)\n        return null;\n    TokenBuffer buf = new TokenBuffer(this, false);\n    JsonNode result;\n    try {\n        writeValue(buf, fromValue);\n        JsonParser jp = buf.asParser();\n        result = readTree(jp);\n        jp.close();\n    } catch (IOException e) {\n        // should not occur, no real i/o...\n        throw new IllegalArgumentException(e.getMessage(), e);\n    }\n    return (T) result;\n}", "method_range": "2504-2520", "fault_locations": "2509,2510"}, "com.fasterxml.jackson.databind.ObjectMapper._convert": {"buggy_content": "@SuppressWarnings(\"resource\")\nprotected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {\n    // also, as per [Issue-11], consider case for simple cast\n        Class<?> targetType = toValueType.getRawClass();\n    if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) {\n        return fromValue;\n    }\n    // Then use TokenBuffer, which is a JsonGenerator:\n    TokenBuffer buf = new TokenBuffer(this, false);\n    try {\n        // inlined 'writeValue' with minor changes:\n        // first: disable wrapping when writing\n        SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n        // no need to check for closing of TokenBuffer\n        _serializerProvider(config).serializeValue(buf, fromValue);\n        // then matching read, inlined 'readValue' with minor mods:\n        final JsonParser jp = buf.asParser();\n        Object result;\n        // ok to pass in existing feature flags; unwrapping handled by mapper\n        final DeserializationConfig deserConfig = getDeserializationConfig();\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n            DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n            result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = null;\n        } else {\n            // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n            // note: no handling of unwarpping\n            result = deser.deserialize(jp, ctxt);\n        }\n        jp.close();\n        return result;\n    } catch (IOException e) {\n        // should not occur, no real i/o...\n        throw new IllegalArgumentException(e.getMessage(), e);\n    }\n}", "method_range": "3408-3455", "fault_locations": "3425,3426"}, "com.fasterxml.jackson.databind.util.TokenBuffer.TokenBuffer": {"buggy_content": "public TokenBuffer(JsonParser p, DeserializationContext ctxt) {\n    _objectCodec = p.getCodec();\n    _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n    _writeContext = JsonWriteContext.createRootContext(null);\n    // at first we have just one segment\n    _first = _last = new Segment();\n    _appendAt = 0;\n    _hasNativeTypeIds = p.canReadTypeId();\n    _hasNativeObjectIds = p.canReadObjectId();\n    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n}", "method_range": "177-188", "fault_locations": "187,188"}, "com.fasterxml.jackson.databind.util.TokenBuffer.copyCurrentEvent": {"buggy_content": "@Override\npublic void copyCurrentEvent(JsonParser p) throws IOException {\n    if (_mayHaveNativeIds) {\n        _checkNativeIds(p);\n    }\n    switch(p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch(p.getNumberType()) {\n                case INT:\n                    writeNumber(p.getIntValue());\n                    break;\n                case BIG_INTEGER:\n                    writeNumber(p.getBigIntegerValue());\n                    break;\n                default:\n                    writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n                        switch(p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n    }\n}", "method_range": "917-990", "fault_locations": "958,959,963,964,972,973"}}