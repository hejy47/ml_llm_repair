{"org.jfree.data.general.DatasetUtilities.iterateDomainBounds": {"buggy_content": "public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = intervalXYData.getStartXValue(series, item);\n                uvalue = intervalXYData.getEndXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getXValue(series, item);\n                uvalue = lvalue;\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    }\n    if (minimum > maximum) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}", "method_range": "740-785", "fault_locations": "754,755,756,757,758,759,760,761"}, "org.jfree.data.general.DatasetUtilities.iterateRangeBounds": {"buggy_content": "public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval) {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    // handle three cases by dataset type\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        // handle special case of IntervalXYDataset\n        IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double lvalue = ixyd.getStartYValue(series, item);\n                double uvalue = ixyd.getEndYValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else if (includeInterval && dataset instanceof OHLCDataset) {\n        // handle special case of OHLCDataset\n        OHLCDataset ohlc = (OHLCDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double lvalue = ohlc.getLowValue(series, item);\n                double uvalue = ohlc.getHighValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        // standard case - plain XYDataset\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double value = dataset.getYValue(series, item);\n                if (!Double.isNaN(value)) {\n                    minimum = Math.min(minimum, value);\n                    maximum = Math.max(maximum, value);\n                }\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}", "method_range": "1229-1289", "fault_locations": "1241,1242,1243,1244,1245,1246,1247,1248"}}