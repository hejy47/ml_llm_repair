{"com.google.javascript.jscomp.TypedScopeCreator.isQualifiedNameInferred": {"buggy_content": "private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n    if (valueType == null) {\n        return true;\n    }\n    // Prototype sets are always declared.\n    boolean inferred = true;\n    if (info != null) {\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n            return false;\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n            // Check if this is in a conditional block.\n            // Functions assigned in conditional blocks are inferred.\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                    return true;\n                }\n            }\n            // Check if this is assigned in an inner scope.\n            // Functions assigned in inner scopes are inferred.\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false;\n            }\n        }\n    }\n    return inferred;\n}", "method_range": "1661-1706", "fault_locations": "1668,1669"}, "com.google.javascript.jscomp.TypeInference.traverseObjectLiteral": {"buggy_content": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "method_range": "719-773", "fault_locations": "731,732,733,734,735,736"}}