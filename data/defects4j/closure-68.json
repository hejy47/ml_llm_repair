{"com.google.javascript.jscomp.parsing.JsDocInfoParser.parse": {"buggy_content": "boolean parse() {\n    int lineno;\n    int charno;\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token = next();\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo = extractBlockComment(token);\n        token = blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {\n            // Mark that there was a description, but don't bother marking\n            // what it was.\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    // Parse the actual JsDoc.\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state == State.SEARCHING_ANNOTATION) {\n                    state = State.SEARCHING_NEWLINE;\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                    String annotationName = stream.getString();\n                    Annotation annotation = annotationNames.get(annotationName);\n                    if (annotation == null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        // Mark the beginning of the annotation.\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                                    String author = authorInfo.string;\n                                    if (author.length() == 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token = authorInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                // Find the reason/description, if any.\n                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);\n                                String reason = reasonInfo.string;\n                                if (reason.length() > 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token = reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token = eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);\n                                    String description = descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token = descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview = \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview = fileOverviewInfo.string;\n                                    token = fileOverviewInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve = preserveInfo.string;\n                                if (preserve.length() > 0) {\n                                    if (fileLevelJsDocBuilder != null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token = preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                type = null;\n                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type == null) {\n                                    type = createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token = eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                boolean matchingRc = false;\n                                if (token == JsDocToken.LC) {\n                                    token = next();\n                                    matchingRc = true;\n                                }\n                                if (token == JsDocToken.STRING) {\n                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno = stream.getLineno();\n                                    charno = stream.getCharno();\n                                    typeNode = wrapNode(Token.BANG, typeNode);\n                                    if (typeNode != null && !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type = createJSTypeExpression(typeNode);\n                                    if (annotation == Annotation.EXTENDS) {\n                                        // record the extended type, check later\n                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                    } else {\n                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token = next();\n                                    if (matchingRc) {\n                                        if (token != JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token = eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc = false;\n                                if (match(JsDocToken.LC)) {\n                                    token = next();\n                                    matchingRc = true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token = next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc && !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);\n                                String meaning = meaningInfo.string;\n                                token = meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                type = null;\n                                if (token == JsDocToken.LC) {\n                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type == null) {\n                                        // parsing error reported during recursive descent\n                                        // recovering parsing\n                                        token = eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                // *Update* the token to that after the type annotation.\n                                token = current();\n                                // Save the throw type.\n                                jsdocBuilder.recordThrowType(type);\n                                // Find the throw's description (if applicable).\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);\n                                    String description = descriptionInfo.string;\n                                    if (description.length() > 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token = descriptionInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token = next();\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                type = null;\n                                if (token == JsDocToken.LC) {\n                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type == null) {\n                                        // parsing error reported during recursive descent\n                                        // recovering parsing\n                                        token = eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token = next();\n                                    lineno = stream.getLineno();\n                                    charno = stream.getCharno();\n                                }\n                                String name = null;\n                                boolean isBracketedParam = JsDocToken.LB == token;\n                                if (isBracketedParam) {\n                                    token = next();\n                                }\n                                if (JsDocToken.STRING != token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name = stream.getString();\n                                    if (isBracketedParam) {\n                                        token = next();\n                                        // Throw out JsDocToolkit's \"default\" parameter\n                                        // annotation.  It makes no sense under our type\n                                        // system.\n                                        if (JsDocToken.EQUALS == token) {\n                                            token = next();\n                                            if (JsDocToken.STRING == token) {\n                                                token = next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB != token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type != null) {\n                                            // Make the type expression optional, if it isn't\n                                            // already.\n                                            type = JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    // If the param name has a DOT in it, just throw it out\n                                    // quietly. We do not handle the JsDocToolkit method\n                                    // for handling properties of params.\n                                    if (name.indexOf('.') > -1) {\n                                        name = null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name == null) {\n                                    token = eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                // Find the parameter's description (if applicable).\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);\n                                    String paramDescription = paramDescriptionInfo.string;\n                                    if (paramDescription.length() > 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token = paramDescriptionInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token = parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                                    String reference = referenceInfo.string;\n                                    if (reference.length() == 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token = referenceInfo.token;\n                                } else {\n                                    token = eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token = parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo = extractSingleLineBlock();\n                                String templateTypeName = templateInfo.string;\n                                if (templateTypeName.length() == 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token = templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo = extractSingleLineBlock();\n                                String version = versionInfo.string;\n                                if (version.length() == 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token = versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                lineno = stream.getLineno();\n                                charno = stream.getCharno();\n                                Node typeNode = null;\n                                if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {\n                                    // If RETURN doesn't have a type annotation, record\n                                    // it as the unknown type.\n                                    typeNode = newNode(Token.QMARK);\n                                } else {\n                                    skipEOLs();\n                                    token = next();\n                                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                                }\n                                if (annotation == Annotation.THIS) {\n                                    typeNode = wrapNode(Token.BANG, typeNode);\n                                    if (typeNode != null && token != JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type = createJSTypeExpression(typeNode);\n                                if (type == null) {\n                                    // error reported during recursive descent\n                                    // recovering parsing\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            // Find the return's description (if applicable).\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);\n                                                String returnDescription = returnDescriptionInfo.string;\n                                                if (returnDescription.length() > 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token = returnDescriptionInfo.token;\n                                            } else {\n                                                token = eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token = eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n                }\n                checkExtendedTypes(extendedTypes);\n                return true;\n            case EOF:\n                // discard any accumulated information\n                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                checkExtendedTypes(extendedTypes);\n                return false;\n            case EOL:\n                if (state == State.SEARCHING_NEWLINE) {\n                    state = State.SEARCHING_ANNOTATION;\n                }\n                token = next();\n                continue retry;\n            default:\n                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n                    token = next();\n                    continue retry;\n                } else {\n                    state = State.SEARCHING_NEWLINE;\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        // next token\n        token = next();\n    }\n}", "method_range": "169-913", "fault_locations": "867,868,870"}, "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseBasicTypeExpression": {"buggy_content": "private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n        skipEOLs();\n        return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n        skipEOLs();\n        return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n        skipEOLs();\n        return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n        String string = stream.getString();\n        if (\"function\".equals(string)) {\n            skipEOLs();\n            return parseFunctionType(next());\n        } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n            return newStringNode(string);\n        } else {\n            return parseTypeName(token);\n        }\n    }\n    return reportGenericTypeSyntaxWarning();\n}", "method_range": "1685-1710", "fault_locations": "1707,1708"}, "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseFunctionType": {"buggy_content": "private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n        token = next();\n        boolean hasParams = true;\n        if (token == JsDocToken.STRING) {\n            String tokenStr = stream.getString();\n            boolean isThis = \"this\".equals(tokenStr);\n            boolean isNew = \"new\".equals(tokenStr);\n            if (isThis || isNew) {\n                if (match(JsDocToken.COLON)) {\n                    next();\n                    skipEOLs();\n                    Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next()));\n                    if (contextType == null) {\n                        return null;\n                    }\n                    functionType.addChildToFront(contextType);\n                } else {\n                    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n                }\n                if (match(JsDocToken.COMMA)) {\n                    next();\n                    skipEOLs();\n                    token = next();\n                } else {\n                    hasParams = false;\n                }\n            }\n        }\n        if (hasParams) {\n            parameters = parseParametersType(token);\n            if (parameters == null) {\n                return null;\n            }\n        }\n    }\n    if (parameters != null) {\n        functionType.addChildToBack(parameters);\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return null;\n    } else {\n        functionType.addChildToBack(resultType);\n    }\n    return functionType;\n}", "method_range": "1757-1826", "fault_locations": "1759,1760"}}