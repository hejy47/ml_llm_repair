{"com.google.javascript.jscomp.NodeTraversal.traverseFunction": {"buggy_content": "private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}", "method_range": "510-545", "fault_locations": "541"}, "com.google.javascript.jscomp.parsing.IRFactory.processFunctionNode": {"buggy_content": "@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "method_range": "609-673", "fault_locations": "666,667,669,670"}}