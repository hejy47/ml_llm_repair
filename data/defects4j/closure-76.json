{"com.google.javascript.jscomp.DeadAssignmentsElimination.isVariableStillLiveWithinExpression": {"buggy_content": "private boolean isVariableStillLiveWithinExpression(Node n, Node exprRoot, String variable) {\n    while (n != exprRoot) {\n        VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n        switch(n.getParent().getType()) {\n            case Token.OR:\n            case Token.AND:\n            // If the currently node is the first child of\n            // AND/OR, be conservative only consider the READs\n            // of the second operand.\n            case Token.HOOK:\n            // If current node is the condition, check each following\n            // branch, otherwise it is a conditional branch and the\n            // other branch can be ignored.\n            default:\n                for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {\n                    if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n                        state = isVariableReadBeforeKill(sibling, variable);\n                        // If we see a READ or KILL there is no need to continue.\n                        if (state == VariableLiveness.READ) {\n                            return true;\n                        } else if (state == VariableLiveness.KILL) {\n                            return false;\n                        }\n                    }\n                }\n        }\n        n = n.getParent();\n    }\n    return false;\n}", "method_range": "290-324", "fault_locations": "299,300,304,305,309,310,317,318,319"}, "com.google.javascript.jscomp.DeadAssignmentsElimination.isVariableReadBeforeKill": {"buggy_content": "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n        if (NodeUtil.isLhs(n, n.getParent())) {\n            Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n            // The expression to which the assignment is made is evaluated before\n            // the RHS is evaluated (normal left to right evaluation) but the KILL\n            // occurs after the RHS is evaluated.\n            Node rhs = n.getNext();\n            VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n            if (state == VariableLiveness.READ) {\n                return state;\n            }\n            return VariableLiveness.KILL;\n        } else {\n            return VariableLiveness.READ;\n        }\n    }\n    switch(n.getType()) {\n        // Conditionals\n        case Token.OR:\n        case Token.AND:\n        // With a AND/OR the first branch always runs, but the second is\n        // may not.\n        case Token.HOOK:\n            return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);\n        default:\n            // Expressions are evaluated left-right, depth first.\n            for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n                if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n                    // Not a FUNCTION\n                    VariableLiveness state = isVariableReadBeforeKill(child, variable);\n                    if (state != VariableLiveness.MAYBE_LIVE) {\n                        return state;\n                    }\n                }\n            }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n}", "method_range": "338-382", "fault_locations": "357,358,359,360,361,372,378"}}