{"com.google.javascript.jscomp.PeepholeFoldConstants.tryFoldTypeof": {"buggy_content": "private Node tryFoldTypeof(Node originalTypeofNode) {\n    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n    Node argumentNode = originalTypeofNode.getFirstChild();\n    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n        return originalTypeofNode;\n    }\n    String typeNameString = null;\n    switch(argumentNode.getType()) {\n        case Token.STRING:\n            typeNameString = \"string\";\n            break;\n        case Token.NUMBER:\n            typeNameString = \"number\";\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            typeNameString = \"boolean\";\n            break;\n        case Token.NULL:\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n            typeNameString = \"object\";\n            break;\n        case Token.NAME:\n            // We assume here that programs don't change the value of the\n            // keyword undefined to something other than the value undefined.\n            if (\"undefined\".equals(argumentNode.getString())) {\n                typeNameString = \"undefined\";\n            }\n            break;\n    }\n    if (typeNameString != null) {\n        Node newNode = Node.newString(typeNameString);\n        originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n        reportCodeChange();\n        return newNode;\n    }\n    return originalTypeofNode;\n}", "method_range": "156-200", "fault_locations": "181,182"}, "com.google.javascript.jscomp.SourceMap.LineMapper": {"buggy_content": "LineMapper(Appendable out) {\n    this.out = out;\n}", "method_range": "353-355", "fault_locations": "355"}, "com.google.javascript.jscomp.SourceMap.appendTo": {"buggy_content": "void appendTo(Appendable out) throws IOException {\n    out.append(\"[\");\n    out.append(sourceFile);\n    // The source file rarely changes, so cache the escaped string.\n    out.append(\",\");\n    out.append(String.valueOf(originalPosition.getLineNumber()));\n    out.append(\",\");\n    out.append(String.valueOf(originalPosition.getCharacterIndex()));\n    if (originalName != null) {\n        out.append(\",\");\n        out.append(originalName);\n    }\n    out.append(\"]\");\n}", "method_range": "93-113", "fault_locations": "93,94,95,96,97,98,99,100,101,102,103,105,106,107,109,112"}, "com.google.javascript.jscomp.SourceMap.addMapping": {"buggy_content": "void addMapping(Node node, Position startPosition, Position endPosition) {\n    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n        return;\n    }\n    String escapedSourceFile;\n    if (lastSourceFile != sourceFile) {\n        // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n        lastSourceFile = sourceFile;\n        lastSourceFileEscaped = escapeString(sourceFile);\n    }\n    escapedSourceFile = lastSourceFileEscaped;\n    // Create the new mapping.\n    Mapping mapping = new Mapping();\n    mapping.id = mappings.size();\n    mapping.sourceFile = escapedSourceFile;\n    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n    if (originalName != null) {\n        mapping.originalName = escapeString(originalName);\n    }\n    // If the mapping is found on the first line, we need to offset\n    // its character position by the number of characters found on\n    // the *last* line of the source file to which the code is\n    // being generated.\n    int offsetLine = offsetPosition.getLineNumber();\n    int startOffsetPosition = offsetPosition.getCharacterIndex();\n    int endOffsetPosition = offsetPosition.getCharacterIndex();\n    if (startPosition.getLineNumber() > 0) {\n        startOffsetPosition = 0;\n    }\n    if (endPosition.getLineNumber() > 0) {\n        endOffsetPosition = 0;\n    }\n    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);\n    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);\n    mappings.add(mapping);\n}", "method_range": "153-205", "fault_locations": "154,155,158,159,160,161,163,164,165,166,167,168,171,172,177,183,184"}, "com.google.javascript.jscomp.SourceMap.findLastLine": {"buggy_content": "private int findLastLine() {\n    int maxLine = 0;\n    for (Mapping mapping : mappings) {\n        int endPositionLine = mapping.endPosition.getLineNumber();\n        maxLine = Math.max(maxLine, endPositionLine);\n    }\n    return maxLine + prefixPosition.getLineNumber();\n}", "method_range": "257-264", "fault_locations": "257,258,259,260,261,262,263,264"}, "com.google.javascript.jscomp.SourceMap.appendTo4": {"buggy_content": "public void appendTo(Appendable out, String name) throws IOException {\n    // Write the mappings out to the file. The format of the generated\n    // source map is three sections, each deliminated by a magic comment.\n    //\n    // The first section contains an array for each line of the generated\n    // code, where each element in the array is the ID of the mapping which\n    // best represents the index-th character found on that line of the\n    // generated source code.\n    //\n    // The second section contains an array per generated line. Unused.\n    //\n    // The third and final section contains an array per line, each of which\n    // represents a mapping with a unique ID. The mappings are added in order.\n    // The array itself contains a tuple representing\n    // ['source file', line, col (, 'original name')]\n    //\n    // Example for 2 lines of generated code (with line numbers added for\n    // readability):\n    //\n    // 1)      // 5)  []\n    // 6)  []\n    // 7)      // 8)  [\"a.js\", 1, 34]\n    // 9)  [\"a.js\", 5, 2]\n    // 10) [\"b.js\", 1, 3, \"event\"]\n    // 11) [\"c.js\", 1, 4]\n    // 12) [\"d.js\", 3, 78, \"foo\"]\n    int maxLine = findLastLine();\n    // Add the line character maps.\n    out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n    out.append(escapeString(name));\n    out.append(\", \\\"count\\\": \");\n    out.append(String.valueOf(maxLine + 1));\n    out.append(\" }\\n\");\n    (new LineMapper(out)).appendLineMappings();\n    // Add the source file maps.\n    out.append(\"/** Begin file information. **/\\n\");\n    // This section is unused but we need one entry per line to\n    // prevent changing the format.\n    for (int i = 0; i <= maxLine; ++i) {\n        out.append(\"[]\\n\");\n    }\n    // Add the mappings themselves.\n    out.append(\"/** Begin mapping definitions. **/\\n\");\n    for (Mapping mapping : mappings) {\n        mapping.appendTo(out);\n        out.append(\"\\n\");\n    }\n}", "method_range": "272-330", "fault_locations": "276,277,297,298,302,303,304,305,306,307,308,309,310,311,315,316,323,324,325,326,327,328,329"}, "com.google.javascript.jscomp.SourceMap.appendLineMappings": {"buggy_content": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n                                // The last line and column written\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they encountered.\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        writeClosedMapping(m);\n    }\n    closeLine();\n}", "method_range": "367-444", "fault_locations": "368,369,373,374,375,376,377,378,389,390,394,395,402,403,426,432,441,442,443,444"}, "com.google.javascript.jscomp.SourceMap.openLine": {"buggy_content": "private void openLine() throws IOException {\n    out.append(\"[\");\n    this.firstChar = true;\n}", "method_range": "445-448", "fault_locations": "445,446,447,448"}, "com.google.javascript.jscomp.SourceMap.closeLine": {"buggy_content": "private void closeLine() throws IOException {\n    out.append(\"]\\n\");\n}", "method_range": "449-451", "fault_locations": "449,450,451"}, "com.google.javascript.jscomp.SourceMap.addCharEntry": {"buggy_content": "private void addCharEntry(String id) throws IOException {\n    if (firstChar) {\n        firstChar = false;\n    } else {\n        out.append(\",\");\n    }\n    out.append(id);\n}", "method_range": "452-459", "fault_locations": "452,453,454,455,456,458,459"}, "com.google.javascript.jscomp.SourceMap.getAdjustedLine": {"buggy_content": "private int getAdjustedLine(Position p) {\n    return p.getLineNumber() + prefixPosition.getLineNumber();\n}", "method_range": "464-466", "fault_locations": "464,466"}, "com.google.javascript.jscomp.SourceMap.writeClosedMapping": {"buggy_content": "private void writeClosedMapping(Mapping m) throws IOException {\n    int nextLine = getAdjustedLine(m.endPosition);\n    int nextCol = getAdjustedCol(m.endPosition);\n    // If this anything remaining in this mapping beyond the\n    // current line and column position, write it out now.\n    if (line < nextLine || (line == nextLine && col < nextCol)) {\n        writeCharsUpTo(nextLine, nextCol, m.id);\n    }\n}", "method_range": "496-504", "fault_locations": "496,502"}, "com.google.javascript.jscomp.SourceMap.writeCharsBetween": {"buggy_content": "private void writeCharsBetween(Mapping prev, Mapping next) throws IOException {\n    int nextLine = getAdjustedLine(next.startPosition);\n    int nextCol = getAdjustedCol(next.startPosition);\n    // If the previous value is null, no mapping exists.\n    int id = (prev != null) ? prev.id : UNMAPPED;\n    writeCharsUpTo(nextLine, nextCol, id);\n}", "method_range": "509-516", "fault_locations": "509,511,512,514,515"}, "com.google.javascript.jscomp.SourceMap.writeCharsUpTo": {"buggy_content": "private void writeCharsUpTo(int nextLine, int nextCol, int id) throws IOException {\n    Preconditions.checkState(line <= nextLine, \"\");\n    Preconditions.checkState(line < nextLine || col <= nextCol);\n    if (line == nextLine && col == nextCol) {\n        // Nothing to do.\n        return;\n    }\n    String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n    for (int i = line; i <= nextLine; i++) {\n        if (i == nextLine) {\n            for (int j = col; j < nextCol; j++) {\n                addCharEntry(idString);\n            }\n            break;\n        }\n        closeLine();\n        openLine();\n    }\n    line = nextLine;\n    col = nextCol;\n}", "method_range": "522-547", "fault_locations": "522,523,525,526,533,534,535,536,537,538,539,540,541,542,543"}}