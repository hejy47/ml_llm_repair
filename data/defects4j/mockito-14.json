{"org.mockito.internal.MockHandler.handle": {"buggy_content": "public Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n    mockingProgress.validateState();\n    //if verificationMode is not null then someone is doing verify()\n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock\n        // - see VerifyingWithAnExtraCallToADifferentMockTest\n        VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);\n        verificationMode.verify(data);\n        return null;\n    }\n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}", "method_range": "57-101", "fault_locations": "75,76,78,79"}, "org.mockito.internal.MockitoCore.verify": {"buggy_content": "public <T> T verify(T mock, VerificationMode mode) {\n    if (mock == null) {\n        reporter.nullPassedToVerify();\n    } else if (!mockUtil.isMock(mock)) {\n        reporter.notAMockPassedToVerify();\n    }\n    mockingProgress.verificationStarted(mode);\n    return mock;\n}", "method_range": "67-75", "fault_locations": "73"}}