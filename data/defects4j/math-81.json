{"org.apache.commons.math.linear.EigenDecompositionImpl.computeGershgorinCircles": {"buggy_content": "private void computeGershgorinCircles() {\n    final int m = main.length;\n    final int lowerStart = 4 * m;\n    final int upperStart = 5 * m;\n    lowerSpectra = Double.POSITIVE_INFINITY;\n    upperSpectra = Double.NEGATIVE_INFINITY;\n    double eMax = 0;\n    double eCurrent = 0;\n    for (int i = 0; i < m - 1; ++i) {\n        final double dCurrent = main[i];\n        final double ePrevious = eCurrent;\n        eCurrent = Math.abs(secondary[i]);\n        eMax = Math.max(eMax, eCurrent);\n        final double radius = ePrevious + eCurrent;\n        final double lower = dCurrent - radius;\n        work[lowerStart + i] = lower;\n        lowerSpectra = Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + radius;\n        work[upperStart + i] = upper;\n        upperSpectra = Math.max(upperSpectra, upper);\n    }\n    final double dCurrent = main[m - 1];\n    final double lower = dCurrent - eCurrent;\n    work[lowerStart + m - 1] = lower;\n    lowerSpectra = Math.min(lowerSpectra, lower);\n    final double upper = dCurrent + eCurrent;\n    work[upperStart + m - 1] = upper;\n    minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n}", "method_range": "569-605", "fault_locations": "602,603"}, "org.apache.commons.math.linear.EigenDecompositionImpl.processGeneralBlock": {"buggy_content": "private void processGeneralBlock(final int n) throws InvalidMatrixException {\n    // check decomposed matrix data range\n    double sumOffDiag = 0;\n    for (int i = 0; i < n - 1; ++i) {\n        final int fourI = 4 * i;\n        final double ei = work[fourI + 2];\n        sumOffDiag += ei;\n    }\n    if (sumOffDiag == 0) {\n        // matrix is already diagonal\n        return;\n    }\n    // initial checks for splits (see Parlett & Marques section 3.3)\n    flipIfWarranted(n, 2);\n    // two iterations with Li's test for initial splits\n    initialSplits(n);\n    // initialize parameters used by goodStep\n    tType = 0;\n    dMin1 = 0;\n    dMin2 = 0;\n    dN = 0;\n    dN1 = 0;\n    dN2 = 0;\n    tau = 0;\n    // process split segments\n    int i0 = 0;\n    int n0 = n;\n    while (n0 > 0) {\n        // retrieve shift that was temporarily stored as a negative off-diagonal element\n        sigma = (n0 == n) ? 0 : -work[4 * n0 - 2];\n        sigmaLow = 0;\n        // find start of a new split segment to process\n        double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n        double offDiagMax = 0;\n        double diagMax = work[4 * n0 - 4];\n        double diagMin = diagMax;\n        i0 = 0;\n        for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n            if (work[i + 2] <= 0) {\n                i0 = 1 + i / 4;\n                break;\n            }\n            if (diagMin >= 4 * offDiagMax) {\n                diagMin = Math.min(diagMin, work[i + 4]);\n                offDiagMax = Math.max(offDiagMax, work[i + 2]);\n            }\n            diagMax = Math.max(diagMax, work[i] + work[i + 2]);\n            offDiagMin = Math.min(offDiagMin, work[i + 2]);\n        }\n        work[4 * n0 - 2] = offDiagMin;\n        // lower bound of Gershgorin disk\n        dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n        pingPong = 0;\n        int maxIter = 30 * (n0 - i0);\n        for (int k = 0; i0 < n0; ++k) {\n            if (k >= maxIter) {\n                throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n            }\n            // perform one step\n            n0 = goodStep(i0, n0);\n            pingPong = 1 - pingPong;\n            // check for new splits after \"ping\" steps\n            // when the last elements of qd array are very small\n            if ((pingPong == 0) && (n0 - i0 > 3) && (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) && (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n                int split = i0 - 1;\n                diagMax = work[4 * i0];\n                offDiagMin = work[4 * i0 + 2];\n                double previousEMin = work[4 * i0 + 3];\n                for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n                    if ((work[i + 3] <= TOLERANCE_2 * work[i]) && (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                        // insert a split\n                        work[i + 2] = -sigma;\n                        split = i / 4;\n                        diagMax = 0;\n                        offDiagMin = work[i + 6];\n                        previousEMin = work[i + 7];\n                    } else {\n                        diagMax = Math.max(diagMax, work[i + 4]);\n                        offDiagMin = Math.min(offDiagMin, work[i + 2]);\n                        previousEMin = Math.min(previousEMin, work[i + 3]);\n                    }\n                }\n                work[4 * n0 - 2] = offDiagMin;\n                work[4 * n0 - 1] = previousEMin;\n                i0 = split + 1;\n            }\n        }\n    }\n}", "method_range": "822-928", "fault_locations": "905,906"}, "org.apache.commons.math.linear.EigenDecompositionImpl.computeShiftIncrement": {"buggy_content": "private void computeShiftIncrement(final int start, final int end, final int deflated) {\n    final double cnst1 = 0.563;\n    final double cnst2 = 1.010;\n    final double cnst3 = 1.05;\n    // a negative dMin forces the shift to take that absolute value\n    // tType records the type of shift.\n    if (dMin <= 0.0) {\n        tau = -dMin;\n        tType = -1;\n        return;\n    }\n    int nn = 4 * end + pingPong - 1;\n    switch(deflated) {\n        case // no realEigenvalues deflated.\n        0:\n            if (dMin == dN || dMin == dN1) {\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5] > work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4] > work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9] > work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n                }\n            } else if (dMin == dN2) {\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n            } else {\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau = g * dMin;\n                tType = -6;\n            }\n            break;\n        case // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n        1:\n            if (dMin1 == dN1 && dMin2 == dN2) {\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n        case // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n        2:\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n        default:\n            // case 12, more than two realEigenvalues deflated. no information.\n            tau = 0.0;\n            tType = -12;\n    }\n}", "method_range": "1430-1672", "fault_locations": "1543"}}