{"com.fasterxml.jackson.core.json.ReaderBasedJsonParser._parseNumber": {"buggy_content": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n                    }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n                // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "method_range": "846-959", "fault_locations": "951,952"}, "com.fasterxml.jackson.core.json.ReaderBasedJsonParser._parseNumber2": {"buggy_content": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "method_range": "968-1085", "fault_locations": "1080,1081"}, "com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseNumber": {"buggy_content": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        end = _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "method_range": "1184-1247", "fault_locations": "1243,1244"}, "com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parserNumber2": {"buggy_content": "private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException {\n    // Ok, parse the rest\n    while (true) {\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _textBuffer.setCurrentLength(outPtr);\n            return resetInt(negative, intPartLength);\n        }\n        int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c > INT_9 || c < INT_0) {\n            if (c == '.' || c == 'e' || c == 'E') {\n                return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n            }\n            break;\n        }\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        ++intPartLength;\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intPartLength);\n}", "method_range": "1253-1284", "fault_locations": "1279,1280"}, "com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseFloat": {"buggy_content": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "method_range": "1323-1412", "fault_locations": "1406,1407"}, "com.fasterxml.jackson.core.json.UTF8StreamJsonParser._skipWSOrEnd": {"buggy_content": "private int _skipWSOrEnd() throws IOException {\n    final int[] codes = _icWS;\n    while ((_inputPtr < _inputEnd) || loadMore()) {\n        final int i = _inputBuffer[_inputPtr++] & 0xFF;\n        switch(codes[i]) {\n            case // done!\n            0:\n                return i;\n            case // skip\n            1:\n                continue;\n            case // 2-byte UTF\n            2:\n                _skipUtf8_2(i);\n                break;\n            case // 3-byte UTF\n            3:\n                _skipUtf8_3(i);\n                break;\n            case // 4-byte UTF\n            4:\n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default:\n                // e.g. -1\n                if (i < 32) {\n                    _throwInvalidSpace(i);\n                }\n                _reportInvalidChar(i);\n        }\n    }\n    // We ran out of input...\n    _handleEOF();\n    return -1;\n}", "method_range": "2540-2584", "fault_locations": "2575,2576,2577"}}