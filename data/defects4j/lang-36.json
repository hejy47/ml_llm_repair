{"org.apache.commons.lang3.math.NumberUtils.createNumber": {"buggy_content": "//-----------------------------------------------------------------------\n// must handle Long, Float, Integer, Float, Short,\n//                  BigDecimal, BigInteger and Byte\n// useful methods:\n// Byte.decode(String)\n// Byte.valueOf(String,int radix)\n// Byte.valueOf(String)\n// Double.valueOf(String)\n// Float.valueOf(String)\n// new Float(String)\n// Integer.valueOf(String,int radix)\n// Integer.valueOf(String)\n// Integer.decode(String)\n// Integer.getInteger(String)\n// Integer.getInteger(String,int val)\n// Integer.getInteger(String,Integer val)\n// new Integer(String)\n// new Double(String)\n// new Byte(String)\n// new Long(String)\n// Long.getLong(String)\n// Long.getLong(String,int)\n// Long.getLong(String,Integer)\n// Long.valueOf(String,int)\n// Long.valueOf(String)\n// new Short(String)\n// Short.decode(String)\n// Short.valueOf(String,int)\n// Short.valueOf(String)\n// new BigDecimal(String)\n// new BigInteger(String)\n// new BigInteger(String,int radix)\n// Possible inputs:\n// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n// plus minus everything. Prolly more. A lot are not separable.\npublic static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear\n        // to be in specification of class. OS X Java parses it to\n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }\n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch(lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            case 'd':\n            case 'D':\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n            //$FALL-THROUGH$\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigDecimal(str);\n        }\n    }\n}", "method_range": "448-595", "fault_locations": "491"}, "org.apache.commons.lang3.math.NumberUtils.isNumber": {"buggy_content": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    // deal with any possible sign up front\n    int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                // str == \"0x\"\n                return false;\n            }\n            // checking hex (it can't be anything else)\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    // don't want to loop to the last char, check it afterwords\n    sz--;\n    // for type qualifiers\n    int i = start;\n    // loop to the next to last char or to the last char if we need another digit to\n    // make a valid number (e.g. chars[0..5] = \"1234E\")\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            // we've already taken care of hex.\n            if (hasExp) {\n                // two E's\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            // we need a digit after the E\n            foundDigit = false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            // no type qualifier, OK\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            // can't have an E at the last byte\n            return false;\n        }\n        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l' || chars[i] == 'L') {\n            // not allowing L with an exponent\n            return foundDigit && !hasExp;\n        }\n        // last character is illegal\n        return false;\n    }\n    // allowSigns is true iff the val ends in 'E'\n    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n    return !allowSigns && foundDigit;\n}", "method_range": "1312-1406", "fault_locations": "1386,1387"}}