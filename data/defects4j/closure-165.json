{"com.google.javascript.rhino.jstype.JSTypeRegistry.canPropertyBeDefined": {"buggy_content": "public boolean canPropertyBeDefined(JSType type, String propertyName) {\n    if (typesIndexedByProperty.containsKey(propertyName)) {\n        for (JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) {\n            JSType greatestSubtype = alt.getGreatestSubtype(type);\n            if (!greatestSubtype.isEmptyType()) {\n                // We've found a type with this property. Now we just have to make\n                // sure it's not a type used for internal bookkeeping.\n                return true;\n            }\n        }\n    }\n    return false;\n}", "method_range": "690-704", "fault_locations": "697,698"}, "com.google.javascript.rhino.jstype.RecordTypeBuilder.build": {"buggy_content": "public JSType build() {\n    // If we have an empty record, simply return the object type.\n    if (isEmpty) {\n        return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n    }\n    return new RecordType(registry, Collections.unmodifiableMap(properties));\n}", "method_range": "85-93", "fault_locations": "92"}, "com.google.javascript.rhino.jstype.RecordType.RecordType": {"buggy_content": "RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n    super(registry, null, null);\n    setPrettyPrint(true);\n    for (String property : properties.keySet()) {\n        RecordProperty prop = properties.get(property);\n        if (prop == null) {\n            throw new IllegalStateException(\"RecordProperty associated with a property should not be null!\");\n        }\n        defineDeclaredProperty(property, prop.getType(), prop.getPropertyNode());\n    }\n    // Freeze the record type.\n    isFrozen = true;\n}", "method_range": "83-99", "fault_locations": "83,84,85,91,92,93,94"}, "com.google.javascript.rhino.jstype.RecordType.getGreatestSubtypeHelper": {"buggy_content": "JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n        RecordType thatRecord = that.toMaybeRecordType();\n        RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n        // The greatest subtype consists of those *unique* properties of both\n        // record types. If any property conflicts, then the NO_TYPE type\n        // is returned.\n        for (String property : properties.keySet()) {\n            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property))) {\n                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n            }\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\n        }\n        for (String property : thatRecord.properties.keySet()) {\n            if (!hasProperty(property)) {\n                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));\n            }\n        }\n        return builder.build();\n    }\n    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n        // In this branch, the other type is some object type. We find\n        // the greatest subtype with the following algorithm:\n        // 1) For each property \"x\" of this record type, take the union\n        //    of all classes with a property \"x\" with a compatible property type.\n        //    and which are a subtype of {@code that}.\n        // 2) Take the intersection of all of these unions.\n        for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n            String propName = entry.getKey();\n            JSType propType = entry.getValue();\n            UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {\n                JSType altPropType = alt.getPropertyType(propName);\n                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {\n                    builder.addAlternate(alt);\n                }\n            }\n            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n        }\n    }\n    return greatestSubtype;\n}", "method_range": "148-207", "fault_locations": "150,151"}}