{"org.jsoup.nodes.Entities.unescape": {"buggy_content": "static String unescape(String string, boolean strict) {\n    if (!string.contains(\"&\"))\n        return string;\n    Matcher m = strict ? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string);\n    StringBuffer accum = new StringBuffer(string.length());\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n        if (charval != -1 || charval > 0xFFFF) {\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}", "method_range": "102-130", "fault_locations": "103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129"}, "org.jsoup.parser.Tokeniser.consumeCharacterReference": {"buggy_content": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (// named with semicolon\n            looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "method_range": "100-164", "fault_locations": "136,137,138,139,140,141,142,143,144,145,146,147,152"}, "org.jsoup.parser.Tokeniser.currentNodeInHtmlNS": {"buggy_content": "boolean currentNodeInHtmlNS() {\n    // todo: implement namespaces correctly\n    return true;\n    // Element currentNode = currentNode();\n    // return currentNode != null && currentNode.namespace().equals(\"HTML\");\n}", "method_range": "226-231", "fault_locations": "226,227"}}