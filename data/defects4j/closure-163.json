{"com.google.javascript.jscomp.AnalyzePrototypeProperties.ProcessProperties": {"buggy_content": "private ProcessProperties() {\n    symbolStack.push(new NameContext(globalNode));\n}", "method_range": "201-203", "fault_locations": "201,202,203"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.GlobalFunction": {"buggy_content": "GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {\n    Preconditions.checkState(parent.isVar() || NodeUtil.isFunctionDeclaration(parent));\n    this.nameNode = nameNode;\n    this.module = module;\n}", "method_range": "518-524", "fault_locations": "518"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.AssignmentProperty": {"buggy_content": "AssignmentProperty(Node node, JSModule module) {\n    this.exprNode = node;\n    this.module = module;\n}", "method_range": "581-584", "fault_locations": "581,582,583,584"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.LiteralProperty": {"buggy_content": "LiteralProperty(Node key, Node value, Node map, Node assign, JSModule module) {\n    this.key = key;\n    this.value = value;\n    this.map = map;\n    this.assign = assign;\n    this.module = module;\n}", "method_range": "625-632", "fault_locations": "626"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.NameContext": {"buggy_content": "NameContext(NameInfo name) {\n    this.name = name;\n}", "method_range": "667-669", "fault_locations": "667"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.enterScope": {"buggy_content": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // NOTE(nicksantos): We use the same anonymous node for all\n    // functions that do not have reasonable names. I can't remember\n    // at the moment why we do this. I think it's because anonymous\n    // nodes can never have in-edges. They're just there as a placeholder\n    // for scope information, and do not matter in the edge propagation.\n}", "method_range": "204-212", "fault_locations": "206,207,208,211,212"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.exitScope": {"buggy_content": "@Override\npublic void exitScope(NodeTraversal t) {\n}", "method_range": "214-217", "fault_locations": "216,217"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.shouldTraverse": {"buggy_content": "@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    // Process prototype assignments to non-functions.\n    if (isPrototypePropertyAssign(n)) {\n        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n    } else if (isGlobalFunctionDeclaration(t, n)) {\n        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n    } else if (n.isFunction()) {\n        symbolStack.push(new NameContext(anonymousNode));\n    }\n    return true;\n}", "method_range": "219-234", "fault_locations": "222,223,224,225,226,227,228,229,230,231,232,233"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.visit": {"buggy_content": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isGetProp()) {\n        String propName = n.getFirstChild().getNext().getString();\n        if (propName.equals(\"prototype\")) {\n            processPrototypeParent(t, parent);\n        } else if (compiler.getCodingConvention().isExported(propName)) {\n            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n        } else {\n            // Do not mark prototype prop assigns as a 'use' in the global scope.\n            addSymbolUse(propName, t.getModule(), PROPERTY);\n        }\n    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n    // assigned to a prototype, as in:\n    // Foo.prototype = {bar: 3, baz: 5};\n    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n        // var x = {a: 1, b: 2}\n        // should count as a use of property a and b.\n        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n            if (!propNameNode.isQuotedString()) {\n                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n            }\n        }\n    } else if (n.isName()) {\n        String name = n.getString();\n        Var var = t.getScope().getVar(name);\n        if (var != null) {\n            // Only process global functions.\n            if (var.isGlobal()) {\n                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n                    if (t.inGlobalScope()) {\n                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n                        }\n                    } else {\n                        addSymbolUse(name, t.getModule(), VAR);\n                    }\n                }\n                // If it is not a global, it might be accessing a local of the outer\n                // scope. If that's the case the functions between the variable's\n                // declaring scope and the variable reference scope cannot be moved.\n            } else if (var.getScope() != t.getScope()) {\n                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n                    NameContext context = symbolStack.get(i);\n                    if (context.scope == var.getScope()) {\n                        break;\n                    }\n                    context.name.readClosureVariables = true;\n                }\n            }\n        }\n    }\n    // Process prototype assignments to non-functions.\n    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n        symbolStack.pop();\n    }\n}", "method_range": "236-309", "fault_locations": "236,242,247,250,254,255,256,257,278,279,280,302,303,304,305,306"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.addSymbolUse": {"buggy_content": "private void addSymbolUse(String name, JSModule module, SymbolType type) {\n    NameInfo info = getNameInfoForName(name, type);\n    NameInfo def = null;\n    // Skip all anonymous nodes. We care only about symbols with names.\n    for (int i = symbolStack.size() - 1; i >= 0; i--) {\n        def = symbolStack.get(i).name;\n        if (def != anonymousNode) {\n            break;\n        }\n    }\n    if (!def.equals(info)) {\n        symbolGraph.connect(def, module, info);\n    }\n}", "method_range": "311-324", "fault_locations": "311,312,316,317,324"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.isGlobalFunctionDeclaration": {"buggy_content": "private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n    // Make sure we're either in the global scope, or the function\n    // we're looking at is the root of the current local scope.\n    return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName());\n}", "method_range": "335-343", "fault_locations": "335,336,337,339,340,341,342"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.isPrototypePropertyAssign": {"buggy_content": "private boolean isPrototypePropertyAssign(Node assign) {\n    Node n = assign.getFirstChild();\n    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) {\n        boolean isChainedProperty = n.getFirstChild().isGetProp();\n                if (isChainedProperty) {\n            Node child = n.getFirstChild().getFirstChild().getNext();\n            if (child.isString() && child.getString().equals(\"prototype\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "method_range": "348-375", "fault_locations": "348,349,350,351,352,353,354,363,364,365,366,367,368,369,370,374"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.processGlobalFunctionDeclaration": {"buggy_content": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "method_range": "381-404", "fault_locations": "382,392,393,395,396,398,399"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.processPrototypeParent": {"buggy_content": "private void processPrototypeParent(NodeTraversal t, Node n) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n            Node dest = n.getFirstChild().getNext();\n            Node parent = n.getParent();\n            Node grandParent = parent.getParent();\n            if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n                String name = dest.getString();\n                Property prop = new AssignmentProperty(grandParent, t.getModule());\n                getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n            Node map = n.getFirstChild().getNext();\n            if (map.isObjectLit()) {\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    // May be STRING, GET, or SET,\n                    String name = key.getString();\n                    Property prop = new LiteralProperty(key, key.getFirstChild(), map, n, t.getModule());\n                    getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n                }\n            }\n            break;\n    }\n}", "method_range": "412-448", "fault_locations": "412"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.addGlobalUseOfSymbol": {"buggy_content": "private void addGlobalUseOfSymbol(String name, JSModule module, SymbolType type) {\n    symbolGraph.connect(globalNode, module, getNameInfoForName(name, type));\n}", "method_range": "450-453", "fault_locations": "450"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.traverseEdge": {"buggy_content": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            return dest.markReference(startModule);\n        } else {\n            return dest.markReference(edge);\n        }\n    }\n    return false;\n}", "method_range": "468-480", "fault_locations": "468,469,472,473,476,477,478"}, "com.google.javascript.jscomp.AnalyzePrototypeProperties.remove": {"buggy_content": "@Override\npublic void remove() {\n    Node parent = nameNode.getParent();\n    if (parent.isFunction() || parent.hasOneChild()) {\n        NodeUtil.removeChild(parent.getParent(), parent);\n    } else {\n        Preconditions.checkState(parent.isVar());\n        parent.removeChild(nameNode);\n    }\n}", "method_range": "526-536", "fault_locations": "526,530,531,532,535,536"}, "com.google.javascript.jscomp.CrossModuleMethodMotion.moveMethods": {"buggy_content": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "method_range": "96-196", "fault_locations": "140,141"}}