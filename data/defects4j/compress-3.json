{"org.apache.commons.compress.archivers.tar.TarArchiveOutputStream.finish": {"buggy_content": "public void finish() throws IOException {\n    writeEOFRecord();\n    writeEOFRecord();\n}", "method_range": "111-114", "fault_locations": "111,112"}, "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream.putArchiveEntry": {"buggy_content": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n    TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n    if (entry.getName().length() >= TarConstants.NAMELEN) {\n        if (longFileMode == LONGFILE_GNU) {\n            // create a TarEntry for the LongLink, the contents\n            // of which are the entry's name\n            TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME);\n            // TODO is it correct to use the default charset here?\n            final byte[] nameBytes = entry.getName().getBytes();\n            // +1 for NUL\n            longLinkEntry.setSize(nameBytes.length + 1);\n            putArchiveEntry(longLinkEntry);\n            write(nameBytes);\n            // NUL terminator\n            write(0);\n            closeArchiveEntry();\n        } else if (longFileMode != LONGFILE_TRUNCATE) {\n            throw new RuntimeException(\"file name '\" + entry.getName() + \"' is too long ( > \" + TarConstants.NAMELEN + \" bytes)\");\n        }\n    }\n    entry.writeEntryHeader(recordBuf);\n    buffer.writeRecord(recordBuf);\n    currBytes = 0;\n    if (entry.isDirectory()) {\n        currSize = 0;\n    } else {\n        currSize = entry.getSize();\n    }\n    currName = entry.getName();\n}", "method_range": "153-187", "fault_locations": "186,187"}, "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream.closeArchiveEntry": {"buggy_content": "public void closeArchiveEntry() throws IOException {\n    if (assemLen > 0) {\n        for (int i = assemLen; i < assemBuf.length; ++i) {\n            assemBuf[i] = 0;\n        }\n        buffer.writeRecord(assemBuf);\n        currBytes += assemLen;\n        assemLen = 0;\n    }\n    if (currBytes < currSize) {\n        throw new IOException(\"entry '\" + currName + \"' closed at '\" + currBytes + \"' before the '\" + currSize + \"' bytes specified in the header were written\");\n    }\n}", "method_range": "199-217", "fault_locations": "216,217"}}