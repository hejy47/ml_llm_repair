{"org.apache.commons.math3.geometry.euclidean.threed.SubLine.intersection": {"buggy_content": "public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n    // compute the intersection on infinite line\n    Vector3D v1D = line.intersection(subLine.line);\n    // check location of point with respect to first sub-line\n    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n    // check location of point with respect to second sub-line\n    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n    if (includeEndPoints) {\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n    } else {\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n    }\n}", "method_range": "110-127", "fault_locations": "113,114"}, "org.apache.commons.math3.geometry.euclidean.twod.SubLine.intersection": {"buggy_content": "public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n    // retrieve the underlying lines\n    Line line1 = (Line) getHyperplane();\n    Line line2 = (Line) subLine.getHyperplane();\n    // compute the intersection on infinite line\n    Vector2D v2D = line1.intersection(line2);\n    // check location of point with respect to first sub-line\n    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n    // check location of point with respect to second sub-line\n    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n    if (includeEndPoints) {\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n    } else {\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n    }\n}", "method_range": "110-131", "fault_locations": "117,118"}}