{"org.apache.commons.math.util.MathUtils.binomialCoefficient": {"buggy_content": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * i) is divisible by j,\n    // but (result * i) may overflow, so we split j:\n    // Filter out the gcd, d, so j/d and i/d are integer.\n    // result is divisible by (j/d) because (j/d)\n    // is relative prime to (i/d) and is a divisor of\n    // result * (i/d).\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n    return result;\n}", "method_range": "169-209", "fault_locations": "184,185,186,208"}, "org.apache.commons.math.util.MathUtils.binomialCoefficientDouble": {"buggy_content": "public static double binomialCoefficientDouble(final int n, final int k) {\n    return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n}", "method_range": "233-237", "fault_locations": "236"}, "org.apache.commons.math.util.MathUtils.binomialCoefficientLog": {"buggy_content": "public static double binomialCoefficientLog(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 0;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return Math.log((double) n);\n    }\n    /*\n         * For values small enough to do exact integer computation,\n         * return the log of the exact value \n         */\n    /*\n         * Return the log of binomialCoefficientDouble for values that will not\n         * overflow binomialCoefficientDouble\n         */\n    /*\n         * Sum logs for values that could overflow\n         */\n    double logSum = 0;\n    // n!/k!\n    for (int i = k + 1; i <= n; i++) {\n        logSum += Math.log((double) i);\n    }\n    // divide by (n-k)!\n    for (int i = 2; i <= n - k; i++) {\n        logSum -= Math.log((double) i);\n    }\n    return logSum;\n}", "method_range": "257-299", "fault_locations": "286"}}