{"org.jsoup.parser.Tokeniser.consumeCharacterReference": {"buggy_content": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n        String nameRef = reader.consumeLetterSequence();\n        // for error reporting. nameRef gets chomped looking for matches\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (// named with semicolon\n            looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "method_range": "100-162", "fault_locations": "135"}}