{"org.apache.commons.math3.util.FastMath.pow": {"buggy_content": "public static double pow(double x, double y) {\n    final double[] lns = new double[2];\n    if (y == 0.0) {\n        return 1.0;\n    }\n    if (x != x) {\n        // X is NaN\n        return x;\n    }\n    if (x == 0) {\n        long bits = Double.doubleToLongBits(x);\n        if ((bits & 0x8000000000000000L) != 0) {\n            // -zero\n            long yi = (long) y;\n            if (y < 0 && y == yi && (yi & 1) == 1) {\n                return Double.NEGATIVE_INFINITY;\n            }\n            if (y > 0 && y == yi && (yi & 1) == 1) {\n                return -0.0;\n            }\n        }\n        if (y < 0) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (y > 0) {\n            return 0.0;\n        }\n        return Double.NaN;\n    }\n    if (x == Double.POSITIVE_INFINITY) {\n        if (y != y) {\n            // y is NaN\n            return y;\n        }\n        if (y < 0.0) {\n            return 0.0;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    if (y == Double.POSITIVE_INFINITY) {\n        if (x * x == 1.0) {\n            return Double.NaN;\n        }\n        if (x * x > 1.0) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return 0.0;\n        }\n    }\n    if (x == Double.NEGATIVE_INFINITY) {\n        if (y != y) {\n            // y is NaN\n            return y;\n        }\n        if (y < 0) {\n            long yi = (long) y;\n            if (y == yi && (yi & 1) == 1) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n        if (y > 0) {\n            long yi = (long) y;\n            if (y == yi && (yi & 1) == 1) {\n                return Double.NEGATIVE_INFINITY;\n            }\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    if (y == Double.NEGATIVE_INFINITY) {\n        if (x * x == 1.0) {\n            return Double.NaN;\n        }\n        if (x * x < 1.0) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return 0.0;\n        }\n    }\n        if (x < 0) {\n        // y is an even integer in this case\n        if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n            return pow(-x, y);\n        }\n        if (y == (long) y) {\n            // If y is an integer\n            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n        } else {\n            return Double.NaN;\n        }\n    }\n        double ya;\n    double yb;\n    if (y < 8e298 && y > -8e298) {\n        double tmp1 = y * HEX_40000000;\n        ya = y + tmp1 - tmp1;\n        yb = y - ya;\n    } else {\n        double tmp1 = y * 9.31322574615478515625E-10;\n        double tmp2 = tmp1 * 9.31322574615478515625E-10;\n        ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n        yb = y - ya;\n    }\n        final double lores = log(x, lns);\n    if (Double.isInfinite(lores)) {\n        // don't allow this to be converted to NaN\n        return lores;\n    }\n    double lna = lns[0];\n    double lnb = lns[1];\n        double tmp1 = lna * HEX_40000000;\n    double tmp2 = lna + tmp1 - tmp1;\n    lnb += lna - tmp2;\n    lna = tmp2;\n    // y*ln(x) = (aa+ab)\n    final double aa = lna * ya;\n    final double ab = lna * yb + lnb * ya + lnb * yb;\n    lna = aa + ab;\n    lnb = -(lna - aa - ab);\n    double z = 1.0 / 120.0;\n    z = z * lnb + (1.0 / 24.0);\n    z = z * lnb + (1.0 / 6.0);\n    z = z * lnb + 0.5;\n    z = z * lnb + 1.0;\n    z = z * lnb;\n    final double result = exp(lna, z, null);\n    //result = result + result * z;\n    return result;\n}", "method_range": "1441-1599", "fault_locations": "1541"}}