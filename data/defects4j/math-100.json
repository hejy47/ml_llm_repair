{"org.apache.commons.math.estimation.AbstractEstimator.getCovariances": {"buggy_content": "public double[][] getCovariances(EstimationProblem problem) throws EstimationException {\n    // set up the jacobian\n    updateJacobian();\n    // compute transpose(J).J, avoiding building big intermediate matrices\n    final int rows = problem.getMeasurements().length;\n    final int cols = problem.getAllParameters().length;\n    final int max = cols * rows;\n    double[][] jTj = new double[cols][cols];\n    for (int i = 0; i < cols; ++i) {\n        for (int j = i; j < cols; ++j) {\n            double sum = 0;\n            for (int k = 0; k < max; k += cols) {\n                sum += jacobian[k + i] * jacobian[k + j];\n            }\n            jTj[i][j] = sum;\n            jTj[j][i] = sum;\n        }\n    }\n    try {\n        // compute the covariances matrix\n        return new RealMatrixImpl(jTj).inverse().getData();\n    } catch (InvalidMatrixException ime) {\n        throw new EstimationException(\"unable to compute covariances: singular problem\", new Object[0]);\n    }\n}", "method_range": "158-188", "fault_locations": "166"}, "org.apache.commons.math.estimation.AbstractEstimator.guessParametersErrors": {"buggy_content": "public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {\n    int m = problem.getMeasurements().length;\n    int p = problem.getAllParameters().length;\n    if (m <= p) {\n        throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\", new Object[] { new Integer(m), new Integer(p) });\n    }\n    double[] errors = new double[problem.getAllParameters().length];\n    final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n    double[][] covar = getCovariances(problem);\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = Math.sqrt(covar[i][i]) * c;\n    }\n    return errors;\n}", "method_range": "199-214", "fault_locations": "200,201,202,204,205,207"}}