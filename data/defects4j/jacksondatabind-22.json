{"com.fasterxml.jackson.databind.ser.BasicSerializerFactory.buildContainerSerializer": {"buggy_content": "protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n    final SerializationConfig config = prov.getConfig();\n        if (!staticTyping && type.useStaticType()) {\n        if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {\n            staticTyping = true;\n        }\n    }\n    // Let's see what we can learn about element/content/value type, type serializer for it:\n    JavaType elementType = type.getContentType();\n    TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType);\n    // if elements have type serializer, can not force static typing:\n    if (elementTypeSerializer != null) {\n        staticTyping = false;\n    }\n    JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo());\n    if (type.isMapLikeType()) {\n        // implements java.util.Map\n        MapLikeType mlt = (MapLikeType) type;\n                JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n        if (mlt.isTrueMapType()) {\n            return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer);\n        }\n        // With Map-like, just 2 options: (1) Custom, (2) Annotations\n        JsonSerializer<?> ser = null;\n        for (Serializers serializers : customSerializers()) {\n            // (1) Custom\n            MapLikeType mlType = (MapLikeType) type;\n            ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n                    }\n                }\n                return ser;\n            }\n        }\n        return null;\n    }\n    if (type.isCollectionLikeType()) {\n        CollectionLikeType clt = (CollectionLikeType) type;\n        if (clt.isTrueCollectionType()) {\n            return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);\n        }\n        // With Map-like, just 2 options: (1) Custom, (2) Annotations\n        JsonSerializer<?> ser = null;\n        CollectionLikeType clType = (CollectionLikeType) type;\n        for (Serializers serializers : customSerializers()) {\n            // (1) Custom\n            ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n            if (ser != null) {\n                if (_factoryConfig.hasSerializerModifiers()) {\n                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n                    }\n                }\n                return ser;\n            }\n        }\n        return null;\n    }\n    if (type.isArrayType()) {\n        return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);\n    }\n    return null;\n}", "method_range": "544-628", "fault_locations": "580,583,584,586,587,594,595,598,603,605,606,612,613,614,615,616,618,621,624,625,626"}, "com.fasterxml.jackson.databind.ser.BasicSerializerFactory.buildCollectionSerializer": {"buggy_content": "protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n    JsonSerializer<?> ser = null;\n    // Order of lookups:\n    // 1. Custom serializers\n    // 2. Annotations (@JsonValue, @JsonDeserialize)\n    // 3. Defaults\n    for (Serializers serializers : customSerializers()) {\n        // (1) Custom\n        ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer);\n        if (ser != null) {\n            break;\n        }\n    }\n    if (ser == null) {\n        // We may also want to use serialize Collections \"as beans\", if (and only if)\n        // this is specified with `@JsonFormat(shape=Object)`\n        JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n        if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n            return null;\n        }\n        Class<?> raw = type.getRawClass();\n        if (EnumSet.class.isAssignableFrom(raw)) {\n            // this may or may not be available (Class doesn't; type of field/method does)\n            JavaType enumType = type.getContentType();\n            // and even if nominally there is something, only use if it really is enum\n            if (!enumType.isEnumType()) {\n                enumType = null;\n            }\n            ser = buildEnumSetSerializer(enumType);\n        } else {\n            Class<?> elementRaw = type.getContentType().getRawClass();\n            if (isIndexedList(raw)) {\n                if (elementRaw == String.class) {\n                    // [JACKSON-829] Must NOT use if we have custom serializer\n                    if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                        ser = IndexedStringListSerializer.instance;\n                    }\n                } else {\n                    ser = buildIndexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);\n                }\n            } else if (elementRaw == String.class) {\n                // [JACKSON-829] Must NOT use if we have custom serializer\n                if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n                    ser = StringCollectionSerializer.instance;\n                }\n            }\n            if (ser == null) {\n                ser = buildCollectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);\n            }\n        }\n    }\n    // [databind#120]: Allow post-processing\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);\n        }\n    }\n    return ser;\n}", "method_range": "636-701", "fault_locations": "636,643,644,679,680"}, "com.fasterxml.jackson.databind.ser.BasicSerializerFactory.buildEnumSetSerializer": {"buggy_content": "public JsonSerializer<?> buildEnumSetSerializer(JavaType enumType) {\n    return new EnumSetSerializer(enumType);\n}", "method_range": "723-725", "fault_locations": "725"}, "com.fasterxml.jackson.databind.ser.BasicSerializerFactory.buildMapSerializer": {"buggy_content": "protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n    JsonSerializer<?> ser = null;\n    // Order of lookups:\n    // 1. Custom serializers\n    // 2. Annotations (@JsonValue, @JsonDeserialize)\n    // 3. Defaults\n    for (Serializers serializers : customSerializers()) {\n        // (1) Custom\n        ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n        if (ser != null) {\n            break;\n        }\n    }\n    if (ser == null) {\n        // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer\n                Object filterId = findFilterId(config, beanDesc);\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer, filterId);\n        Object suppressableValue = findSuppressableContentValue(config, type.getContentType(), beanDesc);\n        if (suppressableValue != null) {\n            mapSer = mapSer.withContentInclusion(suppressableValue);\n        }\n        ser = mapSer;\n    }\n    // [databind#120]: Allow post-processing\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            ser = mod.modifyMapSerializer(config, type, beanDesc, ser);\n        }\n    }\n    return ser;\n}", "method_range": "737-791", "fault_locations": "737,743,744,771,772"}, "com.fasterxml.jackson.databind.ser.BasicSerializerFactory.findSuppressableContentValue": {"buggy_content": "protected Object findSuppressableContentValue(SerializationConfig config, JavaType contentType, BeanDescription beanDesc) throws JsonMappingException {\n    JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);\n    if (incl != null) {\n        switch(incl) {\n            case NON_DEFAULT:\n                // 19-Oct-2014, tatu: Not sure what this'd mean; so take it to mean \"NON_EMPTY\"...\n                incl = JsonInclude.Include.NON_EMPTY;\n                break;\n            default:\n                // all other modes actually good as is, unless we'll find better ways\n                break;\n        }\n        return incl;\n    }\n    return null;\n}", "method_range": "800-819", "fault_locations": "818,819"}, "com.fasterxml.jackson.databind.ser.BasicSerializerFactory.buildArraySerializer": {"buggy_content": "protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException {\n    // 25-Jun-2015, tatu: Note that unlike with Collection(Like) and Map(Like) types, array\n    //   types can not be annotated (in theory I guess we could have mix-ins but... ?)\n    //   so we need not do primary annotation lookup here.\n    //   So all we need is (1) Custom, (2) Default array serializers\n    JsonSerializer<?> ser = null;\n    for (Serializers serializers : customSerializers()) {\n        // (1) Custom\n        ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer);\n        if (ser != null) {\n            break;\n        }\n    }\n    if (ser == null) {\n        Class<?> raw = type.getRawClass();\n        // Important: do NOT use standard serializers if non-standard element value serializer specified\n        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n            if (String[].class == raw) {\n                ser = StringArraySerializer.instance;\n            } else {\n                // other standard types?\n                ser = StdArraySerializers.findStandardImpl(raw);\n            }\n        }\n        if (ser == null) {\n            ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer);\n        }\n    }\n    // [databind#120]: Allow post-processing\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n        }\n    }\n    return ser;\n}", "method_range": "831-874", "fault_locations": "831"}, "com.fasterxml.jackson.databind.ser.BeanSerializerFactory._createSerializer2": {"buggy_content": "protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {\n    JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n    if (ser != null) {\n        return ser;\n    }\n    final SerializationConfig config = prov.getConfig();\n    // Container types differ from non-container types\n    // (note: called method checks for module-provided serializers)\n    if (type.isContainerType()) {\n        if (!staticTyping) {\n            staticTyping = usesStaticTyping(config, beanDesc, null);\n            // [Issue#23]: Need to figure out how to force passed parameterization\n            //  to stick...\n                    }\n        // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n        ser = buildContainerSerializer(prov, type, beanDesc, staticTyping);\n        // Will return right away, since called method does post-processing:\n        if (ser != null) {\n            return ser;\n        }\n    } else {\n        // Modules may provide serializers of POJO types:\n        for (Serializers serializers : customSerializers()) {\n            ser = serializers.findSerializer(config, type, beanDesc);\n            if (ser != null) {\n                break;\n            }\n        }\n        // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6,\n        //    this call was BEFORE custom serializer lookup, which was wrong.\n    }\n    if (ser == null) {\n        // Otherwise, we will check \"primary types\"; both marker types that\n        // indicate specific handling (JsonSerializable), or main types that have\n        // precedence over container types\n        ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n        if (ser == null) {\n            ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n            if (ser == null) {\n                // And this is where this class comes in: if type is not a\n                // known \"primary JDK type\", perhaps it's a bean? We can still\n                // get a null, if we can't find a single suitable bean property.\n                ser = findBeanSerializer(prov, type, beanDesc);\n                // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                if (ser == null) {\n                    ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                    // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n                    //   'unknown' serializer assigned earlier, here, so that it gets properly\n                    //   post-processed\n                    if (ser == null) {\n                        ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n                    }\n                }\n            }\n        }\n    }\n    if (ser != null) {\n        // [databind#120]: Allow post-processing\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                ser = mod.modifySerializer(config, beanDesc, ser);\n            }\n        }\n    }\n    return ser;\n}", "method_range": "170-248", "fault_locations": "174,175,176,177,207,208"}}