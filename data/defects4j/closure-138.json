{"com.google.javascript.jscomp.ClosureReverseAbstractInterpreter.getPreciserScopeKnowingConditionOutcome": {"buggy_content": "@Override\npublic FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {\n    if (condition.getType() == CALL && condition.getChildCount() == 2) {\n        Node callee = condition.getFirstChild();\n        Node param = condition.getLastChild();\n        if (callee.getType() == GETPROP && param.isQualifiedName()) {\n            JSType paramType = getTypeIfRefinable(param, blindScope);\n            if (paramType != null) {\n                Node left = callee.getFirstChild();\n                Node right = callee.getLastChild();\n                if (left.getType() == NAME && \"goog\".equals(left.getString()) && right.getType() == STRING) {\n                    Function<TypeRestriction, JSType> restricter = restricters.get(right.getString());\n                    if (restricter != null) {\n                        return restrictParameter(param, paramType, blindScope, restricter, outcome);\n                    }\n                }\n            }\n        }\n    }\n    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);\n}", "method_range": "200-225", "fault_locations": "208,218"}, "com.google.javascript.jscomp.TypeInference.traverseName": {"buggy_content": "private FlowScope traverseName(Node n, FlowScope scope) {\n    String varName = n.getString();\n    Node value = n.getFirstChild();\n    JSType type = n.getJSType();\n    if (value != null) {\n        scope = traverse(value, scope);\n        updateScopeForTypeChange(scope, n, n.getJSType(),         getJSType(value));\n        return scope;\n    } else {\n        StaticSlot<JSType> var = scope.getSlot(varName);\n        if (var != null && !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {\n            // There are two situations where we don't want to use type information\n            // from the scope, even if we have it.\n            // 1) The var is escaped in a weird way, e.g.,\n            // function f() { var x = 3; function g() { x = null } (x); }\n            // 2) We're reading type information from another scope for an\n            // inferred variable.\n            // var t = null; function f() { (t); }\n            type = var.getType();\n            if (type == null) {\n                type = getNativeType(UNKNOWN_TYPE);\n            }\n        }\n    }\n    n.setJSType(type);\n    return scope;\n}", "method_range": "621-652", "fault_locations": "632,633,636,637,640,641,642,644,645"}}