{"com.fasterxml.jackson.databind.deser.BasicDeserializerFactory.modifyTypeByAnnotation": {"buggy_content": "@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}", "method_range": "1747-1811", "fault_locations": "1757"}, "com.fasterxml.jackson.databind.deser.DeserializerCache.modifyTypeByAnnotation": {"buggy_content": "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            if (kdDef != null) {\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            if (cdDef != null) {\n                JsonDeserializer<?> cd = null;\n                if (cdDef instanceof JsonDeserializer<?>) {\n                    cdDef = (JsonDeserializer<?>) cdDef;\n                } else {\n                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                    if (cdClass != null) {\n                        cd = ctxt.deserializerInstance(a, cdClass);\n                    }\n                }\n                if (cd != null) {\n                    type = type.withContentValueHandler(cd);\n                }\n            }\n        }\n    }\n    return type;\n}", "method_range": "468-543", "fault_locations": "477"}, "com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase._findDeserializer": {"buggy_content": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException {\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n            }\n        } else {\n                        if ((_baseType != null) && _baseType.getClass() == type.getClass()) {\n                                type = _baseType.narrowBy(type.getRawClass());\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}", "method_range": "144-184", "fault_locations": "177"}, "com.fasterxml.jackson.databind.module.SimpleAbstractTypeResolver.findTypeMapping": {"buggy_content": "@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return type.narrowBy(dst);\n}", "method_range": "70-81", "fault_locations": "80"}}