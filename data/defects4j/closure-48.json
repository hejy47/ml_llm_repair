{"com.google.javascript.jscomp.TypedScopeCreator.maybeDeclareQualifiedName": {"buggy_content": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            ObjectType qVarType = ObjectType.cast(qVar.getType());\n            if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {\n                typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVarType.getImplicitPrototype());\n            } else if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.isExprResult()) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    // NOTE(nicksantos): Determining whether a property is declared or not\n    // is really really obnoxious.\n    //\n    // The problem is that there are two (equally valid) coding styles:\n    //\n    // (function() {\n    //       //   goog.bar = function() {};\n    // })();\n    //\n    // function f() {\n    //   goog.bar();\n    //       //   goog.bar = function() {};\n    // }\n    //\n    // In a dynamic language with first-class functions, it's very difficult\n    // to know which one the user intended without looking at lots of\n    // contextual information (the second example demonstrates a small case\n    // of this, but there are some really pathological cases as well).\n    //\n    // The current algorithm checks if either the declaration has\n    // jsdoc type information, or @const with a known type,\n    // or a function literal with a name we haven't seen before.\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}", "method_range": "1416-1561", "fault_locations": "1521,1522,1523,1524,1525"}}