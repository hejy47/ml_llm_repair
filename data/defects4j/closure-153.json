{"com.google.javascript.jscomp.Normalize.onRedeclaration": {"buggy_content": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "method_range": "636-683", "fault_locations": "638,639,640,641,644,645,666,667,669,677,678,681"}, "com.google.javascript.jscomp.SyntacticScopeCreator.scanRoot": {"buggy_content": "private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        final Node fnNameNode = n.getFirstChild();\n        final Node args = fnNameNode.getNext();\n        final Node body = args.getNext();\n        // Bleed the function name into the scope, if it hasn't\n        // been declared in the outer scope.\n        String fnName = fnNameNode.getString();\n        if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n            declareVar(fnName, fnNameNode, n, null, null, n);\n        }\n        // Args: Declare function variables\n        Preconditions.checkState(args.getType() == Token.LP);\n        for (Node a = args.getFirstChild(); a != null; a = a.getNext()) {\n            Preconditions.checkState(a.getType() == Token.NAME);\n            declareVar(a.getString(), a, args, n, null, n);\n        }\n        // Body\n        scanVars(body, n);\n    } else {\n        // It's the global block\n        Preconditions.checkState(scope.getParent() == null);\n        scanVars(n, null);\n    }\n}", "method_range": "83-113", "fault_locations": "93,94,95,100,101,103"}, "com.google.javascript.jscomp.SyntacticScopeCreator.scanVars": {"buggy_content": "private void scanVars(Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.VAR:\n            // Declare all variables. e.g. var x = 1, y, z;\n            for (Node child = n.getFirstChild(); child != null; ) {\n                Node next = child.getNext();\n                Preconditions.checkState(child.getType() == Token.NAME);\n                String name = child.getString();\n                declareVar(name, child, n, parent, null, n);\n                child = next;\n            }\n            return;\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n)) {\n                return;\n            }\n            String fnName = n.getFirstChild().getString();\n            if (fnName.isEmpty()) {\n                // This is invalid, but allow it so the checks can catch it.\n                return;\n            }\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n            // should not examine function's children\n            return;\n        case Token.CATCH:\n            Preconditions.checkState(n.getChildCount() == 2);\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n            // the first child is the catch var and the third child\n            // is the code block\n            final Node var = n.getFirstChild();\n            final Node block = var.getNext();\n            declareVar(var.getString(), var, n, parent, null, n);\n            scanVars(block, n);\n            // only one child to scan\n            return;\n        case Token.SCRIPT:\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n        for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            scanVars(child, n);\n            child = next;\n        }\n    }\n}", "method_range": "118-173", "fault_locations": "121,122,125,126,127,135,136,142,146,147,154,171,172"}, "com.google.javascript.jscomp.SyntacticScopeCreator.onRedeclaration": {"buggy_content": "void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber);", "method_range": "179-181", "fault_locations": "179,180,181"}, "com.google.javascript.jscomp.SyntacticScopeCreator.onRedeclaration3": {"buggy_content": "public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    // Don't allow multiple variables to be declared at the top level scope\n    if (scope.isGlobal()) {\n        Scope.Var origVar = scope.getVar(name);\n        Node origParent = origVar.getParentNode();\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n            // Okay, both are 'catch(x)' variables.\n            return;\n        }\n        boolean allowDupe = false;\n        JSDocInfo info = n.getJSDocInfo();\n        if (info == null) {\n            info = parent.getJSDocInfo();\n        }\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n        if (!allowDupe) {\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n        }\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n        // Disallow shadowing \"arguments\" as we can't handle with our current\n        // scope modeling.\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n    }\n}", "method_range": "188-226", "fault_locations": "189,190,222,223,224,226"}, "com.google.javascript.jscomp.SyntacticScopeCreator.declareVar": {"buggy_content": "private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {\n        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n        scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n}", "method_range": "235-246", "fault_locations": "235,236,237,242,244"}}