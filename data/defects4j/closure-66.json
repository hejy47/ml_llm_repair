{"com.google.javascript.jscomp.TypeCheck.visit": {"buggy_content": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable = visitName(t, n, parent);\n            break;\n        case Token.LP:\n            // If this is under a FUNCTION node, it is a parameter list and can be\n            // ignored here.\n            if (parent.getType() != Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable = false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            // Object literal keys are handled with OBJECTLIT\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n                // Object literal keys are not typeable\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            // Object literal keys are handled with OBJECTLIT\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            // The type of GETELEM is always unknown, so no point counting that.\n            // If that unknown leaks elsewhere (say by an assignment to another\n            // variable), then it will be counted.\n            typeable = false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable = false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable = true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable = !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable = false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left = n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType = getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left = n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType = getJSType(n.getFirstChild());\n                rightType = getJSType(n.getLastChild());\n                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n                TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result != TernaryValue.UNKNOWN) {\n                    if (n.getType() == Token.NE) {\n                        result = result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType = getJSType(n.getFirstChild());\n                rightType = getJSType(n.getLastChild());\n                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType = getJSType(n.getFirstChild());\n            rightType = getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {\n                // OK.\n            } else {\n                // Whether the comparison is numeric will be determined at runtime\n                // each time the expression is evaluated. Regardless, both operands\n                // should match a string context.\n                String message = \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message = \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left = n.getFirstChild();\n            right = n.getLastChild();\n            leftType = getJSType(left);\n            rightType = getJSType(right);\n            validator.expectObject(t, n, rightType, \"'in' requires an object\");\n            validator.expectString(t, left, leftType, \"left side of 'in'\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left = n.getFirstChild();\n            right = n.getLastChild();\n            leftType = getJSType(left);\n            rightType = getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable = false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType = getJSType(parent.getFirstChild());\n            JSType caseType = getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable = false;\n            break;\n        case Token.WITH:\n            {\n                Node child = n.getFirstChild();\n                childType = getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable = false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        // These nodes have no interesting type behavior.\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable = false;\n            break;\n        // These nodes require data flow analysis.\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable = false;\n            break;\n        // These nodes are typed during the type inference.\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() != null) {\n                // If we didn't run type inference.\n                ensureTyped(t, n);\n            } else {\n                // If this is an enum, then give that type to the objectlit as well.\n                if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() == Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}", "method_range": "461-813", "fault_locations": "514,515"}}