{"org.apache.commons.math.optimization.univariate.BrentOptimizer.BrentOptimizer": {"buggy_content": "public BrentOptimizer() {\n    setMaxEvaluations(Integer.MAX_VALUE);\n    setMaximalIterationCount(100);\n    setAbsoluteAccuracy(1E-10);\n    setRelativeAccuracy(1.0e-14);\n}", "method_range": "43-48", "fault_locations": "45,46,47"}, "org.apache.commons.math.optimization.univariate.BrentOptimizer.optimize": {"buggy_content": "public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    return localMin(getGoalType() == GoalType.MINIMIZE, f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());\n}", "method_range": "59-64", "fault_locations": "61"}, "org.apache.commons.math.optimization.univariate.BrentOptimizer.optimize1": {"buggy_content": "public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n}", "method_range": "65-67", "fault_locations": "66"}, "org.apache.commons.math.optimization.univariate.BrentOptimizer.localMin": {"buggy_content": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "method_range": "93-244", "fault_locations": "119,120,126,127,200,201,238,241,243"}}