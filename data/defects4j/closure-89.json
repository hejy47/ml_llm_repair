{"com.google.javascript.jscomp.CollapseProperties.updateSimpleDeclaration": {"buggy_content": "private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n    if (gramps.getType() == Token.EXPR_RESULT) {\n        // BEFORE: a.b.c = ...;\n        //   exprstmt\n        //     assign\n        //       getprop\n        //         getprop\n        //           name a\n        //           string b\n        //         string c\n        //       NODE\n        // AFTER: var a$b$c = ...;\n        //   var\n        //     name a$b$c\n        //       NODE\n        // Remove the rvalue (NODE).\n        parent.removeChild(rvalue);\n        nameNode.addChildToFront(rvalue);\n        Node varNode = new Node(Token.VAR, nameNode);\n        greatGramps.replaceChild(gramps, varNode);\n    } else {\n        // This must be a complex assignment.\n        Preconditions.checkNotNull(ref.getTwin());\n        // BEFORE:\n        // ... (x.y = 3);\n        //\n        // AFTER:\n        // var x$y;\n        // ... (x$y = 3);\n        Node current = gramps;\n        Node currentParent = gramps.getParent();\n        for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) {\n        }\n        // Create a stub variable declaration right\n        // before the current statement.\n        Node stubVar = new Node(Token.VAR, nameNode.cloneTree()).copyInformationFrom(nameNode);\n        currentParent.addChildBefore(stubVar, current);\n        parent.replaceChild(ref.node, nameNode);\n    }\n    compiler.reportCodeChange();\n}", "method_range": "477-540", "fault_locations": "483,484"}, "com.google.javascript.jscomp.GlobalNamespace.canCollapseUnannotatedChildNames": {"buggy_content": "boolean canCollapseUnannotatedChildNames() {\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n    }\n    // Don't try to collapse if the one global set is a twin reference.\n    // We could theoretically handle this case in CollapseProperties, but\n    // it's probably not worth the effort.\n    Preconditions.checkNotNull(declaration);\n    if (declaration.getTwin() != null) {\n        return false;\n    }\n    if (isClassOrEnum) {\n        return true;\n    }\n    // If this is a key of an aliased object literal, then it will be aliased\n    // later. So we won't be able to collapse its properties.\n    if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n    }\n    // If this is aliased, then its properties can't be collapsed either.\n    if (type != Type.FUNCTION && aliasingGets > 0) {\n        return false;\n    }\n    return (parent == null || parent.canCollapseUnannotatedChildNames());\n}", "method_range": "896-925", "fault_locations": "920"}}