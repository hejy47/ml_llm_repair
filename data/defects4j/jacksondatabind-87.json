{"com.fasterxml.jackson.databind.util.StdDateFormat.parseAsISO8601": {"buggy_content": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "method_range": "428-549", "fault_locations": "514,516,517,524,525,526,527,528,529,530,535,536"}, "com.fasterxml.jackson.databind.util.StdDateFormat._cloneFormat": {"buggy_content": "private final static DateFormat _cloneFormat(DateFormat df, String format, TimeZone tz, Locale loc, Boolean lenient) {\n    if (!loc.equals(DEFAULT_LOCALE)) {\n        df = new SimpleDateFormat(format, loc);\n        df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n    } else {\n        df = (DateFormat) df.clone();\n        if (tz != null) {\n            df.setTimeZone(tz);\n        }\n    }\n    if (lenient != null) {\n        df.setLenient(lenient.booleanValue());\n    }\n    return df;\n}", "method_range": "575-591", "fault_locations": "589,590"}}