{"com.google.javascript.jscomp.FlowSensitiveInlineVariables.enterScope": {"buggy_content": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even brother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "method_range": "124-170", "fault_locations": "155"}, "com.google.javascript.jscomp.FlowSensitiveInlineVariables.getDefCfgNode": {"buggy_content": "private Node getDefCfgNode() {\n    return defMetadata.node;\n}", "method_range": "276-278", "fault_locations": "278"}, "com.google.javascript.jscomp.FlowSensitiveInlineVariables.canInline": {"buggy_content": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "method_range": "280-411", "fault_locations": "280,372,373"}, "com.google.javascript.jscomp.FlowSensitiveInlineVariables.apply": {"buggy_content": "@Override\npublic boolean apply(Node input) {\n    switch(input.getType()) {\n        case Token.GETELEM:\n        case Token.GETPROP:\n        case Token.ARRAYLIT:\n        case Token.OBJECTLIT:\n        case Token.REGEXP:\n        case Token.NEW:\n            return true;\n    }\n    return false;\n}", "method_range": "365-377", "fault_locations": "372,373"}}