{"org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter.filterCandidate": {"buggy_content": "public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n    if (mocks.size() == 1) {\n        final Object matchingMock = mocks.iterator().next();\n        return new OngoingInjecter() {\n\n            public Object thenInject() {\n                try {\n                    if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                        new FieldSetter(fieldInstance, field).set(matchingMock);\n                    }\n                } catch (RuntimeException e) {\n                    new Reporter().cannotInjectDependency(field, matchingMock, e);\n                }\n                return matchingMock;\n            }\n        };\n    }\n    return new OngoingInjecter() {\n\n        public Object thenInject() {\n            return null;\n        }\n    };\n}", "method_range": "23-47", "fault_locations": "23"}, "org.mockito.internal.configuration.injection.filter.MockCandidateFilter.filterCandidate": {"buggy_content": "OngoingInjecter filterCandidate(Collection<Object> mocks, Field fieldToBeInjected, Object fieldInstance);", "method_range": "12-16", "fault_locations": "15"}, "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter.filterCandidate": {"buggy_content": "public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n    List<Object> mockNameMatches = new ArrayList<Object>();\n    if (mocks.size() > 1) {\n        for (Object mock : mocks) {\n            if (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n                mockNameMatches.add(mock);\n            }\n        }\n        return next.filterCandidate(mockNameMatches, field, fieldInstance);\n        /*\n\t\t\t * In this case we have to check whether we have conflicting naming\n\t\t\t * fields. E.g. 2 fields of the same type, but we have to make sure\n\t\t\t * we match on the correct name.\n\t\t\t * \n\t\t\t * Therefore we have to go through all other fields and make sure\n\t\t\t * whenever we find a field that does match its name with the mock\n\t\t\t * name, we should take that field instead.\n\t\t\t */\n    }\n    return next.filterCandidate(mocks, field, fieldInstance);\n}", "method_range": "22-44", "fault_locations": "23,29,30,31,39,40,41,43"}, "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter.filterCandidate": {"buggy_content": "public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n    List<Object> mockTypeMatches = new ArrayList<Object>();\n    for (Object mock : mocks) {\n        if (field.getType().isAssignableFrom(mock.getClass())) {\n            mockTypeMatches.add(mock);\n        }\n    }\n    return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n}", "method_range": "20-29", "fault_locations": "20,26,27,28"}, "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.injectMockCandidatesOnFields": {"buggy_content": "private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n    for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n        Field field = it.next();\n        Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n        if (injected != null) {\n            injectionOccurred |= true;\n            mocks.remove(injected);\n            it.remove();\n        }\n    }\n    return injectionOccurred;\n}", "method_range": "111-122", "fault_locations": "114"}}