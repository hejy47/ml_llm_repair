{"com.fasterxml.jackson.databind.DatabindContext.resolveSubType": {"buggy_content": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "method_range": "170-202", "fault_locations": "195"}, "com.fasterxml.jackson.databind.deser.BasicDeserializerFactory.findTypeDeserializer": {"buggy_content": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    }\n}", "method_range": "1554-1593", "fault_locations": "1589"}, "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.buildBeanDeserializer": {"buggy_content": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n        try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "method_range": "201-256", "fault_locations": "222"}, "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.buildBuilderBasedDeserializer": {"buggy_content": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    }\n    builder.setPOJOBuilder(buildMethod, builderConfig);\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "method_range": "265-323", "fault_locations": "279,280,281"}, "com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2": {"buggy_content": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n                if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache) {\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "method_range": "258-300", "fault_locations": "268"}, "com.fasterxml.jackson.databind.deser.SettableAnyProperty._throwAsIOE": {"buggy_content": "protected void _throwAsIOE(Exception e, Object propName, Object value) throws IOException {\n    if (e instanceof IllegalArgumentException) {\n        String actType = ClassUtil.classNameOf(value);\n        StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n        msg.append(\"' of class \" + getClassName() + \" (expected type: \").append(_type);\n        msg.append(\"; actual type: \").append(actType).append(\")\");\n        String origMsg = e.getMessage();\n        if (origMsg != null) {\n            msg.append(\", problem: \").append(origMsg);\n        } else {\n            msg.append(\" (no error message provided)\");\n        }\n        throw new JsonMappingException(null, msg.toString(), e);\n    }\n    ClassUtil.throwIfIOE(e);\n    ClassUtil.throwIfRTE(e);\n    // let's wrap the innermost problem\n    Throwable t = ClassUtil.getRootCause(e);\n    throw new JsonMappingException(null, t.getMessage(), t);\n}", "method_range": "194-215", "fault_locations": "202,212,213,214"}, "com.fasterxml.jackson.databind.deser.SettableBeanProperty._throwAsIOE": {"buggy_content": "protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException {\n    if (e instanceof IllegalArgumentException) {\n        String actType = ClassUtil.classNameOf(value);\n        StringBuilder msg = new StringBuilder(\"Problem deserializing property '\").append(getName()).append(\"' (expected type: \").append(getType()).append(\"; actual type: \").append(actType).append(\")\");\n        String origMsg = e.getMessage();\n        if (origMsg != null) {\n            msg.append(\", problem: \").append(origMsg);\n        } else {\n            msg.append(\" (no error message provided)\");\n        }\n        throw JsonMappingException.from(p, msg.toString(), e);\n    }\n    _throwAsIOE(p, e);\n}", "method_range": "580-600", "fault_locations": "590"}, "com.fasterxml.jackson.databind.deser.SettableBeanProperty._throwAsIOE1": {"buggy_content": "protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException {\n    ClassUtil.throwIfIOE(e);\n    ClassUtil.throwIfRTE(e);\n    // let's wrap the innermost problem\n    Throwable th = ClassUtil.getRootCause(e);\n    throw JsonMappingException.from(p, th.getMessage(), th);\n}", "method_range": "605-612", "fault_locations": "609,610,611"}, "com.fasterxml.jackson.databind.deser.std.StdDeserializer._parseDate": {"buggy_content": "protected java.util.Date _parseDate(String value, DeserializationContext ctxt) throws IOException {\n    try {\n        // Take empty Strings to mean 'empty' Value, usually 'null':\n        if (_isEmptyOrTextualNull(value)) {\n            return (java.util.Date) getNullValue(ctxt);\n        }\n        return ctxt.parseDate(value);\n    } catch (IllegalArgumentException iae) {\n        return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value, \"not a valid representation (error: %s)\", iae.getMessage());\n    }\n}", "method_range": "514-528", "fault_locations": "526"}, "com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer.deserializeKey": {"buggy_content": "@Override\npublic Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n    if (key == null) {\n        // is this even legal call?\n        return null;\n    }\n    try {\n        Object result = _parse(key, ctxt);\n        if (result != null) {\n            return result;\n        }\n    } catch (Exception re) {\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n    }\n    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n        return null;\n    }\n    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n}", "method_range": "120-141", "fault_locations": "135"}, "com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer._weirdKey": {"buggy_content": "protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n    return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\", e.getMessage());\n}", "method_range": "260-263", "fault_locations": "260,261,262"}, "com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.wrapException": {"buggy_content": "// since 2.7\n@Deprecated\nprotected JsonMappingException wrapException(Throwable t) {\n    // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only\n    //   does so if and until `JsonMappingException` is found.\n    for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n        if (curr instanceof JsonMappingException) {\n            return (JsonMappingException) curr;\n        }\n    }\n    return new JsonMappingException(null, \"Instantiation of \" + getValueTypeDesc() + \" value failed: \" + t.getMessage(), t);\n}", "method_range": "445-457", "fault_locations": "456"}, "com.fasterxml.jackson.databind.DeserializationContext.parseDate": {"buggy_content": "public Date parseDate(String dateStr) throws IllegalArgumentException {\n    try {\n        DateFormat df = getDateFormat();\n        return df.parse(dateStr);\n    } catch (ParseException e) {\n        throw new IllegalArgumentException(String.format(\"Failed to parse Date value '%s': %s\", dateStr, e.getMessage()));\n    }\n}", "method_range": "706-716", "fault_locations": "714"}, "com.fasterxml.jackson.databind.DeserializationContext.instantiationException": {"buggy_content": "public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n    // Most likely problem with Creator definition, right?\n    final JavaType type = constructType(instClass);\n    String excMsg;\n    if (cause == null) {\n        excMsg = \"N/A\";\n    } else if ((excMsg = cause.getMessage()) == null) {\n        excMsg = ClassUtil.nameOf(cause.getClass());\n    }\n    String msg = String.format(\"Cannot construct instance of %s, problem: %s\", ClassUtil.nameOf(instClass), excMsg);\n    InvalidDefinitionException e = InvalidDefinitionException.from(_parser, msg, type);\n    e.initCause(cause);\n    return e;\n}", "method_range": "1597-1611", "fault_locations": "1601,1602,1603"}, "com.fasterxml.jackson.databind.introspect.BasicBeanDescription.instantiateBean": {"buggy_content": "@Override\npublic Object instantiateBean(boolean fixAccess) {\n    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n    if (ac == null) {\n        return null;\n    }\n    if (fixAccess) {\n        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n    }\n    try {\n        return ac.getAnnotated().newInstance();\n    } catch (Exception e) {\n        Throwable t = e;\n        while (t.getCause() != null) {\n            t = t.getCause();\n        }\n        ClassUtil.throwIfError(t);\n        ClassUtil.throwIfRTE(t);\n        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n    }\n}", "method_range": "344-366", "fault_locations": "364"}, "com.fasterxml.jackson.databind.JsonMappingException.fromUnexpectedIOE": {"buggy_content": "public static JsonMappingException fromUnexpectedIOE(IOException src) {\n    return new JsonMappingException(null, String.format(\"Unexpected IOException (of type %s): %s\", src.getClass().getName(), src.getMessage()));\n}", "method_range": "335-340", "fault_locations": "339"}, "com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath": {"buggy_content": "@SuppressWarnings(\"resource\")\npublic static JsonMappingException wrapWithPath(Throwable src, Reference ref) {\n    JsonMappingException jme;\n    if (src instanceof JsonMappingException) {\n        jme = (JsonMappingException) src;\n    } else {\n        // [databind#2128]: try to avoid duplication\n        String msg = src.getMessage();\n        // Let's use a more meaningful placeholder if all we have is null\n        if (msg == null || msg.length() == 0) {\n            msg = \"(was \" + src.getClass().getName() + \")\";\n        }\n        // 17-Aug-2015, tatu: Let's also pass the processor (parser/generator) along\n        Closeable proc = null;\n        if (src instanceof JsonProcessingException) {\n            Object proc0 = ((JsonProcessingException) src).getProcessor();\n            if (proc0 instanceof Closeable) {\n                proc = (Closeable) proc0;\n            }\n        }\n        jme = new JsonMappingException(proc, msg, src);\n    }\n    jme.prependPath(ref);\n    return jme;\n}", "method_range": "372-397", "fault_locations": "378,379,380"}, "com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.includeFilterSuppressNulls": {"buggy_content": "@Override\npublic boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n    if (filter == null) {\n        return true;\n    }\n    // should let filter decide what to do with nulls:\n    // But just case, let's handle unexpected (from our perspective) problems explicitly\n    try {\n        return filter.equals(null);\n    } catch (Throwable t) {\n        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n        reportBadDefinition(filter.getClass(), msg, t);\n        // never gets here\n        return false;\n    }\n}", "method_range": "158-175", "fault_locations": "171"}, "com.fasterxml.jackson.databind.ser.DefaultSerializerProvider._wrapAsIOE": {"buggy_content": "private IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n    if (e instanceof IOException) {\n        return (IOException) e;\n    }\n    String msg = e.getMessage();\n    if (msg == null) {\n        msg = \"[no message for \" + e.getClass().getName() + \"]\";\n    }\n    return new JsonMappingException(g, msg, e);\n}", "method_range": "501-510", "fault_locations": "503,504,505"}, "com.fasterxml.jackson.databind.ser.PropertyBuilder.buildWriter": {"buggy_content": "protected BeanPropertyWriter buildWriter(SerializerProvider prov, BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) throws JsonMappingException {\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType;\n    try {\n        serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n    } catch (JsonMappingException e) {\n        if (propDef == null) {\n            return prov.reportBadDefinition(declaredType, e.getMessage());\n        }\n        return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n    }\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        // 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n        //    type information for contents. Should work well (for JAXB case); can be\n        //    revisited if this causes problems.\n        if (serializationType == null) {\n            //                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            prov.reportBadPropertyDefinition(_beanDesc, propDef, \"serialization type \" + serializationType + \" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    // 17-Mar-2017: [databind#1522] Allow config override per property type\n    AnnotatedMember accessor = propDef.getAccessor();\n    if (accessor == null) {\n        // neither Setter nor ConstructorParameter are expected here\n        return prov.reportBadPropertyDefinition(_beanDesc, propDef, \"could not determine property type\");\n    }\n    Class<?> rawPropertyType = accessor.getRawType();\n    // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n    //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n    //   for declared property type... and finally property annotation overrides\n    JsonInclude.Value inclV = _config.getDefaultInclusion(actualType.getRawClass(), rawPropertyType, _defaultInclusion);\n    // property annotation override\n    inclV = inclV.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) {\n        // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n    switch(inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to access values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class/type specifying it; try to find POJO property defaults\n            Object defaultBean;\n            // 16-Oct-2016, tatu: Note: if we cannot for some reason create \"default instance\",\n            //    revert logic to the case of general/per-property handling, so both\n            //    type-default AND null are to be excluded.\n            //    (as per [databind#1417]\n            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                try {\n                    valueToSuppress = am.getValue(defaultBean);\n                } catch (Exception e) {\n                    _throwWrapped(e, propDef.getName(), defaultBean);\n                }\n            } else {\n                valueToSuppress = BeanUtil.getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case // new with 2.6, to support Guava/JDK8 Optionals\n        NON_ABSENT:\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            suppressNulls = true;\n            // but possibly also 'empty' values:\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case // new with 2.9\n        CUSTOM:\n            valueToSuppress = prov.includeFilterInstance(propDef, inclV.getValueFilter());\n            if (valueToSuppress == null) {\n                // is this legal?\n                suppressNulls = true;\n            } else {\n                suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);\n            }\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n        // fall through\n        // default\n        case ALWAYS:\n        default:\n            // we may still want to suppress empty collections\n            if (actualType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n    }\n    Class<?>[] views = propDef.findViews();\n    if (views == null) {\n        views = _beanDesc.findDefaultViews();\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress, views);\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}", "method_range": "91-244", "fault_locations": "103,104,105"}, "com.fasterxml.jackson.databind.SerializerProvider._createAndCacheUntypedSerializer": {"buggy_content": "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType) throws JsonMappingException {\n    JavaType fullType = _config.constructType(rawType);\n    JsonSerializer<Object> ser;\n    try {\n        ser = _createUntypedSerializer(fullType);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        // doesn't matter but compiler whines otherwise\n        ser = null;\n        reportMappingProblem(iae, iae.getMessage());\n    }\n    if (ser != null) {\n        // 21-Dec-2015, tatu: Best to cache for both raw and full-type key\n        _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);\n    }\n    return ser;\n}", "method_range": "1330-1349", "fault_locations": "1341"}, "com.fasterxml.jackson.databind.SerializerProvider._createAndCacheUntypedSerializer1": {"buggy_content": "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type) throws JsonMappingException {\n    JsonSerializer<Object> ser;\n    try {\n        ser = _createUntypedSerializer(type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        ser = null;\n        reportMappingProblem(iae, iae.getMessage());\n    }\n    if (ser != null) {\n        // 21-Dec-2015, tatu: Should we also cache using raw key?\n        _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n    }\n    return ser;\n}", "method_range": "1351-1369", "fault_locations": "1359,1360,1361"}}