{"com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve": {"buggy_content": "@Override\npublic void resolve(DeserializationContext ctxt) throws JsonMappingException {\n    ExternalTypeHandler.Builder extTypes = null;\n    // if ValueInstantiator can use \"creator\" approach, need to resolve it here...\n    SettableBeanProperty[] creatorProps;\n    if (_valueInstantiator.canCreateFromObjectWith()) {\n        creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n        // 21-Jun-2015, tatu: This resolution was duplicated later on and seems like\n        //    it really should be only done at a later point. So commented out in 2.8.\n        //   However, just in case there was a reason for it, leaving commented out\n        //   here instead of immediately removing.\n            } else {\n        creatorProps = null;\n    }\n    UnwrappedPropertyHandler unwrapped = null;\n    for (SettableBeanProperty origProp : _beanProperties) {\n        SettableBeanProperty prop = origProp;\n        // May already have deserializer from annotations, if so, skip:\n        if (!prop.hasValueDeserializer()) {\n            // [databind#125]: allow use of converters\n            JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop);\n            if (deser == null) {\n                deser = findDeserializer(ctxt, prop.getType(), prop);\n            }\n            prop = prop.withValueDeserializer(deser);\n        } else {\n            // may need contextual version\n            JsonDeserializer<Object> deser = prop.getValueDeserializer();\n                        JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop, prop.getType());\n            if (cd != deser) {\n                prop = prop.withValueDeserializer(cd);\n            }\n        }\n        // Need to link managed references with matching back references\n        prop = _resolveManagedReferenceProperty(ctxt, prop);\n        // [databind#351[: need to wrap properties that require object id resolution.\n        if (!(prop instanceof ManagedReferenceProperty)) {\n            prop = _resolvedObjectIdProperty(ctxt, prop);\n        }\n        // Support unwrapped values (via @JsonUnwrapped)\n        SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);\n        if (u != null) {\n            prop = u;\n            if (unwrapped == null) {\n                unwrapped = new UnwrappedPropertyHandler();\n            }\n            unwrapped.addProperty(prop);\n                        _beanProperties.remove(prop);\n            continue;\n        }\n        // non-static inner classes too:\n        prop = _resolveInnerClassValuedProperty(ctxt, prop);\n        if (prop != origProp) {\n            _beanProperties.replace(prop);\n            // [databind#795]: Make sure PropertyBasedCreator's properties stay in sync\n            if (creatorProps != null) {\n                // 18-May-2015, tatu: _Should_ start with consistent set. But can we really\n                //   fully count on this? May need to revisit in future; seems to hold for now.\n                for (int i = 0, len = creatorProps.length; i < len; ++i) {\n                    if (creatorProps[i] == origProp) {\n                        creatorProps[i] = prop;\n                        break;\n                    }\n                    // ... as per above, it is possible we'd need to add this as fallback\n                    // if (but only if) identity check fails?\n                                    }\n            }\n        }\n        // one more thing: if this property uses \"external property\" type inclusion,\n        // it needs different handling altogether\n        if (prop.hasValueTypeDeserializer()) {\n            TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n            if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n                if (extTypes == null) {\n                    extTypes = new ExternalTypeHandler.Builder();\n                }\n                extTypes.addExternal(prop, typeDeser);\n                // In fact, remove from list of known properties to simplify later handling\n                _beanProperties.remove(prop);\n                continue;\n            }\n        }\n    }\n    // \"any setter\" may also need to be resolved now\n    if (_anySetter != null && !_anySetter.hasValueDeserializer()) {\n        _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty()));\n    }\n    // as well as delegate-based constructor:\n    if (_valueInstantiator.canCreateUsingDelegate()) {\n        JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n        if (delegateType == null) {\n            throw new IllegalArgumentException(\"Invalid delegate-creator definition for \" + _beanType + \": value instantiator (\" + _valueInstantiator.getClass().getName() + \") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n        }\n        _delegateDeserializer = _findDelegateDeserializer(ctxt, delegateType, _valueInstantiator.getDelegateCreator());\n    }\n    // and array-delegate-based constructor:\n    if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n        JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n        if (delegateType == null) {\n            throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \" + _beanType + \": value instantiator (\" + _valueInstantiator.getClass().getName() + \") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n        }\n        _arrayDelegateDeserializer = _findDelegateDeserializer(ctxt, delegateType, _valueInstantiator.getArrayDelegateCreator());\n    }\n    // And now that we know CreatorProperty instances are also resolved can finally create the creator:\n    if (creatorProps != null) {\n        _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n    }\n    if (extTypes != null) {\n        // 21-Jun-2016, tatu: related to [databind#999], may need to link type ids too,\n        //    so need to pass collected properties\n        _externalTypeIdHandler = extTypes.build();\n        // we consider this non-standard, to offline handling\n        _nonStandardCreation = true;\n    }\n    _unwrappedPropertyHandler = unwrapped;\n    if (unwrapped != null) {\n        // we consider this non-standard, to offline handling\n        _nonStandardCreation = true;\n    }\n    // may need to disable vanilla processing, if unwrapped handling was enabled...\n    _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;\n}", "method_range": "456-624", "fault_locations": "612"}}