{"com.google.javascript.jscomp.CodeGenerator.add": {"buggy_content": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n        Preconditions.checkState(childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        // For right-hand-side of operations, only pass context if it's\n        // the IN_FOR_INIT_CLAUSE one.\n        Context rhsContext = getContextForNoInOperator(context);\n        // Handle associativity.\n        // e.g. if the parse tree is a * (b * c),\n        // we can simply generate a * b * c.\n        if (last.getType() == type && NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n            // Assignments are the only right-associative binary operators\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount >= 2 && childCount <= 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                // second child contains the catch block, or nothing if there\n                // isn't a catch block\n                Node catchblock = first.getNext().getFirstChild();\n                if (catchblock != null) {\n                    add(catchblock);\n                }\n                if (childCount == 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount == 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount == 1);\n            add(\"throw\");\n            add(first);\n            // Must have a ';' after a throw statement, otherwise safari can't\n            // parse this.\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount == 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount == 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first != null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first == null || first.getType() == Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"=\", true);\n                if (first.getType() == Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    // Add expression, consider nearby code at lowest level of\n                    // precedence.\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount == 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount == ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                // All of these unary operators are right-associative\n                Preconditions.checkState(childCount == 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount == 1);\n                // It's important to our sanity checker that the code\n                // we print produces the same AST as the code we parse back.\n                // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n                if (n.getFirstChild().getType() == Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount == 3);\n                int p = NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() != Token.STRING || last.getType() != Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n            // I only use one .add because whitespace matters\n            if (childCount == 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount == 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() != Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount == 3);\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context == Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n            Preconditions.checkState(childCount == 1);\n            Preconditions.checkState(first.getType() == Token.FUNCTION);\n            // Get methods are unnamed\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type == Token.GET) {\n                // Get methods have no parameters.\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                // Set methods have one parameter.\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            // The name is on the GET or SET node.\n            String name = n.getString();\n            Node fn = first;\n            Node parameters = fn.getChildAtIndex(1);\n            Node body = fn.getLastChild();\n            // Add the property name.\n            if (TokenStream.isJSIdentifier(name) && // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                // Determine if the string is a simple number.\n                add(jsString(n.getString(), outputCharsetEncoder));\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() != Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT);\n                for (Node c = first; c != null; c = c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    // VAR doesn't include ';' since it gets used in expressions\n                    if (c.getType() == Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() == Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    // Prefer to break lines in between top-level statements\n                    // because top level statements are more homogeneous.\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount == 4) {\n                add(\"for(\");\n                if (first.getType() == Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount == 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount == 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount == 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount == 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() == Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens = (first.getType() == Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount == 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount == 1);\n                String o = type == Token.INC ? \"++\" : \"--\";\n                int postProp = n.getIntProp(Node.INCRDECR_PROP);\n                // A non-zero post-prop value indicates a post inc/dec, default of zero\n                // is a pre-inc/dec.\n                if (postProp != 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            // We have two special cases here:\n            // 1) If the left hand side of the call is a direct reference to eval,\n            // then it must have a DIRECT_EVAL annotation. If it does not, then\n            // that means it was originally an indirect call to eval, and that\n            // indirectness must be preserved.\n            // 2) If the left hand side of the call is a property reference,\n            // then the call must not a FREE_CALL annotation. If it does, then\n            // that means it was originally an call without an explicit this and\n            // that must be preserved.\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse = childCount == 3;\n            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount == 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount == 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount <= 1);\n            add(\"continue\");\n            if (childCount == 1) {\n                if (first.getType() != Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount == 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount <= 1);\n            add(\"break\");\n            if (childCount == 1) {\n                if (first.getType() != Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount == 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence = NodeUtil.precedence(type);\n            // If the first child contains a CALL, then claim higher precedence\n            // to force parentheses. Otherwise, when parsed, NEW will bind to the\n            // first viable parentheses (don't traverse into functions).\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence = NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            // '()' is optional when no arguments are present\n            Node next = first.getNext();\n            if (next != null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount == 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens = (context == Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c = first; c != null; c = c.getNext()) {\n                    if (c != first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() == Token.GET || c.getType() == Token.SET) {\n                        add(c);\n                    } else {\n                        // Object literal property names don't have to be quoted if they\n                        // are not JavaScript keywords\n                        if (c.getType() == Token.STRING && !c.isQuotedString() && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && // do not encode literally any non-literal characters that\n                        // were unicode escaped.\n                        NodeUtil.isLatin(c.getString())) {\n                            add(c.getString());\n                        } else {\n                            // Determine if the string is a simple number.\n                            addExpr(c, 1);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context == Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount == 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount == 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount == 2);\n            if (first.getType() != Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        // This node is auto generated in anonymous functions and should just get\n        // ignored for our purposes.\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}", "method_range": "82-722", "fault_locations": "343,348,349,350,651,652,653,654,656,657,658,659,662,663,666,714,715,716"}, "com.google.javascript.jscomp.parsing.IRFactory.transformAsString": {"buggy_content": "private Node transformAsString(AstNode n) {\n    Node ret;\n    if (n instanceof Name) {\n        ret = transformNameAsString((Name) n);\n    } else {\n        ret = transform(n);\n        Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING);\n        if (ret.getType() == Token.STRING) {\n            ret.putBooleanProp(Node.QUOTED_PROP, true);\n        }\n    }\n    return ret;\n}", "method_range": "343-356", "fault_locations": "346,347,349,350,351,353"}, "com.google.javascript.jscomp.RenamePrototypes.visit": {"buggy_content": "public void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                String s = dest.getString();\n                if (s.equals(\"prototype\")) {\n                    processPrototypeParent(parent, t.getInput());\n                } else {\n                    markPropertyAccessCandidate(dest, t.getInput());\n                }\n            }\n            break;\n        case Token.OBJECTLIT:\n            if (!prototypeObjLits.contains(n)) {\n                // Object literals have their property name/value pairs as a flat\n                // list as their children. We want every other node in order to get\n                // only the property names.\n                for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n                    if (child.getType() != Token.NUMBER) {\n                        markObjLitPropertyCandidate(child, t.getInput());\n                    }\n                }\n            }\n            break;\n    }\n}", "method_range": "313-343", "fault_locations": "336"}, "com.google.javascript.jscomp.RenamePrototypes.processPrototypeParent": {"buggy_content": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getFirstChild().getNext();\n            } else {\n                map = n.getLastChild();\n            }\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "method_range": "350-385", "fault_locations": "375,376,377"}}