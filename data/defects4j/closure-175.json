{"com.google.javascript.jscomp.FunctionInjector.canInlineReferenceToFunction": {"buggy_content": "CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set<String> needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n        if (!assumeMinimumCapture && !t.inGlobalScope()) {\n            // TODO(johnlenz): Allow inlining into any scope without local names or\n            // inner functions.\n            return CanInlineResult.NO;\n        } else if (NodeUtil.isWithinLoop(callNode)) {\n            // An inner closure maybe relying on a local value holding a value for a\n            // single iteration through a loop.\n            return CanInlineResult.NO;\n        }\n    }\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Allow 'this' references to be replaced with a\n        // global 'this' object.\n        return CanInlineResult.NO;\n    }\n    if (mode == InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n    }\n}", "method_range": "173-213", "fault_locations": "208"}, "com.google.javascript.jscomp.FunctionInjector.canInlineReferenceDirectly": {"buggy_content": "private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n        return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n        if (NodeUtil.isFunctionObjectCall(callNode)) {\n            // TODO(johnlenz): Support replace this with a value.\n            if (cArg == null || !cArg.isThis()) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        } else {\n            // \".apply\" call should be filtered before this.\n            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        }\n    }\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n        if (fnParam != null) {\n            if (cArg != null) {\n                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n                    return CanInlineResult.NO;\n                }\n            }\n            fnParam = fnParam.getNext();\n        }\n        // Limit the inlining\n        if (cArg != null) {\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n                return CanInlineResult.NO;\n            }\n            cArg = cArg.getNext();\n        }\n    }\n    return CanInlineResult.YES;\n}", "method_range": "689-737", "fault_locations": "689,690,695,711,712,713,715,716,717,718,719,720,721,722,723,724,725,726,728,729,731,732"}}