{"com.google.javascript.jscomp.FunctionTypeBuilder.apply": {"buggy_content": "@Override\npublic boolean apply(JSType type) {\n    // TODO(user): Doing an instanceof check here is too\n    // restrictive as (Date,Error) is, for instance, an object type\n    // even though its implementation is a UnionType. Would need to\n    // create interfaces JSType, ObjectType, FunctionType etc and have\n    // separate implementation instead of the class hierarchy, so that\n    // union types can also be object types, etc.\n    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n    }\n    return true;\n}", "method_range": "176-190", "fault_locations": "184"}, "com.google.javascript.rhino.jstype.FunctionType.resolveInternal": {"buggy_content": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "method_range": "861-903", "fault_locations": "879,880"}}