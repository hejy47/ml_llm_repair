{"com.google.javascript.jscomp.Compiler.toSource": {"buggy_content": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "method_range": "1393-1452", "fault_locations": "1432"}, "com.google.javascript.jscomp.Compiler.call": {"buggy_content": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "method_range": "1397-1450", "fault_locations": "1432"}, "com.google.javascript.jscomp.Compiler.toSource2": {"buggy_content": "@Override\nString toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null);\n}", "method_range": "1458-1462", "fault_locations": "1459,1460,1461"}, "com.google.javascript.jscomp.Compiler.toSource3": {"buggy_content": "private String toSource(Node n, SourceMap sourceMap) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n    Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n    return builder.build();\n}", "method_range": "1467-1482", "fault_locations": "1467,1469,1470,1473"}}