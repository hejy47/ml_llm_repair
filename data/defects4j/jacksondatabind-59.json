{"com.fasterxml.jackson.databind.type.TypeFactory.constructSpecializedType": {"buggy_content": "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // If not, we'll need to do more thorough forward+backwards resolution. Sigh.\n        // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is\n        //    a way to fully resolve and merge hierarchies; but that gets expensive\n        //    so let's, for now, try to create close-enough approximation that\n        //    is not 100% same, structurally, but has equivalent information for\n        //    our specific neeeds.\n        // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)\n        //  for a case where this code does get invoked: not ideal\n        // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but\n        //  not certain it would reliably work... but let's hope for best for now\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        if (baseType.isInterface()) {\n            newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n        } else {\n            newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n        }\n        // Only SimpleType returns null, but if so just resolve regularly\n        if (newType == null) {\n            newType = _fromClass(null, subclass, tb);\n        }\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    return newType;\n    // 20-Oct-2015, tatu: Old simplistic approach\n    }", "method_range": "342-474", "fault_locations": "427,428"}}