{"com.google.javascript.jscomp.JsAst.parse": {"buggy_content": "private void parse(AbstractCompiler compiler) {\n    try {\n        ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(), compiler.getParserConfig(), compiler.getDefaultErrorReporter(), logger_);\n        root = result.ast;\n        compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n        compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n    if (root == null || compiler.hasHaltingErrors()) {\n        // Most passes try to report as many errors as possible,\n        // so there may already be errors. We only care if there were\n        // errors in the code we just parsed.\n        // There was a parse error or IOException, so use a dummy block.\n        root = IR.script();\n    } else {\n        compiler.prepareAst(root);\n    }\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n}", "method_range": "81-108", "fault_locations": "81,82,95,97,98"}, "com.google.javascript.jscomp.NodeUtil.newQualifiedNameNodeDeclaration": {"buggy_content": "public static Node newQualifiedNameNodeDeclaration(CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n        result = IR.var(nameNode, value);\n        result.setJSDocInfo(info);\n    } else {\n        result = IR.exprResult(IR.assign(nameNode, value));\n        result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n}", "method_range": "2360-2372", "fault_locations": "2367,2368,2369"}, "com.google.javascript.jscomp.ScopedAliases.findAliases": {"buggy_content": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "method_range": "351-398", "fault_locations": "356,357,362,363,365,366,372,373,381,382"}}