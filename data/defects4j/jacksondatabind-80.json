{"com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver.collectAndResolveSubtypesByClass": {"buggy_content": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(collected.values());\n}", "method_range": "57-95", "fault_locations": "78,79,85,86"}, "com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver.collectAndResolveSubtypesByTypeId": {"buggy_content": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n}", "method_range": "127-164", "fault_locations": "144,145,150,151"}}