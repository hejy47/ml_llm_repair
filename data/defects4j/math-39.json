{"org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate": {"buggy_content": "@Override\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n    // create some internal working arrays\n    final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n    // set up integration control objects\n    stepStart = equations.getTime();\n    double hNew = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n    // main integration loop\n    isLastStep = false;\n    do {\n        interpolator.shift();\n        // iterate over step size, ensuring local normalized error is smaller than 1\n        double error = 10;\n        while (error >= 1.0) {\n            if (firstTime || !fsal) {\n                // first stage\n                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n            if (firstTime) {\n                final double[] scale = new double[mainSetDimension];\n                if (vecAbsoluteTolerance == null) {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n                    }\n                } else {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n                    }\n                }\n                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false;\n            }\n            stepSize = hNew;\n            // next stages\n            for (int k = 1; k < stages; ++k) {\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[k - 1][0] * yDotK[0][j];\n                    for (int l = 1; l < k; ++l) {\n                        sum += a[k - 1][l] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n            }\n            // estimate the state at the end of the step\n            for (int j = 0; j < y0.length; ++j) {\n                double sum = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n            // estimate the error at the end of the step\n            error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error >= 1.0) {\n                // reject the step and attempt to reduce error by stepsize control\n                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n        }\n        // local error is small enough: accept the step, trigger events and step handlers\n        interpolator.storeTime(stepStart + stepSize);\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n        System.arraycopy(y, 0, yTmp, 0, y.length);\n        if (!isLastStep) {\n            // prepare next step\n            interpolator.storeTime(stepStart);\n            if (fsal) {\n                // save the last evaluation for the next step\n                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n            }\n            // stepsize control for next step\n            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n            final double scaledH = stepSize * factor;\n            final double nextT = stepStart + scaledH;\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n            hNew = filterStep(scaledH, forward, nextIsLast);\n            final double filteredNextT = stepStart + hNew;\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n            if (filteredNextIsLast) {\n                hNew = t - stepStart;\n            }\n        }\n    } while (!isLastStep);\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n    resetInternalState();\n}", "method_range": "190-328", "fault_locations": "252"}}