{"com.google.javascript.jscomp.CheckGlobalThis.shouldTraverse": {"buggy_content": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // or @override annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.isInterface() || jsDoc.hasThisType() || jsDoc.isOverride())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {}; // or\n        // var a = {x: function() {}};\n        int pType = parent.getType();\n        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (NodeUtil.isGet(lhs)) {\n                if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                Node llhs = lhs.getFirstChild();\n                if (llhs.getType() == Token.GETPROP && llhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "method_range": "84-142", "fault_locations": "108"}, "com.google.javascript.jscomp.RuntimeTypeCheck.visitFunction": {"buggy_content": "private void visitFunction(NodeTraversal t, Node n) {\n    FunctionType funType = (FunctionType) n.getJSType();\n    Node block = n.getLastChild();\n    Node paramName = NodeUtil.getFnParameters(n).getFirstChild();\n    Node insertionPoint = null;\n    // To satisfy normalization constraints, the type checking must be\n    // added after any inner function declarations.\n    for (Node paramType : funType.getParameters()) {\n        // Can this ever happen?\n        if (paramName == null) {\n            return;\n        }\n        Node checkNode = createCheckTypeCallNode(paramType.getJSType(), paramName.cloneTree());\n        if (checkNode == null) {\n            // We don't know how to check this parameter type.\n            paramName = paramName.getNext();\n            continue;\n        }\n        checkNode = new Node(Token.EXPR_RESULT, checkNode);\n        if (insertionPoint == null) {\n            block.addChildToFront(checkNode);\n        } else {\n            block.addChildAfter(checkNode, insertionPoint);\n        }\n        compiler.reportCodeChange();\n        paramName = paramName.getNext();\n        insertionPoint = checkNode;\n    }\n}", "method_range": "239-274", "fault_locations": "246,247"}}