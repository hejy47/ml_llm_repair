{"org.apache.commons.codec.binary.Base64InputStream.read": {"buggy_content": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "method_range": "138-182", "fault_locations": "169,170,171"}, "org.apache.commons.codec.binary.Base64.setInitialBuffer": {"buggy_content": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length == outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}", "method_range": "419-425", "fault_locations": "419,420,421,422,423,424,425"}}