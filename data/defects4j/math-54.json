{"org.apache.commons.math.dfp.Dfp.Dfp": {"buggy_content": "protected Dfp(final DfpField field, double x) {\n    // initialize as if 0\n    mant = new int[field.getRadixDigits()];\n    sign = 1;\n    exp = 0;\n    nans = FINITE;\n    this.field = field;\n    long bits = Double.doubleToLongBits(x);\n    long mantissa = bits & 0x000fffffffffffffL;\n    int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n    if (exponent == -1023) {\n        // Zero or sub-normal\n        if (x == 0) {\n            // make sure 0 has the right sign\n            return;\n        }\n        exponent++;\n        // Normalize the subnormal number\n        while ((mantissa & 0x0010000000000000L) == 0) {\n            exponent--;\n            mantissa <<= 1;\n        }\n        mantissa &= 0x000fffffffffffffL;\n    }\n    if (exponent == 1024) {\n        // infinity or NAN\n        if (x != x) {\n            sign = (byte) 1;\n            nans = QNAN;\n        } else if (x < 0) {\n            sign = (byte) -1;\n            nans = INFINITE;\n        } else {\n            sign = (byte) 1;\n            nans = INFINITE;\n        }\n        return;\n    }\n    Dfp xdfp = new Dfp(field, mantissa);\n    // Divide by 2^52, then add one\n    xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());\n    xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n    if ((bits & 0x8000000000000000L) != 0) {\n        xdfp = xdfp.negate();\n    }\n    System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n    sign = xdfp.sign;\n    exp = xdfp.exp;\n    nans = xdfp.nans;\n}", "method_range": "256-314", "fault_locations": "272,273"}, "org.apache.commons.math.dfp.Dfp.toDouble": {"buggy_content": "public double toDouble() {\n    if (isInfinite()) {\n        if (lessThan(getZero())) {\n            return Double.NEGATIVE_INFINITY;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    if (isNaN()) {\n        return Double.NaN;\n    }\n    Dfp y = this;\n    boolean negate = false;\n    if (lessThan(getZero())) {\n        y = negate();\n        negate = true;\n    }\n        int exponent = (int) (y.log10() * 3.32);\n    if (exponent < 0) {\n        exponent--;\n    }\n    Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n    while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n        tempDfp = tempDfp.multiply(2);\n        exponent++;\n    }\n    exponent--;\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n    if (exponent > -1023) {\n        y = y.subtract(getOne());\n    }\n    if (exponent < -1074) {\n        return 0;\n    }\n    if (exponent > 1023) {\n        return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n    }\n    y = y.multiply(newInstance(4503599627370496l)).rint();\n    String str = y.toString();\n    str = str.substring(0, str.length() - 1);\n    long mantissa = Long.parseLong(str);\n    if (mantissa == 4503599627370496L) {\n        // Handle special case where we round up to next power of two\n        mantissa = 0;\n        exponent++;\n    }\n        if (exponent <= -1023) {\n        exponent--;\n    }\n    while (exponent < -1023) {\n        exponent++;\n        mantissa >>>= 1;\n    }\n    long bits = mantissa | ((exponent + 1023L) << 52);\n    double x = Double.longBitsToDouble(bits);\n    if (negate) {\n        x = -x;\n    }\n    return x;\n}", "method_range": "2303-2384", "fault_locations": "2319"}}