{"com.google.javascript.jscomp.UnreachableCodeElimination.tryRemoveUnconditionalBranching": {"buggy_content": "@SuppressWarnings(\"fallthrough\")\nprivate void tryRemoveUnconditionalBranching(Node n) {\n    /*\n       * For each unconditional branching control flow node, check to see\n       * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n       * the branching target. If it is, the branch node is safe to be removed.\n       *\n       * This is not as clever as MinimizeExitPoints because it doesn't do any\n       * if-else conversion but it handles more complicated switch statements\n       * much more nicely.\n       */\n    // If n is null the target is the end of the function, nothing to do.\n    if (n == null) {\n        return;\n    }\n    DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n    if (gNode == null) {\n        return;\n    }\n    switch(n.getType()) {\n        case Token.RETURN:\n            if (n.hasChildren()) {\n                break;\n            }\n        case Token.BREAK:\n        case Token.CONTINUE:\n            // We are looking for a control flow changing statement that always\n            // branches to the same node. If after removing it control still\n            // branches to the same node, it is safe to remove.\n            List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\n            if (outEdges.size() == 1 && // If there is a next node, this jump is not useless.\n            (n.getNext() == null || n.getNext().isFunction())) {\n                Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n                Node fallThrough = computeFollowing(n);\n                Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n                if (nextCfgNode == fallThrough) {\n                    removeNode(n);\n                }\n            }\n    }\n}", "method_range": "128-175", "fault_locations": "170"}}