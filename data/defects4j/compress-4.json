{"org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream.close": {"buggy_content": "public void close() throws IOException {\n    if (!this.closed) {\n        this.finish();\n        out.close();\n        this.closed = true;\n    }\n}", "method_range": "334-340", "fault_locations": "336"}, "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream.close": {"buggy_content": "public void close() throws IOException {\n    if (!closed) {\n        finish();\n        buffer.close();\n        out.close();\n        closed = true;\n    }\n}", "method_range": "124-131", "fault_locations": "126"}, "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.close": {"buggy_content": "public void close() throws IOException {\n    finish();\n    if (raf != null) {\n        raf.close();\n    }\n    if (out != null) {\n        out.close();\n    }\n}", "method_range": "529-537", "fault_locations": "530"}, "org.apache.commons.compress.changes.ChangeSetPerformer.perform": {"buggy_content": "public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {\n    ChangeSetResults results = new ChangeSetResults();\n    Set workingSet = new LinkedHashSet(changes);\n    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\n        Change change = (Change) it.next();\n        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n    ArchiveEntry entry = null;\n    while ((entry = in.getNextEntry()) != null) {\n        boolean copy = true;\n        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\n            Change change = (Change) it.next();\n            final int type = change.type();\n            final String name = entry.getName();\n            if (type == Change.TYPE_DELETE && name != null) {\n                if (name.equals(change.targetFile())) {\n                    copy = false;\n                    it.remove();\n                    results.deleted(name);\n                    break;\n                }\n            } else if (type == Change.TYPE_DELETE_DIR && name != null) {\n                if (name.startsWith(change.targetFile() + \"/\")) {\n                    copy = false;\n                    results.deleted(name);\n                    break;\n                }\n            }\n        }\n        if (copy) {\n            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                copyStream(in, out, entry);\n                results.addedFromStream(entry.getName());\n            }\n        }\n    }\n    // Adds files which hasn't been added from the original and do not have replace mode on\n    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\n        Change change = (Change) it.next();\n        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n    return results;\n}", "method_range": "67-129", "fault_locations": "127,128"}}