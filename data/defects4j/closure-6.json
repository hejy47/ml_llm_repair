{"com.google.javascript.jscomp.TypeValidator.expectCanAssignToPropertyOf": {"buggy_content": "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "method_range": "362-389", "fault_locations": "366,367,368,385"}, "com.google.javascript.jscomp.TypeValidator.expectCanAssignTo": {"buggy_content": "boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "method_range": "402-413", "fault_locations": "405,406,407,409"}}