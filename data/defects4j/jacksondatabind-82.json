{"com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.addBeanProps": {"buggy_content": "protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig().getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        // Or explicit/implicit definitions?\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    } else {\n        anySetterField = beanDesc.findAnySetterField();\n        if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);\n    // After which we can let custom code change the set\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n                if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n                        AnnotatedMethod getter = propDef.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                        // but let's call a method just to allow custom builders to be aware...\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}", "method_range": "472-615", "fault_locations": "495"}}