{"org.joda.time.field.UnsupportedDurationField.compareTo": {"buggy_content": "public int compareTo(DurationField durationField) {\n    if (durationField.isSupported()) {\n        return 1;\n    }\n    return 0;\n}", "method_range": "226-231", "fault_locations": "227,228,229"}, "org.joda.time.Partial.Partial": {"buggy_content": "public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n    super();\n    chronology = DateTimeUtils.getChronology(chronology).withUTC();\n    iChronology = chronology;\n    if (types == null) {\n        throw new IllegalArgumentException(\"Types array must not be null\");\n    }\n    if (values == null) {\n        throw new IllegalArgumentException(\"Values array must not be null\");\n    }\n    if (values.length != types.length) {\n        throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n    }\n    if (types.length == 0) {\n        iTypes = types;\n        iValues = values;\n        return;\n    }\n    for (int i = 0; i < types.length; i++) {\n        if (types[i] == null) {\n            throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n        }\n    }\n    DurationField lastUnitField = null;\n    for (int i = 0; i < types.length; i++) {\n        DateTimeFieldType loopType = types[i];\n        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n        if (i > 0) {\n            int compare = lastUnitField.compareTo(loopUnitField);\n            if (compare < 0) {\n                throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" < \" + loopType.getName());\n            } else if (compare == 0) {\n                if (types[i - 1].getRangeDurationType() == null) {\n                    if (loopType.getRangeDurationType() == null) {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                } else {\n                    if (loopType.getRangeDurationType() == null) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" < \" + loopType.getName());\n                    }\n                    DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                    DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                    if (lastRangeField.compareTo(loopRangeField) < 0) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + types[i - 1].getName() + \" < \" + loopType.getName());\n                    }\n                    if (lastRangeField.compareTo(loopRangeField) == 0) {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                }\n            }\n        }\n        lastUnitField = loopUnitField;\n    }\n    iTypes = (DateTimeFieldType[]) types.clone();\n    chronology.validate(this, values);\n    iValues = (int[]) values.clone();\n}", "method_range": "189-251", "fault_locations": "216,217,221"}}