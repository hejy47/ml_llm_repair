{"com.google.javascript.jscomp.MakeDeclaredNamesUnique.enterScope": {"buggy_content": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "method_range": "75-104", "fault_locations": "91,92,93,94,96,97,98"}, "com.google.javascript.jscomp.MakeDeclaredNamesUnique.shouldTraverse": {"buggy_content": "@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}", "method_range": "113-153", "fault_locations": "116,152"}, "com.google.javascript.jscomp.MakeDeclaredNamesUnique.visit": {"buggy_content": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "method_range": "155-186", "fault_locations": "157,174"}}