{"com.google.javascript.jscomp.FunctionTypeBuilder.inferReturnType": {"buggy_content": "FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n    returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE);\n    if (templateTypeName != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    return this;\n}", "method_range": "198-207", "fault_locations": "200,201"}, "com.google.javascript.jscomp.FunctionTypeBuilder.buildAndRegister": {"buggy_content": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "method_range": "472-510", "fault_locations": "493,494,496"}, "com.google.javascript.jscomp.TypedScopeCreator.getFunctionType": {"buggy_content": "private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType = null;\n    // Handle function aliases.\n    if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n            functionType = (FunctionType) var.getType();\n            if (functionType != null && functionType.isConstructor()) {\n                typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n        }\n        return functionType;\n    }\n    Node owner = null;\n    if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n    }\n    Node errorRoot = rValue == null ? lvalueNode : rValue;\n    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n    Node fnRoot = isFnLiteral ? rValue : null;\n    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n    if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n        }\n    }\n    if (functionType == null) {\n        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            // We don't really have any type information in the annotation.\n            // Before we give up on this function, look at the object we're\n            // assigning it to. For example, if the function looks like this:\n            // SubFoo.prototype.bar = function() { ... };\n            // We can use type information on Foo.prototype.bar and apply it\n            // to this function.\n            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var != null) {\n                    ObjectType ownerType = ObjectType.cast(var.getType());\n                    FunctionType propType = null;\n                    if (ownerType != null) {\n                        String propName = lvalueNode.getLastChild().getString();\n                        propType = findOverriddenFunction(ownerType, propName);\n                    }\n                    if (propType != null) {\n                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n                    }\n                }\n            }\n        }\n    }\n    // end if (functionType == null)\n    if (functionType == null) {\n        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n    }\n    // assigning the function type to the function node\n    if (rValue != null) {\n        setDeferredType(rValue, functionType);\n    }\n    // all done\n    return functionType;\n}", "method_range": "550-644", "fault_locations": "576,577,616,617,633,634"}, "com.google.javascript.rhino.jstype.FunctionType.cloneWithNewReturnType": {"buggy_content": "FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\n    return new FunctionType(registry, null, null, new ArrowType(registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);\n}", "method_range": "515-521", "fault_locations": "517"}}