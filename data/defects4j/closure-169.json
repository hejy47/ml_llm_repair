{"com.google.javascript.rhino.jstype.ArrowType.hasEqualParameters": {"buggy_content": "boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\n    Node thisParam = parameters.getFirstChild();\n    Node otherParam = that.parameters.getFirstChild();\n    while (thisParam != null && otherParam != null) {\n        JSType thisParamType = thisParam.getJSType();\n        JSType otherParamType = otherParam.getJSType();\n        if (thisParamType != null) {\n            // Both parameter lists give a type for this param, it should be equal\n            if (otherParamType != null && !thisParamType.checkEquivalenceHelper(otherParamType, tolerateUnknowns)) {\n                return false;\n            }\n        } else {\n            if (otherParamType != null) {\n                return false;\n            }\n        }\n        thisParam = thisParam.getNext();\n        otherParam = otherParam.getNext();\n    }\n    // One of the parameters is null, so the types are only equal if both\n    // parameter lists are null (they are equal).\n    return thisParam == otherParam;\n}", "method_range": "177-201", "fault_locations": "177,185,186,187,201"}, "com.google.javascript.rhino.jstype.ArrowType.checkArrowEquivalenceHelper": {"buggy_content": "boolean checkArrowEquivalenceHelper(ArrowType that, boolean tolerateUnknowns) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {\n        return false;\n    }\n    return hasEqualParameters(that, tolerateUnknowns);\n}", "method_range": "203-210", "fault_locations": "203,204,205,206,209"}, "com.google.javascript.rhino.jstype.FunctionType.tryMergeFunctionPiecewise": {"buggy_content": "private FunctionType tryMergeFunctionPiecewise(FunctionType other, boolean leastSuper) {\n    Node newParamsNode = null;\n    if (call.hasEqualParameters(other.call, false)) {\n        newParamsNode = call.parameters;\n    } else {\n        // If the parameters are not equal, don't try to merge them.\n        // Someday, we should try to merge the individual params.\n        return null;\n    }\n    JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType);\n    ObjectType newTypeOfThis = null;\n    if (isEquivalent(typeOfThis, other.typeOfThis)) {\n        newTypeOfThis = typeOfThis;\n    } else {\n        JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis);\n        if (maybeNewTypeOfThis instanceof ObjectType) {\n            newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\n        } else {\n            newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n        }\n    }\n    boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred;\n    return new FunctionType(registry, null, null, new ArrowType(registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false);\n}", "method_range": "789-828", "fault_locations": "792"}, "com.google.javascript.rhino.jstype.FunctionType.checkFunctionEquivalenceHelper": {"buggy_content": "boolean checkFunctionEquivalenceHelper(FunctionType that, boolean tolerateUnknowns) {\n    if (isConstructor()) {\n        if (that.isConstructor()) {\n            return this == that;\n        }\n        return false;\n    }\n    if (isInterface()) {\n        if (that.isInterface()) {\n            return getReferenceName().equals(that.getReferenceName());\n        }\n        return false;\n    }\n    if (that.isInterface()) {\n        return false;\n    }\n    return typeOfThis.checkEquivalenceHelper(that.typeOfThis, tolerateUnknowns) && call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);\n}", "method_range": "889-910", "fault_locations": "889,890,905,906,908,909"}, "com.google.javascript.rhino.jstype.FunctionType.hashCode": {"buggy_content": "@Override\npublic int hashCode() {\n    return isInterface() ? getReferenceName().hashCode() : call.hashCode();\n}", "method_range": "912-915", "fault_locations": "913,914"}, "com.google.javascript.rhino.jstype.FunctionType.hasEqualCallType": {"buggy_content": "public boolean hasEqualCallType(FunctionType otherType) {\n    return this.call.checkArrowEquivalenceHelper(otherType.call, false);\n}", "method_range": "917-919", "fault_locations": "918"}, "com.google.javascript.rhino.jstype.JSType.isEquivalentTo": {"buggy_content": "public final boolean isEquivalentTo(JSType that) {\n    return checkEquivalenceHelper(that, false);\n}", "method_range": "491-493", "fault_locations": "492"}, "com.google.javascript.rhino.jstype.JSType.isInvariant": {"buggy_content": "public final boolean isInvariant(JSType that) {\n    return checkEquivalenceHelper(that, false);\n}", "method_range": "499-501", "fault_locations": "499,500"}, "com.google.javascript.rhino.jstype.JSType.differsFrom": {"buggy_content": "public final boolean differsFrom(JSType that) {\n    return !checkEquivalenceHelper(that, true);\n}", "method_range": "513-515", "fault_locations": "514"}, "com.google.javascript.rhino.jstype.JSType.checkEquivalenceHelper": {"buggy_content": "boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {\n    if (this == that) {\n        return true;\n    }\n    boolean thisUnknown = isUnknownType();\n    boolean thatUnknown = that.isUnknownType();\n    if (thisUnknown || thatUnknown) {\n        if (tolerateUnknowns) {\n            // If we're checking for invariance, the unknown type is invariant\n            // with everyone.\n            // If we're checking data flow, then two types are the same if they're\n            // both unknown.\n            return thisUnknown && thatUnknown;\n        } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {\n            // If they're both unknown, but one is a nominal type and the other\n            // is not, then we should fail out immediately. This ensures that\n            // we won't unbox the unknowns further down.\n            return false;\n        }\n    }\n    if (isUnionType() && that.isUnionType()) {\n        return this.toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(), tolerateUnknowns);\n    }\n    if (isFunctionType() && that.isFunctionType()) {\n        return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(), tolerateUnknowns);\n    }\n    if (isRecordType() && that.isRecordType()) {\n        return this.toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(), tolerateUnknowns);\n    }\n    ParameterizedType thisParamType = toMaybeParameterizedType();\n    ParameterizedType thatParamType = that.toMaybeParameterizedType();\n    if (thisParamType != null || thatParamType != null) {\n        // Check if one type is parameterized, but the other is not.\n        boolean paramsMatch = false;\n        if (thisParamType != null && thatParamType != null) {\n            paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(), tolerateUnknowns);\n        } else if (tolerateUnknowns) {\n            // If one of the type parameters is unknown, but the other is not,\n            // then we consider these the same for the purposes of data flow\n            // and invariance.\n            paramsMatch = true;\n        } else {\n            paramsMatch = false;\n        }\n        JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal();\n        JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal();\n        return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);\n    }\n    if (isNominalType() && that.isNominalType()) {\n        return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName());\n    }\n    // Unbox other proxies.\n    if (this instanceof ProxyObjectType) {\n        return ((ProxyObjectType) this).getReferencedTypeInternal().checkEquivalenceHelper(that, tolerateUnknowns);\n    }\n    if (that instanceof ProxyObjectType) {\n        return checkEquivalenceHelper(((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns);\n    }\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == that;\n}", "method_range": "520-606", "fault_locations": "520,523,524,525,526,528,539,540,543,544,545,547,548,550,555,556,557,565,566,567,568,571,572,578,579,580,583,584,592,598"}, "com.google.javascript.rhino.jstype.RecordType.checkRecordEquivalenceHelper": {"buggy_content": "boolean checkRecordEquivalenceHelper(RecordType otherRecord, boolean tolerateUnknowns) {\n    Set<String> keySet = properties.keySet();\n    Map<String, JSType> otherProps = otherRecord.properties;\n    if (!otherProps.keySet().equals(keySet)) {\n        return false;\n    }\n    for (String key : keySet) {\n        if (!otherProps.get(key).checkEquivalenceHelper(properties.get(key), tolerateUnknowns)) {\n            return false;\n        }\n    }\n    return true;\n}", "method_range": "117-131", "fault_locations": "118,124,125,126"}, "com.google.javascript.rhino.jstype.RecordType.getGreatestSubtypeHelper": {"buggy_content": "JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n        RecordType thatRecord = that.toMaybeRecordType();\n        RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n        builder.setSynthesized(true);\n        // The greatest subtype consists of those *unique* properties of both\n        // record types. If any property conflicts, then the NO_TYPE type\n        // is returned.\n        for (String property : properties.keySet()) {\n            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isInvariant(getPropertyType(property))) {\n                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n            }\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\n        }\n        for (String property : thatRecord.properties.keySet()) {\n            if (!hasProperty(property)) {\n                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));\n            }\n        }\n        return builder.build();\n    }\n    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n        // In this branch, the other type is some object type. We find\n        // the greatest subtype with the following algorithm:\n        // 1) For each property \"x\" of this record type, take the union\n        //    of all classes with a property \"x\" with a compatible property type.\n        //    and which are a subtype of {@code that}.\n        // 2) Take the intersection of all of these unions.\n        for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n            String propName = entry.getKey();\n            JSType propType = entry.getValue();\n            UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {\n                JSType altPropType = alt.getPropertyType(propName);\n                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {\n                    builder.addAlternate(alt);\n                }\n            }\n            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n        }\n    }\n    return greatestSubtype;\n}", "method_range": "153-213", "fault_locations": "201,202,204,205"}, "com.google.javascript.rhino.jstype.RecordType.isSubtype": {"buggy_content": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "method_range": "243-286", "fault_locations": "268,280"}, "com.google.javascript.rhino.jstype.UnionType.checkUnionEquivalenceHelper": {"buggy_content": "boolean checkUnionEquivalenceHelper(UnionType that, boolean tolerateUnknowns) {\n    if (!tolerateUnknowns && alternates.size() != that.alternates.size()) {\n        return false;\n    }\n    for (JSType alternate : that.alternates) {\n        if (!hasAlternate(alternate, tolerateUnknowns)) {\n            return false;\n        }\n    }\n    return true;\n}", "method_range": "333-345", "fault_locations": "334,335,337,338,340,343,344,345"}, "com.google.javascript.rhino.jstype.UnionType.hasAlternate": {"buggy_content": "private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n    for (JSType alternate : alternates) {\n        if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n            return true;\n        }\n    }\n    return false;\n}", "method_range": "347-354", "fault_locations": "347,349"}}