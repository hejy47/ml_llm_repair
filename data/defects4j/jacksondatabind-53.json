{"com.fasterxml.jackson.databind.type.TypeFactory.constructSpecializedType": {"buggy_content": "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // If not, we'll need to do more thorough forward+backwards resolution. Sigh.\n        // !!! TODO (as of 28-Jan-2016, at least)\n        // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is\n        //    a way to fully resolve and merge hierarchies; but that gets expensive\n        //    so let's, for now, try to create close-enough approximation that\n        //    is not 100% same, structurally, but has equivalent information for\n        //    our specific neeeds.\n        // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)\n        //  for a case where this code does get invoked: not ideal\n        // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but\n        //  not certain it would reliably work... but let's hope for best for now\n        if (baseType.isInterface()) {\n            newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });\n        } else {\n            newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);\n        }\n        // Only SimpleType returns null, but if so just resolve regularly\n        if (newType == null) {\n            TypeBindings tb = null;\n            if (baseType.containedTypeCount() == typeParamCount) {\n                if (typeParamCount == 1) {\n                    tb = TypeBindings.create(subclass, baseType.containedType(0));\n                } else if (typeParamCount == 2) {\n                    tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1));\n                }\n            }\n            newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb);\n        }\n    } while (false);\n    // except possibly handlers\n    //      newType = newType.withHandlersFrom(baseType);\n    return newType;\n    // 20-Oct-2015, tatu: Old simplistic approach\n    }", "method_range": "312-454", "fault_locations": "383,384,385,386,388,389,392,393,394,395,396,397,398,399,400,401,402,441,442,443,444,445"}, "com.fasterxml.jackson.databind.type.TypeFactory._fromAny": {"buggy_content": "protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings) {\n    JavaType resultType;\n    // simple class?\n    if (type instanceof Class<?>) {\n        // Important: remove possible bindings since this is type-erased thingy\n        resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);\n    } else // But if not, need to start resolving.\n    if (type instanceof ParameterizedType) {\n        resultType = _fromParamType(context, (ParameterizedType) type, bindings);\n    } else if (type instanceof JavaType) {\n        // [databind#116]\n        // no need to modify further if we already had JavaType\n        return (JavaType) type;\n    } else if (type instanceof GenericArrayType) {\n        resultType = _fromArrayType(context, (GenericArrayType) type, bindings);\n    } else if (type instanceof TypeVariable<?>) {\n        resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);\n    } else if (type instanceof WildcardType) {\n        resultType = _fromWildcard(context, (WildcardType) type, bindings);\n    } else {\n        // sanity check\n        throw new IllegalArgumentException(\"Unrecognized Type: \" + ((type == null) ? \"[null]\" : type.toString()));\n    }\n        if (_modifiers != null) {\n        TypeBindings b = resultType.getBindings();\n        if (b == null) {\n            b = EMPTY_BINDINGS;\n        }\n        for (TypeModifier mod : _modifiers) {\n            JavaType t = mod.modifyType(resultType, type, b, this);\n            if (t == null) {\n                throw new IllegalStateException(String.format(\"TypeModifier %s (of type %s) return null for type %s\", mod, mod.getClass().getName(), resultType));\n            }\n            resultType = t;\n        }\n    }\n    return resultType;\n}", "method_range": "1098-1146", "fault_locations": "1145,1146"}, "com.fasterxml.jackson.databind.type.TypeFactory._fromClass": {"buggy_content": "protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings) {\n    // Very first thing: small set of core types we know well:\n    JavaType result = _findWellKnownSimple(rawType);\n    if (result != null) {\n        return result;\n    }\n    // Barring that, we may have recently constructed an instance\n    boolean cachable = (bindings == null) || bindings.isEmpty();\n    if (cachable) {\n        result = _typeCache.get(rawType);\n        if (result != null) {\n            return result;\n        }\n    }\n    // 15-Oct-2015, tatu: recursive reference?\n    if (context == null) {\n        context = new ClassStack(rawType);\n    } else {\n        ClassStack prev = context.find(rawType);\n        if (prev != null) {\n            // Self-reference: needs special handling, then...\n            ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);\n            prev.addSelfReference(selfRef);\n            return selfRef;\n        }\n        // no, but need to update context to allow for proper cycle resolution\n        context = context.child(rawType);\n    }\n    // First: do we have an array type?\n    if (rawType.isArray()) {\n        result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings);\n    } else {\n        // If not, need to proceed by first resolving parent type hierarchy\n        JavaType superClass;\n        JavaType[] superInterfaces;\n        if (rawType.isInterface()) {\n            superClass = null;\n            superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n        } else {\n            // Note: even Enums can implement interfaces, so can not drop those\n            superClass = _resolveSuperClass(context, rawType, bindings);\n            superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);\n        }\n        // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...\n        if (rawType == Properties.class) {\n            result = MapType.construct(rawType, bindings, superClass, superInterfaces, CORE_TYPE_STRING, CORE_TYPE_STRING);\n        } else // And then check what flavor of type we got. Start by asking resolved\n        // super-type if refinement is all that is needed?\n        if (superClass != null) {\n            result = superClass.refine(rawType, bindings, superClass, superInterfaces);\n        }\n        // if not, perhaps we are now resolving a well-known class or interface?\n        if (result == null) {\n            result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces);\n            if (result == null) {\n                result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);\n                if (result == null) {\n                    // but if nothing else, \"simple\" class for now:\n                    result = _newSimpleType(rawType, bindings, superClass, superInterfaces);\n                }\n            }\n        }\n    }\n    context.resolveSelfReferences(result);\n    if (cachable) {\n        _typeCache.putIfAbsent(rawType, result);\n    }\n    return result;\n}", "method_range": "1152-1229", "fault_locations": "1160,1161,1162,1165,1206,1207,1225,1226,1227"}}