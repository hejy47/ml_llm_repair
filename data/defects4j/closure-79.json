{"com.google.javascript.jscomp.Normalize.process": {"buggy_content": "@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}", "method_range": "118-149", "fault_locations": "122"}, "com.google.javascript.jscomp.VarCheck.createSynthesizedExternVar": {"buggy_content": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "method_range": "205-221", "fault_locations": "220,221"}}