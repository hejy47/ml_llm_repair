{"com.google.javascript.jscomp.MakeDeclaredNamesUnique.getOrginalNameInternal": {"buggy_content": "private static String getOrginalNameInternal(String name, int index) {\n    return name.substring(0, index);\n}", "method_range": "266-268", "fault_locations": "266,267,268"}, "com.google.javascript.jscomp.MakeDeclaredNamesUnique.getNameSuffix": {"buggy_content": "private static String getNameSuffix(String name, int index) {\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\n}", "method_range": "274-278", "fault_locations": "274,275,276,277,278"}, "com.google.javascript.jscomp.MakeDeclaredNamesUnique.visit": {"buggy_content": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOrginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                                // Check if the new name is valid and if it would cause conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.scope.declare(newName, var.nameNode, null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}", "method_range": "284-344", "fault_locations": "284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,303,304,307,308,309,310,318,319,320,321,322,325,326,327,328,329,330,331,335"}, "com.google.javascript.jscomp.MakeDeclaredNamesUnique.addDeclaredName": {"buggy_content": "@Override\npublic void addDeclaredName(String name) {\n    if (global) {\n        reserveName(name);\n    } else {\n        // It hasn't been declared locally yet, so increment the count.\n        if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n                newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n        }\n    }\n}", "method_range": "390-405", "fault_locations": "402"}, "com.google.javascript.jscomp.MakeDeclaredNamesUnique.reserveName": {"buggy_content": "private void reserveName(String name) {\n    nameUsage.setCount(name, 0, 1);\n}", "method_range": "419-421", "fault_locations": "419"}, "com.google.javascript.jscomp.Normalize.process": {"buggy_content": "@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "method_range": "78-104", "fault_locations": "82,100,101"}}