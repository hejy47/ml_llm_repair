{"com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode": {"buggy_content": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n        Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "method_range": "692-789", "fault_locations": "767"}}