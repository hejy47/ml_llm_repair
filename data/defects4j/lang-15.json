{"org.apache.commons.lang3.reflect.TypeUtils.isAssignable": {"buggy_content": "private static boolean isAssignable(Type type, ParameterizedType toParameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n    if (type == null) {\n        return true;\n    }\n    // only a null type can be assigned to null type which\n    // would have cause the previous to return true\n    if (toParameterizedType == null) {\n        return false;\n    }\n    // all types are assignable to themselves\n    if (toParameterizedType.equals(type)) {\n        return true;\n    }\n    // get the target type's raw type\n    Class<?> toClass = getRawType(toParameterizedType);\n    // get the subject type's type arguments including owner type arguments\n    // and supertype arguments up to and including the target class.\n    Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n    // null means the two types are not compatible\n    if (fromTypeVarAssigns == null) {\n        return false;\n    }\n    // compatible types, but there's no type arguments. this is equivalent\n    // to comparing Map< ?, ? > to Map, and raw types are always assignable\n    // to parameterized types.\n    if (fromTypeVarAssigns.isEmpty()) {\n        return true;\n    }\n    // get the target type's type arguments including owner type arguments\n    Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns);\n    // now to check each type argument\n    for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n        Type toTypeArg = entry.getValue();\n        Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n        // parameters must either be absent from the subject type, within\n        // the bounds of the wildcard type, or be an exact match to the\n        // parameters of the target type.\n        if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) {\n            return false;\n        }\n    }\n    return true;\n}", "method_range": "179-235", "fault_locations": "219,220,221"}, "org.apache.commons.lang3.reflect.TypeUtils.getTypeArguments": {"buggy_content": "private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n    // make sure they're assignable\n    if (!isAssignable(cls, toClass)) {\n        return null;\n    }\n    // can't work with primitives\n    if (cls.isPrimitive()) {\n        // both classes are primitives?\n        if (toClass.isPrimitive()) {\n            // dealing with widening here. No type arguments to be\n            // harvested with these two types.\n            return new HashMap<TypeVariable<?>, Type>();\n        }\n        // work with wrapper the wrapper class instead of the primitive\n        cls = ClassUtils.primitiveToWrapper(cls);\n    }\n    // create a copy of the incoming map, or an empty one if it's null\n    HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n    // has target class been reached?\n    if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n        return typeVarAssigns;\n    }\n    // walk the inheritance hierarchy until the target class is reached\n    return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n}", "method_range": "650-681", "fault_locations": "675"}}