{"com.google.javascript.jscomp.ScopedAliases.exitScope": {"buggy_content": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "method_range": "308-321", "fault_locations": "315,316"}, "com.google.javascript.jscomp.ScopedAliases.findAliases": {"buggy_content": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "method_range": "357-445", "fault_locations": "431,432"}, "com.google.javascript.jscomp.ScopedAliases.visit": {"buggy_content": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "method_range": "522-589", "fault_locations": "581"}}