{"com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder.buildTypeSerializer": {"buggy_content": "@Override\npublic TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeSerializer(idRes, null);\n        case PROPERTY:\n            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeSerializer(idRes, null);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n        case EXISTING_PROPERTY:\n            // as per [#528]\n            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n    }\n    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n}", "method_range": "67-89", "fault_locations": "73,74"}, "com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder.buildTypeDeserializer": {"buggy_content": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n    }\n    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n}", "method_range": "97-144", "fault_locations": "103,104"}, "com.fasterxml.jackson.databind.ObjectMapper.useForType": {"buggy_content": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "method_range": "228-263", "fault_locations": "231,232"}}