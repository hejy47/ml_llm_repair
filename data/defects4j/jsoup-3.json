{"org.jsoup.nodes.Element.append": {"buggy_content": "public Element append(String html) {\n    Validate.notNull(html);\n    Element fragment = Parser.parseBodyFragment(html, baseUri).body();\n    for (Node node : fragment.childNodes()) {\n        node.parentNode = null;\n        appendChild(node);\n    }\n    return this;\n}", "method_range": "267-276", "fault_locations": "270"}, "org.jsoup.nodes.Element.prepend": {"buggy_content": "public Element prepend(String html) {\n    Validate.notNull(html);\n    Element fragment = Parser.parseBodyFragment(html, baseUri).body();\n    List<Node> nodes = fragment.childNodes();\n    for (int i = nodes.size() - 1; i >= 0; i--) {\n        Node node = nodes.get(i);\n        node.parentNode = null;\n        prependChild(node);\n    }\n    return this;\n}", "method_range": "284-295", "fault_locations": "285,286,287"}, "org.jsoup.nodes.Element.wrap": {"buggy_content": "public Element wrap(String html) {\n    Validate.notEmpty(html);\n    Element wrapBody = Parser.parseBodyFragment(html, baseUri).body();\n    Elements wrapChildren = wrapBody.children();\n    Element wrap = wrapChildren.first();\n    if (// nothing to wrap with; noop\n    wrap == null)\n        return null;\n    Element deepest = getDeepChild(wrap);\n    parentNode.replaceChild(this, wrap);\n    deepest.addChild(this);\n    // remainder (unbalananced wrap, like <div></div><p></p> -- The <p> is remainder\n    if (wrapChildren.size() > 1) {\n        for (int i = 1; i < wrapChildren.size(); i++) {\n            // skip first\n            Element remainder = wrapChildren.get(i);\n            remainder.parentNode.removeChild(remainder);\n            wrap.appendChild(remainder);\n        }\n    }\n    return this;\n}", "method_range": "311-333", "fault_locations": "311,312,314"}, "org.jsoup.parser.Parser.addChildToParent": {"buggy_content": "private Element addChildToParent(Element child, boolean isEmptyElement) {\n    Element parent = popStackToSuitableContainer(child.tag());\n    Tag childTag = child.tag();\n    boolean validAncestor = stackHasValidParent(childTag);\n    if (!validAncestor) {\n        // create implicit parent around this child\n        Tag parentTag = childTag.getImplicitParent();\n        Element implicit = new Element(parentTag, baseUri);\n        // special case: make sure there's a head before putting in body\n        if (child.tag().equals(bodyTag)) {\n            Element head = new Element(headTag, baseUri);\n            implicit.appendChild(head);\n        }\n        implicit.appendChild(child);\n        // recurse to ensure somewhere to put parent\n        Element root = addChildToParent(implicit, false);\n        if (!isEmptyElement)\n            stack.addLast(child);\n        return root;\n    }\n    parent.appendChild(child);\n    if (!isEmptyElement)\n        stack.addLast(child);\n    return parent;\n}", "method_range": "219-247", "fault_locations": "224"}, "org.jsoup.parser.Parser.stackHasValidParent": {"buggy_content": "private boolean stackHasValidParent(Tag childTag) {\n    if (stack.size() == 1 && childTag.equals(htmlTag))\n        // root is valid for html node\n        return true;\n    // otherwise, look up the stack for valid ancestors\n    for (int i = stack.size() - 1; i >= 0; i--) {\n        Element el = stack.get(i);\n        Tag parent2 = el.tag();\n        if (parent2.isValidParent(childTag)) {\n            return true;\n        }\n    }\n    return false;\n}", "method_range": "249-263", "fault_locations": "251,252,256,257,258"}, "org.jsoup.parser.Tag.canContain": {"buggy_content": "boolean canContain(Tag child) {\n    Validate.notNull(child);\n    if (child.isBlock && !this.canContainBlock)\n        return false;\n    if (// not block == inline\n    !child.isBlock && !this.canContainInline)\n        return false;\n    if (this.optionalClosing && this.equals(child))\n        return false;\n    if (this.empty || this.isData())\n        return false;\n    // head can only contain a few. if more than head in here, modify to have a list of valids\n    // TODO: (could solve this with walk for ancestor)\n    if (this.tagName.equals(\"head\")) {\n        if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") || child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) {\n            return true;\n        }\n        return false;\n    }\n    // dt and dd (in dl)\n    if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\"))\n        return false;\n    if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\"))\n        return false;\n    // don't allow children to contain their parent (directly)\n    return true;\n}", "method_range": "67-101", "fault_locations": "98,99"}, "org.jsoup.parser.Tag.isValidParent": {"buggy_content": "boolean isValidParent(Tag child) {\n    if (child.ancestors.isEmpty())\n        // HTML tag\n        return true;\n    for (Tag tag : child.ancestors) {\n        if (this.equals(tag))\n            return true;\n    }\n    return false;\n}", "method_range": "156-166", "fault_locations": "156,157,158"}, "org.jsoup.parser.Tag.setPreserveWhitespace": {"buggy_content": "private Tag setPreserveWhitespace() {\n    preserveWhitespace = true;\n    return this;\n}", "method_range": "362-365", "fault_locations": "362,363"}}