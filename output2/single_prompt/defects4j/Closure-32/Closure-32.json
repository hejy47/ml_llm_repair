[{"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno = stream.getCharno() + 1;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                ignoreStar = true;\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = false;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,6 +24,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno = stream.getCharno() + 1;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n@@ -32,12 +33,13 @@\n                     builder.append('*');\n                 }\n                 token = next();\n+                ignoreStar = true;\n                 continue;\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n-                ignoreStar = true;\n+                ignoreStar = false;\n                 token = next();\n                 continue;\n             default:\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno = stream.getCharno() + 1;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,6 +24,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno = stream.getCharno() + 1;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0 && !builder.toString().endsWith(\" \")) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = false;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0 && !builder.toString().endsWith(\" \")) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,20 +24,25 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n-                } else {\n-                    // The star is part of the comment.\n                     if (builder.length() > 0) {\n                         builder.append(' ');\n                     }\n                     builder.append('*');\n+                } else {\n+                    // The star is part of the comment.\n+                    if (builder.length() > 0 && !builder.toString().endsWith(\" \")) {\n+                        builder.append(' ');\n+                    }\n+                    builder.append('*');\n                 }\n+                ignoreStar = true;\n                 token = next();\n                 continue;\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n-                ignoreStar = true;\n+                ignoreStar = false;\n                 token = next();\n                 continue;\n             default:\n@@ -58,7 +63,7 @@\n                     }\n                     return new ExtractionInfo(multilineText, token);\n                 }\n-                if (builder.length() > 0) {\n+                if (builder.length() > 0 && !builder.toString().endsWith(\" \")) {\n                     builder.append(' ');\n                 }\n                 builder.append(toString(token));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0 && builder.charAt(builder.length()-1) != ' ') {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                // ignore falls through to default behavior\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0 && builder.charAt(builder.length()-1) != ' ') {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -26,20 +26,13 @@\n                     // Mark the position after the star as the new start of the line.\n                 } else {\n                     // The star is part of the comment.\n-                    if (builder.length() > 0) {\n+                    if (builder.length() > 0 && builder.charAt(builder.length()-1) != ' ') {\n                         builder.append(' ');\n                     }\n                     builder.append('*');\n                 }\n                 token = next();\n-                continue;\n-            case EOL:\n-                if (option != WhitespaceOption.SINGLE_LINE) {\n-                    builder.append(\"\\n\");\n-                }\n-                ignoreStar = true;\n-                token = next();\n-                continue;\n+                // ignore falls through to default behavior\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n@@ -58,7 +51,7 @@\n                     }\n                     return new ExtractionInfo(multilineText, token);\n                 }\n-                if (builder.length() > 0) {\n+                if (builder.length() > 0 && builder.charAt(builder.length()-1) != ' ') {\n                     builder.append(' ');\n                 }\n                 builder.append(toString(token));\n@@ -68,6 +61,12 @@\n                 }\n                 builder.append(line);\n                 token = next();\n+            case EOL:\n+                if (option != WhitespaceOption.SINGLE_LINE) {\n+                    builder.append(\"\\n\");\n+                }\n+                ignoreStar = true;\n+                token = next();\n         }\n     } while (true);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno += 1;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                ignoreStar = false;\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                startLineno += 1;\n                startCharno = 0;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                startCharno += line.length() + 1;\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,6 +24,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno += 1;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n@@ -31,6 +32,7 @@\n                     }\n                     builder.append('*');\n                 }\n+                ignoreStar = false;\n                 token = next();\n                 continue;\n             case EOL:\n@@ -38,6 +40,8 @@\n                     builder.append(\"\\n\");\n                 }\n                 ignoreStar = true;\n+                startLineno += 1;\n+                startCharno = 0;\n                 token = next();\n                 continue;\n             default:\n@@ -67,6 +71,7 @@\n                     line = trimEnd(line);\n                 }\n                 builder.append(line);\n+                startCharno += line.length() + 1;\n                 token = next();\n         }\n     } while (true);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno++;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno() + 1;\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,6 +24,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno++;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n@@ -52,7 +53,7 @@\n                         multilineText = multilineText.trim();\n                     }\n                     int endLineno = stream.getLineno();\n-                    int endCharno = stream.getCharno();\n+                    int endCharno = stream.getCharno() + 1;\n                     if (multilineText.length() > 0) {\n                         jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno++;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                ignoreStar = true;\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = false;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno() - 1;  // Should subtract 1 to get the correct end char index. \n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,6 +24,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno++;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n@@ -32,12 +33,13 @@\n                     builder.append('*');\n                 }\n                 token = next();\n+                ignoreStar = true;\n                 continue;\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n-                ignoreStar = true;\n+                ignoreStar = false;\n                 token = next();\n                 continue;\n             default:\n@@ -52,7 +54,7 @@\n                         multilineText = multilineText.trim();\n                     }\n                     int endLineno = stream.getLineno();\n-                    int endCharno = stream.getCharno();\n+                    int endCharno = stream.getCharno() - 1;  // Should subtract 1 to get the correct end char index. \n                     if (multilineText.length() > 0) {\n                         jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno = stream.getCharno() + 2;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                ignoreStar = false;\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,6 +24,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno = stream.getCharno() + 2;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n@@ -31,6 +32,7 @@\n                     }\n                     builder.append('*');\n                 }\n+                ignoreStar = false;\n                 token = next();\n                 continue;\n             case EOL:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno = stream.getCharno() + 1;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                    startCharno = stream.getCharno() + 1;\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,6 +24,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno = stream.getCharno() + 1;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n@@ -36,6 +37,7 @@\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n+                    startCharno = stream.getCharno() + 1;\n                 }\n                 ignoreStar = true;\n                 token = next();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno = stream.getCharno() + 1;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno() + 1; // Add one to account for last token read\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,6 +24,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno = stream.getCharno() + 1;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n@@ -52,7 +53,7 @@\n                         multilineText = multilineText.trim();\n                     }\n                     int endLineno = stream.getLineno();\n-                    int endCharno = stream.getCharno();\n+                    int endCharno = stream.getCharno() + 1; // Add one to account for last token read\n                     if (multilineText.length() > 0) {\n                         jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno = stream.getCharno() + 1;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno() + 1;\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,6 +24,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno = stream.getCharno() + 1;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n@@ -52,7 +53,7 @@\n                         multilineText = multilineText.trim();\n                     }\n                     int endLineno = stream.getLineno();\n-                    int endCharno = stream.getCharno();\n+                    int endCharno = stream.getCharno() + 1;\n                     if (multilineText.length() > 0) {\n                         jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                     }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno = stream.getCharno() + 1;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = false;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,6 +24,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno = stream.getCharno() + 1;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n@@ -31,13 +32,14 @@\n                     }\n                     builder.append('*');\n                 }\n+                ignoreStar = true;\n                 token = next();\n                 continue;\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n-                ignoreStar = true;\n+                ignoreStar = false;\n                 token = next();\n                 continue;\n             default:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    ignoreStar = false;\n                    builder.append('*');\n                    state = State.SEARCHING_ANNOTATION;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                    token = next();\n                    if (token != JsDocToken.EOL) {\n                        ignoreStar = true;\n                    }\n                }\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,20 +24,27 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    ignoreStar = false;\n+                    builder.append('*');\n+                    state = State.SEARCHING_ANNOTATION;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n                         builder.append(' ');\n                     }\n                     builder.append('*');\n+                    token = next();\n+                    if (token != JsDocToken.EOL) {\n+                        ignoreStar = true;\n+                    }\n                 }\n-                token = next();\n                 continue;\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n-                ignoreStar = true;\n+                ignoreStar = false;\n+                state = State.SEARCHING_ANNOTATION;\n                 token = next();\n                 continue;\n             default:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\n\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno += 1;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno() + 1;\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -1,4 +1,5 @@\n @SuppressWarnings(\"fallthrough\")\n+\n private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n     if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n         return new ExtractionInfo(\"\", token);\n@@ -24,6 +25,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno += 1;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n@@ -52,7 +54,7 @@\n                         multilineText = multilineText.trim();\n                     }\n                     int endLineno = stream.getLineno();\n-                    int endCharno = stream.getCharno();\n+                    int endCharno = stream.getCharno() + 1;\n                     if (multilineText.length() > 0) {\n                         jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    startCharno += 1; // Increment startCharno to account for the ignored star.\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = stream.getCharno();\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -23,7 +23,7 @@\n         switch(token) {\n             case STAR:\n                 if (ignoreStar) {\n-                    // Mark the position after the star as the new start of the line.\n+                    startCharno += 1; // Increment startCharno to account for the ignored star.\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    // Mark the position after the star as the new start of the line.\n                    startCharno = stream.getCharno() + 1;\n                } else {\n                    // The star is part of the comment.\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                // All tokens must be separated by a space.\n                if (token == JsDocToken.EOC || token == JsDocToken.EOF || // When we're capturing a license block, annotations\n                // in the block are ok.\n                (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                    String multilineText = builder.toString();\n                    if (option != WhitespaceOption.PRESERVE) {\n                        multilineText = multilineText.trim();\n                    }\n                    int endLineno = stream.getLineno();\n                    int endCharno = ignoreStar ? stream.getCharno() : stream.getCharno() + 1;\n                    if (multilineText.length() > 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -24,6 +24,7 @@\n             case STAR:\n                 if (ignoreStar) {\n                     // Mark the position after the star as the new start of the line.\n+                    startCharno = stream.getCharno() + 1;\n                 } else {\n                     // The star is part of the comment.\n                     if (builder.length() > 0) {\n@@ -52,7 +53,7 @@\n                         multilineText = multilineText.trim();\n                     }\n                     int endLineno = stream.getLineno();\n-                    int endCharno = stream.getCharno();\n+                    int endCharno = ignoreStar ? stream.getCharno() : stream.getCharno() + 1;\n                     if (multilineText.length() > 0) {\n                         jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                     }\n", "finish_reason": "stop", "valid": false, "num": 1}]