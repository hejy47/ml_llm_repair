[{"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; // Number of matches (i.e., 3) is arbitrary\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    for (int i = start; i < text.length(); i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,33 +1,24 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n-    // mchyzer Performance note: This creates very few new objects (one major goal)\n-    // let me know if there are performance requests, we can create a harness to measure\n     if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength = searchList.length;\n     int replacementLength = replacementList.length;\n-    // make sure lengths are ok, these need to be equal\n     if (searchLength != replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    // keep track of which still have matches\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n     int tempIndex = -1;\n-    // index of replace array that will replace the search string found\n-    // NOTE: logic duplicated below START\n     for (int i = 0; i < searchLength; i++) {\n         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n             continue;\n         }\n         tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n         if (tempIndex == -1) {\n             noMoreMatchesForReplIndex[i] = true;\n         } else {\n@@ -37,23 +28,17 @@\n             }\n         }\n     }\n-    // NOTE: logic mostly below END\n-    // no search strings found, we are done\n     if (textIndex == -1) {\n         return text;\n     }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n     int increase = 0;\n-    // count the replacement text elements that are larger than their corresponding text being replaced\n     for (int i = 0; i < searchList.length; i++) {\n         int greater = replacementList[i].length() - searchList[i].length();\n         if (greater > 0) {\n-            // assume 3 matches\n-            increase += 3 * greater;\n+            increase += 3 * greater; // Number of matches (i.e., 3) is arbitrary\n         }\n     }\n-    // have upper-bound at 20% increase, then let Java take over\n     increase = Math.min(increase, text.length() / 5);\n     StringBuilder buf = new StringBuilder(text.length() + increase);\n     while (textIndex != -1) {\n@@ -65,14 +50,11 @@\n         textIndex = -1;\n         replaceIndex = -1;\n         tempIndex = -1;\n-        // find the next earliest match\n-        // NOTE: logic mostly duplicated above START\n         for (int i = 0; i < searchLength; i++) {\n             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                 continue;\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n             if (tempIndex == -1) {\n                 noMoreMatchesForReplIndex[i] = true;\n             } else {\n@@ -82,10 +64,8 @@\n                 }\n             }\n         }\n-        // NOTE: logic duplicated above END\n     }\n-    int textLength = text.length();\n-    for (int i = start; i < textLength; i++) {\n+    for (int i = start; i < text.length(); i++) {\n         buf.append(text.charAt(i));\n     }\n     String result = buf.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = start - 1;\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    for (int i = start; i < text.length(); i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,33 +1,24 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n-    // mchyzer Performance note: This creates very few new objects (one major goal)\n-    // let me know if there are performance requests, we can create a harness to measure\n     if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength = searchList.length;\n     int replacementLength = replacementList.length;\n-    // make sure lengths are ok, these need to be equal\n     if (searchLength != replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    // keep track of which still have matches\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n     int tempIndex = -1;\n-    // index of replace array that will replace the search string found\n-    // NOTE: logic duplicated below START\n     for (int i = 0; i < searchLength; i++) {\n         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n             continue;\n         }\n-        tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n+        tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n         if (tempIndex == -1) {\n             noMoreMatchesForReplIndex[i] = true;\n         } else {\n@@ -37,23 +28,17 @@\n             }\n         }\n     }\n-    // NOTE: logic mostly below END\n-    // no search strings found, we are done\n     if (textIndex == -1) {\n         return text;\n     }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n     int increase = 0;\n-    // count the replacement text elements that are larger than their corresponding text being replaced\n     for (int i = 0; i < searchList.length; i++) {\n         int greater = replacementList[i].length() - searchList[i].length();\n         if (greater > 0) {\n-            // assume 3 matches\n             increase += 3 * greater;\n         }\n     }\n-    // have upper-bound at 20% increase, then let Java take over\n     increase = Math.min(increase, text.length() / 5);\n     StringBuilder buf = new StringBuilder(text.length() + increase);\n     while (textIndex != -1) {\n@@ -64,15 +49,12 @@\n         start = textIndex + searchList[replaceIndex].length();\n         textIndex = -1;\n         replaceIndex = -1;\n-        tempIndex = -1;\n-        // find the next earliest match\n-        // NOTE: logic mostly duplicated above START\n+        tempIndex = start - 1;\n         for (int i = 0; i < searchLength; i++) {\n             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                 continue;\n             }\n-            tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n+            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n             if (tempIndex == -1) {\n                 noMoreMatchesForReplIndex[i] = true;\n             } else {\n@@ -82,10 +64,8 @@\n                 }\n             }\n         }\n-        // NOTE: logic duplicated above END\n     }\n-    int textLength = text.length();\n-    for (int i = start; i < textLength; i++) {\n+    for (int i = start; i < text.length(); i++) {\n         buf.append(text.charAt(i));\n     }\n     String result = buf.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    //changing the tempIndex variable name to currentIndex for better understanding of the index\n    int currentIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        //setting the currentIndex with the return of the index of the searchList[i] substring in the given text string, starting from the currentIndex+1\n        currentIndex = text.indexOf(searchList[i], currentIndex + 1);\n        if (currentIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || currentIndex < textIndex) {\n                textIndex = currentIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        currentIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            currentIndex = text.indexOf(searchList[i], start);\n            if (currentIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || currentIndex < textIndex) {\n                    textIndex = currentIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,59 +1,46 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n-    // mchyzer Performance note: This creates very few new objects (one major goal)\n-    // let me know if there are performance requests, we can create a harness to measure\n     if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength = searchList.length;\n     int replacementLength = replacementList.length;\n-    // make sure lengths are ok, these need to be equal\n     if (searchLength != replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    // keep track of which still have matches\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n-    int tempIndex = -1;\n-    // index of replace array that will replace the search string found\n-    // NOTE: logic duplicated below START\n+    //changing the tempIndex variable name to currentIndex for better understanding of the index\n+    int currentIndex = -1;\n     for (int i = 0; i < searchLength; i++) {\n         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n             continue;\n         }\n-        tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n-        if (tempIndex == -1) {\n+        //setting the currentIndex with the return of the index of the searchList[i] substring in the given text string, starting from the currentIndex+1\n+        currentIndex = text.indexOf(searchList[i], currentIndex + 1);\n+        if (currentIndex == -1) {\n             noMoreMatchesForReplIndex[i] = true;\n         } else {\n-            if (textIndex == -1 || tempIndex < textIndex) {\n-                textIndex = tempIndex;\n+            if (textIndex == -1 || currentIndex < textIndex) {\n+                textIndex = currentIndex;\n                 replaceIndex = i;\n             }\n         }\n     }\n-    // NOTE: logic mostly below END\n-    // no search strings found, we are done\n     if (textIndex == -1) {\n         return text;\n     }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n     int increase = 0;\n-    // count the replacement text elements that are larger than their corresponding text being replaced\n     for (int i = 0; i < searchList.length; i++) {\n         int greater = replacementList[i].length() - searchList[i].length();\n         if (greater > 0) {\n-            // assume 3 matches\n             increase += 3 * greater;\n         }\n     }\n-    // have upper-bound at 20% increase, then let Java take over\n     increase = Math.min(increase, text.length() / 5);\n     StringBuilder buf = new StringBuilder(text.length() + increase);\n     while (textIndex != -1) {\n@@ -64,25 +51,21 @@\n         start = textIndex + searchList[replaceIndex].length();\n         textIndex = -1;\n         replaceIndex = -1;\n-        tempIndex = -1;\n-        // find the next earliest match\n-        // NOTE: logic mostly duplicated above START\n+        currentIndex = -1;\n         for (int i = 0; i < searchLength; i++) {\n             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                 continue;\n             }\n-            tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n-            if (tempIndex == -1) {\n+            currentIndex = text.indexOf(searchList[i], start);\n+            if (currentIndex == -1) {\n                 noMoreMatchesForReplIndex[i] = true;\n             } else {\n-                if (textIndex == -1 || tempIndex < textIndex) {\n-                    textIndex = tempIndex;\n+                if (textIndex == -1 || currentIndex < textIndex) {\n+                    textIndex = currentIndex;\n                     replaceIndex = i;\n                 }\n             }\n         }\n-        // NOTE: logic duplicated above END\n     }\n     int textLength = text.length();\n     for (int i = start; i < textLength; i++) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        // check if we need to keep searching for this\n        while (tempIndex != -1) {\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n        }\n    }\n    // NOTE: logic mostly below END\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            // assume 3 matches\n            increase += 3 * greater;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            // check if we need to keep searching for this\n            while (tempIndex != -1) {\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n            }\n        }\n        // NOTE: logic duplicated above END\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -27,14 +27,17 @@\n             continue;\n         }\n         tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n-        if (tempIndex == -1) {\n-            noMoreMatchesForReplIndex[i] = true;\n-        } else {\n-            if (textIndex == -1 || tempIndex < textIndex) {\n-                textIndex = tempIndex;\n-                replaceIndex = i;\n+        // check if we need to keep searching for this\n+        while (tempIndex != -1) {\n+            if (tempIndex == -1) {\n+                noMoreMatchesForReplIndex[i] = true;\n+            } else {\n+                if (textIndex == -1 || tempIndex < textIndex) {\n+                    textIndex = tempIndex;\n+                    replaceIndex = i;\n+                }\n             }\n+            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n         }\n     }\n     // NOTE: logic mostly below END\n@@ -72,14 +75,17 @@\n                 continue;\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n-            if (tempIndex == -1) {\n-                noMoreMatchesForReplIndex[i] = true;\n-            } else {\n-                if (textIndex == -1 || tempIndex < textIndex) {\n-                    textIndex = tempIndex;\n-                    replaceIndex = i;\n+            // check if we need to keep searching for this\n+            while (tempIndex != -1) {\n+                if (tempIndex == -1) {\n+                    noMoreMatchesForReplIndex[i] = true;\n+                } else {\n+                    if (textIndex == -1 || tempIndex < textIndex) {\n+                        textIndex = tempIndex;\n+                        replaceIndex = i;\n+                    }\n                 }\n+                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n             }\n         }\n         // NOTE: logic duplicated above END\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    for (int i = start; i < text.length(); i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (repeat && timeToLive > 0) {\n        // Recursive call\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n    return result;\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,33 +1,24 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n-    // mchyzer Performance note: This creates very few new objects (one major goal)\n-    // let me know if there are performance requests, we can create a harness to measure\n     if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength = searchList.length;\n     int replacementLength = replacementList.length;\n-    // make sure lengths are ok, these need to be equal\n     if (searchLength != replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    // keep track of which still have matches\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n     int tempIndex = -1;\n-    // index of replace array that will replace the search string found\n-    // NOTE: logic duplicated below START\n     for (int i = 0; i < searchLength; i++) {\n         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n             continue;\n         }\n         tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n         if (tempIndex == -1) {\n             noMoreMatchesForReplIndex[i] = true;\n         } else {\n@@ -37,23 +28,17 @@\n             }\n         }\n     }\n-    // NOTE: logic mostly below END\n-    // no search strings found, we are done\n     if (textIndex == -1) {\n         return text;\n     }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n     int increase = 0;\n-    // count the replacement text elements that are larger than their corresponding text being replaced\n     for (int i = 0; i < searchList.length; i++) {\n         int greater = replacementList[i].length() - searchList[i].length();\n         if (greater > 0) {\n-            // assume 3 matches\n             increase += 3 * greater;\n         }\n     }\n-    // have upper-bound at 20% increase, then let Java take over\n     increase = Math.min(increase, text.length() / 5);\n     StringBuilder buf = new StringBuilder(text.length() + increase);\n     while (textIndex != -1) {\n@@ -65,14 +50,11 @@\n         textIndex = -1;\n         replaceIndex = -1;\n         tempIndex = -1;\n-        // find the next earliest match\n-        // NOTE: logic mostly duplicated above START\n         for (int i = 0; i < searchLength; i++) {\n             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                 continue;\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n             if (tempIndex == -1) {\n                 noMoreMatchesForReplIndex[i] = true;\n             } else {\n@@ -82,15 +64,14 @@\n                 }\n             }\n         }\n-        // NOTE: logic duplicated above END\n     }\n-    int textLength = text.length();\n-    for (int i = start; i < textLength; i++) {\n+    for (int i = start; i < text.length(); i++) {\n         buf.append(text.charAt(i));\n     }\n     String result = buf.toString();\n-    if (!repeat) {\n-        return result;\n+    if (repeat && timeToLive > 0) {\n+        // Recursive call\n+        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n     }\n-    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n+    return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    // if recursing, this shouldn't be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    int start = 0;\n    StringBuilder buf = new StringBuilder(text.length());\n\n    while (textIndex != -1) {\n        for (int i = start; i < text.length(); i++) {\n            buf.append(text.charAt(i));\n        }\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n\n            tempIndex = text.indexOf(searchList[i], start);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex != -1) {\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n\n            buf.append(replacementList[replaceIndex]);\n            start = textIndex + searchList[replaceIndex].length();\n        }\n    }\n\n    for (int i = start; i < text.length(); i++) {\n        buf.append(text.charAt(i));\n    }\n\n    String result = buf.toString();\n\n    if (repeat && timeToLive > 0) {\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n\n    return result;\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,78 +1,40 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n-    // mchyzer Performance note: This creates very few new objects (one major goal)\n-    // let me know if there are performance requests, we can create a harness to measure\n     if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n+    // if recursing, this shouldn't be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength = searchList.length;\n     int replacementLength = replacementList.length;\n-    // make sure lengths are ok, these need to be equal\n     if (searchLength != replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    // keep track of which still have matches\n+\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n     int tempIndex = -1;\n-    // index of replace array that will replace the search string found\n-    // NOTE: logic duplicated below START\n-    for (int i = 0; i < searchLength; i++) {\n-        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n-            continue;\n-        }\n-        tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n-        if (tempIndex == -1) {\n-            noMoreMatchesForReplIndex[i] = true;\n-        } else {\n-            if (textIndex == -1 || tempIndex < textIndex) {\n-                textIndex = tempIndex;\n-                replaceIndex = i;\n-            }\n-        }\n-    }\n-    // NOTE: logic mostly below END\n-    // no search strings found, we are done\n-    if (textIndex == -1) {\n-        return text;\n-    }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n-    int increase = 0;\n-    // count the replacement text elements that are larger than their corresponding text being replaced\n-    for (int i = 0; i < searchList.length; i++) {\n-        int greater = replacementList[i].length() - searchList[i].length();\n-        if (greater > 0) {\n-            // assume 3 matches\n-            increase += 3 * greater;\n-        }\n-    }\n-    // have upper-bound at 20% increase, then let Java take over\n-    increase = Math.min(increase, text.length() / 5);\n-    StringBuilder buf = new StringBuilder(text.length() + increase);\n+    StringBuilder buf = new StringBuilder(text.length());\n+\n     while (textIndex != -1) {\n-        for (int i = start; i < textIndex; i++) {\n+        for (int i = start; i < text.length(); i++) {\n             buf.append(text.charAt(i));\n         }\n-        buf.append(replacementList[replaceIndex]);\n-        start = textIndex + searchList[replaceIndex].length();\n+\n         textIndex = -1;\n         replaceIndex = -1;\n         tempIndex = -1;\n-        // find the next earliest match\n-        // NOTE: logic mostly duplicated above START\n+\n         for (int i = 0; i < searchLength; i++) {\n             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                 continue;\n             }\n+\n             tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n+\n             if (tempIndex == -1) {\n                 noMoreMatchesForReplIndex[i] = true;\n             } else {\n@@ -82,15 +44,26 @@\n                 }\n             }\n         }\n-        // NOTE: logic duplicated above END\n+\n+        if (textIndex != -1) {\n+            for (int i = start; i < textIndex; i++) {\n+                buf.append(text.charAt(i));\n+            }\n+\n+            buf.append(replacementList[replaceIndex]);\n+            start = textIndex + searchList[replaceIndex].length();\n+        }\n     }\n-    int textLength = text.length();\n-    for (int i = start; i < textLength; i++) {\n+\n+    for (int i = start; i < text.length(); i++) {\n         buf.append(text.charAt(i));\n     }\n+\n     String result = buf.toString();\n-    if (!repeat) {\n-        return result;\n+\n+    if (repeat && timeToLive > 0) {\n+        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n     }\n-    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n+\n+    return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        int tempIndex = text.indexOf(searchList[i]);\n        // see if we need to keep searching for this\n        while (tempIndex != -1) {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n        }\n        if (textIndex != -1) {\n            break;\n        } else {\n            noMoreMatchesForReplIndex[i] = true;\n        }\n    }\n    // NOTE: logic mostly below END\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            // assume 3 matches\n            increase += 3 * greater;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            int tempIndex = text.indexOf(searchList[i], start);\n            // see if we need to keep searching for this\n            while (tempIndex != -1) {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n            }\n            if (textIndex != -1) {\n                break;\n            } else {\n                noMoreMatchesForReplIndex[i] = true;\n            }\n        }\n        // NOTE: logic duplicated above END\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -19,22 +19,25 @@\n     // index on index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n-    int tempIndex = -1;\n     // index of replace array that will replace the search string found\n     // NOTE: logic duplicated below START\n     for (int i = 0; i < searchLength; i++) {\n         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n             continue;\n         }\n-        tempIndex = text.indexOf(searchList[i]);\n+        int tempIndex = text.indexOf(searchList[i]);\n         // see if we need to keep searching for this\n-        if (tempIndex == -1) {\n-            noMoreMatchesForReplIndex[i] = true;\n-        } else {\n+        while (tempIndex != -1) {\n             if (textIndex == -1 || tempIndex < textIndex) {\n                 textIndex = tempIndex;\n                 replaceIndex = i;\n             }\n+            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n+        }\n+        if (textIndex != -1) {\n+            break;\n+        } else {\n+            noMoreMatchesForReplIndex[i] = true;\n         }\n     }\n     // NOTE: logic mostly below END\n@@ -64,22 +67,25 @@\n         start = textIndex + searchList[replaceIndex].length();\n         textIndex = -1;\n         replaceIndex = -1;\n-        tempIndex = -1;\n         // find the next earliest match\n         // NOTE: logic mostly duplicated above START\n         for (int i = 0; i < searchLength; i++) {\n             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                 continue;\n             }\n-            tempIndex = text.indexOf(searchList[i], start);\n+            int tempIndex = text.indexOf(searchList[i], start);\n             // see if we need to keep searching for this\n-            if (tempIndex == -1) {\n-                noMoreMatchesForReplIndex[i] = true;\n-            } else {\n+            while (tempIndex != -1) {\n                 if (textIndex == -1 || tempIndex < textIndex) {\n                     textIndex = tempIndex;\n                     replaceIndex = i;\n                 }\n+                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n+            }\n+            if (textIndex != -1) {\n+                break;\n+            } else {\n+                noMoreMatchesForReplIndex[i] = true;\n             }\n         }\n         // NOTE: logic duplicated above END\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i], tempIndex + 1); // fix 1\n\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = start - 1; // fix 2\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], tempIndex + 1); // fix 1\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    for (int i = start; i < text.length(); i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,33 +1,25 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n-    // mchyzer Performance note: This creates very few new objects (one major goal)\n-    // let me know if there are performance requests, we can create a harness to measure\n     if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength = searchList.length;\n     int replacementLength = replacementList.length;\n-    // make sure lengths are ok, these need to be equal\n     if (searchLength != replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    // keep track of which still have matches\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n     int tempIndex = -1;\n-    // index of replace array that will replace the search string found\n-    // NOTE: logic duplicated below START\n     for (int i = 0; i < searchLength; i++) {\n         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n             continue;\n         }\n-        tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n+        tempIndex = text.indexOf(searchList[i], tempIndex + 1); // fix 1\n+\n         if (tempIndex == -1) {\n             noMoreMatchesForReplIndex[i] = true;\n         } else {\n@@ -37,23 +29,17 @@\n             }\n         }\n     }\n-    // NOTE: logic mostly below END\n-    // no search strings found, we are done\n     if (textIndex == -1) {\n         return text;\n     }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n     int increase = 0;\n-    // count the replacement text elements that are larger than their corresponding text being replaced\n     for (int i = 0; i < searchList.length; i++) {\n         int greater = replacementList[i].length() - searchList[i].length();\n         if (greater > 0) {\n-            // assume 3 matches\n             increase += 3 * greater;\n         }\n     }\n-    // have upper-bound at 20% increase, then let Java take over\n     increase = Math.min(increase, text.length() / 5);\n     StringBuilder buf = new StringBuilder(text.length() + increase);\n     while (textIndex != -1) {\n@@ -64,15 +50,12 @@\n         start = textIndex + searchList[replaceIndex].length();\n         textIndex = -1;\n         replaceIndex = -1;\n-        tempIndex = -1;\n-        // find the next earliest match\n-        // NOTE: logic mostly duplicated above START\n+        tempIndex = start - 1; // fix 2\n         for (int i = 0; i < searchLength; i++) {\n             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                 continue;\n             }\n-            tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n+            tempIndex = text.indexOf(searchList[i], tempIndex + 1); // fix 1\n             if (tempIndex == -1) {\n                 noMoreMatchesForReplIndex[i] = true;\n             } else {\n@@ -82,10 +65,8 @@\n                 }\n             }\n         }\n-        // NOTE: logic duplicated above END\n     }\n-    int textLength = text.length();\n-    for (int i = start; i < textLength; i++) {\n+    for (int i = start; i < text.length(); i++) {\n         buf.append(text.charAt(i));\n     }\n     String result = buf.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    for (int i = start; i < text.length(); i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,33 +1,24 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n-    // mchyzer Performance note: This creates very few new objects (one major goal)\n-    // let me know if there are performance requests, we can create a harness to measure\n-    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n+    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength = searchList.length;\n     int replacementLength = replacementList.length;\n-    // make sure lengths are ok, these need to be equal\n     if (searchLength != replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    // keep track of which still have matches\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n     int tempIndex = -1;\n-    // index of replace array that will replace the search string found\n-    // NOTE: logic duplicated below START\n     for (int i = 0; i < searchLength; i++) {\n-        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n             continue;\n         }\n         tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n         if (tempIndex == -1) {\n             noMoreMatchesForReplIndex[i] = true;\n         } else {\n@@ -37,23 +28,17 @@\n             }\n         }\n     }\n-    // NOTE: logic mostly below END\n-    // no search strings found, we are done\n     if (textIndex == -1) {\n         return text;\n     }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n     int increase = 0;\n-    // count the replacement text elements that are larger than their corresponding text being replaced\n     for (int i = 0; i < searchList.length; i++) {\n         int greater = replacementList[i].length() - searchList[i].length();\n         if (greater > 0) {\n-            // assume 3 matches\n             increase += 3 * greater;\n         }\n     }\n-    // have upper-bound at 20% increase, then let Java take over\n     increase = Math.min(increase, text.length() / 5);\n     StringBuilder buf = new StringBuilder(text.length() + increase);\n     while (textIndex != -1) {\n@@ -65,14 +50,11 @@\n         textIndex = -1;\n         replaceIndex = -1;\n         tempIndex = -1;\n-        // find the next earliest match\n-        // NOTE: logic mostly duplicated above START\n         for (int i = 0; i < searchLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n                 continue;\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n             if (tempIndex == -1) {\n                 noMoreMatchesForReplIndex[i] = true;\n             } else {\n@@ -82,10 +64,8 @@\n                 }\n             }\n         }\n-        // NOTE: logic duplicated above END\n     }\n-    int textLength = text.length();\n-    for (int i = start; i < textLength; i++) {\n+    for (int i = start; i < text.length(); i++) {\n         buf.append(text.charAt(i));\n     }\n     String result = buf.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    // get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit\n    int increase = 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            // assume 3 matches\n            increase += 3 * greater;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (true) {\n        if (start > text.length()) {\n            break;\n        }\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        if (textIndex == -1) {\n            for (int i = start; i < text.length(); i++) {\n                buf.append(text.charAt(i));\n            }\n            break;\n        }\n        // NOTE: logic duplicated above END\n        if (timeToLive-- == 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" has been exhausted: \" + text);           \n        }\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -43,7 +43,7 @@\n         return text;\n     }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n+    // get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit\n     int increase = 0;\n     // count the replacement text elements that are larger than their corresponding text being replaced\n     for (int i = 0; i < searchList.length; i++) {\n@@ -56,7 +56,10 @@\n     // have upper-bound at 20% increase, then let Java take over\n     increase = Math.min(increase, text.length() / 5);\n     StringBuilder buf = new StringBuilder(text.length() + increase);\n-    while (textIndex != -1) {\n+    while (true) {\n+        if (start > text.length()) {\n+            break;\n+        }\n         for (int i = start; i < textIndex; i++) {\n             buf.append(text.charAt(i));\n         }\n@@ -82,15 +85,20 @@\n                 }\n             }\n         }\n+        if (textIndex == -1) {\n+            for (int i = start; i < text.length(); i++) {\n+                buf.append(text.charAt(i));\n+            }\n+            break;\n+        }\n         // NOTE: logic duplicated above END\n-    }\n-    int textLength = text.length();\n-    for (int i = start; i < textLength; i++) {\n-        buf.append(text.charAt(i));\n+        if (timeToLive-- == 0) {\n+            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" has been exhausted: \" + text);           \n+        }\n     }\n     String result = buf.toString();\n     if (!repeat) {\n         return result;\n     }\n-    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n+    return replaceEach(result, searchList, replacementList, repeat, timeToLive);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    for (int i = start; i < text.length(); i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,33 +1,24 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n-    // mchyzer Performance note: This creates very few new objects (one major goal)\n-    // let me know if there are performance requests, we can create a harness to measure\n     if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength = searchList.length;\n     int replacementLength = replacementList.length;\n-    // make sure lengths are ok, these need to be equal\n     if (searchLength != replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    // keep track of which still have matches\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n     int tempIndex = -1;\n-    // index of replace array that will replace the search string found\n-    // NOTE: logic duplicated below START\n     for (int i = 0; i < searchLength; i++) {\n-        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n             continue;\n         }\n         tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n         if (tempIndex == -1) {\n             noMoreMatchesForReplIndex[i] = true;\n         } else {\n@@ -37,23 +28,17 @@\n             }\n         }\n     }\n-    // NOTE: logic mostly below END\n-    // no search strings found, we are done\n     if (textIndex == -1) {\n         return text;\n     }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n     int increase = 0;\n-    // count the replacement text elements that are larger than their corresponding text being replaced\n     for (int i = 0; i < searchList.length; i++) {\n         int greater = replacementList[i].length() - searchList[i].length();\n         if (greater > 0) {\n-            // assume 3 matches\n             increase += 3 * greater;\n         }\n     }\n-    // have upper-bound at 20% increase, then let Java take over\n     increase = Math.min(increase, text.length() / 5);\n     StringBuilder buf = new StringBuilder(text.length() + increase);\n     while (textIndex != -1) {\n@@ -65,14 +50,11 @@\n         textIndex = -1;\n         replaceIndex = -1;\n         tempIndex = -1;\n-        // find the next earliest match\n-        // NOTE: logic mostly duplicated above START\n         for (int i = 0; i < searchLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n                 continue;\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n             if (tempIndex == -1) {\n                 noMoreMatchesForReplIndex[i] = true;\n             } else {\n@@ -82,10 +64,8 @@\n                 }\n             }\n         }\n-        // NOTE: logic duplicated above END\n     }\n-    int textLength = text.length();\n-    for (int i = start; i < textLength; i++) {\n+    for (int i = start; i < text.length(); i++) {\n         buf.append(text.charAt(i));\n     }\n     String result = buf.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        // see if we need to keep searching for this\n        while (tempIndex != -1) {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n        }\n        if (textIndex != -1) {\n            break;\n        }\n        noMoreMatchesForReplIndex[i] = true;\n    }\n    // NOTE: logic mostly below END\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            // assume 3 matches\n            increase += 3 * greater;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            // see if we need to keep searching for this\n            while (tempIndex != -1) {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n            }\n            if (textIndex != -1) {\n                break;\n            }\n            noMoreMatchesForReplIndex[i] = true;\n        }\n        // NOTE: logic duplicated above END\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -28,14 +28,17 @@\n         }\n         tempIndex = text.indexOf(searchList[i]);\n         // see if we need to keep searching for this\n-        if (tempIndex == -1) {\n-            noMoreMatchesForReplIndex[i] = true;\n-        } else {\n+        while (tempIndex != -1) {\n             if (textIndex == -1 || tempIndex < textIndex) {\n                 textIndex = tempIndex;\n                 replaceIndex = i;\n             }\n+            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n         }\n+        if (textIndex != -1) {\n+            break;\n+        }\n+        noMoreMatchesForReplIndex[i] = true;\n     }\n     // NOTE: logic mostly below END\n     // no search strings found, we are done\n@@ -73,14 +76,17 @@\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n             // see if we need to keep searching for this\n-            if (tempIndex == -1) {\n-                noMoreMatchesForReplIndex[i] = true;\n-            } else {\n+            while (tempIndex != -1) {\n                 if (textIndex == -1 || tempIndex < textIndex) {\n                     textIndex = tempIndex;\n                     replaceIndex = i;\n                 }\n+                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n             }\n+            if (textIndex != -1) {\n+                break;\n+            }\n+            noMoreMatchesForReplIndex[i] = true;\n         }\n         // NOTE: logic duplicated above END\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        // see if we need to keep searching for this\n        while (tempIndex != -1) {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n        }\n        if (textIndex != -1) {\n            break;\n        } else {\n            noMoreMatchesForReplIndex[i] = true;\n        }\n    }\n    // NOTE: logic mostly below END\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            // assume 3 matches\n            increase += 3 * greater;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            // see if we need to keep searching for this\n            while (tempIndex != -1) {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n            }\n            if (textIndex != -1) {\n                break;\n            } else {\n                noMoreMatchesForReplIndex[i] = true;\n            }\n        }\n        // NOTE: logic duplicated above END\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,7 +1,7 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n     // mchyzer Performance note: This creates very few new objects (one major goal)\n     // let me know if there are performance requests, we can create a harness to measure\n-    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n+    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n     // if recursing, this shouldnt be less than 0\n@@ -23,18 +23,22 @@\n     // index of replace array that will replace the search string found\n     // NOTE: logic duplicated below START\n     for (int i = 0; i < searchLength; i++) {\n-        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n             continue;\n         }\n         tempIndex = text.indexOf(searchList[i]);\n         // see if we need to keep searching for this\n-        if (tempIndex == -1) {\n-            noMoreMatchesForReplIndex[i] = true;\n-        } else {\n+        while (tempIndex != -1) {\n             if (textIndex == -1 || tempIndex < textIndex) {\n                 textIndex = tempIndex;\n                 replaceIndex = i;\n             }\n+            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n+        }\n+        if (textIndex != -1) {\n+            break;\n+        } else {\n+            noMoreMatchesForReplIndex[i] = true;\n         }\n     }\n     // NOTE: logic mostly below END\n@@ -73,13 +77,17 @@\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n             // see if we need to keep searching for this\n-            if (tempIndex == -1) {\n-                noMoreMatchesForReplIndex[i] = true;\n-            } else {\n+            while (tempIndex != -1) {\n                 if (textIndex == -1 || tempIndex < textIndex) {\n                     textIndex = tempIndex;\n                     replaceIndex = i;\n                 }\n+                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n+            }\n+            if (textIndex != -1) {\n+                break;\n+            } else {\n+                noMoreMatchesForReplIndex[i] = true;\n             }\n         }\n         // NOTE: logic duplicated above END\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    for (int i = start; i < text.length(); i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    if (timeToLive == 0) {\n        throw new IllegalStateException(\"TimeToLive of 0 exceeded: \" + text);\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,33 +1,24 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n-    // mchyzer Performance note: This creates very few new objects (one major goal)\n-    // let me know if there are performance requests, we can create a harness to measure\n     if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength = searchList.length;\n     int replacementLength = replacementList.length;\n-    // make sure lengths are ok, these need to be equal\n     if (searchLength != replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    // keep track of which still have matches\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n     int tempIndex = -1;\n-    // index of replace array that will replace the search string found\n-    // NOTE: logic duplicated below START\n     for (int i = 0; i < searchLength; i++) {\n         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n             continue;\n         }\n         tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n         if (tempIndex == -1) {\n             noMoreMatchesForReplIndex[i] = true;\n         } else {\n@@ -37,23 +28,17 @@\n             }\n         }\n     }\n-    // NOTE: logic mostly below END\n-    // no search strings found, we are done\n     if (textIndex == -1) {\n         return text;\n     }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n     int increase = 0;\n-    // count the replacement text elements that are larger than their corresponding text being replaced\n     for (int i = 0; i < searchList.length; i++) {\n         int greater = replacementList[i].length() - searchList[i].length();\n         if (greater > 0) {\n-            // assume 3 matches\n             increase += 3 * greater;\n         }\n     }\n-    // have upper-bound at 20% increase, then let Java take over\n     increase = Math.min(increase, text.length() / 5);\n     StringBuilder buf = new StringBuilder(text.length() + increase);\n     while (textIndex != -1) {\n@@ -65,14 +50,11 @@\n         textIndex = -1;\n         replaceIndex = -1;\n         tempIndex = -1;\n-        // find the next earliest match\n-        // NOTE: logic mostly duplicated above START\n         for (int i = 0; i < searchLength; i++) {\n             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                 continue;\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n             if (tempIndex == -1) {\n                 noMoreMatchesForReplIndex[i] = true;\n             } else {\n@@ -82,15 +64,16 @@\n                 }\n             }\n         }\n-        // NOTE: logic duplicated above END\n     }\n-    int textLength = text.length();\n-    for (int i = start; i < textLength; i++) {\n+    for (int i = start; i < text.length(); i++) {\n         buf.append(text.charAt(i));\n     }\n     String result = buf.toString();\n     if (!repeat) {\n         return result;\n     }\n+    if (timeToLive == 0) {\n+        throw new IllegalStateException(\"TimeToLive of 0 exceeded: \" + text);\n+    }\n     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null || \n                replacementList[i].length() == 0) { // Add check for empty replacement string\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            // assume 3 matches\n            increase += 3 * greater;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null || \n                    replacementList[i].length() == 0) { // Add check for empty replacement string\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic duplicated above END\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -23,7 +23,8 @@\n     // index of replace array that will replace the search string found\n     // NOTE: logic duplicated below START\n     for (int i = 0; i < searchLength; i++) {\n-        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null || \n+                replacementList[i].length() == 0) { // Add check for empty replacement string\n             continue;\n         }\n         tempIndex = text.indexOf(searchList[i]);\n@@ -68,7 +69,8 @@\n         // find the next earliest match\n         // NOTE: logic mostly duplicated above START\n         for (int i = 0; i < searchLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null || \n+                    replacementList[i].length() == 0) { // Add check for empty replacement string\n                 continue;\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    // if recursing, this shouldn't be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    // index of index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        // see if we need to keep searching for this\n        while (tempIndex != -1) {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n        }\n        noMoreMatchesForReplIndex[i] = true; // mark this search string as done\n    }\n    // NOTE: logic mostly below END\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    // get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit\n    int increase = 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            // assume 3 matches\n            increase += 3 * greater;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            // see if we need to keep searching for this\n            while (tempIndex != -1) {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n            }\n            noMoreMatchesForReplIndex[i] = true; // mark this search string as done\n        }\n        // NOTE: logic duplicated above END\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -4,7 +4,7 @@\n     if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n+    // if recursing, this shouldn't be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n@@ -16,7 +16,7 @@\n     }\n     // keep track of which still have matches\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n+    // index of index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n     int tempIndex = -1;\n@@ -28,14 +28,14 @@\n         }\n         tempIndex = text.indexOf(searchList[i]);\n         // see if we need to keep searching for this\n-        if (tempIndex == -1) {\n-            noMoreMatchesForReplIndex[i] = true;\n-        } else {\n+        while (tempIndex != -1) {\n             if (textIndex == -1 || tempIndex < textIndex) {\n                 textIndex = tempIndex;\n                 replaceIndex = i;\n             }\n+            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n         }\n+        noMoreMatchesForReplIndex[i] = true; // mark this search string as done\n     }\n     // NOTE: logic mostly below END\n     // no search strings found, we are done\n@@ -43,7 +43,7 @@\n         return text;\n     }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n+    // get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit\n     int increase = 0;\n     // count the replacement text elements that are larger than their corresponding text being replaced\n     for (int i = 0; i < searchList.length; i++) {\n@@ -73,14 +73,14 @@\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n             // see if we need to keep searching for this\n-            if (tempIndex == -1) {\n-                noMoreMatchesForReplIndex[i] = true;\n-            } else {\n+            while (tempIndex != -1) {\n                 if (textIndex == -1 || tempIndex < textIndex) {\n                     textIndex = tempIndex;\n                     replaceIndex = i;\n                 }\n+                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n             }\n+            noMoreMatchesForReplIndex[i] = true; // mark this search string as done\n         }\n         // NOTE: logic duplicated above END\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n   if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    for (int i = start; i < text.length(); i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (repeat) {\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    } else {\n        return result;\n    }\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,33 +1,24 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n-    // mchyzer Performance note: This creates very few new objects (one major goal)\n-    // let me know if there are performance requests, we can create a harness to measure\n-    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n+   if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength = searchList.length;\n     int replacementLength = replacementList.length;\n-    // make sure lengths are ok, these need to be equal\n     if (searchLength != replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    // keep track of which still have matches\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n     int textIndex = -1;\n     int replaceIndex = -1;\n     int tempIndex = -1;\n-    // index of replace array that will replace the search string found\n-    // NOTE: logic duplicated below START\n     for (int i = 0; i < searchLength; i++) {\n-        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n             continue;\n         }\n         tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n         if (tempIndex == -1) {\n             noMoreMatchesForReplIndex[i] = true;\n         } else {\n@@ -37,23 +28,17 @@\n             }\n         }\n     }\n-    // NOTE: logic mostly below END\n-    // no search strings found, we are done\n     if (textIndex == -1) {\n         return text;\n     }\n     int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n     int increase = 0;\n-    // count the replacement text elements that are larger than their corresponding text being replaced\n     for (int i = 0; i < searchList.length; i++) {\n         int greater = replacementList[i].length() - searchList[i].length();\n         if (greater > 0) {\n-            // assume 3 matches\n             increase += 3 * greater;\n         }\n     }\n-    // have upper-bound at 20% increase, then let Java take over\n     increase = Math.min(increase, text.length() / 5);\n     StringBuilder buf = new StringBuilder(text.length() + increase);\n     while (textIndex != -1) {\n@@ -65,14 +50,11 @@\n         textIndex = -1;\n         replaceIndex = -1;\n         tempIndex = -1;\n-        // find the next earliest match\n-        // NOTE: logic mostly duplicated above START\n         for (int i = 0; i < searchLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {\n                 continue;\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n             if (tempIndex == -1) {\n                 noMoreMatchesForReplIndex[i] = true;\n             } else {\n@@ -82,15 +64,14 @@\n                 }\n             }\n         }\n-        // NOTE: logic duplicated above END\n     }\n-    int textLength = text.length();\n-    for (int i = start; i < textLength; i++) {\n+    for (int i = start; i < text.length(); i++) {\n         buf.append(text.charAt(i));\n     }\n     String result = buf.toString();\n-    if (!repeat) {\n+    if (repeat) {\n+        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n+    } else {\n         return result;\n     }\n-    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        fixTempIndex:\n        {\n            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n                break fixTempIndex;\n            }\n\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            // assume 3 matches\n            increase += 3 * greater;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = start - 1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            fixTempIndex:\n            {\n                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                    break fixTempIndex;\n                }\n\n                // see if we need to keep searching for this\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic duplicated above END\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -26,11 +26,15 @@\n         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n             continue;\n         }\n-        tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n-        if (tempIndex == -1) {\n-            noMoreMatchesForReplIndex[i] = true;\n-        } else {\n+        fixTempIndex:\n+        {\n+            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n+            // see if we need to keep searching for this\n+            if (tempIndex == -1) {\n+                noMoreMatchesForReplIndex[i] = true;\n+                break fixTempIndex;\n+            }\n+\n             if (textIndex == -1 || tempIndex < textIndex) {\n                 textIndex = tempIndex;\n                 replaceIndex = i;\n@@ -64,18 +68,23 @@\n         start = textIndex + searchList[replaceIndex].length();\n         textIndex = -1;\n         replaceIndex = -1;\n-        tempIndex = -1;\n+        tempIndex = start - 1;\n         // find the next earliest match\n         // NOTE: logic mostly duplicated above START\n         for (int i = 0; i < searchLength; i++) {\n             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                 continue;\n             }\n-            tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n-            if (tempIndex == -1) {\n-                noMoreMatchesForReplIndex[i] = true;\n-            } else {\n+            fixTempIndex:\n+            {\n+                tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n+                // see if we need to keep searching for this\n+                if (tempIndex == -1) {\n+                    noMoreMatchesForReplIndex[i] = true;\n+                    break fixTempIndex;\n+                }\n+\n+                // see if we need to keep searching for this\n                 if (textIndex == -1 || tempIndex < textIndex) {\n                     textIndex = tempIndex;\n                     replaceIndex = i;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        // see if we need to keep searching for this\n        while (tempIndex != -1) {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n        }\n        if(textIndex > -1) break;\n        noMoreMatchesForReplIndex[i] = true;\n    }\n    // NOTE: logic mostly below END\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            // assume 3 matches\n            increase += 3 * greater;\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            // see if we need to keep searching for this\n            while (tempIndex != -1) {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n                tempIndex = text.indexOf(searchList[i], tempIndex + 1);    \n            }\n            if(textIndex > -1) break;\n            noMoreMatchesForReplIndex[i] = true;\n        }\n        // NOTE: logic duplicated above END\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -28,14 +28,15 @@\n         }\n         tempIndex = text.indexOf(searchList[i]);\n         // see if we need to keep searching for this\n-        if (tempIndex == -1) {\n-            noMoreMatchesForReplIndex[i] = true;\n-        } else {\n+        while (tempIndex != -1) {\n             if (textIndex == -1 || tempIndex < textIndex) {\n                 textIndex = tempIndex;\n                 replaceIndex = i;\n             }\n+            tempIndex = text.indexOf(searchList[i], tempIndex + 1);\n         }\n+        if(textIndex > -1) break;\n+        noMoreMatchesForReplIndex[i] = true;\n     }\n     // NOTE: logic mostly below END\n     // no search strings found, we are done\n@@ -73,14 +74,15 @@\n             }\n             tempIndex = text.indexOf(searchList[i], start);\n             // see if we need to keep searching for this\n-            if (tempIndex == -1) {\n-                noMoreMatchesForReplIndex[i] = true;\n-            } else {\n+            while (tempIndex != -1) {\n                 if (textIndex == -1 || tempIndex < textIndex) {\n                     textIndex = tempIndex;\n                     replaceIndex = i;\n                 }\n+                tempIndex = text.indexOf(searchList[i], tempIndex + 1);    \n             }\n+            if(textIndex > -1) break;\n+            noMoreMatchesForReplIndex[i] = true;\n         }\n         // NOTE: logic duplicated above END\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex;\n    int replaceIndex;\n    int tempIndex;\n    StringBuilder buf = new StringBuilder(text.length() + Math.min(20, text.length() / 5));\n    while (true) {\n        textIndex = Integer.MAX_VALUE;\n        replaceIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n            if (!noMoreMatchesForReplIndex[i] && (searchList[i] != null && !searchList[i].isEmpty() &&\n                    replacementList[i] != null)) {\n                tempIndex = text.indexOf(searchList[i]);\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else if (tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        if (textIndex == Integer.MAX_VALUE) {\n            break;\n        }\n        buf.append(text, 0, textIndex).append(replacementList[replaceIndex]);\n        text = text.substring(textIndex + searchList[replaceIndex].length());\n    }\n    buf.append(text);\n    String result = buf.toString();\n    if (repeat && timeToLive > 0 && result.contains(String.join(\"\", searchList))) {\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n    return result;\n}", "diff": "--- org/apache/commons/lang3/StringUtils.java@replaceEach\n+++ org/apache/commons/lang3/StringUtils.java@replaceEach\n@@ -1,96 +1,45 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n-    // mchyzer Performance note: This creates very few new objects (one major goal)\n-    // let me know if there are performance requests, we can create a harness to measure\n-    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n+    if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n         return text;\n     }\n-    // if recursing, this shouldnt be less than 0\n     if (timeToLive < 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength = searchList.length;\n     int replacementLength = replacementList.length;\n-    // make sure lengths are ok, these need to be equal\n     if (searchLength != replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    // keep track of which still have matches\n     boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-    // index on index that the match was found\n-    int textIndex = -1;\n-    int replaceIndex = -1;\n-    int tempIndex = -1;\n-    // index of replace array that will replace the search string found\n-    // NOTE: logic duplicated below START\n-    for (int i = 0; i < searchLength; i++) {\n-        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n-            continue;\n-        }\n-        tempIndex = text.indexOf(searchList[i]);\n-        // see if we need to keep searching for this\n-        if (tempIndex == -1) {\n-            noMoreMatchesForReplIndex[i] = true;\n-        } else {\n-            if (textIndex == -1 || tempIndex < textIndex) {\n-                textIndex = tempIndex;\n-                replaceIndex = i;\n-            }\n-        }\n-    }\n-    // NOTE: logic mostly below END\n-    // no search strings found, we are done\n-    if (textIndex == -1) {\n-        return text;\n-    }\n-    int start = 0;\n-    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n-    int increase = 0;\n-    // count the replacement text elements that are larger than their corresponding text being replaced\n-    for (int i = 0; i < searchList.length; i++) {\n-        int greater = replacementList[i].length() - searchList[i].length();\n-        if (greater > 0) {\n-            // assume 3 matches\n-            increase += 3 * greater;\n-        }\n-    }\n-    // have upper-bound at 20% increase, then let Java take over\n-    increase = Math.min(increase, text.length() / 5);\n-    StringBuilder buf = new StringBuilder(text.length() + increase);\n-    while (textIndex != -1) {\n-        for (int i = start; i < textIndex; i++) {\n-            buf.append(text.charAt(i));\n-        }\n-        buf.append(replacementList[replaceIndex]);\n-        start = textIndex + searchList[replaceIndex].length();\n-        textIndex = -1;\n+    int textIndex;\n+    int replaceIndex;\n+    int tempIndex;\n+    StringBuilder buf = new StringBuilder(text.length() + Math.min(20, text.length() / 5));\n+    while (true) {\n+        textIndex = Integer.MAX_VALUE;\n         replaceIndex = -1;\n-        tempIndex = -1;\n-        // find the next earliest match\n-        // NOTE: logic mostly duplicated above START\n         for (int i = 0; i < searchLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n-                continue;\n-            }\n-            tempIndex = text.indexOf(searchList[i], start);\n-            // see if we need to keep searching for this\n-            if (tempIndex == -1) {\n-                noMoreMatchesForReplIndex[i] = true;\n-            } else {\n-                if (textIndex == -1 || tempIndex < textIndex) {\n+            if (!noMoreMatchesForReplIndex[i] && (searchList[i] != null && !searchList[i].isEmpty() &&\n+                    replacementList[i] != null)) {\n+                tempIndex = text.indexOf(searchList[i]);\n+                if (tempIndex == -1) {\n+                    noMoreMatchesForReplIndex[i] = true;\n+                } else if (tempIndex < textIndex) {\n                     textIndex = tempIndex;\n                     replaceIndex = i;\n                 }\n             }\n         }\n-        // NOTE: logic duplicated above END\n+        if (textIndex == Integer.MAX_VALUE) {\n+            break;\n+        }\n+        buf.append(text, 0, textIndex).append(replacementList[replaceIndex]);\n+        text = text.substring(textIndex + searchList[replaceIndex].length());\n     }\n-    int textLength = text.length();\n-    for (int i = start; i < textLength; i++) {\n-        buf.append(text.charAt(i));\n+    buf.append(text);\n+    String result = buf.toString();\n+    if (repeat && timeToLive > 0 && result.contains(String.join(\"\", searchList))) {\n+        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n     }\n-    String result = buf.toString();\n-    if (!repeat) {\n-        return result;\n-    }\n-    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n+    return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]