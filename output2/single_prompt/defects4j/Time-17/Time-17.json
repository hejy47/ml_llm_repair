[{"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    if (earlierOrLater) {\n        return convertLocalToUTC(local, true, instantAfter);\n    } else {\n        return convertLocalToUTC(local, false, instantBefore);\n    }\n    // calculate result\n    // currently in later offset\n    // currently in earlier offset\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -9,7 +9,11 @@\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+    if (earlierOrLater) {\n+        return convertLocalToUTC(local, true, instantAfter);\n+    } else {\n+        return convertLocalToUTC(local, false, instantBefore);\n+    }\n     // calculate result\n     // currently in later offset\n     // currently in earlier offset\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 4 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 4 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 4 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n    // calculate result\n    // currently in later offset\n    // currently in earlier offset\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -1,8 +1,8 @@\n public long adjustOffset(long instant, boolean earlierOrLater) {\n     // a bit messy, but will work in all non-pathological cases\n-    // evaluate 3 hours before and after to work out if anything is happening\n-    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+    // evaluate 4 hours before and after to work out if anything is happening\n+    long instantBefore = convertUTCToLocal(instant - 4 * DateTimeConstants.MILLIS_PER_HOUR);\n+    long instantAfter = convertUTCToLocal(instant + 4 * DateTimeConstants.MILLIS_PER_HOUR);\n     if (instantBefore == instantAfter) {\n         // not an overlap (less than is a gap, equal is normal case)\n         return instant;\n", "finish_reason": "stop", "valid": true, "num": 2}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy but will work correctly in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    if (earlierOrLater) {\n        return convertLocalToUTC(local, false, instantAfter);\n    } else {\n        return convertLocalToUTC(local, true, instantBefore);\n    }\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -1,5 +1,5 @@\n public long adjustOffset(long instant, boolean earlierOrLater) {\n-    // a bit messy, but will work in all non-pathological cases\n+    // a bit messy but will work correctly in all non-pathological cases\n     // evaluate 3 hours before and after to work out if anything is happening\n     long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n     long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n@@ -9,8 +9,9 @@\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n-    // calculate result\n-    // currently in later offset\n-    // currently in earlier offset\n+    if (earlierOrLater) {\n+        return convertLocalToUTC(local, false, instantAfter);\n+    } else {\n+        return convertLocalToUTC(local, true, instantBefore);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // Determine whether to use the earlier or later offset\n    long local = convertUTCToLocal(instant);\n    boolean useLaterOffset = local < convertUTCToLocal(instantAfter);\n    return convertLocalToUTC(local, false, useLaterOffset ^ earlierOrLater);\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -7,10 +7,8 @@\n         // not an overlap (less than is a gap, equal is normal case)\n         return instant;\n     }\n-    // work out range of instants that have duplicate local times\n+    // Determine whether to use the earlier or later offset\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n-    // calculate result\n-    // currently in later offset\n-    // currently in earlier offset\n+    boolean useLaterOffset = local < convertUTCToLocal(instantAfter);\n+    return convertLocalToUTC(local, false, useLaterOffset ^ earlierOrLater);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter - 1 : instantBefore + 1);\n    // calculate result\n    // currently in later offset\n    // currently in earlier offset\n}\n\nExplanation: The previous version of the function was not handling the overlap of time zones correctly. Adding or subtracting a small value (1 millisecond) to the boundaries of the overlap range fixes the problem.", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -9,7 +9,7 @@\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter - 1 : instantBefore + 1);\n     // calculate result\n     // currently in later offset\n     // currently in earlier offset\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    return convertLocalToUTC(local, earlierOrLater ? instantAfter : instantBefore, false);\n    // calculate result\n    // currently in later offset\n    // currently in earlier offset\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -9,7 +9,7 @@\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+    return convertLocalToUTC(local, earlierOrLater ? instantAfter : instantBefore, false);\n     // calculate result\n     // currently in later offset\n     // currently in earlier offset\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    if(earlierOrLater) {\n        return convertLocalToUTC(local, false, instantAfter);\n    } else {\n        return convertLocalToUTC(local, true, instantBefore);\n    }\n    // calculate result\n    // currently in later offset\n    // currently in earlier offset\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -9,7 +9,11 @@\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+    if(earlierOrLater) {\n+        return convertLocalToUTC(local, false, instantAfter);\n+    } else {\n+        return convertLocalToUTC(local, true, instantBefore);\n+    }\n     // calculate result\n     // currently in later offset\n     // currently in earlier offset\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long offsetBefore = getOffset(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long offsetAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (offsetBefore == offsetAfter) {\n        // no transition\n        return instant;\n    }\n    // Calculate local time from input instant\n    long localTime = instant + offsetBefore;\n    // Calculate local time after the transition\n    long transitionTime = convertLocalToUTC(localTime, false, earlierOrLater ? offsetAfter : offsetBefore);\n    // return the corresponding UTC time\n    return transitionTime - (earlierOrLater ? offsetAfter : offsetBefore);\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -1,16 +1,14 @@\n public long adjustOffset(long instant, boolean earlierOrLater) {\n-    // a bit messy, but will work in all non-pathological cases\n-    // evaluate 3 hours before and after to work out if anything is happening\n-    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-    if (instantBefore == instantAfter) {\n-        // not an overlap (less than is a gap, equal is normal case)\n+    long offsetBefore = getOffset(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+    long offsetAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+    if (offsetBefore == offsetAfter) {\n+        // no transition\n         return instant;\n     }\n-    // work out range of instants that have duplicate local times\n-    long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n-    // calculate result\n-    // currently in later offset\n-    // currently in earlier offset\n+    // Calculate local time from input instant\n+    long localTime = instant + offsetBefore;\n+    // Calculate local time after the transition\n+    long transitionTime = convertLocalToUTC(localTime, false, earlierOrLater ? offsetAfter : offsetBefore);\n+    // return the corresponding UTC time\n+    return transitionTime - (earlierOrLater ? offsetAfter : offsetBefore);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n    // calculate result\n}\n    \n    // currently in later offset\n    // currently in earlier offset\n}\n\nThe fixed function is the same as the original, but without the unnecessary comments.", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -11,6 +11,4 @@\n     long local = convertUTCToLocal(instant);\n     return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n     // calculate result\n-    // currently in later offset\n-    // currently in earlier offset\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    // calculate result\n    return convertLocalToUTC(local, earlierOrLater ? instantAfter : instantBefore, false);\n    // currently in later offset\n    // currently in earlier offset\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -9,8 +9,8 @@\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n     // calculate result\n+    return convertLocalToUTC(local, earlierOrLater ? instantAfter : instantBefore, false);\n     // currently in later offset\n     // currently in earlier offset\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long newInstant = instant;\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    long newLocal;\n    boolean isCurrentOffsetEarlier = (convertLocalToUTC(local, false) == instant);\n    if (isCurrentOffsetEarlier && !earlierOrLater) {\n        newLocal = convertUTCToLocal(instantBefore);\n        newInstant = convertLocalToUTC(newLocal, false);\n    } else if (!isCurrentOffsetEarlier && earlierOrLater) {\n        newLocal = convertUTCToLocal(instantAfter);\n        newInstant = convertLocalToUTC(newLocal, false);\n    }\n    return newInstant;\n    // calculate result\n    // currently in later offset\n    // currently in earlier offset\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -1,4 +1,5 @@\n public long adjustOffset(long instant, boolean earlierOrLater) {\n+    long newInstant = instant;\n     // a bit messy, but will work in all non-pathological cases\n     // evaluate 3 hours before and after to work out if anything is happening\n     long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n@@ -9,7 +10,16 @@\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+    long newLocal;\n+    boolean isCurrentOffsetEarlier = (convertLocalToUTC(local, false) == instant);\n+    if (isCurrentOffsetEarlier && !earlierOrLater) {\n+        newLocal = convertUTCToLocal(instantBefore);\n+        newInstant = convertLocalToUTC(newLocal, false);\n+    } else if (!isCurrentOffsetEarlier && earlierOrLater) {\n+        newLocal = convertUTCToLocal(instantAfter);\n+        newInstant = convertLocalToUTC(newLocal, false);\n+    }\n+    return newInstant;\n     // calculate result\n     // currently in later offset\n     // currently in earlier offset\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    return convertLocalToUTC(local, earlierOrLater ? instantAfter : instantBefore, false);\n    // calculate result\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -9,8 +9,6 @@\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+    return convertLocalToUTC(local, earlierOrLater ? instantAfter : instantBefore, false);\n     // calculate result\n-    // currently in later offset\n-    // currently in earlier offset\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    if (earlierOrLater) {\n        // currently in later offset\n        long local = convertUTCToLocal(instantAfter - 1);\n        return convertLocalToUTC(local, false, instantAfter);\n    } else {\n        // currently in earlier offset\n        long local = convertUTCToLocal(instantBefore - 1);\n        return convertLocalToUTC(local, false, instantBefore);\n    }\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -7,10 +7,13 @@\n         // not an overlap (less than is a gap, equal is normal case)\n         return instant;\n     }\n-    // work out range of instants that have duplicate local times\n-    long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n-    // calculate result\n-    // currently in later offset\n-    // currently in earlier offset\n+    if (earlierOrLater) {\n+        // currently in later offset\n+        long local = convertUTCToLocal(instantAfter - 1);\n+        return convertLocalToUTC(local, false, instantAfter);\n+    } else {\n+        // currently in earlier offset\n+        long local = convertUTCToLocal(instantBefore - 1);\n+        return convertLocalToUTC(local, false, instantBefore);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    if (earlierOrLater) {\n        local = findEarlierOrLaterLocal(local, instantBefore, instantAfter);\n    } else {\n        local = findEarlierOrLaterLocal(local, instantAfter, instantBefore);\n    }\n    return convertLocalToUTC(local, false);\n    // calculate result\n    // currently in later offset\n    // currently in earlier offset\n}\n\nprivate long findEarlierOrLaterLocal(long targetLocal, long lowerInclusive, long upperExclusive) {\n    // binary search to refine estimate\n    while (lowerInclusive + 1 < upperExclusive) {\n        long mid = (lowerInclusive + upperExclusive) / 2;\n        long midLocal = convertUTCToLocal(mid);\n        if (midLocal == targetLocal) {\n            // target found\n            return mid;\n        } else if (midLocal < targetLocal) {\n            lowerInclusive = mid;\n        } else {\n            upperExclusive = mid;\n        }\n    }\n    return lowerInclusive;\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -9,7 +9,12 @@\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+    if (earlierOrLater) {\n+        local = findEarlierOrLaterLocal(local, instantBefore, instantAfter);\n+    } else {\n+        local = findEarlierOrLaterLocal(local, instantAfter, instantBefore);\n+    }\n+    return convertLocalToUTC(local, false);\n     // calculate result\n     // currently in later offset\n     // currently in earlier offset\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter - DateTimeConstants.MILLIS_PER_HOUR : instantBefore + DateTimeConstants.MILLIS_PER_HOUR);\n    // calculate result\n    // currently in later offset\n    // currently in earlier offset\n}\n\nThe fixed function removes the factor of 3 in the calculation of the instants before and after and adjusts the corresponding instant ranges accordingly, by subtracting or adding `DateTimeConstants.MILLIS_PER_HOUR`.", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -1,15 +1,15 @@\n public long adjustOffset(long instant, boolean earlierOrLater) {\n     // a bit messy, but will work in all non-pathological cases\n     // evaluate 3 hours before and after to work out if anything is happening\n-    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+    long instantBefore = convertUTCToLocal(instant - DateTimeConstants.MILLIS_PER_HOUR);\n+    long instantAfter = convertUTCToLocal(instant + DateTimeConstants.MILLIS_PER_HOUR);\n     if (instantBefore == instantAfter) {\n         // not an overlap (less than is a gap, equal is normal case)\n         return instant;\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter - DateTimeConstants.MILLIS_PER_HOUR : instantBefore + DateTimeConstants.MILLIS_PER_HOUR);\n     // calculate result\n     // currently in later offset\n     // currently in earlier offset\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    if (earlierOrLater) {\n        return convertLocalToUTC(local, false, instantAfter);\n    } else {\n        return convertLocalToUTC(local, true, instantBefore);\n    }\n    // calculate result\n    // currently in later offset\n    // currently in earlier offset\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -9,7 +9,11 @@\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+    if (earlierOrLater) {\n+        return convertLocalToUTC(local, false, instantAfter);\n+    } else {\n+        return convertLocalToUTC(local, true, instantBefore);\n+    }\n     // calculate result\n     // currently in later offset\n     // currently in earlier offset\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    if (earlierOrLater) {\n        // currently in later offset\n        return convertLocalToUTC(local, false, instantAfter);\n    } else {\n        // currently in earlier offset\n        return convertLocalToUTC(local, true, instantBefore);\n    }\n    // calculate result\n}", "diff": "--- org/joda/time/DateTimeZone.java@adjustOffset\n+++ org/joda/time/DateTimeZone.java@adjustOffset\n@@ -9,8 +9,12 @@\n     }\n     // work out range of instants that have duplicate local times\n     long local = convertUTCToLocal(instant);\n-    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+    if (earlierOrLater) {\n+        // currently in later offset\n+        return convertLocalToUTC(local, false, instantAfter);\n+    } else {\n+        // currently in earlier offset\n+        return convertLocalToUTC(local, true, instantBefore);\n+    }\n     // calculate result\n-    // currently in later offset\n-    // currently in earlier offset\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]