[{"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((p2 < -overflow) || (p2 > overflow) || (q2 < -overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -26,7 +26,7 @@\n         long a1 = (long) FastMath.floor(r1);\n         p2 = (a1 * p1) + p0;\n         q2 = (a1 * q1) + q0;\n-        if ((p2 > overflow) || (q2 > overflow)) {\n+        if ((p2 < -overflow) || (p2 > overflow) || (q2 < -overflow) || (q2 > overflow)) {\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Long.MAX_VALUE; // Changed from Integer.MAX_VALUE to Long.MAX_VALUE\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -1,5 +1,5 @@\n private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n-    long overflow = Integer.MAX_VALUE;\n+    long overflow = Long.MAX_VALUE; // Changed from Integer.MAX_VALUE to Long.MAX_VALUE\n     double r0 = value;\n     long a0 = (long) FastMath.floor(r0);\n     if (a0 > overflow) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2;\n    long q2;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        // Replaced q1 with q2\n        this.numerator = (int) p1;\n        this.denominator = (int) q2;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -16,8 +16,8 @@\n     long q0 = 0;\n     long p1 = a0;\n     long q1 = 1;\n-    long p2 = 0;\n-    long q2 = 1;\n+    long p2;\n+    long q2;\n     int n = 0;\n     boolean stop = false;\n     do {\n@@ -48,7 +48,8 @@\n         this.numerator = (int) p2;\n         this.denominator = (int) q2;\n     } else {\n+        // Replaced q1 with q2\n         this.numerator = (int) p1;\n-        this.denominator = (int) q1;\n+        this.denominator = (int) q2;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "There does not appear to be a clear solution to the given buggy function without additional context or information about the desired behavior of the function.", "diff": "", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = a1 * p1 + p0;\n        q2 = a1 * q1 + q0;\n        if (q2 <= 0 || q2 > maxDenominator || p2 > overflow) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    this.numerator = (int) p2;\n    this.denominator = (int) q2;\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -24,9 +24,9 @@\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n         long a1 = (long) FastMath.floor(r1);\n-        p2 = (a1 * p1) + p0;\n-        q2 = (a1 * q1) + q0;\n-        if ((p2 > overflow) || (q2 > overflow)) {\n+        p2 = a1 * p1 + p0;\n+        q2 = a1 * q1 + q0;\n+        if (q2 <= 0 || q2 > maxDenominator || p2 > overflow) {\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n@@ -44,11 +44,6 @@\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n     }\n-    if (q2 < maxDenominator) {\n-        this.numerator = (int) p2;\n-        this.denominator = (int) q2;\n-    } else {\n-        this.numerator = (int) p1;\n-        this.denominator = (int) q1;\n-    }\n+    this.numerator = (int) p2;\n+    this.denominator = (int) q2;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1 + epsilon);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -23,7 +23,7 @@\n     do {\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n-        long a1 = (long) FastMath.floor(r1);\n+        long a1 = (long) FastMath.floor(r1 + epsilon);\n         p2 = (a1 * p1) + p0;\n         q2 = (a1 * q1) + q0;\n         if ((p2 > overflow) || (q2 > overflow)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Long.MAX_VALUE; // Change Integer.MAX_VALUE to Long.MAX_VALUE\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -1,5 +1,5 @@\n private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n-    long overflow = Integer.MAX_VALUE;\n+    long overflow = Long.MAX_VALUE; // Change Integer.MAX_VALUE to Long.MAX_VALUE\n     double r0 = value;\n     long a0 = (long) FastMath.floor(r0);\n     if (a0 > overflow) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        long ptemp = p2;\n        long qtemp = q2;\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        p0 = p1;\n        p1 = ptemp;\n        q0 = q1;\n        q1 = qtemp;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    } else {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -24,17 +24,19 @@\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n         long a1 = (long) FastMath.floor(r1);\n+        long ptemp = p2;\n+        long qtemp = q2;\n         p2 = (a1 * p1) + p0;\n         q2 = (a1 * q1) + q0;\n+        p0 = p1;\n+        p1 = ptemp;\n+        q0 = q1;\n+        q1 = qtemp;\n         if ((p2 > overflow) || (q2 > overflow)) {\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n         if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n-            p0 = p1;\n-            p1 = p2;\n-            q0 = q1;\n-            q1 = q2;\n             a0 = a1;\n             r0 = r1;\n         } else {\n@@ -43,12 +45,8 @@\n     } while (!stop);\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n-    }\n-    if (q2 < maxDenominator) {\n+    } else {\n         this.numerator = (int) p2;\n         this.denominator = (int) q2;\n-    } else {\n-        this.numerator = (int) p1;\n-        this.denominator = (int) q1;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n <= maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 <= maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -30,7 +30,7 @@\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n-        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n+        if (n <= maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n             p0 = p1;\n             p1 = p2;\n             q0 = q1;\n@@ -44,7 +44,7 @@\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n     }\n-    if (q2 < maxDenominator) {\n+    if (q2 <= maxDenominator) {\n         this.numerator = (int) p2;\n         this.denominator = (int) q2;\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = r0 - a0;\n        if (r1 < Double.MIN_VALUE) {\n            break;\n        }\n        if (r1 > Double.MAX_VALUE) {\n            throw new FractionConversionException(value, Double.POSITIVE_INFINITY);\n        }\n        r1 = 1 / r1;\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -22,7 +22,14 @@\n     boolean stop = false;\n     do {\n         ++n;\n-        double r1 = 1.0 / (r0 - a0);\n+        double r1 = r0 - a0;\n+        if (r1 < Double.MIN_VALUE) {\n+            break;\n+        }\n+        if (r1 > Double.MAX_VALUE) {\n+            throw new FractionConversionException(value, Double.POSITIVE_INFINITY);\n+        }\n+        r1 = 1 / r1;\n         long a1 = (long) FastMath.floor(r1);\n         p2 = (a1 * p1) + p0;\n         q2 = (a1 * q1) + q0;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = a1 * p1 + p0;\n        q2 = a1 * q1 + q0;\n        if (q2 <= 0 || q2 > maxDenominator || p2 <= 0 || p2 > overflow) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    this.numerator = (int) p2;\n    this.denominator = (int) q2;\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -24,13 +24,13 @@\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n         long a1 = (long) FastMath.floor(r1);\n-        p2 = (a1 * p1) + p0;\n-        q2 = (a1 * q1) + q0;\n-        if ((p2 > overflow) || (q2 > overflow)) {\n+        p2 = a1 * p1 + p0;\n+        q2 = a1 * q1 + q0;\n+        if (q2 <= 0 || q2 > maxDenominator || p2 <= 0 || p2 > overflow) {\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n-        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n+        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon) {\n             p0 = p1;\n             p1 = p2;\n             q0 = q1;\n@@ -44,11 +44,6 @@\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n     }\n-    if (q2 < maxDenominator) {\n-        this.numerator = (int) p2;\n-        this.denominator = (int) q2;\n-    } else {\n-        this.numerator = (int) p1;\n-        this.denominator = (int) q1;\n-    }\n+    this.numerator = (int) p2;\n+    this.denominator = (int) q2;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = Math.addExact(Math.multiplyExact(a1, p1), p0);   // Updated with Math.addExact and Math.multiplyExact\n        q2 = Math.addExact(Math.multiplyExact(a1, q1), q0);   // Updated with Math.addExact and Math.multiplyExact\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -24,8 +24,8 @@\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n         long a1 = (long) FastMath.floor(r1);\n-        p2 = (a1 * p1) + p0;\n-        q2 = (a1 * q1) + q0;\n+        p2 = Math.addExact(Math.multiplyExact(a1, p1), p0);   // Updated with Math.addExact and Math.multiplyExact\n+        q2 = Math.addExact(Math.multiplyExact(a1, q1), q0);   // Updated with Math.addExact and Math.multiplyExact\n         if ((p2 > overflow) || (q2 > overflow)) {\n             throw new FractionConversionException(value, p2, q2);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = a1 * p1 + p0;\n        q2 = a1 * q1 + q0;\n        if (q2 <= 0 || p2 > overflow || q2 > overflow) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -24,9 +24,9 @@\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n         long a1 = (long) FastMath.floor(r1);\n-        p2 = (a1 * p1) + p0;\n-        q2 = (a1 * q1) + q0;\n-        if ((p2 > overflow) || (q2 > overflow)) {\n+        p2 = a1 * p1 + p0;\n+        q2 = a1 * q1 + q0;\n+        if (q2 <= 0 || p2 > overflow || q2 > overflow) {\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = (long) Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = a1 * p1 + p0;\n        q2 = a1 * q1 + q0;\n        if (q2 > overflow) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -1,5 +1,5 @@\n private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n-    long overflow = Integer.MAX_VALUE;\n+    long overflow = (long) Integer.MAX_VALUE;\n     double r0 = value;\n     long a0 = (long) FastMath.floor(r0);\n     if (a0 > overflow) {\n@@ -24,9 +24,9 @@\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n         long a1 = (long) FastMath.floor(r1);\n-        p2 = (a1 * p1) + p0;\n-        q2 = (a1 * q1) + q0;\n-        if ((p2 > overflow) || (q2 > overflow)) {\n+        p2 = a1 * p1 + p0;\n+        q2 = a1 * q1 + q0;\n+        if (q2 > overflow) {\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        if (a1 > overflow) {\n            throw new FractionConversionException(value, a0, 1L);\n        }\n        p2 = a1 * p1 + p0;\n        q2 = a1 * q1 + q0;\n        if (p2 > overflow || q2 > overflow) {\n            if (epsilon == 0.0 && FastMath.abs(value - (double) p1 / (double) q1) <= FastMath.abs(value - (double) p2 / (double) q2)) {\n                this.numerator = (int) p1;\n                this.denominator = (int) q1;\n                return;\n            }\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -24,9 +24,17 @@\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n         long a1 = (long) FastMath.floor(r1);\n-        p2 = (a1 * p1) + p0;\n-        q2 = (a1 * q1) + q0;\n-        if ((p2 > overflow) || (q2 > overflow)) {\n+        if (a1 > overflow) {\n+            throw new FractionConversionException(value, a0, 1L);\n+        }\n+        p2 = a1 * p1 + p0;\n+        q2 = a1 * q1 + q0;\n+        if (p2 > overflow || q2 > overflow) {\n+            if (epsilon == 0.0 && FastMath.abs(value - (double) p1 / (double) q1) <= FastMath.abs(value - (double) p2 / (double) q2)) {\n+                this.numerator = (int) p1;\n+                this.denominator = (int) q1;\n+                return;\n+            }\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, a1, 1l);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -27,7 +27,7 @@\n         p2 = (a1 * p1) + p0;\n         q2 = (a1 * q1) + q0;\n         if ((p2 > overflow) || (q2 > overflow)) {\n-            throw new FractionConversionException(value, p2, q2);\n+            throw new FractionConversionException(value, a1, 1l);\n         }\n         double convergent = (double) p2 / (double) q2;\n         if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = a1 * p1 + p0;\n        q2 = a1 * q1 + q0;\n        if (p2 < -overflow || p2 > overflow || q2 < -overflow || q2 > overflow) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -24,9 +24,9 @@\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n         long a1 = (long) FastMath.floor(r1);\n-        p2 = (a1 * p1) + p0;\n-        q2 = (a1 * q1) + q0;\n-        if ((p2 > overflow) || (q2 > overflow)) {\n+        p2 = a1 * p1 + p0;\n+        q2 = a1 * q1 + q0;\n+        if (p2 < -overflow || p2 > overflow || q2 < -overflow || q2 > overflow) {\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Long.MAX_VALUE; // fixed to Long.MAX_VALUE\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -1,5 +1,5 @@\n private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n-    long overflow = Integer.MAX_VALUE;\n+    long overflow = Long.MAX_VALUE; // fixed to Long.MAX_VALUE\n     double r0 = value;\n     long a0 = (long) FastMath.floor(r0);\n     if (a0 > overflow) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (a0 > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        // Changed the order of this if statement to check denominator first\n        if (q2 >= maxDenominator || FastMath.abs(convergent - value) < epsilon || n >= maxIterations) {\n            stop = true;\n        } else {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    } else {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -30,25 +30,22 @@\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n-        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n+        // Changed the order of this if statement to check denominator first\n+        if (q2 >= maxDenominator || FastMath.abs(convergent - value) < epsilon || n >= maxIterations) {\n+            stop = true;\n+        } else {\n             p0 = p1;\n             p1 = p2;\n             q0 = q1;\n             q1 = q2;\n             a0 = a1;\n             r0 = r1;\n-        } else {\n-            stop = true;\n         }\n     } while (!stop);\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n-    }\n-    if (q2 < maxDenominator) {\n+    } else {\n         this.numerator = (int) p2;\n         this.denominator = (int) q2;\n-    } else {\n-        this.numerator = (int) p1;\n-        this.denominator = (int) q1;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]