[{"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n            oldParameterType = oldParameterType.getNext();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        Node newParam = builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -33,6 +33,11 @@\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -29,6 +29,7 @@\n             parameterType = oldParameterType.getJSType();\n             isOptionalParam = oldParameterType.isOptionalArg();\n             isVarArgs = oldParameterType.isVarArgs();\n+            oldParameterType = oldParameterType.getNext();\n         } else {\n             parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n         }\n@@ -39,11 +40,12 @@\n             foundTemplateType = true;\n         }\n         warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n-        if (oldParameterType != null) {\n-            oldParameterType = oldParameterType.getNext();\n-        }\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        Node newParam = builder.newParameterFromNode(oldParameterType);\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = paramBuilder.build();\n        } else {\n            for (Node oldParam : oldType.getParameters()) {\n                paramBuilder.newParameterFromNode(oldParam);\n            }\n            parametersNode = paramBuilder.build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while(oldParams.hasNext()) {\n            paramBuilder.newParameterFromNode(oldParams.next());\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while(oldParameterType != null) {\n        builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -4,16 +4,21 @@\n     }\n     returnType = oldType.getReturnType();\n     returnTypeInferred = oldType.isReturnTypeInferred();\n+    FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n     if (paramsParent == null) {\n         // Not a function literal.\n         parametersNode = oldType.getParametersNode();\n         if (parametersNode == null) {\n-            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n+            parametersNode = paramBuilder.build();\n+        } else {\n+            for (Node oldParam : oldType.getParameters()) {\n+                paramBuilder.newParameterFromNode(oldParam);\n+            }\n+            parametersNode = paramBuilder.build();\n         }\n     } else {\n         // We're overriding with a function literal. Apply type information\n         // to each parameter of the literal.\n-        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n         Iterator<Node> oldParams = oldType.getParameters().iterator();\n         boolean warnedAboutArgList = false;\n         boolean oldParamsListHitOptArgs = false;\n@@ -33,6 +38,9 @@\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while(oldParams.hasNext()) {\n+            paramBuilder.newParameterFromNode(oldParams.next());\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -44,6 +44,10 @@\n         }\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while(oldParameterType != null) {\n+        builder.newParameterFromNode(oldParameterType);\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": true, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                if (oldParam.isVarArgs() || oldParam.isOptionalArg()) {\n                    oldParamsListHitOptArgs = true;\n                }\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            paramBuilder.addParameter(oldParam);\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n            oldParameterType = oldParameterType.getNext();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        builder.addParameter(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -20,8 +20,10 @@\n         for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n             if (oldParams.hasNext()) {\n                 Node oldParam = oldParams.next();\n+                if (oldParam.isVarArgs() || oldParam.isOptionalArg()) {\n+                    oldParamsListHitOptArgs = true;\n+                }\n                 Node newParam = paramBuilder.newParameterFromNode(oldParam);\n-                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                 // The subclass method might write its var_args as individual\n                 // arguments.\n                 if (currentParam.getNext() != null && newParam.isVarArgs()) {\n@@ -33,6 +35,10 @@\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            paramBuilder.addParameter(oldParam);\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -29,6 +29,7 @@\n             parameterType = oldParameterType.getJSType();\n             isOptionalParam = oldParameterType.isOptionalArg();\n             isVarArgs = oldParameterType.isVarArgs();\n+            oldParameterType = oldParameterType.getNext();\n         } else {\n             parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n         }\n@@ -39,11 +40,12 @@\n             foundTemplateType = true;\n         }\n         warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n-        if (oldParameterType != null) {\n-            oldParameterType = oldParameterType.getNext();\n-        }\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        builder.addParameter(oldParameterType);\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                paramBuilder.add(newParam); // Add the new parameter to paramBuilder\n                parametersNode = paramBuilder.build(); // Update the parametersNode with the new parameters list\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n                paramBuilder.add(newParam); // Add the new parameter to paramBuilder\n                parametersNode = paramBuilder.build(); // Update the parametersNode with the new parameters list\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            paramBuilder.add(newParam); // Add the new parameter to paramBuilder\n            parametersNode = paramBuilder.build(); // Update the parametersNode with the new parameters list\n        }\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        boolean isOptionalParam = oldParameterType.isOptionalArg();\n        boolean isVarArgs = oldParameterType.isVarArgs();\n        parameterType = oldParameterType.getJSType();\n        builder.add(paramBuilder.newParameter(\"\", parameterType, isOptionalParam, isVarArgs));\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,12 +28,21 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                paramBuilder.add(newParam); // Add the new parameter to paramBuilder\n+                parametersNode = paramBuilder.build(); // Update the parametersNode with the new parameters list\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                paramBuilder.add(newParam); // Add the new parameter to paramBuilder\n+                parametersNode = paramBuilder.build(); // Update the parametersNode with the new parameters list\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            paramBuilder.add(newParam); // Add the new parameter to paramBuilder\n+            parametersNode = paramBuilder.build(); // Update the parametersNode with the new parameters list\n+        }\n     }\n     return this;\n }\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -44,6 +44,13 @@\n         }\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        boolean isOptionalParam = oldParameterType.isOptionalArg();\n+        boolean isVarArgs = oldParameterType.isVarArgs();\n+        parameterType = oldParameterType.getJSType();\n+        builder.add(paramBuilder.newParameter(\"\", parameterType, isOptionalParam, isVarArgs));\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), false, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            if (oldParam.getNext() != null && newParam.isVarArgs()) {\n                newParam.setVarArgs(false);\n                newParam.setOptionalArg(true);\n            }\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n            oldParameterType = oldParameterType.getNext();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, false, isOptionalParam, isVarArgs);\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        builder.addParameter(new Node(Token.EMPTY), oldParameterType.getJSType(), oldParameterType.isVarArgs(), oldParameterType.isOptionalArg());\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -29,10 +29,18 @@\n                     newParam.setOptionalArg(true);\n                 }\n             } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), false, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            if (oldParam.getNext() != null && newParam.isVarArgs()) {\n+                newParam.setVarArgs(false);\n+                newParam.setOptionalArg(true);\n+            }\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -29,6 +29,7 @@\n             parameterType = oldParameterType.getJSType();\n             isOptionalParam = oldParameterType.isOptionalArg();\n             isVarArgs = oldParameterType.isVarArgs();\n+            oldParameterType = oldParameterType.getNext();\n         } else {\n             parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n         }\n@@ -38,12 +39,13 @@\n             }\n             foundTemplateType = true;\n         }\n-        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n-        if (oldParameterType != null) {\n-            oldParameterType = oldParameterType.getNext();\n-        }\n+        warnedAboutArgList |= addParameter(builder, parameterType, false, isOptionalParam, isVarArgs);\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        builder.addParameter(new Node(Token.EMPTY), oldParameterType.getJSType(), oldParameterType.isVarArgs(), oldParameterType.isOptionalArg());\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                boolean isOptArg = codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs;\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), isOptArg, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            paramBuilder.newParameterFromNode(oldParam);\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        builder.newParameterFromNode(oldParameterType).setOptionalArg(oldParameterType.isOptionalArg()).setVarArgs(oldParameterType.isVarArgs());\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -29,10 +29,15 @@\n                     newParam.setOptionalArg(true);\n                 }\n             } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                boolean isOptArg = codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs;\n+                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), isOptArg, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            paramBuilder.newParameterFromNode(oldParam);\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -38,12 +38,16 @@\n             }\n             foundTemplateType = true;\n         }\n-        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n+        warnedAboutArgList |= addParameter(builder, parameterType, isOptionalParam, isVarArgs);\n         if (oldParameterType != null) {\n             oldParameterType = oldParameterType.getNext();\n         }\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        builder.newParameterFromNode(oldParameterType).setOptionalArg(oldParameterType.isOptionalArg()).setVarArgs(oldParameterType.isVarArgs());\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        List<Node> oldParams = oldType.getParameters();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.size() > 0) {\n                Node oldParam = oldParams.remove(0);\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while(oldParams.size() > 0 ) {\n          Node oldParam = oldParams.remove(0);\n          paramBuilder.newParameterFromNode(oldParam);\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    Iterator<Node> argsIterator = argsParent.children().iterator();\n    while (argsIterator.hasNext()) {\n        Node arg = argsIterator.next();\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n            oldParameterType = oldParameterType.getNext();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        Node newParam = builder.newParameterFromNode(oldParameterType);\n        newParam.makeOptional();\n        warnedAboutArgList |= addParameter(builder, oldParameterType.getJSType(), warnedAboutArgList, true, isVarArgs);\n        oldParameterType = oldParameterType.getNext();\n    }\n \n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -14,12 +14,12 @@\n         // We're overriding with a function literal. Apply type information\n         // to each parameter of the literal.\n         FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n-        Iterator<Node> oldParams = oldType.getParameters().iterator();\n+        List<Node> oldParams = oldType.getParameters();\n         boolean warnedAboutArgList = false;\n         boolean oldParamsListHitOptArgs = false;\n         for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n-            if (oldParams.hasNext()) {\n-                Node oldParam = oldParams.next();\n+            if (oldParams.size() > 0) {\n+                Node oldParam = oldParams.remove(0);\n                 Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                 oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                 // The subclass method might write its var_args as individual\n@@ -33,6 +33,10 @@\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while(oldParams.size() > 0 ) {\n+          Node oldParam = oldParams.remove(0);\n+          paramBuilder.newParameterFromNode(oldParam);\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -16,7 +16,9 @@\n     Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n     boolean foundTemplateType = false;\n     boolean isVarArgs = false;\n-    for (Node arg : argsParent.children()) {\n+    Iterator<Node> argsIterator = argsParent.children().iterator();\n+    while (argsIterator.hasNext()) {\n+        Node arg = argsIterator.next();\n         String argumentName = arg.getString();\n         allJsDocParams.remove(argumentName);\n         // type from JSDocInfo\n@@ -29,6 +31,7 @@\n             parameterType = oldParameterType.getJSType();\n             isOptionalParam = oldParameterType.isOptionalArg();\n             isVarArgs = oldParameterType.isVarArgs();\n+            oldParameterType = oldParameterType.getNext();\n         } else {\n             parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n         }\n@@ -39,11 +42,15 @@\n             foundTemplateType = true;\n         }\n         warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n-        if (oldParameterType != null) {\n-            oldParameterType = oldParameterType.getNext();\n-        }\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        Node newParam = builder.newParameterFromNode(oldParameterType);\n+        newParam.makeOptional();\n+        warnedAboutArgList |= addParameter(builder, oldParameterType.getJSType(), warnedAboutArgList, true, isVarArgs);\n+        oldParameterType = oldParameterType.getNext();\n+    }\n+ \n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                parametersNode.addChildToBack(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            parametersNode.addChildToBack(newParam);\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        Node newParam = (Node) oldParameterType.cloneTree();\n        builder.addParameter(newParam);\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,11 +28,17 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                parametersNode.addChildToBack(newParam);\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            parametersNode.addChildToBack(newParam);\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -44,6 +44,11 @@\n         }\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        Node newParam = (Node) oldParameterType.cloneTree();\n+        builder.addParameter(newParam);\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                boolean isOptionalParam = codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs;\n                boolean isVarArgs = codingConvention.isVarArgsParameter(currentParam);\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), isOptionalParam, isVarArgs);\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -29,7 +29,9 @@\n                     newParam.setOptionalArg(true);\n                 }\n             } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                boolean isOptionalParam = codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs;\n+                boolean isVarArgs = codingConvention.isVarArgsParameter(currentParam);\n+                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), isOptionalParam, isVarArgs);\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -38,7 +38,7 @@\n             }\n             foundTemplateType = true;\n         }\n-        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n+        warnedAboutArgList |= addParameter(builder, parameterType, isOptionalParam, isVarArgs);\n         if (oldParameterType != null) {\n             oldParameterType = oldParameterType.getNext();\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                parametersNode.addChildToBack(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n                Node newParam = paramBuilder.buildSingleParameterNode();\n                if (newParam != null) {\n                    parametersNode.addChildToBack(newParam);\n                }\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        for (int numParamsToAdd = oldType.getParametersCount() - parametersNode.getChildCount(); numParamsToAdd > 0; numParamsToAdd--) {\n            paramBuilder.buildSingleParameterNode(true);\n            Node newParam = paramBuilder.buildSingleParameterNode();\n            if (newParam != null) {\n                parametersNode.addChildToBack(newParam);\n            }\n        }\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        oldParameterType = oldParameterType != null ? oldParameterType.getNext() : null;\n    }\n    // Copy over any old parameters that aren't in the param list.\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    while (oldParameterType != null) {\n        builder.copyParameter(oldParameterType, true);\n        oldParameterType = oldParameterType.getNext();\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,12 +28,23 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                parametersNode.addChildToBack(newParam);\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                Node newParam = paramBuilder.buildSingleParameterNode();\n+                if (newParam != null) {\n+                    parametersNode.addChildToBack(newParam);\n+                }\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        for (int numParamsToAdd = oldType.getParametersCount() - parametersNode.getChildCount(); numParamsToAdd > 0; numParamsToAdd--) {\n+            paramBuilder.buildSingleParameterNode(true);\n+            Node newParam = paramBuilder.buildSingleParameterNode();\n+            if (newParam != null) {\n+                parametersNode.addChildToBack(newParam);\n+            }\n+        }\n     }\n     return this;\n }\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -39,9 +39,7 @@\n             foundTemplateType = true;\n         }\n         warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n-        if (oldParameterType != null) {\n-            oldParameterType = oldParameterType.getNext();\n-        }\n+        oldParameterType = oldParameterType != null ? oldParameterType.getNext() : null;\n     }\n     // Copy over any old parameters that aren't in the param list.\n     if (templateTypeName != null && !foundTemplateType) {\n@@ -50,6 +48,10 @@\n     for (String inexistentName : allJsDocParams) {\n         reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n     }\n+    while (oldParameterType != null) {\n+        builder.copyParameter(oldParameterType, true);\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     parametersNode = builder.build();\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            paramBuilder.newParameterFromNode(oldParam);\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -33,6 +33,10 @@\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            paramBuilder.newParameterFromNode(oldParam);\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -44,6 +44,10 @@\n         }\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        builder.newParameterFromNode(oldParameterType);\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": true, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs || currentParam.isOptArg(), codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n        }\n        if (oldParamsListHitOptArgs) {\n            paramBuilder.markParameterOptional();\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info) || isOptArgParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg() || isOptionalParam;\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        Node newParam = builder.newParameterFromNode(oldParameterType);\n        builder.markParameterOptional();\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -29,10 +29,18 @@\n                     newParam.setOptionalArg(true);\n                 }\n             } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs || currentParam.isOptArg(), codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+        }\n+        if (oldParamsListHitOptArgs) {\n+            paramBuilder.markParameterOptional();\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -21,13 +21,13 @@\n         allJsDocParams.remove(argumentName);\n         // type from JSDocInfo\n         JSType parameterType = null;\n-        boolean isOptionalParam = isOptionalParameter(arg, info);\n+        boolean isOptionalParam = isOptionalParameter(arg, info) || isOptArgParameter(arg, info);\n         isVarArgs = isVarArgsParameter(arg, info);\n         if (info != null && info.hasParameterType(argumentName)) {\n             parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n         } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n             parameterType = oldParameterType.getJSType();\n-            isOptionalParam = oldParameterType.isOptionalArg();\n+            isOptionalParam = oldParameterType.isOptionalArg() || isOptionalParam;\n             isVarArgs = oldParameterType.isVarArgs();\n         } else {\n             parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n@@ -44,6 +44,11 @@\n         }\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        Node newParam = builder.newParameterFromNode(oldParameterType);\n+        builder.markParameterOptional();\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, currentParam.isVarArgsParameter());\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    // Set optional/rest parameters on old nodes\n    if (oldParameterType != null) {\n        for (Node currentParam = argsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParameterType.isOptionalArg()) {\n                currentParam.putBooleanProp(Node.OPT_ES6_TYPED, true);\n            }\n            if (oldParameterType.isVarArgs() && !currentParam.isVarArgs()) {\n                currentParam.setVarArgs(true);\n            }\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -29,7 +29,7 @@\n                     newParam.setOptionalArg(true);\n                 }\n             } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, currentParam.isVarArgsParameter());\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -51,5 +51,17 @@\n         reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n     }\n     parametersNode = builder.build();\n+    // Set optional/rest parameters on old nodes\n+    if (oldParameterType != null) {\n+        for (Node currentParam = argsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n+            if (oldParameterType.isOptionalArg()) {\n+                currentParam.putBooleanProp(Node.OPT_ES6_TYPED, true);\n+            }\n+            if (oldParameterType.isVarArgs() && !currentParam.isVarArgs()) {\n+                currentParam.setVarArgs(true);\n+            }\n+            oldParameterType = oldParameterType.getNext();\n+        }\n+    }\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n                oldParam = paramBuilder.build().getLastChild();\n                oldParam.setOptionalArg(codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs);\n                oldParam.setVarArgs(codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParam = paramBuilder.build().getLastChild();\n            oldParam.setOptionalArg(oldParam.isOptionalArg() || oldParam.isOptionalArg());\n            oldParam.setVarArgs(oldParam.isVarArgs() || oldParam.isVarArgs());\n        }\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    Node lastAddedNode = null; // Keeps track of the last parameter node added to the parametersNode list\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        Node lastParameterNode = builder.build().getLastChild();\n        lastParameterNode.setOptionalArg(isOptionalParam);\n        lastParameterNode.setVarArgs(isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n        lastAddedNode = lastParameterNode;\n    }\n    // Copy over any old parameters that aren't in the param list.\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    while (oldParameterType != null) {\n        Node newParam = builder.newParameterFromNode(oldParameterType);\n        lastAddedNode = parametersNode.addChildToBack(newParam);\n        lastAddedNode.setOptionalArg(lastAddedNode.isOptionalArg() || oldParameterType.isOptionalArg());\n        lastAddedNode.setVarArgs(lastAddedNode.isVarArgs() || oldParameterType.isVarArgs());\n        oldParameterType = oldParameterType.getNext();\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -30,10 +30,20 @@\n                 }\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                oldParam = paramBuilder.build().getLastChild();\n+                oldParam.setOptionalArg(codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs);\n+                oldParam.setVarArgs(codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n         parametersNode = paramBuilder.build();\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParam = paramBuilder.build().getLastChild();\n+            oldParam.setOptionalArg(oldParam.isOptionalArg() || oldParam.isOptionalArg());\n+            oldParam.setVarArgs(oldParam.isVarArgs() || oldParam.isVarArgs());\n+        }\n     }\n     return this;\n }\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -16,6 +16,7 @@\n     Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n     boolean foundTemplateType = false;\n     boolean isVarArgs = false;\n+    Node lastAddedNode = null; // Keeps track of the last parameter node added to the parametersNode list\n     for (Node arg : argsParent.children()) {\n         String argumentName = arg.getString();\n         allJsDocParams.remove(argumentName);\n@@ -39,13 +40,24 @@\n             foundTemplateType = true;\n         }\n         warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n+        Node lastParameterNode = builder.build().getLastChild();\n+        lastParameterNode.setOptionalArg(isOptionalParam);\n+        lastParameterNode.setVarArgs(isVarArgs);\n         if (oldParameterType != null) {\n             oldParameterType = oldParameterType.getNext();\n         }\n+        lastAddedNode = lastParameterNode;\n     }\n     // Copy over any old parameters that aren't in the param list.\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n+    }\n+    while (oldParameterType != null) {\n+        Node newParam = builder.newParameterFromNode(oldParameterType);\n+        lastAddedNode = parametersNode.addChildToBack(newParam);\n+        lastAddedNode.setOptionalArg(lastAddedNode.isOptionalArg() || oldParameterType.isOptionalArg());\n+        lastAddedNode.setVarArgs(lastAddedNode.isVarArgs() || oldParameterType.isVarArgs());\n+        oldParameterType = oldParameterType.getNext();\n     }\n     for (String inexistentName : allJsDocParams) {\n         reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        Node currentParam = paramsParent.getFirstChild();\n        while (currentParam != null && oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n            // The subclass method might write its var_args as individual\n            // arguments.\n            if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                newParam.setVarArgs(false);\n                newParam.setOptionalArg(true);\n            }\n\n            currentParam = currentParam.getNext();\n        }\n\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(oldParam), oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg());\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (currentParam != null) {\n            Node newParam = paramBuilder.newParameterFromNode(currentParam);\n            warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam), oldParamsListHitOptArgs || newParam.isVarArgs() || newParam.isOptionalArg());\n            currentParam = currentParam.getNext();\n        }\n\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n\n    List<JSType> oldParameterTypes = (parametersNode == null) ? Collections.<JSType>emptyList() : parametersNode.getJSTypes();\n    List<String> oldParameterNames = (parametersNode == null) ? Collections.<String>emptyList() : parametersNode.getNames();\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    int nArgs = argsParent.getChildCount();\n    int nParams = oldParameterTypes.size();\n    int i;\n    for (i = 0; i < nArgs && i < nParams; i++) {\n        Node arg = argsParent.getChildAtIndex(i);\n        String paramName = oldParameterNames.get(i);\n        JSType oldParameterType = oldParameterTypes.get(i);\n        allJsDocParams.remove(paramName);\n        JSType parameterType = null;\n        boolean isOptional = isOptionalParameter(arg, info);\n        boolean isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(paramName)) {\n            parameterType = info.getParameterType(paramName).evaluate(scope, typeRegistry);\n        } else {\n            parameterType = oldParameterType.restrictByNotNullOrUndefined();\n        }\n        if (templateTypeName != null && parameterType.isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptional, isVarArgs);\n    }\n\n    // Add remaining parameters\n    for (; i < nParams; i++) {\n        JSType oldParameterType = oldParameterTypes.get(i);\n        boolean isOptional = oldParameterType.isOptionalArg();\n        boolean isVarArgs = oldParameterType.isVarArgs();\n        JSType parameterType = oldParameterType.restrictByNotNullOrUndefined();\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptional, isVarArgs);\n    }\n\n    // Add remaining args\n    for (; i < nArgs; i++) {\n        Node arg = argsParent.getChildAtIndex(i);\n        boolean isOptional = isOptionalParameter(arg, info);\n        boolean isVarArgs = isVarArgsParameter(arg, info);\n        JSType parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptional, isVarArgs);\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -17,22 +17,32 @@\n         Iterator<Node> oldParams = oldType.getParameters().iterator();\n         boolean warnedAboutArgList = false;\n         boolean oldParamsListHitOptArgs = false;\n-        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n-            if (oldParams.hasNext()) {\n-                Node oldParam = oldParams.next();\n-                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n-                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n-                // The subclass method might write its var_args as individual\n-                // arguments.\n-                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n-                    newParam.setVarArgs(false);\n-                    newParam.setOptionalArg(true);\n-                }\n-            } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+        Node currentParam = paramsParent.getFirstChild();\n+        while (currentParam != null && oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+            // The subclass method might write its var_args as individual\n+            // arguments.\n+            if (currentParam.getNext() != null && newParam.isVarArgs()) {\n+                newParam.setVarArgs(false);\n+                newParam.setOptionalArg(true);\n             }\n+\n+            currentParam = currentParam.getNext();\n+        }\n+\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(oldParam), oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg());\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (currentParam != null) {\n+            Node newParam = paramBuilder.newParameterFromNode(currentParam);\n+            warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam), oldParamsListHitOptArgs || newParam.isVarArgs() || newParam.isOptionalArg());\n+            currentParam = currentParam.getNext();\n+        }\n+\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -6,50 +6,62 @@\n             return inferParameterTypes(info);\n         }\n     }\n-    // arguments\n-    Node oldParameterType = null;\n-    if (parametersNode != null) {\n-        oldParameterType = parametersNode.getFirstChild();\n-    }\n+\n+    List<JSType> oldParameterTypes = (parametersNode == null) ? Collections.<JSType>emptyList() : parametersNode.getJSTypes();\n+    List<String> oldParameterNames = (parametersNode == null) ? Collections.<String>emptyList() : parametersNode.getNames();\n     FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n     boolean warnedAboutArgList = false;\n     Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n-    boolean foundTemplateType = false;\n-    boolean isVarArgs = false;\n-    for (Node arg : argsParent.children()) {\n-        String argumentName = arg.getString();\n-        allJsDocParams.remove(argumentName);\n-        // type from JSDocInfo\n+    int nArgs = argsParent.getChildCount();\n+    int nParams = oldParameterTypes.size();\n+    int i;\n+    for (i = 0; i < nArgs && i < nParams; i++) {\n+        Node arg = argsParent.getChildAtIndex(i);\n+        String paramName = oldParameterNames.get(i);\n+        JSType oldParameterType = oldParameterTypes.get(i);\n+        allJsDocParams.remove(paramName);\n         JSType parameterType = null;\n-        boolean isOptionalParam = isOptionalParameter(arg, info);\n-        isVarArgs = isVarArgsParameter(arg, info);\n-        if (info != null && info.hasParameterType(argumentName)) {\n-            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n-        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n-            parameterType = oldParameterType.getJSType();\n-            isOptionalParam = oldParameterType.isOptionalArg();\n-            isVarArgs = oldParameterType.isVarArgs();\n+        boolean isOptional = isOptionalParameter(arg, info);\n+        boolean isVarArgs = isVarArgsParameter(arg, info);\n+        if (info != null && info.hasParameterType(paramName)) {\n+            parameterType = info.getParameterType(paramName).evaluate(scope, typeRegistry);\n         } else {\n-            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n+            parameterType = oldParameterType.restrictByNotNullOrUndefined();\n         }\n-        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n+        if (templateTypeName != null && parameterType.isTemplateType()) {\n             if (foundTemplateType) {\n                 reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n             }\n             foundTemplateType = true;\n         }\n-        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n-        if (oldParameterType != null) {\n-            oldParameterType = oldParameterType.getNext();\n-        }\n+        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptional, isVarArgs);\n     }\n-    // Copy over any old parameters that aren't in the param list.\n+\n+    // Add remaining parameters\n+    for (; i < nParams; i++) {\n+        JSType oldParameterType = oldParameterTypes.get(i);\n+        boolean isOptional = oldParameterType.isOptionalArg();\n+        boolean isVarArgs = oldParameterType.isVarArgs();\n+        JSType parameterType = oldParameterType.restrictByNotNullOrUndefined();\n+        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptional, isVarArgs);\n+    }\n+\n+    // Add remaining args\n+    for (; i < nArgs; i++) {\n+        Node arg = argsParent.getChildAtIndex(i);\n+        boolean isOptional = isOptionalParameter(arg, info);\n+        boolean isVarArgs = isVarArgsParameter(arg, info);\n+        JSType parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n+        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptional, isVarArgs);\n+    }\n+\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n     for (String inexistentName : allJsDocParams) {\n         reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n     }\n+\n     parametersNode = builder.build();\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    FunctionTypeBuilder builder = new FunctionTypeBuilder(typeRegistry);\n    if (oldType == null) {\n        return builder;\n    }\n    builder.returnType(oldType.getReturnType());\n    builder.returnTypeInferred(oldType.isReturnTypeInferred());\n    if (paramsParent == null) {\n        // Not a function literal.\n        builder.parametersNode(oldType.getParametersNode());\n        if (builder.parametersNode() == null) {\n            builder.parametersNode(new FunctionParamBuilder(typeRegistry).build());\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= builder.addParameter(typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        builder.parametersNode(paramBuilder.build());\n    }\n    return builder;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    FunctionTypeBuilder builder = new FunctionTypeBuilder(typeRegistry);\n    if (argsParent == null) {\n        if (info == null) {\n            return builder;\n        } else {\n            return builder.inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= builder.addParameter(parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    builder.parametersNode(paramBuilder.build());\n    return builder;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -1,14 +1,15 @@\n FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n+    FunctionTypeBuilder builder = new FunctionTypeBuilder(typeRegistry);\n     if (oldType == null) {\n-        return this;\n+        return builder;\n     }\n-    returnType = oldType.getReturnType();\n-    returnTypeInferred = oldType.isReturnTypeInferred();\n+    builder.returnType(oldType.getReturnType());\n+    builder.returnTypeInferred(oldType.isReturnTypeInferred());\n     if (paramsParent == null) {\n         // Not a function literal.\n-        parametersNode = oldType.getParametersNode();\n-        if (parametersNode == null) {\n-            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n+        builder.parametersNode(oldType.getParametersNode());\n+        if (builder.parametersNode() == null) {\n+            builder.parametersNode(new FunctionParamBuilder(typeRegistry).build());\n         }\n     } else {\n         // We're overriding with a function literal. Apply type information\n@@ -29,11 +30,11 @@\n                     newParam.setOptionalArg(true);\n                 }\n             } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                warnedAboutArgList |= builder.addParameter(typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        builder.parametersNode(paramBuilder.build());\n     }\n-    return this;\n+    return builder;\n }\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -1,9 +1,10 @@\n FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n+    FunctionTypeBuilder builder = new FunctionTypeBuilder(typeRegistry);\n     if (argsParent == null) {\n         if (info == null) {\n-            return this;\n+            return builder;\n         } else {\n-            return inferParameterTypes(info);\n+            return builder.inferParameterTypes(info);\n         }\n     }\n     // arguments\n@@ -11,7 +12,7 @@\n     if (parametersNode != null) {\n         oldParameterType = parametersNode.getFirstChild();\n     }\n-    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n+    FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n     boolean warnedAboutArgList = false;\n     Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n     boolean foundTemplateType = false;\n@@ -38,7 +39,7 @@\n             }\n             foundTemplateType = true;\n         }\n-        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n+        warnedAboutArgList |= builder.addParameter(parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n         if (oldParameterType != null) {\n             oldParameterType = oldParameterType.getNext();\n         }\n@@ -50,6 +51,6 @@\n     for (String inexistentName : allJsDocParams) {\n         reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n     }\n-    parametersNode = builder.build();\n-    return this;\n+    builder.parametersNode(paramBuilder.build());\n+    return builder;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                // We need to add the new parameter node to the parametersNode\n                // to make sure that 'parametersNode' becomes non-null in case the\n                // number of new nodes is less than that of old nodes\n                parametersNode.addChildToFront(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n            parametersNode.addChildToFront(newParam);\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        Node newParam = new Node(Token.PARAM_LIST, oldParameterType.cloneNode());\n        newParam.setOptionalArg(oldParameterType.isOptionalArg());\n        newParam.setVarArgs(oldParameterType.isVarArgs());\n        builder.addParameter(newParam);\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,11 +28,21 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                // We need to add the new parameter node to the parametersNode\n+                // to make sure that 'parametersNode' becomes non-null in case the\n+                // number of new nodes is less than that of old nodes\n+                parametersNode.addChildToFront(newParam);\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+            parametersNode.addChildToFront(newParam);\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -44,6 +44,13 @@\n         }\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        Node newParam = new Node(Token.PARAM_LIST, oldParameterType.cloneNode());\n+        newParam.setOptionalArg(oldParameterType.isOptionalArg());\n+        newParam.setVarArgs(oldParameterType.isVarArgs());\n+        builder.addParameter(newParam);\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        boolean currentParamIsOptional = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    currentParamIsOptional = true;\n                }\n            } else {\n                currentParamIsOptional = codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs;\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, currentParamIsOptional, codingConvention.isVarArgsParameter(currentParam));\n            }\n            if (!currentParamIsOptional) {\n                oldParamsListHitOptArgs = true;\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    boolean oldParamsListHitOptArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || isVarArgs || isOptionalParam;\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam || oldParamsListHitOptArgs, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n        if (!isOptionalParam && !isVarArgs) {\n            oldParamsListHitOptArgs = true;\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -17,6 +17,7 @@\n         Iterator<Node> oldParams = oldType.getParameters().iterator();\n         boolean warnedAboutArgList = false;\n         boolean oldParamsListHitOptArgs = false;\n+        boolean currentParamIsOptional = false;\n         for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n             if (oldParams.hasNext()) {\n                 Node oldParam = oldParams.next();\n@@ -26,10 +27,14 @@\n                 // arguments.\n                 if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                     newParam.setVarArgs(false);\n-                    newParam.setOptionalArg(true);\n+                    currentParamIsOptional = true;\n                 }\n             } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                currentParamIsOptional = codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs;\n+                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, currentParamIsOptional, codingConvention.isVarArgsParameter(currentParam));\n+            }\n+            if (!currentParamIsOptional) {\n+                oldParamsListHitOptArgs = true;\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -16,6 +16,7 @@\n     Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n     boolean foundTemplateType = false;\n     boolean isVarArgs = false;\n+    boolean oldParamsListHitOptArgs = false;\n     for (Node arg : argsParent.children()) {\n         String argumentName = arg.getString();\n         allJsDocParams.remove(argumentName);\n@@ -29,6 +30,7 @@\n             parameterType = oldParameterType.getJSType();\n             isOptionalParam = oldParameterType.isOptionalArg();\n             isVarArgs = oldParameterType.isVarArgs();\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || isVarArgs || isOptionalParam;\n         } else {\n             parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n         }\n@@ -38,9 +40,12 @@\n             }\n             foundTemplateType = true;\n         }\n-        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n+        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam || oldParamsListHitOptArgs, isVarArgs);\n         if (oldParameterType != null) {\n             oldParameterType = oldParameterType.getNext();\n+        }\n+        if (!isOptionalParam && !isVarArgs) {\n+            oldParamsListHitOptArgs = true;\n         }\n     }\n     // Copy over any old parameters that aren't in the param list.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n                oldParamsListHitOptArgs |= codingConvention.isOptionalParameter(currentParam) || codingConvention.isVarArgsParameter(currentParam);\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            newParam.setOptionalArg(oldParamsListHitOptArgs || oldParam.isOptionalArg());\n            newParam.setVarArgs(oldParamsListHitOptArgs || oldParam.isVarArgs());\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n            oldParameterType = oldParameterType.getNext();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        Node newParam = builder.newParameterFromNode(oldParameterType);\n        newParam.setOptionalArg(oldParameterType.isOptionalArg());\n        newParam.setVarArgs(oldParameterType.isVarArgs());\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -30,9 +30,16 @@\n                 }\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                oldParamsListHitOptArgs |= codingConvention.isOptionalParameter(currentParam) || codingConvention.isVarArgsParameter(currentParam);\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            newParam.setOptionalArg(oldParamsListHitOptArgs || oldParam.isOptionalArg());\n+            newParam.setVarArgs(oldParamsListHitOptArgs || oldParam.isVarArgs());\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -29,6 +29,7 @@\n             parameterType = oldParameterType.getJSType();\n             isOptionalParam = oldParameterType.isOptionalArg();\n             isVarArgs = oldParameterType.isVarArgs();\n+            oldParameterType = oldParameterType.getNext();\n         } else {\n             parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n         }\n@@ -39,11 +40,14 @@\n             foundTemplateType = true;\n         }\n         warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n-        if (oldParameterType != null) {\n-            oldParameterType = oldParameterType.getNext();\n-        }\n     }\n     // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        Node newParam = builder.newParameterFromNode(oldParameterType);\n+        newParam.setOptionalArg(oldParameterType.isOptionalArg());\n+        newParam.setVarArgs(oldParameterType.isVarArgs());\n+        oldParameterType = oldParameterType.getNext();\n+    }\n     if (templateTypeName != null && !foundTemplateType) {\n         reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= paramBuilder.addParameter(typeRegistry.getNativeType(UNKNOWN_TYPE), codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= builder.addParameter(parameterType, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -29,7 +29,7 @@\n                     newParam.setOptionalArg(true);\n                 }\n             } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                warnedAboutArgList |= paramBuilder.addParameter(typeRegistry.getNativeType(UNKNOWN_TYPE), codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferParameterTypes\n@@ -38,7 +38,7 @@\n             }\n             foundTemplateType = true;\n         }\n-        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n+        warnedAboutArgList |= builder.addParameter(parameterType, isOptionalParam, isVarArgs);\n         if (oldParameterType != null) {\n             oldParameterType = oldParameterType.getNext();\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}]