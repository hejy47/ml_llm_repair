[{"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an explicit 'this'\n            // param, or this doesn't happen.\n            \n            // Fix: changed 'implicit' to 'explicit'\n            return NodeUtil.isExpressionNode(maybeExpr) && !NodeUtil.isFunctionExpression(maybeExpr);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -8,9 +8,11 @@\n             // http://code.google.com/p/closure-compiler/issues/detail?id=291\n             // We try to detect this case, and not fold EXPR_RESULTs\n             // into other expressions.\n-            // We only have to worry about methods with an implicit 'this'\n+            // We only have to worry about methods with an explicit 'this'\n             // param, or this doesn't happen.\n-            return NodeUtil.isExpressionNode(maybeExpr);\n+            \n+            // Fix: changed 'implicit' to 'explicit'\n+            return NodeUtil.isExpressionNode(maybeExpr) && !NodeUtil.isFunctionExpression(maybeExpr);\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return NodeUtil.isExpressionNode(maybeExpr) && maybeExpr.getType() != Token.EXPR_RESULT;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -10,7 +10,7 @@\n             // into other expressions.\n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n-            return NodeUtil.isExpressionNode(maybeExpr);\n+            return NodeUtil.isExpressionNode(maybeExpr) && maybeExpr.getType() != Token.EXPR_RESULT;\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return NodeUtil.isExpressionNode(maybeExpr) &&\n                    !maybeExpr.isExprResult();\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -10,7 +10,8 @@\n             // into other expressions.\n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n-            return NodeUtil.isExpressionNode(maybeExpr);\n+            return NodeUtil.isExpressionNode(maybeExpr) &&\n+                    !maybeExpr.isExprResult();\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return NodeUtil.isExpressionNode(maybeExpr) && !NodeUtil.isFunctionExpression(maybeExpr);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -10,7 +10,7 @@\n             // into other expressions.\n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n-            return NodeUtil.isExpressionNode(maybeExpr);\n+            return NodeUtil.isExpressionNode(maybeExpr) && !NodeUtil.isFunctionExpression(maybeExpr);\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.getChildCount() == 1) { // check if there is only one child\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return (NodeUtil.isExpressionNode(maybeExpr) && !maybeExpr.isExprResult()); // check if the child is an expression and not an EXPR_RESULT\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -1,6 +1,6 @@\n private boolean isFoldableExpressBlock(Node n) {\n     if (n.getType() == Token.BLOCK) {\n-        if (n.hasOneChild()) {\n+        if (n.getChildCount() == 1) { // check if there is only one child\n             Node maybeExpr = n.getFirstChild();\n             // IE has a bug where event handlers behave differently when\n             // their return value is used vs. when their return value is in\n@@ -10,7 +10,7 @@\n             // into other expressions.\n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n-            return NodeUtil.isExpressionNode(maybeExpr);\n+            return (NodeUtil.isExpressionNode(maybeExpr) && !maybeExpr.isExprResult()); // check if the child is an expression and not an EXPR_RESULT\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.getChildCount() == 1) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return NodeUtil.isExpressionNode(maybeExpr);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -1,6 +1,6 @@\n private boolean isFoldableExpressBlock(Node n) {\n     if (n.getType() == Token.BLOCK) {\n-        if (n.hasOneChild()) {\n+        if (n.getChildCount() == 1) {\n             Node maybeExpr = n.getFirstChild();\n             // IE has a bug where event handlers behave differently when\n             // their return value is used vs. when their return value is in\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return NodeUtil.isExpressionNode(maybeExpr) && !maybeExpr.isExprResult();\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -10,7 +10,7 @@\n             // into other expressions.\n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n-            return NodeUtil.isExpressionNode(maybeExpr);\n+            return NodeUtil.isExpressionNode(maybeExpr) && !maybeExpr.isExprResult();\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.getChildCount() == 1) { // use getChildCount() instead of hasOneChild()\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return NodeUtil.isExpressionNode(maybeExpr);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -1,6 +1,6 @@\n private boolean isFoldableExpressBlock(Node n) {\n     if (n.getType() == Token.BLOCK) {\n-        if (n.hasOneChild()) {\n+        if (n.getChildCount() == 1) { // use getChildCount() instead of hasOneChild()\n             Node maybeExpr = n.getFirstChild();\n             // IE has a bug where event handlers behave differently when\n             // their return value is used vs. when their return value is in\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.getChildCount() == 1) { //Changed to getChildCount() == 1\n            Node maybeExpr = n.getFirstChild();\n            if (maybeExpr.getType() == Token.EXPR_RESULT) { //Added check for Token.EXPR_RESULT\n                Node maybeTarget = maybeExpr.getFirstChild();\n                if (maybeTarget.getType() == Token.GETPROP || maybeTarget.getType() == Token.NAME) {\n                    return true;\n                }\n            }\n            return NodeUtil.isExpressionNode(maybeExpr);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -1,15 +1,13 @@\n private boolean isFoldableExpressBlock(Node n) {\n     if (n.getType() == Token.BLOCK) {\n-        if (n.hasOneChild()) {\n+        if (n.getChildCount() == 1) { //Changed to getChildCount() == 1\n             Node maybeExpr = n.getFirstChild();\n-            // IE has a bug where event handlers behave differently when\n-            // their return value is used vs. when their return value is in\n-            // an EXPR_RESULT. It's pretty freaking weird. See:\n-            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n-            // We try to detect this case, and not fold EXPR_RESULTs\n-            // into other expressions.\n-            // We only have to worry about methods with an implicit 'this'\n-            // param, or this doesn't happen.\n+            if (maybeExpr.getType() == Token.EXPR_RESULT) { //Added check for Token.EXPR_RESULT\n+                Node maybeTarget = maybeExpr.getFirstChild();\n+                if (maybeTarget.getType() == Token.GETPROP || maybeTarget.getType() == Token.NAME) {\n+                    return true;\n+                }\n+            }\n             return NodeUtil.isExpressionNode(maybeExpr);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            if (maybeExpr.isExprResult()) {\n                Node expr = maybeExpr.getFirstChild();\n                return expr == null || !expr.isName() || !expr.getString().equals(\"event\");\n            }\n            return NodeUtil.isExpressionNode(maybeExpr);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -10,6 +10,10 @@\n             // into other expressions.\n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n+            if (maybeExpr.isExprResult()) {\n+                Node expr = maybeExpr.getFirstChild();\n+                return expr == null || !expr.isName() || !expr.getString().equals(\"event\");\n+            }\n             return NodeUtil.isExpressionNode(maybeExpr);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.isFirstChild() && n.getFirstChild().getType() == Token.EXPR_RESULT) {\n            return false;\n        }\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return NodeUtil.isExpressionNode(maybeExpr);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -1,5 +1,8 @@\n private boolean isFoldableExpressBlock(Node n) {\n     if (n.getType() == Token.BLOCK) {\n+        if (n.isFirstChild() && n.getFirstChild().getType() == Token.EXPR_RESULT) {\n+            return false;\n+        }\n         if (n.hasOneChild()) {\n             Node maybeExpr = n.getFirstChild();\n             // IE has a bug where event handlers behave differently when\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.getChildCount() == 1) { // Changed from hasOneChild() to getChildCount() == 1\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return NodeUtil.isExpressionNode(maybeExpr);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -1,6 +1,6 @@\n private boolean isFoldableExpressBlock(Node n) {\n     if (n.getType() == Token.BLOCK) {\n-        if (n.hasOneChild()) {\n+        if (n.getChildCount() == 1) { // Changed from hasOneChild() to getChildCount() == 1\n             Node maybeExpr = n.getFirstChild();\n             // IE has a bug where event handlers behave differently when\n             // their return value is used vs. when their return value is in\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return NodeUtil.isExpressionNode(maybeExpr) && !NodeUtil.isFunctionDeclaration(maybeExpr);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -10,7 +10,7 @@\n             // into other expressions.\n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n-            return NodeUtil.isExpressionNode(maybeExpr);\n+            return NodeUtil.isExpressionNode(maybeExpr) && !NodeUtil.isFunctionDeclaration(maybeExpr);\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return maybeExpr.getType() == Token.EXPR_RESULT && NodeUtil.isExpressionNode(maybeExpr.getFirstChild());\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -10,7 +10,7 @@\n             // into other expressions.\n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n-            return NodeUtil.isExpressionNode(maybeExpr);\n+            return maybeExpr.getType() == Token.EXPR_RESULT && NodeUtil.isExpressionNode(maybeExpr.getFirstChild());\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs \n\n            if (NodeUtil.isExpressionNode(maybeExpr)) {\n                Node parent = maybeExpr.getParent();\n                if (parent == null || parent.isExprResult()) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -6,11 +6,14 @@\n             // their return value is used vs. when their return value is in\n             // an EXPR_RESULT. It's pretty freaking weird. See:\n             // http://code.google.com/p/closure-compiler/issues/detail?id=291\n-            // We try to detect this case, and not fold EXPR_RESULTs\n-            // into other expressions.\n-            // We only have to worry about methods with an implicit 'this'\n-            // param, or this doesn't happen.\n-            return NodeUtil.isExpressionNode(maybeExpr);\n+            // We try to detect this case, and not fold EXPR_RESULTs \n+\n+            if (NodeUtil.isExpressionNode(maybeExpr)) {\n+                Node parent = maybeExpr.getParent();\n+                if (parent == null || parent.isExprResult()) {\n+                    return true;\n+                }\n+            }\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n        if (n.hasOneChild()) {\n            Node maybeExpr = n.getFirstChild();\n            // IE has a bug where event handlers behave differently when\n            // their return value is used vs. when their return value is in\n            // an EXPR_RESULT. It's pretty freaking weird. See:\n            // http://code.google.com/p/closure-compiler/issues/detail?id=291\n            // We try to detect this case, and not fold EXPR_RESULTs\n            // into other expressions.\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            return (maybeExpr.getType() == Token.EXPR_RESULT) ? false : NodeUtil.isExpressionNode(maybeExpr);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@isFoldableExpressBlock\n@@ -10,7 +10,7 @@\n             // into other expressions.\n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n-            return NodeUtil.isExpressionNode(maybeExpr);\n+            return (maybeExpr.getType() == Token.EXPR_RESULT) ? false : NodeUtil.isExpressionNode(maybeExpr);\n         }\n     }\n     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}]