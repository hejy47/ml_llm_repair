[{"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        if (left.isString() || right.isString()) {\n            return new Node(Token.ADD, left, right);\n        } else {\n            return null;\n        }\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -2,7 +2,11 @@\n     // Unlike other operations, ADD operands are not always converted\n     // to Number.\n     if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n-        return null;\n+        if (left.isString() || right.isString()) {\n+            return new Node(Token.ADD, left, right);\n+        } else {\n+            return null;\n+        }\n     }\n     double result;\n     // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            // Check if the operands are strings or if one operand is a string and the other is not a number.\n            if (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false) || \n                Double.isNaN(lval) || Double.isNaN(rval) ||\n                Double.isInfinite(lval) || Double.isInfinite(rval)) {\n                \n                String lString = NodeUtil.getStringValue(left);\n                String rString = NodeUtil.getStringValue(right);\n                return Node.newString(lString + rString);\n            } else {\n                result = lval + rval;\n            }\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -28,7 +28,17 @@\n             result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n-            result = lval + rval;\n+            // Check if the operands are strings or if one operand is a string and the other is not a number.\n+            if (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false) || \n+                Double.isNaN(lval) || Double.isNaN(rval) ||\n+                Double.isInfinite(lval) || Double.isInfinite(rval)) {\n+                \n+                String lString = NodeUtil.getStringValue(left);\n+                String rString = NodeUtil.getStringValue(right);\n+                return Node.newString(lString + rString);\n+            } else {\n+                result = lval + rval;\n+            }\n             break;\n         case Token.SUB:\n             result = lval - rval;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            if (NodeUtil.isNumber(left) && NodeUtil.isNumber(right)) { // Add an additional check for operands being numbers\n                result = lval + rval;\n            } else {\n                result = Double.NaN;\n            }\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        return Node.newNumber(result);\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -28,7 +28,11 @@\n             result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n-            result = lval + rval;\n+            if (NodeUtil.isNumber(left) && NodeUtil.isNumber(right)) { // Add an additional check for operands being numbers\n+                result = lval + rval;\n+            } else {\n+                result = Double.NaN;\n+            }\n             break;\n         case Token.SUB:\n             result = lval - rval;\n@@ -58,8 +62,7 @@\n     if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n     // point, fixed-point math starts to break down and become inaccurate.\n     Math.abs(result) <= MAX_FOLD_NUMBER) {\n-        Node newNumber = Node.newNumber(result);\n-        return newNumber;\n+        return Node.newNumber(result);\n     } else if (Double.isNaN(result)) {\n         return Node.newString(Token.NAME, \"NaN\");\n     } else if (result == Double.POSITIVE_INFINITY) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return Node.newString(Token.STRING, \"\");\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            if (NodeUtil.isNullOrUndefined(left) || NodeUtil.isNullOrUndefined(right)) {\n                result = Double.NaN;\n            } else {\n                result = lval + rval;\n            }\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -2,7 +2,7 @@\n     // Unlike other operations, ADD operands are not always converted\n     // to Number.\n     if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n-        return null;\n+        return Node.newString(Token.STRING, \"\");\n     }\n     double result;\n     // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n@@ -28,7 +28,11 @@\n             result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n-            result = lval + rval;\n+            if (NodeUtil.isNullOrUndefined(left) || NodeUtil.isNullOrUndefined(right)) {\n+                result = Double.NaN;\n+            } else {\n+                result = lval + rval;\n+            }\n             break;\n         case Token.SUB:\n             result = lval - rval;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            if (NodeUtil.isNaN(lValObj) || NodeUtil.isNaN(rValObj)) {\n                return Node.newString(Token.NAME, \"NaN\");\n            } else if (NodeUtil.isInfinity(lValObj) && NodeUtil.isInfinity(rValObj)) {\n                if (NodeUtil.isNegative(lValObj) == NodeUtil.isNegative(rValObj)) {\n                    return NodeUtil.isNegative(lValObj) ? \n                           new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\")) :\n                           Node.newString(Token.NAME, \"Infinity\");\n                } else {\n                    return null;\n                }\n            } else {\n                result = lval + rval;\n            }\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -28,7 +28,19 @@\n             result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n-            result = lval + rval;\n+            if (NodeUtil.isNaN(lValObj) || NodeUtil.isNaN(rValObj)) {\n+                return Node.newString(Token.NAME, \"NaN\");\n+            } else if (NodeUtil.isInfinity(lValObj) && NodeUtil.isInfinity(rValObj)) {\n+                if (NodeUtil.isNegative(lValObj) == NodeUtil.isNegative(rValObj)) {\n+                    return NodeUtil.isNegative(lValObj) ? \n+                           new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\")) :\n+                           Node.newString(Token.NAME, \"Infinity\");\n+                } else {\n+                    return null;\n+                }\n+            } else {\n+                result = lval + rval;\n+            }\n             break;\n         case Token.SUB:\n             result = lval - rval;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = (long) lval & (long) rval; // cast double to long before bitwise AND operation\n            break;\n        case Token.BITOR:\n            result = (long) lval | (long) rval; // cast double to long before bitwise OR operation\n            break;\n        case Token.BITXOR:\n            result = (long) lval ^ (long) rval; // cast double to long before bitwise XOR operation\n            break;\n        case Token.ADD:\n            if (NodeUtil.isTypeOf(left, Token.STRING) || NodeUtil.isTypeOf(right, Token.STRING)) {\n                // if either operand is a string, concatenate them\n                String lStr = NodeUtil.getStringValue(left);\n                String rStr = NodeUtil.getStringValue(right);\n                return Node.newString(lStr + rStr);\n            }\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -19,15 +19,21 @@\n     double rval = rValObj;\n     switch(opType) {\n         case Token.BITAND:\n-            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n+            result = (long) lval & (long) rval; // cast double to long before bitwise AND operation\n             break;\n         case Token.BITOR:\n-            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n+            result = (long) lval | (long) rval; // cast double to long before bitwise OR operation\n             break;\n         case Token.BITXOR:\n-            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n+            result = (long) lval ^ (long) rval; // cast double to long before bitwise XOR operation\n             break;\n         case Token.ADD:\n+            if (NodeUtil.isTypeOf(left, Token.STRING) || NodeUtil.isTypeOf(right, Token.STRING)) {\n+                // if either operand is a string, concatenate them\n+                String lStr = NodeUtil.getStringValue(left);\n+                String rStr = NodeUtil.getStringValue(right);\n+                return Node.newString(lStr + rStr);\n+            }\n             result = lval + rval;\n             break;\n         case Token.SUB:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            // Handle adding Strings and concatenation\n            if(NodeUtil.isImmutableValue(left) && NodeUtil.isImmutableValue(right)) {\n                return Node.newString(left.getString() + right.getString());\n            } else {\n                result = lval + rval;\n            }\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -28,7 +28,12 @@\n             result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n-            result = lval + rval;\n+            // Handle adding Strings and concatenation\n+            if(NodeUtil.isImmutableValue(left) && NodeUtil.isImmutableValue(right)) {\n+                return Node.newString(left.getString() + right.getString());\n+            } else {\n+                result = lval + rval;\n+            }\n             break;\n         case Token.SUB:\n             result = lval - rval;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = (double)ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = (double)ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = (double)ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -19,13 +19,13 @@\n     double rval = rValObj;\n     switch(opType) {\n         case Token.BITAND:\n-            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n+            result = (double)ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n             break;\n         case Token.BITOR:\n-            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n+            result = (double)ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n             break;\n         case Token.BITXOR:\n-            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n+            result = (double)ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n             result = lval + rval;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            if (NodeUtil.isNumericExpression(left) && NodeUtil.isNumericExpression(right)) {\n                // Ensure that large numbers are not subject to precision loss\n                // due to JavaScript's representation of floating point numbers.\n                double sum = lval + rval;\n                // The following check looks redundant, but it's essential.\n                // For some edge cases where lval or rval overflow, the value of\n                // sum might be incorrect.\n                if (sum != Double.POSITIVE_INFINITY && sum != Double.NEGATIVE_INFINITY) {\n                    return Node.newNumber(sum);\n                }\n            }\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -28,6 +28,17 @@\n             result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n+            if (NodeUtil.isNumericExpression(left) && NodeUtil.isNumericExpression(right)) {\n+                // Ensure that large numbers are not subject to precision loss\n+                // due to JavaScript's representation of floating point numbers.\n+                double sum = lval + rval;\n+                // The following check looks redundant, but it's essential.\n+                // For some edge cases where lval or rval overflow, the value of\n+                // sum might be incorrect.\n+                if (sum != Double.POSITIVE_INFINITY && sum != Double.NEGATIVE_INFINITY) {\n+                    return Node.newNumber(sum);\n+                }\n+            }\n             result = lval + rval;\n             break;\n         case Token.SUB:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result = 0;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            //if either of operands is a string, convert both operands to string\n            if(NodeUtil.mayBeString(left) || NodeUtil.mayBeString(right)){\n                return NodeUtil.getStringConcatenation(left, right);\n            }\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -4,7 +4,7 @@\n     if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n         return null;\n     }\n-    double result;\n+    double result = 0;\n     // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n     // to zero so this is a little akward here.\n     Double lValObj = NodeUtil.getNumberValue(left);\n@@ -28,6 +28,10 @@\n             result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n+            //if either of operands is a string, convert both operands to string\n+            if(NodeUtil.mayBeString(left) || NodeUtil.mayBeString(right)){\n+                return NodeUtil.getStringConcatenation(left, right);\n+            }\n             result = lval + rval;\n             break;\n         case Token.SUB:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            if (NodeUtil.isNullOrUndefined(left) || NodeUtil.isNullOrUndefined(right)) {\n                return new Node(Token.STRING, \"\");\n            }\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -28,6 +28,9 @@\n             result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n+            if (NodeUtil.isNullOrUndefined(left) || NodeUtil.isNullOrUndefined(right)) {\n+                return new Node(Token.STRING, \"\");\n+            }\n             result = lval + rval;\n             break;\n         case Token.SUB:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return NodeUtil.getStringConcatExpr(left, right);\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            // The following condition is added to handle cases where left and/or right operands are String but not both\n            if (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false)) {\n                return NodeUtil.getStringConcatExpr(left, right);\n            }\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -2,7 +2,7 @@\n     // Unlike other operations, ADD operands are not always converted\n     // to Number.\n     if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n-        return null;\n+        return NodeUtil.getStringConcatExpr(left, right);\n     }\n     double result;\n     // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n@@ -28,6 +28,10 @@\n             result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n+            // The following condition is added to handle cases where left and/or right operands are String but not both\n+            if (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false)) {\n+                return NodeUtil.getStringConcatExpr(left, right);\n+            }\n             result = lval + rval;\n             break;\n         case Token.SUB:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return Node.newString(Token.ADD, \"\"); // Return an empty string instead of null to prevent NullPointerExceptions\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= Math.max(String.valueOf(lval).length(), String.valueOf(rval).length()) + (opType == Token.ADD ? 1 : 0) && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -2,7 +2,7 @@\n     // Unlike other operations, ADD operands are not always converted\n     // to Number.\n     if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n-        return null;\n+        return Node.newString(Token.ADD, \"\"); // Return an empty string instead of null to prevent NullPointerExceptions\n     }\n     double result;\n     // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n@@ -55,7 +55,7 @@\n     }\n     // TODO(johnlenz): consider removing the result length check.\n     // length of the left and right value plus 1 byte for the operator.\n-    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n+    if (String.valueOf(result).length() <= Math.max(String.valueOf(lval).length(), String.valueOf(rval).length()) + (opType == Token.ADD ? 1 : 0) && // Do not try to fold arithmetic for numbers > 2^53. After that\n     // point, fixed-point math starts to break down and become inaccurate.\n     Math.abs(result) <= MAX_FOLD_NUMBER) {\n         Node newNumber = Node.newNumber(result);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj.doubleValue(); // Explicit unboxing to double\n    double rval = rValObj.doubleValue(); // Explicit unboxing to double\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -15,8 +15,8 @@\n     if (rValObj == null) {\n         return null;\n     }\n-    double lval = lValObj;\n-    double rval = rValObj;\n+    double lval = lValObj.doubleValue(); // Explicit unboxing to double\n+    double rval = rValObj.doubleValue(); // Explicit unboxing to double\n     switch(opType) {\n         case Token.BITAND:\n             result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj.doubleValue(); //fixed here\n    double rval = rValObj.doubleValue(); //fixed here\n    switch(opType) {\n        case Token.BITAND:\n            result = (double)(ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval)); //fixed here\n            break;\n        case Token.BITOR:\n            result = (double)(ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval)); //fixed here\n            break;\n        case Token.BITXOR:\n            result = (double)(ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval)); //fixed here\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -15,17 +15,17 @@\n     if (rValObj == null) {\n         return null;\n     }\n-    double lval = lValObj;\n-    double rval = rValObj;\n+    double lval = lValObj.doubleValue(); //fixed here\n+    double rval = rValObj.doubleValue(); //fixed here\n     switch(opType) {\n         case Token.BITAND:\n-            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n+            result = (double)(ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval)); //fixed here\n             break;\n         case Token.BITOR:\n-            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n+            result = (double)(ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval)); //fixed here\n             break;\n         case Token.BITXOR:\n-            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n+            result = (double)(ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval)); //fixed here\n             break;\n         case Token.ADD:\n             result = lval + rval;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj.doubleValue();\n    double rval = rValObj.doubleValue();\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -15,8 +15,8 @@\n     if (rValObj == null) {\n         return null;\n     }\n-    double lval = lValObj;\n-    double rval = rValObj;\n+    double lval = lValObj.doubleValue();\n+    double rval = rValObj.doubleValue();\n     switch(opType) {\n         case Token.BITAND:\n             result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj.doubleValue();\n    double rval = rValObj.doubleValue();\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n        Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -15,8 +15,8 @@\n     if (rValObj == null) {\n         return null;\n     }\n-    double lval = lValObj;\n-    double rval = rValObj;\n+    double lval = lValObj.doubleValue();\n+    double rval = rValObj.doubleValue();\n     switch(opType) {\n         case Token.BITAND:\n             result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n@@ -55,9 +55,10 @@\n     }\n     // TODO(johnlenz): consider removing the result length check.\n     // length of the left and right value plus 1 byte for the operator.\n-    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n+    // Do not try to fold arithmetic for numbers > 2^53. After that\n     // point, fixed-point math starts to break down and become inaccurate.\n-    Math.abs(result) <= MAX_FOLD_NUMBER) {\n+    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n+        Math.abs(result) <= MAX_FOLD_NUMBER) {\n         Node newNumber = Node.newNumber(result);\n         return newNumber;\n     } else if (Double.isNaN(result)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                warnings.add(DiagnosticType.warning(\"JSC_DIVIDE_BY_0_WARNING\", \"Divide by 0\"), right); // changed from error to warning\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                warnings.add(DiagnosticType.warning(\"JSC_DIVIDE_BY_0_WARNING\", \"Divide by 0\"), right); // changed from error to warning\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -38,14 +38,14 @@\n             break;\n         case Token.MOD:\n             if (rval == 0) {\n-                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+                warnings.add(DiagnosticType.warning(\"JSC_DIVIDE_BY_0_WARNING\", \"Divide by 0\"), right); // changed from error to warning\n                 return null;\n             }\n             result = lval % rval;\n             break;\n         case Token.DIV:\n             if (rval == 0) {\n-                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+                warnings.add(DiagnosticType.warning(\"JSC_DIVIDE_BY_0_WARNING\", \"Divide by 0\"), right); // changed from error to warning\n                 return null;\n             }\n             result = lval / rval;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        if (left.isNull()) {\n            return right;\n        } else if (right.isNull()) {\n            return left;\n        } else {\n            return null;\n        }\n    }\n    double result;\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && // Do not try to fold arithmetic for numbers > 2^53. After that\n    // point, fixed-point math starts to break down and become inaccurate.\n    Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@performArithmeticOp\n@@ -2,7 +2,13 @@\n     // Unlike other operations, ADD operands are not always converted\n     // to Number.\n     if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n-        return null;\n+        if (left.isNull()) {\n+            return right;\n+        } else if (right.isNull()) {\n+            return left;\n+        } else {\n+            return null;\n+        }\n     }\n     double result;\n     // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n", "finish_reason": "stop", "valid": false, "num": 1}]