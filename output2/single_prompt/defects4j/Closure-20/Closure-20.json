[{"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            if (value.isImmutable()) {  // ensure that value is immutable before folding\n                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,10 +10,12 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n-            reportCodeChange();\n-            return addition;\n+            if (value.isImmutable()) {  // ensure that value is immutable before folding\n+                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+                n.getParent().replaceChild(n, addition);\n+                reportCodeChange();\n+                return addition;\n+            }\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            if (value.isImmutable()) {\n                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,10 +10,12 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n-            reportCodeChange();\n-            return addition;\n+            if (value.isImmutable()) {\n+                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+                n.getParent().replaceChild(n, addition);\n+                reportCodeChange();\n+                return addition;\n+            }\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": false, "num": 4}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            if (value.isImmutable()) { // Check if value is immutable before folding\n                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,10 +10,12 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n-            reportCodeChange();\n-            return addition;\n+            if (value.isImmutable()) { // Check if value is immutable before folding\n+                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+                n.getParent().replaceChild(n, addition);\n+                reportCodeChange();\n+                return addition;\n+            }\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        Node value = callTarget.getNext();\n        if (value != null) {\n            if (value.isImmutable()) { // Add a check for immutable values\n                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -2,18 +2,14 @@\n     Preconditions.checkState(n.isCall());\n     Node callTarget = n.getFirstChild();\n     if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n-        // Fold String(a) to '' + (a) on immutable literals,\n-        // which allows further optimizations\n-        //\n-        // We can't do this in the general case, because String(a) has\n-        // slightly different semantics than '' + (a). See\n-        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n-            reportCodeChange();\n-            return addition;\n+            if (value.isImmutable()) { // Add a check for immutable values\n+                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+                n.getParent().replaceChild(n, addition);\n+                reportCodeChange();\n+                return addition;\n+            }\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            Node addition;\n            if (value.isImmutable()) {\n                // If the value is immutable, use IR.string instead of creating a new string node.\n                addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n            } else {\n                addition = IR.add(IR.string(\"\").srcref(callTarget), IR.string(value.toString()).srcref(value));\n            }\n            n.getParent().replaceChild(n, addition);\n            reportCodeChange();\n            return addition;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,7 +10,13 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+            Node addition;\n+            if (value.isImmutable()) {\n+                // If the value is immutable, use IR.string instead of creating a new string node.\n+                addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+            } else {\n+                addition = IR.add(IR.string(\"\").srcref(callTarget), IR.string(value.toString()).srcref(value));\n+            }\n             n.getParent().replaceChild(n, addition);\n             reportCodeChange();\n             return addition;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            // Check if the value is an immutable or a primitive type\n            boolean isImmutableOrPrimitive = (value.isImmutable() || NodeUtil.isImmutableValue(value));\n            if (isImmutableOrPrimitive) {\n                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,10 +10,14 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n-            reportCodeChange();\n-            return addition;\n+            // Check if the value is an immutable or a primitive type\n+            boolean isImmutableOrPrimitive = (value.isImmutable() || NodeUtil.isImmutableValue(value));\n+            if (isImmutableOrPrimitive) {\n+                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+                n.getParent().replaceChild(n, addition);\n+                reportCodeChange();\n+                return addition;\n+            }\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            if (value.isImmutable()) { // added check for immutability\n                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,10 +10,12 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n-            reportCodeChange();\n-            return addition;\n+            if (value.isImmutable()) { // added check for immutability\n+                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+                n.getParent().replaceChild(n, addition);\n+                reportCodeChange();\n+                return addition;\n+            }\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Check if String(a) has only one argument\n        Node value = callTarget.getNext();\n        if (value != null && value.getNext() == null) {\n            // Fold String(a) to '' + (a) on immutable literals,\n            // which allows further optimizations\n            //\n            // We can't do this in the general case, because String(a) has\n            // slightly different semantics than '' + (a). See\n            // http://code.google.com/p/closure-compiler/issues/detail?id=759\n            if (NodeUtil.isImmutableValue(value)) {\n                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -2,18 +2,21 @@\n     Preconditions.checkState(n.isCall());\n     Node callTarget = n.getFirstChild();\n     if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n-        // Fold String(a) to '' + (a) on immutable literals,\n-        // which allows further optimizations\n-        //\n-        // We can't do this in the general case, because String(a) has\n-        // slightly different semantics than '' + (a). See\n-        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n+        // Check if String(a) has only one argument\n         Node value = callTarget.getNext();\n-        if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n-            reportCodeChange();\n-            return addition;\n+        if (value != null && value.getNext() == null) {\n+            // Fold String(a) to '' + (a) on immutable literals,\n+            // which allows further optimizations\n+            //\n+            // We can't do this in the general case, because String(a) has\n+            // slightly different semantics than '' + (a). See\n+            // http://code.google.com/p/closure-compiler/issues/detail?id=759\n+            if (NodeUtil.isImmutableValue(value)) {\n+                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+                n.getParent().replaceChild(n, addition);\n+                reportCodeChange();\n+                return addition;\n+            }\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": true, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            boolean isImmutable = NodeUtil.isImmutableValue(value);\n            if (isImmutable) {\n                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,10 +10,13 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n-            reportCodeChange();\n-            return addition;\n+            boolean isImmutable = NodeUtil.isImmutableValue(value);\n+            if (isImmutable) {\n+                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+                n.getParent().replaceChild(n, addition);\n+                reportCodeChange();\n+                return addition;\n+            }\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            // Check if the value is mutable\n            if (value.isMutable()) {\n                // Clone the value to make it immutable\n                value = value.cloneTree();\n                value.setImmutable();\n            }\n            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n            n.getParent().replaceChild(n, addition);\n            reportCodeChange();\n            return addition;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,6 +10,12 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n+            // Check if the value is mutable\n+            if (value.isMutable()) {\n+                // Clone the value to make it immutable\n+                value = value.cloneTree();\n+                value.setImmutable();\n+            }\n             Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n             n.getParent().replaceChild(n, addition);\n             reportCodeChange();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null && NodeUtil.isImmutableValue(value)) {\n            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n            n.getParent().replaceChild(n, addition);\n            reportCodeChange();\n            return addition;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -9,7 +9,7 @@\n         // slightly different semantics than '' + (a). See\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n-        if (value != null) {\n+        if (value != null && NodeUtil.isImmutableValue(value)) {\n             Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n             n.getParent().replaceChild(n, addition);\n             reportCodeChange();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            if (value.isImmutable()) { // Check if value is immutable\n                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,10 +10,12 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n-            reportCodeChange();\n-            return addition;\n+            if (value.isImmutable()) { // Check if value is immutable\n+                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+                n.getParent().replaceChild(n, addition);\n+                reportCodeChange();\n+                return addition;\n+            }\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n            n.replaceWith(addition); // replace n instead of n.getParent().replaceChild(n, addition);\n            reportCodeChange();\n            return addition;\n        } else {\n            n.replaceWith(IR.string(\"\").srcref(callTarget));\n            reportCodeChange();\n            return n;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -11,9 +11,13 @@\n         Node value = callTarget.getNext();\n         if (value != null) {\n             Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n+            n.replaceWith(addition); // replace n instead of n.getParent().replaceChild(n, addition);\n             reportCodeChange();\n             return addition;\n+        } else {\n+            n.replaceWith(IR.string(\"\").srcref(callTarget));\n+            reportCodeChange();\n+            return n;\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            Node addition = IR.add(IR.string(\"\").srcref(callTarget.getSourceFileName(), callTarget.getLineno(), callTarget.getCharno()), value.detachFromParent());\n            n.getParent().replaceChild(n, addition);\n            reportCodeChange();\n            return addition;\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,7 +10,7 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+            Node addition = IR.add(IR.string(\"\").srcref(callTarget.getSourceFileName(), callTarget.getLineno(), callTarget.getCharno()), value.detachFromParent());\n             n.getParent().replaceChild(n, addition);\n             reportCodeChange();\n             return addition;\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            if (value.isImmutable()) { // Fixed by adding this if statement\n                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,10 +10,12 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n-            reportCodeChange();\n-            return addition;\n+            if (value.isImmutable()) { // Fixed by adding this if statement\n+                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+                n.getParent().replaceChild(n, addition);\n+                reportCodeChange();\n+                return addition;\n+            }\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null) {\n            if (value.isImmutable()) { // check if the value is immutable\n                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n+++ com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java@tryFoldSimpleFunctionCall\n@@ -10,10 +10,12 @@\n         // http://code.google.com/p/closure-compiler/issues/detail?id=759\n         Node value = callTarget.getNext();\n         if (value != null) {\n-            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n-            n.getParent().replaceChild(n, addition);\n-            reportCodeChange();\n-            return addition;\n+            if (value.isImmutable()) { // check if the value is immutable\n+                Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\n+                n.getParent().replaceChild(n, addition);\n+                reportCodeChange();\n+                return addition;\n+            }\n         }\n     }\n     return n;\n", "finish_reason": "stop", "valid": false, "num": 1}]