[{"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            if (NodeUtil.isNameDeclaration(c)) {\n                String name = c.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                if (NodeUtil.isFunctionDeclaration(n)) {\n                    String name = n.getFirstChild().getString();\n                    if (name != null && !name.isEmpty()) {\n                        renamer.addDeclaredName(name);\n                    }\n                }\n                // Add the function parameters\n                if (n.hasChildren()) {\n                    Node paramList = n.getFirstChild().getNext();\n                    for (Node p : paramList.children()) {\n                        String paramName = p.getString();\n                        renamer.addDeclaredName(paramName);\n                    }\n                }\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,12 +13,14 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (NodeUtil.isNameDeclaration(c)) {\n+                String name = c.getFirstChild().getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (NodeUtil.isNameDeclaration(c)) {\n+                String name = c.getFirstChild().getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (NodeUtil.isNameDeclaration(c)) {\n+                String name = c.getFirstChild().getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        // Check for anonymous functions and assign a unique name.\n        if (declarationRoot.getFirstChild().isEmpty()) {\n            String functionName = String.format(\"__anonymous_%s\", anonymousFunctionCounter);\n            anonymousFunctionCounter++;\n            declarationRoot.getFirstChild().setString(functionName);\n        }\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                for (Node c = n.getFirstChild().getNext(); c != null; c = c.getNext()) {\n                    String paramName = c.getString();\n                    renamer.addDeclaredName(paramName);\n                }\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            nameStack.pop();\n            // Remove function recursive name (if any).\n            Node functionNode = n.getFirstChild();\n            String functionName = functionNode.getString();\n            if (functionName.startsWith(\"__anonymous_\")) {\n                anonymousFunctionCounter--;\n            }\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,6 +12,12 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n+        // Check for anonymous functions and assign a unique name.\n+        if (declarationRoot.getFirstChild().isEmpty()) {\n+            String functionName = String.format(\"__anonymous_%s\", anonymousFunctionCounter);\n+            anonymousFunctionCounter++;\n+            declarationRoot.getFirstChild().setString(functionName);\n+        }\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n             String name = c.getString();\n             renamer.addDeclaredName(name);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,32 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        // Check for anonymous functions and assign a unique name.\n+        if (declarationRoot.getFirstChild().isEmpty()) {\n+            String functionName = String.format(\"__anonymous_%s\", anonymousFunctionCounter);\n+            anonymousFunctionCounter++;\n+            declarationRoot.getFirstChild().setString(functionName);\n+        }\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,32 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        // Check for anonymous functions and assign a unique name.\n+        if (declarationRoot.getFirstChild().isEmpty()) {\n+            String functionName = String.format(\"__anonymous_%s\", anonymousFunctionCounter);\n+            anonymousFunctionCounter++;\n+            declarationRoot.getFirstChild().setString(functionName);\n+        }\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            if (c.getType() == Token.NAME) {\n              String name = c.getString();\n              renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && (parent == null || !NodeUtil.isFunctionDeclaration(n))) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                Node paramList = n.getChildAtIndex(1);\n                for (Node c = paramList.getFirstChild(); c != null; c = c.getNext()) {\n                  String paramName = c.getString();\n                  renamer.addParamName(paramName);\n                }\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,8 +13,10 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (c.getType() == Token.NAME) {\n+              String name = c.getString();\n+              renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.NAME) {\n+              String name = c.getString();\n+              renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.NAME) {\n+              String name = c.getString();\n+              renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        if (!t.getInput().isExtern()) { // Fix: Only global scope should use rootRenamer.\n            Preconditions.checkState(t.inGlobalScope());\n            renamer = rootRenamer;\n        } else {\n            renamer = new Renamer(t.getCompiler(), false, false);\n        }\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                // Add the function body declarations\n                findDeclaredNames(n.getLastChild(), null, renamer); // Fix: Add function parameters and body declarations.\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            nameStack.peek().clearBlockScopedDeclarations(); // Fix: Clear block-scoped declarations after removing function body scope.\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -6,8 +6,12 @@\n         // If the contextual renamer is being used the starting context can not\n         // be a function.\n         Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n-        Preconditions.checkState(t.inGlobalScope());\n-        renamer = rootRenamer;\n+        if (!t.getInput().isExtern()) { // Fix: Only global scope should use rootRenamer.\n+            Preconditions.checkState(t.inGlobalScope());\n+            renamer = rootRenamer;\n+        } else {\n+            renamer = new Renamer(t.getCompiler(), false, false);\n+        }\n     } else {\n         renamer = nameStack.peek().forChildScope();\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,30 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        if (!t.getInput().isExtern()) { // Fix: Only global scope should use rootRenamer.\n+            Preconditions.checkState(t.inGlobalScope());\n+            renamer = rootRenamer;\n+        } else {\n+            renamer = new Renamer(t.getCompiler(), false, false);\n+        }\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,30 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        if (!t.getInput().isExtern()) { // Fix: Only global scope should use rootRenamer.\n+            Preconditions.checkState(t.inGlobalScope());\n+            renamer = rootRenamer;\n+        } else {\n+            renamer = new Renamer(t.getCompiler(), false, false);\n+        }\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            if (c.getType() == Token.NAME) {\n                String name = c.getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                Node functionNode = NodeUtil.getEnclosingFunction(n);\n                if (functionNode != null) {\n                    String name = functionNode.getFirstChild().getString();\n                    if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                        renamer.addDeclaredName(name);\n                    }\n                }\n                // Add the function parameters\n                Node functionParent = n.getParent();\n                Renamer functionRenamer = new Renamer(renamer);\n                functionRenamer.inherit = true;\n                Node params = n.getFirstChild().getNext();\n                for (Node child : params.children()) {\n                    if (child.getType() == Token.NAME) {\n                        String name = child.getString();\n                        functionRenamer.addDeclaredName(name);\n                    }\n                }\n                // Add the function body declarations\n                nameStack.push(functionRenamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,8 +13,10 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (c.getType() == Token.NAME) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.NAME) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.NAME) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            if (c.getType() == Token.NAME) { // Only add declared names if they are NAME tokens\n                String name = c.getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else { // Removed unnecessary check for Token.FUNCTION type\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                if (NodeUtil.isFunctionDeclaration(n)) { // Only add declared names if it's a function declaration\n                    String name = n.getFirstChild().getString();\n                    if (name != null && !name.isEmpty()) {\n                        renamer.addDeclaredName(name);\n                    }\n                }\n                // Add the function parameters\n                for (Node parameter = n.getSecondChild(); parameter != null; parameter = parameter.getNext()) {\n                    if (parameter.getType() == Token.NAME) { // Only add parameter names if they are NAME tokens\n                        String name = parameter.getString();\n                        renamer.addDeclaredName(name);\n                    }\n                }\n                // Add the function body declarations\n                findDeclaredNames(n.getLastChild(), null, renamer);\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n\n            // Pop the parameter names from the scope\n            for (Node parameter = n.getSecondChild(); parameter != null; parameter = parameter.getNext()) {\n                if (parameter.getType() == Token.NAME) { // Only remove parameter names if they are NAME tokens\n                    nameStack.pop();\n                }\n            }\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,12 +13,14 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (c.getType() == Token.NAME) { // Only add declared names if they are NAME tokens\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else { // Removed unnecessary check for Token.FUNCTION type\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.NAME) { // Only add declared names if they are NAME tokens\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else { // Removed unnecessary check for Token.FUNCTION type\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.NAME) { // Only add declared names if they are NAME tokens\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else { // Removed unnecessary check for Token.FUNCTION type\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            if (name != null && !name.isEmpty()) {\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                Node paramList = n.getFirstChild().getNext();\n                for (Node c = paramList.getFirstChild(); c != null; c = c.getNext()) {\n                    String paramName = c.getString();\n                    if (paramName != null && !paramName.isEmpty()) {\n                        renamer.addDeclaredName(paramName);\n                    }\n                }\n                // Add the function body declarations\n                findDeclaredNames(n.getLastChild(), null, renamer);\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty()) {\n                    renamer.addDeclaredName(name);\n                }\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -14,11 +14,13 @@\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n             String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (name != null && !name.isEmpty()) {\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            if (name != null && !name.isEmpty()) {\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            if (name != null && !name.isEmpty()) {\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        if (functionBody != null) {\n            findDeclaredNames(functionBody, null, renamer);\n        }\n    } else if (!NodeUtil.isControlStructure(declarationRoot) && !NodeUtil.isStatementBlock(declarationRoot)) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                Node nameNode = n.getFirstChild();\n                if (NodeUtil.isNameDeclaration(nameNode)) {\n                    String name = nameNode.getString();\n                    if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                        renamer.addDeclaredName(name);\n                    }\n                }\n                // Add the function parameters\n                Node functionArgs = nameNode.getNext();\n                if (functionArgs != null) {\n                    for (Node arg : functionArgs.children()) {\n                        renamer.addDeclaredName(arg.getString());\n                    }\n                }\n                // Add the function body declarations\n                if (n.getLastChild() != null) {\n                    findDeclaredNames(n.getLastChild(), null, renamer);\n                }\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -17,8 +17,10 @@\n             renamer.addDeclaredName(name);\n         }\n         Node functionBody = declarationRoot.getLastChild();\n-        findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        if (functionBody != null) {\n+            findDeclaredNames(functionBody, null, renamer);\n+        }\n+    } else if (!NodeUtil.isControlStructure(declarationRoot) && !NodeUtil.isStatementBlock(declarationRoot)) {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        if (functionBody != null) {\n+            findDeclaredNames(functionBody, null, renamer);\n+        }\n+    } else if (!NodeUtil.isControlStructure(declarationRoot) && !NodeUtil.isStatementBlock(declarationRoot)) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        if (functionBody != null) {\n+            findDeclaredNames(functionBody, null, renamer);\n+        }\n+    } else if (!NodeUtil.isControlStructure(declarationRoot) && !NodeUtil.isStatementBlock(declarationRoot)) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && NodeUtil.isFunctionExpression(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                Node functionArgs = n.getSecondChild();\n                while (functionArgs != null) {\n                    if (functionArgs.getType() == Token.NAME) {\n                        renamer.addDeclaredName(functionArgs.getString());\n                    }\n                    functionArgs = functionArgs.getNext();\n                }\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop().stripCurrentScope();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,12 +12,12 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n             String name = c.getString();\n             renamer.addDeclaredName(name);\n         }\n-        Node functionBody = declarationRoot.getLastChild();\n-        findDeclaredNames(functionBody, null, renamer);\n     } else if (declarationRoot.getType() != Token.FUNCTION) {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,26 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,26 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        Node nameNode = declarationRoot.getFirstChild();\n        if (nameNode.getToken() == Token.NAME) {\n            renamer.addDeclaredName(nameNode.getString());\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                Node nameNode = n.getFirstChild();\n                if (nameNode != null && nameNode.getToken() == Token.NAME && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(nameNode.getString());\n                }\n                // Add the function parameters\n                if (n.hasChildren()) {\n                    Node parameterList = n.getFirstChild().getNext();\n                    for (Node param = parameterList.getFirstChild(); param != null; param = param.getNext()) {\n                        if (param.getToken() == Token.NAME) {\n                            renamer.addDeclaredName(param.getString());\n                        }\n                    }\n                }\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                Node nameNode = n.getFirstChild();\n                if (nameNode.getToken() == Token.NAME) {\n                    renamer.addDeclaredName(nameNode.getString());\n                }\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,13 +12,13 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+        Node nameNode = declarationRoot.getFirstChild();\n+        if (nameNode.getToken() == Token.NAME) {\n+            renamer.addDeclaredName(nameNode.getString());\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,26 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        Node nameNode = declarationRoot.getFirstChild();\n+        if (nameNode.getToken() == Token.NAME) {\n+            renamer.addDeclaredName(nameNode.getString());\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,26 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        Node nameNode = declarationRoot.getFirstChild();\n+        if (nameNode.getToken() == Token.NAME) {\n+            renamer.addDeclaredName(nameNode.getString());\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        Node functionNameNode = declarationRoot.getFirstChild();\n        String functionName = functionNameNode.getString();\n        Node functionParametersNode = functionNameNode.getNext();\n        for (Node c = functionParametersNode.getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n        if (functionName != null && !functionName.isEmpty()) {\n            renamer.addDeclaredName(functionName);\n        }\n    } else {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                Node functionNameNode = n.getFirstChild();\n                String functionName = functionNameNode.getString();\n                Node functionParametersNode = functionNameNode.getNext();\n                for (Node c = functionParametersNode.getFirstChild(); c != null; c = c.getNext()) {\n                    String name = c.getString();\n                    renamer.addDeclaredName(name);\n                }\n                Node functionBody = n.getLastChild();\n                findDeclaredNames(functionBody, null, renamer);\n                if (functionName != null && !functionName.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(functionName);\n                }\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,13 +12,19 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+        Node functionNameNode = declarationRoot.getFirstChild();\n+        String functionName = functionNameNode.getString();\n+        Node functionParametersNode = functionNameNode.getNext();\n+        for (Node c = functionParametersNode.getFirstChild(); c != null; c = c.getNext()) {\n             String name = c.getString();\n             renamer.addDeclaredName(name);\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        if (functionName != null && !functionName.isEmpty()) {\n+            renamer.addDeclaredName(functionName);\n+        }\n+    } else {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,32 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        Node functionNameNode = declarationRoot.getFirstChild();\n+        String functionName = functionNameNode.getString();\n+        Node functionParametersNode = functionNameNode.getNext();\n+        for (Node c = functionParametersNode.getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+        if (functionName != null && !functionName.isEmpty()) {\n+            renamer.addDeclaredName(functionName);\n+        }\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,32 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        Node functionNameNode = declarationRoot.getFirstChild();\n+        String functionName = functionNameNode.getString();\n+        Node functionParametersNode = functionNameNode.getNext();\n+        for (Node c = functionParametersNode.getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+        if (functionName != null && !functionName.isEmpty()) {\n+            renamer.addDeclaredName(functionName);\n+        }\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            if (NodeUtil.isNameDeclaration(c.getParent()) && c.hasChildren()) {\n                renamer.addDeclaredName(name);\n            } else {\n                renamer.addReferencedName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                Node params = n.getSecondChild();\n                while (params != null) {\n                    String paramName = params.getString();\n                    renamer.addDeclaredName(paramName);\n                    params = params.getNext();\n                }\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -14,7 +14,11 @@\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n             String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (NodeUtil.isNameDeclaration(c.getParent()) && c.hasChildren()) {\n+                renamer.addDeclaredName(name);\n+            } else {\n+                renamer.addReferencedName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,30 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            if (NodeUtil.isNameDeclaration(c.getParent()) && c.hasChildren()) {\n+                renamer.addDeclaredName(name);\n+            } else {\n+                renamer.addReferencedName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,30 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            if (NodeUtil.isNameDeclaration(c.getParent()) && c.hasChildren()) {\n+                renamer.addDeclaredName(name);\n+            } else {\n+                renamer.addReferencedName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n            if (c.getType() == Token.PARAM_LIST) {\n                for (Node param = c.getFirstChild(); param != null; param = param.getNext()) {\n                    String name = param.getString();\n                    renamer.addDeclaredName(name);\n                }\n            } else if (c.getType() == Token.BLOCK) {\n                findDeclaredNames(c, null, renamer);\n            }\n        }\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && NodeUtil.isFunctionExpression(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                for (Node param : n.getFirstChild().getNext().children()) {\n                    renamer.addDeclaredName(param.getString());\n                }\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            nameStack.pop();\n            // Remove function recursive name (if any).\n            if (NodeUtil.isFunctionExpression(n)) {\n                nameStack.peek().removeDeclaredName(n.getFirstChild().getString());\n            }\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,12 +12,16 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.PARAM_LIST) {\n+                for (Node param = c.getFirstChild(); param != null; param = param.getNext()) {\n+                    String name = param.getString();\n+                    renamer.addDeclaredName(name);\n+                }\n+            } else if (c.getType() == Token.BLOCK) {\n+                findDeclaredNames(c, null, renamer);\n+            }\n         }\n-        Node functionBody = declarationRoot.getLastChild();\n-        findDeclaredNames(functionBody, null, renamer);\n     } else if (declarationRoot.getType() != Token.FUNCTION) {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,30 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.PARAM_LIST) {\n+                for (Node param = c.getFirstChild(); param != null; param = param.getNext()) {\n+                    String name = param.getString();\n                     renamer.addDeclaredName(name);\n                 }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+            } else if (c.getType() == Token.BLOCK) {\n+                findDeclaredNames(c, null, renamer);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,30 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.PARAM_LIST) {\n+                for (Node param = c.getFirstChild(); param != null; param = param.getNext()) {\n+                    String name = param.getString();\n+                    renamer.addDeclaredName(name);\n                 }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+            } else if (c.getType() == Token.BLOCK) {\n+                findDeclaredNames(c, null, renamer);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            if (c.getType() == Token.PARAM_LIST) {\n              for (Node param = c.getFirstChild(); param != null; param = param.getNext()) {\n                String name = param.getString();\n                renamer.addDeclaredName(name);\n              }\n            } else {\n              String name = c.getString();\n              renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                if (n.isFromExterns()) {\n                  String functionName = n.getFirstChild().getString();\n                  renamer.addDeclaredName(functionName);\n                } else if (!NodeUtil.isFunctionDeclaration(n)) {\n                  String functionName = n.getFirstChild().getString();\n                  if (functionName != null && !functionName.isEmpty() && parent != null) {\n                      renamer.addDeclaredName(functionName);\n                  }\n                }\n                // Add the function parameters\n                if (n.getFirstChild().getNext() != null) {\n                  Node paramList = n.getFirstChild().getNext();\n                  for (Node param = paramList.getFirstChild(); param != null; param = param.getNext()) {\n                    String paramName = param.getString();\n                    renamer.addDeclaredName(paramName);\n                  }\n                }\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,8 +13,15 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (c.getType() == Token.PARAM_LIST) {\n+              for (Node param = c.getFirstChild(); param != null; param = param.getNext()) {\n+                String name = param.getString();\n+                renamer.addDeclaredName(name);\n+              }\n+            } else {\n+              String name = c.getString();\n+              renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,33 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.PARAM_LIST) {\n+              for (Node param = c.getFirstChild(); param != null; param = param.getNext()) {\n+                String name = param.getString();\n+                renamer.addDeclaredName(name);\n+              }\n+            } else {\n+              String name = c.getString();\n+              renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,33 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.PARAM_LIST) {\n+              for (Node param = c.getFirstChild(); param != null; param = param.getNext()) {\n+                String name = param.getString();\n+                renamer.addDeclaredName(name);\n+              }\n+            } else {\n+              String name = c.getString();\n+              renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            if (c.isName()) { // Only add names to declared names list\n                String name = c.getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.isBlockScope()) { // Only add block-scoped declarations\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                if (n.isFunction() && n.getFirstChild().isName()) { // Make sure function has a name\n                    String name = n.getFirstChild().getString();\n                    if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                        renamer.addDeclaredName(name);\n                    }\n                }\n                // Add the function parameters\n                Node paramList = n.getSecondChild();\n                for (Node param : paramList.children()) {\n                    if (param.isName()) { // Only add names to declared names list\n                        String paramName = param.getString();\n                        renamer.addDeclaredName(paramName);\n                    }\n                }\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced() && n.getBooleanProp(Node.IS_CONSTANT_NAME)) { // Only remove const prop if replaced and present\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,12 +13,14 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (c.isName()) { // Only add names to declared names list\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else if (declarationRoot.isBlockScope()) { // Only add block-scoped declarations\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) { // Only add names to declared names list\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.isBlockScope()) { // Only add block-scoped declarations\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) { // Only add names to declared names list\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.isBlockScope()) { // Only add block-scoped declarations\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n            if (c.isName()) {\n                String name = c.getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.isBlock() && declarationRoot.getParent().isFunction()) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                Node params = n.getSecondChild();\n                while (params != null) {\n                    if (params.isName()) {\n                        renamer.addDeclaredName(params.getString());\n                    }\n                    params = params.getNext();\n                }\n                // Add the function body declarations\n                Node functionBody = n.getLastChild();\n                findDeclaredNames(functionBody, null, renamer);\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            nameStack.pop();\n            // Remove function recursive name (if any).\n            Node functionName = n.getFirstChild();\n            if (functionName != null && functionName.isName()) {\n                String name = functionName.getString();\n                Renamer renamer = nameStack.peek();\n                renamer.removeDeclaredName(name);\n            }\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,13 +12,15 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else if (declarationRoot.isBlock() && declarationRoot.getParent().isFunction()) {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.isBlock() && declarationRoot.getParent().isFunction()) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.isBlock() && declarationRoot.getParent().isFunction()) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            if(name != null && !name.isEmpty())\n                renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                if (!NodeUtil.isFunctionDeclaration(n)) {\n                    String name = n.getFirstChild().getString();\n                    if (name != null && !name.isEmpty() && parent != null) {\n                        renamer.addDeclaredName(name);\n                    }\n                }\n                // Add the function parameters\n                for (Node c = n.getFirstChild().getNext(); c != null; c = c.getNext()) {\n                    String name = c.getString();\n                    if (name != null && !name.isEmpty()) {\n                        renamer.addDeclaredName(name);\n                    }\n                }\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                if(name != null && !name.isEmpty())\n                    renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -14,11 +14,12 @@\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n             String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if(name != null && !name.isEmpty())\n+                renamer.addDeclaredName(name);\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,27 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            if(name != null && !name.isEmpty())\n                 renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,27 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            if(name != null && !name.isEmpty())\n+                renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n            if (NodeUtil.isFunctionBlock(c)) {\n                for (Node param : NodeUtil.getFunctionParameters(c)) {\n                    String paramName = param.getString();\n                    renamer.addDeclaredName(paramName);\n                }\n                findDeclaredNames(NodeUtil.getFunctionBody(c), null, renamer);\n            } else if (NodeUtil.isFunctionDeclaration(c)) {\n                String name = c.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n    } else {\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}\n\n## Fixed Function 2\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.FUNCTION:\n            {\n                // Add recursive function name, if needed.\n                // NOTE: \"enterScope\" is called after we need to pick up this name.\n                Renamer renamer = nameStack.peek().forChildScope();\n                // If needed, add the function recursive name.\n                String name = n.getFirstChild().getString();\n                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n                    renamer.addDeclaredName(name);\n                }\n                // Add the function parameters\n                for (Node param : NodeUtil.getFunctionParameters(n)) {\n                    String paramName = param.getString();\n                    renamer.addDeclaredName(paramName);\n                }\n                // Add the function body declarations\n                nameStack.push(renamer);\n            }\n            break;\n        case Token.CATCH:\n            {\n                Renamer renamer = nameStack.peek().forChildScope();\n                String name = n.getFirstChild().getString();\n                renamer.addDeclaredName(name);\n                nameStack.push(renamer);\n            }\n            break;\n    }\n    return true;\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n            String newName = getReplacementName(n.getString());\n            if (newName != null) {\n                Renamer renamer = nameStack.peek();\n                if (renamer.stripConstIfReplaced()) {\n                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n                    n.removeProp(Node.IS_CONSTANT_NAME);\n                }\n                n.setString(newName);\n                t.getCompiler().reportCodeChange();\n            }\n            break;\n        case Token.FUNCTION:\n            // Remove the function body scope\n            // Remove function recursive name (if any).\n            nameStack.pop();\n            break;\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        case Token.CATCH:\n            // Remove catch except name from the stack of names.\n            nameStack.pop();\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,14 +12,19 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (NodeUtil.isFunctionBlock(c)) {\n+                for (Node param : NodeUtil.getFunctionParameters(c)) {\n+                    String paramName = param.getString();\n+                    renamer.addDeclaredName(paramName);\n+                }\n+                findDeclaredNames(NodeUtil.getFunctionBody(c), null, renamer);\n+            } else if (NodeUtil.isFunctionDeclaration(c)) {\n+                String name = c.getFirstChild().getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n-        Node functionBody = declarationRoot.getLastChild();\n-        findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n-        // Add the block declarations\n+    } else {\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n     nameStack.push(renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,31 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (NodeUtil.isFunctionBlock(c)) {\n+                for (Node param : NodeUtil.getFunctionParameters(c)) {\n+                    String paramName = param.getString();\n+                    renamer.addDeclaredName(paramName);\n                 }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+                findDeclaredNames(NodeUtil.getFunctionBody(c), null, renamer);\n+            } else if (NodeUtil.isFunctionDeclaration(c)) {\n+                String name = c.getFirstChild().getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+    } else {\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,31 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (NodeUtil.isFunctionBlock(c)) {\n+                for (Node param : NodeUtil.getFunctionParameters(c)) {\n+                    String paramName = param.getString();\n+                    renamer.addDeclaredName(paramName);\n                 }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+                findDeclaredNames(NodeUtil.getFunctionBody(c), null, renamer);\n+            } else if (NodeUtil.isFunctionDeclaration(c)) {\n+                String name = c.getFirstChild().getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+    } else {\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]