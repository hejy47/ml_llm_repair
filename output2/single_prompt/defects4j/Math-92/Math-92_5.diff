--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient
+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient
@@ -11,10 +11,7 @@
     if ((k == 1) || (k == n - 1)) {
         return n;
     }
-    long result = Math.round(binomialCoefficientDouble(n, k));
-    if (result == Long.MAX_VALUE) {
-        throw new ArithmeticException("result too large to represent in a long integer");
-    }
+    long result = 1;
     // Use symmetry for large k
     // We use the formula
     // (n choose k) = n! / (n-k)! / k!
@@ -24,14 +21,21 @@
     // For n <= 61, the naive implementation cannot overflow.
     // For n > 61 but n <= 66, the result cannot overflow,
     // but we must take care not to overflow intermediate values.
-    // We know that (result * i) is divisible by j,
-    // but (result * i) may overflow, so we split j:
-    // Filter out the gcd, d, so j/d and i/d are integer.
-    // result is divisible by (j/d) because (j/d)
-    // is relative prime to (i/d) and is a divisor of
-    // result * (i/d).
-    // For n > 66, a result overflow might occur, so we check
-    // the multiplication, taking care to not overflow
-    // unnecessary.
+    if (n <= 66) {
+        int i = n - k + 1;
+        for (int j = 1; j <= k; j++) {
+            result = result * i / j;
+            i++;
+        }
+    } else {
+        // For n > 66, a result overflow might occur, so we use a
+        // different formula: (n choose k) = exp(lgamma(n+1) - lgamma(k+1) - lgamma(n-k+1)),
+        // where lgamma is the logarithm of the gamma function.
+        double logResult = binomialCoefficientLog(n, k);
+        if (logResult > Math.log(Long.MAX_VALUE)) {
+            throw new ArithmeticException("result too large to represent in a long integer");
+        }
+        result = Math.round(Math.exp(logResult));
+    }
     return result;
 }
--- org/apache/commons/math/util/MathUtils.java@binomialCoefficientLog
+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficientLog
@@ -11,7 +11,7 @@
     if ((k == 1) || (k == n - 1)) {
         return Math.log((double) n);
     }
-                double logSum = 0;
+    double logSum = 0;
     // n!/k!
     for (int i = k + 1; i <= n; i++) {
         logSum += Math.log((double) i);
