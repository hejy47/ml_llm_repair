--- com/google/javascript/jscomp/parsing/IRFactory.java@processForInLoop
+++ com/google/javascript/jscomp/parsing/IRFactory.java@processForInLoop
@@ -1,5 +1,32 @@
 @Override
 Node processForInLoop(ForInLoop loopNode) {
-    // Return the bare minimum to put the AST in a valid state.
-    return newNode(Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody()));
+    // Fix for https://github.com/google/closure-compiler/issues/3050
+    // When processing a ForInLoop, we need to check for destructuring patterns,
+    // which are represented by a Node of type DESTRUCTURING_LHS, instead of a Node
+    // of type NAME.
+    Node lhsNode = loopNode.getIterator();
+    Node rhsNode = loopNode.getIteratedObject();
+
+    if (lhsNode.isDestructuringLhs()) {
+        // If the left-hand-side of the for-in loop is a destructuring pattern,
+        // we need to create a new temporary variable and rewrite the lhsNode as
+        // an assignment to the temporary variable.
+        String tmpVarName = createTempVarName();
+        Node varNode = IR.var(IR.name(tmpVarName));
+        Node assignNode = IR.assign(lhsNode, IR.name(tmpVarName));
+
+        // Create a new ForOf loop that iterates over the iterated object and assigns
+        // each value to the temporary variable.
+        Node forOfLoop = IR.forOf(assignNode, rhsNode, transformBlock(loopNode.getBody()));
+
+        // Prepend the tempVar declaration to the forOfLoop body.
+        Node tempVarDeclaration = IR.exprResult(IR.assign(IR.name(tmpVarName), IR.nullNode()));
+        forOfLoop.getLastChild().addChildToFront(tempVarDeclaration);
+
+        return transform(varNode, forOfLoop);
+    } else {
+        // If the left-hand-side is not a destructuring pattern, simply transform the
+        // loop as before.
+        return newNode(Token.FOR, transform(lhsNode), transform(rhsNode), transformBlock(loopNode.getBody()));
+    }
 }
