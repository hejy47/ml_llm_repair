[{"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        // If we are in a function and have reached the last statement, return the parent node\n        if (parent != null && parent.isFunction() && parent.getLastChild() == node) {\n            return parent;\n        }\n        return null;\n    }\n    switch(parent.getType()) {\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,17 +1,17 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n+        // If we are in a function and have reached the last statement, return the parent node\n+        if (parent != null && parent.isFunction() && parent.getLastChild() == node) {\n+            return parent;\n+        }\n         return null;\n     }\n-    // If we are just before a IF/WHILE/DO/FOR:\n     switch(parent.getType()) {\n-        // The follow() of any of the path from IF would be what follows IF.\n         case Token.IF:\n             return computeFollowNode(fromNode, parent, cfa);\n         case Token.CASE:\n         case Token.DEFAULT_CASE:\n-            // After the body of a CASE, the control goes to the body of the next\n-            // case, without having to go to the case condition.\n             if (parent.getNext() != null) {\n                 if (parent.getNext().isCase()) {\n                     return parent.getNext().getFirstChild().getNext();\n@@ -34,24 +34,18 @@\n         case Token.DO:\n             return parent;\n         case Token.TRY:\n-            // If we are coming out of the TRY block...\n             if (parent.getFirstChild() == node) {\n                 if (NodeUtil.hasFinally(parent)) {\n-                    // and have FINALLY block.\n                     return computeFallThrough(parent.getLastChild());\n                 } else {\n-                    // and have no FINALLY.\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n-                // CATCH block.\n             } else if (NodeUtil.getCatchBlock(parent) == node) {\n                 if (NodeUtil.hasFinally(parent)) {\n-                    // and have FINALLY block.\n                     return computeFallThrough(node.getNext());\n                 } else {\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n-                // If we are coming out of the FINALLY block...\n             } else if (parent.getLastChild() == node) {\n                 if (cfa != null) {\n                     for (Node finallyNode : cfa.finallyMap.get(parent)) {\n@@ -61,17 +55,13 @@\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n     }\n-    // Now that we are done with the special cases follow should be its\n-    // immediate sibling, unless its sibling is a function\n     Node nextSibling = node.getNext();\n-    // Skip function declarations because control doesn't get pass into it.\n     while (nextSibling != null && nextSibling.isFunction()) {\n         nextSibling = nextSibling.getNext();\n     }\n     if (nextSibling != null) {\n         return computeFallThrough(nextSibling);\n     } else {\n-        // If there are no more siblings, control is transferred up the AST.\n         return computeFollowNode(fromNode, parent, cfa);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    switch(parent.getType()) {\n        case Token.IF:\n            // The follow() of any of the path from IF would be what follows IF.\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    // Check if case has any children, get next item\n                    if (parent.getNext().hasChildren()) {\n                        return NodeUtil.getSuccessor(parent.getNext().getLastChild());\n                    } else {\n                        return computeFollowNode(fromNode, parent, cfa);\n                    }\n                } else if (parent.getNext().isDefaultCase()) {\n                    // If default case has any children, get next item\n                    if (parent.getNext().hasChildren()) {\n                        return NodeUtil.getSuccessor(parent.getNext().getFirstChild());\n                    } else {\n                        return computeFollowNode(fromNode, parent, cfa);\n                    }\n                } \n            }\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                // If FOR loop in, get target (second child)\n                return parent.getSecondChild();\n            } else {\n                // If regular FOR loop, get body (third child)\n                return parent.getLastChild();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            // Get the body of the loop\n            return parent.getLastChild();\n        case Token.TRY:\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,12 +1,11 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n-    // If we are just before a IF/WHILE/DO/FOR:\n     switch(parent.getType()) {\n-        // The follow() of any of the path from IF would be what follows IF.\n         case Token.IF:\n+            // The follow() of any of the path from IF would be what follows IF.\n             return computeFollowNode(fromNode, parent, cfa);\n         case Token.CASE:\n         case Token.DEFAULT_CASE:\n@@ -14,27 +13,35 @@\n             // case, without having to go to the case condition.\n             if (parent.getNext() != null) {\n                 if (parent.getNext().isCase()) {\n-                    return parent.getNext().getFirstChild().getNext();\n+                    // Check if case has any children, get next item\n+                    if (parent.getNext().hasChildren()) {\n+                        return NodeUtil.getSuccessor(parent.getNext().getLastChild());\n+                    } else {\n+                        return computeFollowNode(fromNode, parent, cfa);\n+                    }\n                 } else if (parent.getNext().isDefaultCase()) {\n-                    return parent.getNext().getFirstChild();\n-                } else {\n-                    Preconditions.checkState(false, \"Not reachable\");\n-                }\n-            } else {\n-                return computeFollowNode(fromNode, parent, cfa);\n+                    // If default case has any children, get next item\n+                    if (parent.getNext().hasChildren()) {\n+                        return NodeUtil.getSuccessor(parent.getNext().getFirstChild());\n+                    } else {\n+                        return computeFollowNode(fromNode, parent, cfa);\n+                    }\n+                } \n             }\n-            break;\n+            return computeFollowNode(fromNode, parent, cfa);\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n-                return parent;\n+                // If FOR loop in, get target (second child)\n+                return parent.getSecondChild();\n             } else {\n-                return parent.getFirstChild().getNext().getNext();\n+                // If regular FOR loop, get body (third child)\n+                return parent.getLastChild();\n             }\n         case Token.WHILE:\n         case Token.DO:\n-            return parent;\n+            // Get the body of the loop\n+            return parent.getLastChild();\n         case Token.TRY:\n-            // If we are coming out of the TRY block...\n             if (parent.getFirstChild() == node) {\n                 if (NodeUtil.hasFinally(parent)) {\n                     // and have FINALLY block.\n@@ -43,7 +50,6 @@\n                     // and have no FINALLY.\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n-                // CATCH block.\n             } else if (NodeUtil.getCatchBlock(parent) == node) {\n                 if (NodeUtil.hasFinally(parent)) {\n                     // and have FINALLY block.\n@@ -51,7 +57,6 @@\n                 } else {\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n-                // If we are coming out of the FINALLY block...\n             } else if (parent.getLastChild() == node) {\n                 if (cfa != null) {\n                     for (Node finallyNode : cfa.finallyMap.get(parent)) {\n@@ -61,17 +66,13 @@\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n     }\n-    // Now that we are done with the special cases follow should be its\n-    // immediate sibling, unless its sibling is a function\n     Node nextSibling = node.getNext();\n-    // Skip function declarations because control doesn't get pass into it.\n     while (nextSibling != null && nextSibling.isFunction()) {\n         nextSibling = nextSibling.getNext();\n     }\n     if (nextSibling != null) {\n         return computeFallThrough(nextSibling);\n     } else {\n-        // If there are no more siblings, control is transferred up the AST.\n         return computeFollowNode(fromNode, parent, cfa);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    throw new IllegalStateException(\"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                Node condition = parent.getSecondChild().getNext();\n                if (condition != null) {\n                    return condition;\n                } else {\n                    return parent.getFirstChild().getNext().getNext();\n                }\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n              Node finallyBlock = NodeUtil.getFinallyBlock(parent);\n              if (finallyBlock != null) {\n                  return finallyBlock;\n                } else {\n                  Node catchBlock = NodeUtil.getCatchBlock(parent);\n                  if (catchBlock != null) {\n                      return catchBlock.getFirstChild();\n                  } else {\n                      return computeFollowNode(fromNode, parent, cfa);\n                  }\n              }\n              // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                Node finallyBlock = NodeUtil.getFinallyBlock(parent);\n                if (finallyBlock != null) {\n                    return finallyBlock;\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n              // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,5 +1,23 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n@@ -18,17 +36,21 @@\n                 } else if (parent.getNext().isDefaultCase()) {\n                     return parent.getNext().getFirstChild();\n                 } else {\n-                    Preconditions.checkState(false, \"Not reachable\");\n+                    throw new IllegalStateException(\"Not reachable\");\n                 }\n             } else {\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n-            break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n                 return parent;\n             } else {\n-                return parent.getFirstChild().getNext().getNext();\n+                Node condition = parent.getSecondChild().getNext();\n+                if (condition != null) {\n+                    return condition;\n+                } else {\n+                    return parent.getFirstChild().getNext().getNext();\n+                }\n             }\n         case Token.WHILE:\n         case Token.DO:\n@@ -36,22 +58,26 @@\n         case Token.TRY:\n             // If we are coming out of the TRY block...\n             if (parent.getFirstChild() == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n-                    // and have FINALLY block.\n-                    return computeFallThrough(parent.getLastChild());\n+              Node finallyBlock = NodeUtil.getFinallyBlock(parent);\n+              if (finallyBlock != null) {\n+                  return finallyBlock;\n                 } else {\n-                    // and have no FINALLY.\n-                    return computeFollowNode(fromNode, parent, cfa);\n-                }\n-                // CATCH block.\n+                  Node catchBlock = NodeUtil.getCatchBlock(parent);\n+                  if (catchBlock != null) {\n+                      return catchBlock.getFirstChild();\n+                  } else {\n+                      return computeFollowNode(fromNode, parent, cfa);\n+                  }\n+              }\n+              // CATCH block.\n             } else if (NodeUtil.getCatchBlock(parent) == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n-                    // and have FINALLY block.\n-                    return computeFallThrough(node.getNext());\n+                Node finallyBlock = NodeUtil.getFinallyBlock(parent);\n+                if (finallyBlock != null) {\n+                    return finallyBlock;\n                 } else {\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n-                // If we are coming out of the FINALLY block...\n+              // If we are coming out of the FINALLY block...\n             } else if (parent.getLastChild() == node) {\n                 if (cfa != null) {\n                     for (Node finallyNode : cfa.finallyMap.get(parent)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                // Fix 1: changed getFirstChild().getNext() to getSecondChild()\n                return parent.getSecondChild();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,5 +1,23 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n@@ -28,7 +46,8 @@\n             if (NodeUtil.isForIn(parent)) {\n                 return parent;\n             } else {\n-                return parent.getFirstChild().getNext().getNext();\n+                // Fix 1: changed getFirstChild().getNext() to getSecondChild()\n+                return parent.getSecondChild();\n             }\n         case Token.WHILE:\n         case Token.DO:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    throw new IllegalStateException(\"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            // Add default case to switch statement\n        case Token.SWITCH:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,5 +1,23 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n@@ -18,12 +36,14 @@\n                 } else if (parent.getNext().isDefaultCase()) {\n                     return parent.getNext().getFirstChild();\n                 } else {\n-                    Preconditions.checkState(false, \"Not reachable\");\n+                    throw new IllegalStateException(\"Not reachable\");\n                 }\n             } else {\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n-            break;\n+            // Add default case to switch statement\n+        case Token.SWITCH:\n+            return computeFollowNode(fromNode, parent, cfa);\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n                 return parent;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, NodeUtil.getConditionExpression(parent), cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                // For..in loops don't have a condition to follow.\n                return parent.getLastChild();\n            } else {\n                // For loops follow the condition first.\n                // fallthrough\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return NodeUtil.getConditionExpression(parent);\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) {\n                    // and have FINALLY block.\n                    return NodeUtil.getFinallyBlock(parent);\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) {\n                    // and have FINALLY block.\n                    return NodeUtil.getFinallyBlock(parent);\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.getFinallyBlocks(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip over functions and variable declarations.\n    while (nextSibling != null && (NodeUtil.isFunctionDeclaration(nextSibling) || NodeUtil.isNameDeclaration(nextSibling))) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,13 +1,31 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n-    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n+    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n         return null;\n     }\n     // If we are just before a IF/WHILE/DO/FOR:\n     switch(parent.getType()) {\n         // The follow() of any of the path from IF would be what follows IF.\n         case Token.IF:\n-            return computeFollowNode(fromNode, parent, cfa);\n+            return computeFollowNode(fromNode, NodeUtil.getConditionExpression(parent), cfa);\n         case Token.CASE:\n         case Token.DEFAULT_CASE:\n             // After the body of a CASE, the control goes to the body of the next\n@@ -26,35 +44,37 @@\n             break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n-                return parent;\n+                // For..in loops don't have a condition to follow.\n+                return parent.getLastChild();\n             } else {\n-                return parent.getFirstChild().getNext().getNext();\n+                // For loops follow the condition first.\n+                // fallthrough\n             }\n         case Token.WHILE:\n         case Token.DO:\n-            return parent;\n+            return NodeUtil.getConditionExpression(parent);\n         case Token.TRY:\n             // If we are coming out of the TRY block...\n             if (parent.getFirstChild() == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) {\n                     // and have FINALLY block.\n-                    return computeFallThrough(parent.getLastChild());\n+                    return NodeUtil.getFinallyBlock(parent);\n                 } else {\n                     // and have no FINALLY.\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n                 // CATCH block.\n             } else if (NodeUtil.getCatchBlock(parent) == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) {\n                     // and have FINALLY block.\n-                    return computeFallThrough(node.getNext());\n+                    return NodeUtil.getFinallyBlock(parent);\n                 } else {\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n                 // If we are coming out of the FINALLY block...\n             } else if (parent.getLastChild() == node) {\n                 if (cfa != null) {\n-                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n+                    for (Node finallyNode : cfa.getFinallyBlocks(parent)) {\n                         cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                     }\n                 }\n@@ -64,8 +84,8 @@\n     // Now that we are done with the special cases follow should be its\n     // immediate sibling, unless its sibling is a function\n     Node nextSibling = node.getNext();\n-    // Skip function declarations because control doesn't get pass into it.\n-    while (nextSibling != null && nextSibling.isFunction()) {\n+    // Skip over functions and variable declarations.\n+    while (nextSibling != null && (NodeUtil.isFunctionDeclaration(nextSibling) || NodeUtil.isNameDeclaration(nextSibling))) {\n         nextSibling = nextSibling.getNext();\n     }\n     if (nextSibling != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    switch(parent.getType()) {\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    throw new IllegalStateException(\"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                Node update = NodeUtil.getContinueTarget(parent);\n                if (update != null) {\n                    return update;\n                } else {\n                    // If there is no update node in the loop, skip the condition and go\n                    // straight to the body.\n                    return parent.getFirstChild().getNext().getNext();\n                }\n            }\n        case Token.WHILE:\n            return parent;\n        case Token.DO:\n            return parent.getFirstChild();\n        case Token.TRY:\n            if (parent.getFirstChild() == node) {\n                // Coming out of try block\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have finally block\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no finally block\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                // Coming out of catch block\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have finally block\n                    return computeFallThrough(NodeUtil.getFinallyBlock(parent));\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            } else {\n                // Coming out of finally block\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,24 +1,20 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n-    // If we are just before a IF/WHILE/DO/FOR:\n     switch(parent.getType()) {\n-        // The follow() of any of the path from IF would be what follows IF.\n         case Token.IF:\n             return computeFollowNode(fromNode, parent, cfa);\n         case Token.CASE:\n         case Token.DEFAULT_CASE:\n-            // After the body of a CASE, the control goes to the body of the next\n-            // case, without having to go to the case condition.\n             if (parent.getNext() != null) {\n                 if (parent.getNext().isCase()) {\n                     return parent.getNext().getFirstChild().getNext();\n                 } else if (parent.getNext().isDefaultCase()) {\n                     return parent.getNext().getFirstChild();\n                 } else {\n-                    Preconditions.checkState(false, \"Not reachable\");\n+                    throw new IllegalStateException(\"Not reachable\");\n                 }\n             } else {\n                 return computeFollowNode(fromNode, parent, cfa);\n@@ -28,31 +24,39 @@\n             if (NodeUtil.isForIn(parent)) {\n                 return parent;\n             } else {\n-                return parent.getFirstChild().getNext().getNext();\n+                Node update = NodeUtil.getContinueTarget(parent);\n+                if (update != null) {\n+                    return update;\n+                } else {\n+                    // If there is no update node in the loop, skip the condition and go\n+                    // straight to the body.\n+                    return parent.getFirstChild().getNext().getNext();\n+                }\n             }\n         case Token.WHILE:\n+            return parent;\n         case Token.DO:\n-            return parent;\n+            return parent.getFirstChild();\n         case Token.TRY:\n-            // If we are coming out of the TRY block...\n             if (parent.getFirstChild() == node) {\n+                // Coming out of try block\n                 if (NodeUtil.hasFinally(parent)) {\n-                    // and have FINALLY block.\n+                    // and have finally block\n                     return computeFallThrough(parent.getLastChild());\n                 } else {\n-                    // and have no FINALLY.\n+                    // and have no finally block\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n-                // CATCH block.\n             } else if (NodeUtil.getCatchBlock(parent) == node) {\n+                // Coming out of catch block\n                 if (NodeUtil.hasFinally(parent)) {\n-                    // and have FINALLY block.\n-                    return computeFallThrough(node.getNext());\n+                    // and have finally block\n+                    return computeFallThrough(NodeUtil.getFinallyBlock(parent));\n                 } else {\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n-                // If we are coming out of the FINALLY block...\n-            } else if (parent.getLastChild() == node) {\n+            } else {\n+                // Coming out of finally block\n                 if (cfa != null) {\n                     for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                         cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n@@ -61,17 +65,13 @@\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n     }\n-    // Now that we are done with the special cases follow should be its\n-    // immediate sibling, unless its sibling is a function\n     Node nextSibling = node.getNext();\n-    // Skip function declarations because control doesn't get pass into it.\n     while (nextSibling != null && nextSibling.isFunction()) {\n         nextSibling = nextSibling.getNext();\n     }\n     if (nextSibling != null) {\n         return computeFallThrough(nextSibling);\n     } else {\n-        // If there are no more siblings, control is transferred up the AST.\n         return computeFollowNode(fromNode, parent, cfa);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    throw new IllegalStateException(\"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return computeFollowNode(fromNode, parent.getFirstChild().getNext(), cfa);\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,5 +1,23 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n@@ -18,15 +36,14 @@\n                 } else if (parent.getNext().isDefaultCase()) {\n                     return parent.getNext().getFirstChild();\n                 } else {\n-                    Preconditions.checkState(false, \"Not reachable\");\n+                    throw new IllegalStateException(\"Not reachable\");\n                 }\n             } else {\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n-            break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n-                return parent;\n+                return computeFollowNode(fromNode, parent.getFirstChild().getNext(), cfa);\n             } else {\n                 return parent.getFirstChild().getNext().getNext();\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    throw new IllegalStateException(\"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,5 +1,23 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n@@ -18,12 +36,11 @@\n                 } else if (parent.getNext().isDefaultCase()) {\n                     return parent.getNext().getFirstChild();\n                 } else {\n-                    Preconditions.checkState(false, \"Not reachable\");\n+                    throw new IllegalStateException(\"Not reachable\");\n                 }\n             } else {\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n-            break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n                 return parent;\n@@ -60,6 +77,7 @@\n                 }\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n+            break;\n     }\n     // Now that we are done with the special cases follow should be its\n     // immediate sibling, unless its sibling is a function\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    throw new IllegalStateException(\"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                Node cond = parent.getFirstChild().getNext();\n                if (cond != null) {\n                    return cond;\n                }\n                return computeFallThrough(parent.getLastChild());\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,5 +1,23 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n@@ -18,17 +36,20 @@\n                 } else if (parent.getNext().isDefaultCase()) {\n                     return parent.getNext().getFirstChild();\n                 } else {\n-                    Preconditions.checkState(false, \"Not reachable\");\n+                    throw new IllegalStateException(\"Not reachable\");\n                 }\n             } else {\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n-            break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n                 return parent;\n             } else {\n-                return parent.getFirstChild().getNext().getNext();\n+                Node cond = parent.getFirstChild().getNext();\n+                if (cond != null) {\n+                    return cond;\n+                }\n+                return computeFallThrough(parent.getLastChild());\n             }\n         case Token.WHILE:\n         case Token.DO:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.getFinallyMap().get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,6 +1,24 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n-    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n+    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n         return null;\n     }\n     // If we are just before a IF/WHILE/DO/FOR:\n@@ -54,7 +72,7 @@\n                 // If we are coming out of the FINALLY block...\n             } else if (parent.getLastChild() == node) {\n                 if (cfa != null) {\n-                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n+                    for (Node finallyNode : cfa.getFinallyMap().get(parent)) {\n                         cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                     }\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    throw new IllegalStateException(\"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) {\n                    // and have FINALLY block.\n                    return computeReachableNode(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) {\n                    // and have FINALLY block.\n                    return computeReachableNode(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.getFinallyMap(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeReachableNode(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,6 +1,24 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n-    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n+    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n         return null;\n     }\n     // If we are just before a IF/WHILE/DO/FOR:\n@@ -18,12 +36,11 @@\n                 } else if (parent.getNext().isDefaultCase()) {\n                     return parent.getNext().getFirstChild();\n                 } else {\n-                    Preconditions.checkState(false, \"Not reachable\");\n+                    throw new IllegalStateException(\"Not reachable\");\n                 }\n             } else {\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n-            break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n                 return parent;\n@@ -36,25 +53,25 @@\n         case Token.TRY:\n             // If we are coming out of the TRY block...\n             if (parent.getFirstChild() == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) {\n                     // and have FINALLY block.\n-                    return computeFallThrough(parent.getLastChild());\n+                    return computeReachableNode(parent.getLastChild());\n                 } else {\n                     // and have no FINALLY.\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n                 // CATCH block.\n             } else if (NodeUtil.getCatchBlock(parent) == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) {\n                     // and have FINALLY block.\n-                    return computeFallThrough(node.getNext());\n+                    return computeReachableNode(node.getNext());\n                 } else {\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n                 // If we are coming out of the FINALLY block...\n             } else if (parent.getLastChild() == node) {\n                 if (cfa != null) {\n-                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n+                    for (Node finallyNode : cfa.getFinallyMap(parent)) {\n                         cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                     }\n                 }\n@@ -69,7 +86,7 @@\n         nextSibling = nextSibling.getNext();\n     }\n     if (nextSibling != null) {\n-        return computeFallThrough(nextSibling);\n+        return computeReachableNode(nextSibling);\n     } else {\n         // If there are no more siblings, control is transferred up the AST.\n         return computeFollowNode(fromNode, parent, cfa);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    throw new IllegalStateException(\"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.getFinallyMap().get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,6 +1,24 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n-    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n+    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n         return null;\n     }\n     // If we are just before a IF/WHILE/DO/FOR:\n@@ -18,12 +36,11 @@\n                 } else if (parent.getNext().isDefaultCase()) {\n                     return parent.getNext().getFirstChild();\n                 } else {\n-                    Preconditions.checkState(false, \"Not reachable\");\n+                    throw new IllegalStateException(\"Not reachable\");\n                 }\n             } else {\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n-            break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n                 return parent;\n@@ -36,7 +53,7 @@\n         case Token.TRY:\n             // If we are coming out of the TRY block...\n             if (parent.getFirstChild() == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) {\n                     // and have FINALLY block.\n                     return computeFallThrough(parent.getLastChild());\n                 } else {\n@@ -45,7 +62,7 @@\n                 }\n                 // CATCH block.\n             } else if (NodeUtil.getCatchBlock(parent) == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) {\n                     // and have FINALLY block.\n                     return computeFallThrough(node.getNext());\n                 } else {\n@@ -54,7 +71,7 @@\n                 // If we are coming out of the FINALLY block...\n             } else if (parent.getLastChild() == node) {\n                 if (cfa != null) {\n-                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n+                    for (Node finallyNode : cfa.getFinallyMap().get(parent)) {\n                         cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                     }\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    switch(parent.getType()) {\n        case Token.IF:\n            return parent.getNext() != null ? computeFallThrough(parent.getNext()) : computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return computeFallThrough(parent.getLastChild());\n            } else {\n                Node nextStatement = NodeUtil.getNextStatement(parent);\n                return nextStatement != null ? computeFallThrough(nextStatement) : computeFollowNode(fromNode, parent, cfa);\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            Node catchBlock = NodeUtil.getCatchBlock(parent);\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) {\n                    Node finallyBlock = parent.getLastChild();\n                    return finallyBlock.getFirstChild();\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            } else if (catchBlock == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) {\n                    Node finallyBlock = parent.getLastChild();\n                    return finallyBlock.getFirstChild();\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    List<Node> finallyList = cfa.getFinallyBlocksForTry(parent);\n                    if (finallyList != null) {\n                        for (Node finallyNode : finallyList) {\n                            cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                        }\n                        Node nextStatement = NodeUtil.getNextStatement(parent);\n                        return nextStatement != null ? computeFallThrough(nextStatement) : computeFollowNode(fromNode, parent, cfa);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,17 +1,13 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n-    // If we are just before a IF/WHILE/DO/FOR:\n     switch(parent.getType()) {\n-        // The follow() of any of the path from IF would be what follows IF.\n         case Token.IF:\n-            return computeFollowNode(fromNode, parent, cfa);\n+            return parent.getNext() != null ? computeFallThrough(parent.getNext()) : computeFollowNode(fromNode, parent, cfa);\n         case Token.CASE:\n         case Token.DEFAULT_CASE:\n-            // After the body of a CASE, the control goes to the body of the next\n-            // case, without having to go to the case condition.\n             if (parent.getNext() != null) {\n                 if (parent.getNext().isCase()) {\n                     return parent.getNext().getFirstChild().getNext();\n@@ -26,52 +22,49 @@\n             break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n-                return parent;\n+                return computeFallThrough(parent.getLastChild());\n             } else {\n-                return parent.getFirstChild().getNext().getNext();\n+                Node nextStatement = NodeUtil.getNextStatement(parent);\n+                return nextStatement != null ? computeFallThrough(nextStatement) : computeFollowNode(fromNode, parent, cfa);\n             }\n         case Token.WHILE:\n         case Token.DO:\n             return parent;\n         case Token.TRY:\n-            // If we are coming out of the TRY block...\n+            Node catchBlock = NodeUtil.getCatchBlock(parent);\n             if (parent.getFirstChild() == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n-                    // and have FINALLY block.\n-                    return computeFallThrough(parent.getLastChild());\n-                } else {\n-                    // and have no FINALLY.\n-                    return computeFollowNode(fromNode, parent, cfa);\n+                if (NodeUtil.hasFinallyBlock(parent)) {\n+                    Node finallyBlock = parent.getLastChild();\n+                    return finallyBlock.getFirstChild();\n                 }\n-                // CATCH block.\n-            } else if (NodeUtil.getCatchBlock(parent) == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n-                    // and have FINALLY block.\n-                    return computeFallThrough(node.getNext());\n-                } else {\n-                    return computeFollowNode(fromNode, parent, cfa);\n+                return computeFollowNode(fromNode, parent, cfa);\n+            } else if (catchBlock == node) {\n+                if (NodeUtil.hasFinallyBlock(parent)) {\n+                    Node finallyBlock = parent.getLastChild();\n+                    return finallyBlock.getFirstChild();\n                 }\n-                // If we are coming out of the FINALLY block...\n+                return computeFollowNode(fromNode, parent, cfa);\n             } else if (parent.getLastChild() == node) {\n                 if (cfa != null) {\n-                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+                    List<Node> finallyList = cfa.getFinallyBlocksForTry(parent);\n+                    if (finallyList != null) {\n+                        for (Node finallyNode : finallyList) {\n+                            cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+                        }\n+                        Node nextStatement = NodeUtil.getNextStatement(parent);\n+                        return nextStatement != null ? computeFallThrough(nextStatement) : computeFollowNode(fromNode, parent, cfa);\n                     }\n                 }\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n     }\n-    // Now that we are done with the special cases follow should be its\n-    // immediate sibling, unless its sibling is a function\n     Node nextSibling = node.getNext();\n-    // Skip function declarations because control doesn't get pass into it.\n     while (nextSibling != null && nextSibling.isFunction()) {\n         nextSibling = nextSibling.getNext();\n     }\n     if (nextSibling != null) {\n         return computeFallThrough(nextSibling);\n     } else {\n-        // If there are no more siblings, control is transferred up the AST.\n         return computeFollowNode(fromNode, parent, cfa);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    throw new IllegalStateException(\"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else if (NodeUtil.getConditionExpression(parent) != null) { // add check for condition expression\n                return NodeUtil.getConditionExpression(parent); // return condition expression instead of \"parent.getFirstChild().getNext().getNext()\"\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,5 +1,23 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n@@ -18,17 +36,18 @@\n                 } else if (parent.getNext().isDefaultCase()) {\n                     return parent.getNext().getFirstChild();\n                 } else {\n-                    Preconditions.checkState(false, \"Not reachable\");\n+                    throw new IllegalStateException(\"Not reachable\");\n                 }\n             } else {\n                 return computeFollowNode(fromNode, parent, cfa);\n             }\n-            break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n                 return parent;\n+            } else if (NodeUtil.getConditionExpression(parent) != null) { // add check for condition expression\n+                return NodeUtil.getConditionExpression(parent); // return condition expression instead of \"parent.getFirstChild().getNext().getNext()\"\n             } else {\n-                return parent.getFirstChild().getNext().getNext();\n+                return computeFollowNode(fromNode, parent, cfa);\n             }\n         case Token.WHILE:\n         case Token.DO:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    Node caseChild = parent.getNext().getFirstChild();\n                    if (caseChild != null) {\n                        return caseChild.getNext();\n                    } else {\n                        return null;\n                    }\n                } else if (parent.getNext().isDefaultCase()) {\n                    Node defaultChild = parent.getNext().getFirstChild();\n                    if (defaultChild != null) {\n                        return defaultChild.getNext();\n                    } else {\n                        return null;\n                    }\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                    return null; // fix error: add return statement\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                Node firstChild = parent.getFirstChild();\n                if (firstChild != null && firstChild.getNext() != null) {\n                    return firstChild.getNext();\n                } else {\n                    return null;\n                }\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    // and have FINALLY block.\n                    Node nextNode = node.getNext();\n                    if (nextNode != null) {\n                        return nextNode;\n                    } else {\n                        return computeFollowNode(fromNode, parent, cfa);\n                    }\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,5 +1,23 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n@@ -14,11 +32,22 @@\n             // case, without having to go to the case condition.\n             if (parent.getNext() != null) {\n                 if (parent.getNext().isCase()) {\n-                    return parent.getNext().getFirstChild().getNext();\n+                    Node caseChild = parent.getNext().getFirstChild();\n+                    if (caseChild != null) {\n+                        return caseChild.getNext();\n+                    } else {\n+                        return null;\n+                    }\n                 } else if (parent.getNext().isDefaultCase()) {\n-                    return parent.getNext().getFirstChild();\n+                    Node defaultChild = parent.getNext().getFirstChild();\n+                    if (defaultChild != null) {\n+                        return defaultChild.getNext();\n+                    } else {\n+                        return null;\n+                    }\n                 } else {\n                     Preconditions.checkState(false, \"Not reachable\");\n+                    return null; // fix error: add return statement\n                 }\n             } else {\n                 return computeFollowNode(fromNode, parent, cfa);\n@@ -28,7 +57,12 @@\n             if (NodeUtil.isForIn(parent)) {\n                 return parent;\n             } else {\n-                return parent.getFirstChild().getNext().getNext();\n+                Node firstChild = parent.getFirstChild();\n+                if (firstChild != null && firstChild.getNext() != null) {\n+                    return firstChild.getNext();\n+                } else {\n+                    return null;\n+                }\n             }\n         case Token.WHILE:\n         case Token.DO:\n@@ -47,7 +81,12 @@\n             } else if (NodeUtil.getCatchBlock(parent) == node) {\n                 if (NodeUtil.hasFinally(parent)) {\n                     // and have FINALLY block.\n-                    return computeFallThrough(node.getNext());\n+                    Node nextNode = node.getNext();\n+                    if (nextNode != null) {\n+                        return nextNode;\n+                    } else {\n+                        return computeFollowNode(fromNode, parent, cfa);\n+                    }\n                 } else {\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) {\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,6 +1,24 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n-    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n+    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n         return null;\n     }\n     // If we are just before a IF/WHILE/DO/FOR:\n@@ -36,7 +54,7 @@\n         case Token.TRY:\n             // If we are coming out of the TRY block...\n             if (parent.getFirstChild() == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) {\n                     // and have FINALLY block.\n                     return computeFallThrough(parent.getLastChild());\n                 } else {\n@@ -45,7 +63,7 @@\n                 }\n                 // CATCH block.\n             } else if (NodeUtil.getCatchBlock(parent) == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) {\n                     // and have FINALLY block.\n                     return computeFallThrough(node.getNext());\n                 } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) { //use getRoot() instead of root\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) { //use hasFinallyBlock instead of hasFinally\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) { //use hasFinallyBlock instead of hasFinally\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.getFinallyMap().get(parent)) { //use getFinallyMap instead of finallyMap\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,6 +1,24 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n-    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n+    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) { //use getRoot() instead of root\n         return null;\n     }\n     // If we are just before a IF/WHILE/DO/FOR:\n@@ -36,7 +54,7 @@\n         case Token.TRY:\n             // If we are coming out of the TRY block...\n             if (parent.getFirstChild() == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) { //use hasFinallyBlock instead of hasFinally\n                     // and have FINALLY block.\n                     return computeFallThrough(parent.getLastChild());\n                 } else {\n@@ -45,7 +63,7 @@\n                 }\n                 // CATCH block.\n             } else if (NodeUtil.getCatchBlock(parent) == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) { //use hasFinallyBlock instead of hasFinally\n                     // and have FINALLY block.\n                     return computeFallThrough(node.getNext());\n                 } else {\n@@ -54,7 +72,7 @@\n                 // If we are coming out of the FINALLY block...\n             } else if (parent.getLastChild() == node) {\n                 if (cfa != null) {\n-                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n+                    for (Node finallyNode : cfa.getFinallyMap().get(parent)) { //use getFinallyMap instead of finallyMap\n                         cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                     }\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n    switch(parent.getType()) {\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return computeBoundaries(parent.getNext().getFirstChild().getNext());\n                } else if (parent.getNext().isDefaultCase()) {\n                    return computeBoundaries(parent.getNext().getFirstChild());\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else if (NodeUtil.isFor(parent)) {\n                if (node == NodeUtil.getConditionExpression(parent)) {\n                    return computeBoundaries(NodeUtil.getConditionExpression(parent).getFirstChild());\n                } else if (NodeUtil.getIncrementExpression(parent) != null && node == NodeUtil.getIncrementExpression(parent)) {\n                    return computeBoundaries(NodeUtil.getIncrementExpression(parent).getFirstChild());\n                } else {\n                    return computeBoundaries(NodeUtil.getLoopBody(parent));\n                }\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    return computeBoundaries(NodeUtil.getFinallyBlock(parent));\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    return computeBoundaries(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeBoundaries(parent.getNext());\n            }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeBoundaries(nextSibling);\n    } else {\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}\n\n// Added function to compute start and end boundaries of a node.\nprivate static Node computeBoundaries(Node node) {\n    if (node.getFirstChild() != null) {\n        return node.getFirstChild();\n    } else {\n        return node;\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,22 +1,18 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n+    Node parent = node.getParent();\n     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n         return null;\n     }\n-    // If we are just before a IF/WHILE/DO/FOR:\n     switch(parent.getType()) {\n-        // The follow() of any of the path from IF would be what follows IF.\n         case Token.IF:\n             return computeFollowNode(fromNode, parent, cfa);\n         case Token.CASE:\n         case Token.DEFAULT_CASE:\n-            // After the body of a CASE, the control goes to the body of the next\n-            // case, without having to go to the case condition.\n             if (parent.getNext() != null) {\n                 if (parent.getNext().isCase()) {\n-                    return parent.getNext().getFirstChild().getNext();\n+                    return computeBoundaries(parent.getNext().getFirstChild().getNext());\n                 } else if (parent.getNext().isDefaultCase()) {\n-                    return parent.getNext().getFirstChild();\n+                    return computeBoundaries(parent.getNext().getFirstChild());\n                 } else {\n                     Preconditions.checkState(false, \"Not reachable\");\n                 }\n@@ -27,6 +23,14 @@\n         case Token.FOR:\n             if (NodeUtil.isForIn(parent)) {\n                 return parent;\n+            } else if (NodeUtil.isFor(parent)) {\n+                if (node == NodeUtil.getConditionExpression(parent)) {\n+                    return computeBoundaries(NodeUtil.getConditionExpression(parent).getFirstChild());\n+                } else if (NodeUtil.getIncrementExpression(parent) != null && node == NodeUtil.getIncrementExpression(parent)) {\n+                    return computeBoundaries(NodeUtil.getIncrementExpression(parent).getFirstChild());\n+                } else {\n+                    return computeBoundaries(NodeUtil.getLoopBody(parent));\n+                }\n             } else {\n                 return parent.getFirstChild().getNext().getNext();\n             }\n@@ -34,44 +38,34 @@\n         case Token.DO:\n             return parent;\n         case Token.TRY:\n-            // If we are coming out of the TRY block...\n             if (parent.getFirstChild() == node) {\n                 if (NodeUtil.hasFinally(parent)) {\n-                    // and have FINALLY block.\n-                    return computeFallThrough(parent.getLastChild());\n-                } else {\n-                    // and have no FINALLY.\n-                    return computeFollowNode(fromNode, parent, cfa);\n-                }\n-                // CATCH block.\n-            } else if (NodeUtil.getCatchBlock(parent) == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n-                    // and have FINALLY block.\n-                    return computeFallThrough(node.getNext());\n+                    return computeBoundaries(NodeUtil.getFinallyBlock(parent));\n                 } else {\n                     return computeFollowNode(fromNode, parent, cfa);\n                 }\n-                // If we are coming out of the FINALLY block...\n+            } else if (NodeUtil.getCatchBlock(parent) == node) {\n+                if (NodeUtil.hasFinally(parent)) {\n+                    return computeBoundaries(node.getNext());\n+                } else {\n+                    return computeFollowNode(fromNode, parent, cfa);\n+                }\n             } else if (parent.getLastChild() == node) {\n                 if (cfa != null) {\n                     for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                         cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                     }\n                 }\n-                return computeFollowNode(fromNode, parent, cfa);\n+                return computeBoundaries(parent.getNext());\n             }\n     }\n-    // Now that we are done with the special cases follow should be its\n-    // immediate sibling, unless its sibling is a function\n     Node nextSibling = node.getNext();\n-    // Skip function declarations because control doesn't get pass into it.\n     while (nextSibling != null && nextSibling.isFunction()) {\n         nextSibling = nextSibling.getNext();\n     }\n     if (nextSibling != null) {\n-        return computeFallThrough(nextSibling);\n+        return computeBoundaries(nextSibling);\n     } else {\n-        // If there are no more siblings, control is transferred up the AST.\n         return computeFollowNode(fromNode, parent, cfa);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n        return null;\n    }\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch(parent.getType()) {\n        // The follow() of any of the path from IF would be what follows IF.\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            // After the body of a CASE, the control goes to the body of the next\n            // case, without having to go to the case condition.\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                    return parent.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                    return null; // fix: must have a return statement\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return parent.getFirstChild().getNext().getNext();\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            // If we are coming out of the TRY block...\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) { // fix: method name corrected\n                    // and have FINALLY block.\n                    return computeFallThrough(parent.getLastChild());\n                } else {\n                    // and have no FINALLY.\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // CATCH block.\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinallyBlock(parent)) { // fix: method name corrected\n                    // and have FINALLY block.\n                    return computeFallThrough(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n                // If we are coming out of the FINALLY block...\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.getFinallyMap().get(parent)) { // fix: method name corrected\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}", "diff": "--- com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n+++ com/google/javascript/jscomp/ControlFlowAnalysis.java@computeFollowNode\n@@ -1,6 +1,24 @@\n private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-        Node parent = node.getParent();\n-    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n+    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.getRoot())) {\n         return null;\n     }\n     // If we are just before a IF/WHILE/DO/FOR:\n@@ -19,6 +37,7 @@\n                     return parent.getNext().getFirstChild();\n                 } else {\n                     Preconditions.checkState(false, \"Not reachable\");\n+                    return null; // fix: must have a return statement\n                 }\n             } else {\n                 return computeFollowNode(fromNode, parent, cfa);\n@@ -36,7 +55,7 @@\n         case Token.TRY:\n             // If we are coming out of the TRY block...\n             if (parent.getFirstChild() == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) { // fix: method name corrected\n                     // and have FINALLY block.\n                     return computeFallThrough(parent.getLastChild());\n                 } else {\n@@ -45,7 +64,7 @@\n                 }\n                 // CATCH block.\n             } else if (NodeUtil.getCatchBlock(parent) == node) {\n-                if (NodeUtil.hasFinally(parent)) {\n+                if (NodeUtil.hasFinallyBlock(parent)) { // fix: method name corrected\n                     // and have FINALLY block.\n                     return computeFallThrough(node.getNext());\n                 } else {\n@@ -54,7 +73,7 @@\n                 // If we are coming out of the FINALLY block...\n             } else if (parent.getLastChild() == node) {\n                 if (cfa != null) {\n-                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n+                    for (Node finallyNode : cfa.getFinallyMap().get(parent)) { // fix: method name corrected\n                         cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                     }\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}]