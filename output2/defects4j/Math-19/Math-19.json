[{"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // Changed || to &&\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // Changed || to &&\n             hasFiniteBounds = true;\n             break;\n         }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // fixed logical operator\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n            if (boundaries[0] != null) { // added null check\n                for (int i = 0; i < boundaries[0].length; i++) { // corrected index\n                    if ((boundaries[1][i] - boundaries[0][i]) / constants.getNormalization() > Double.MAX_VALUE) { // corrected overflow check\n                        throw new MathIllegalArgumentException(LocalizedFormats.OVERFLOW_IN_COST_EVALUATION);\n                    }\n                }\n            }\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // fixed logical operator\n             hasFiniteBounds = true;\n             break;\n         }\n@@ -29,6 +29,13 @@\n             boundaries[0] = lB;\n             boundaries[1] = uB;\n             // Abort early if the normalization will overflow (cf. \"encode\" method).\n+            if (boundaries[0] != null) { // added null check\n+                for (int i = 0; i < boundaries[0].length; i++) { // corrected index\n+                    if ((boundaries[1][i] - boundaries[0][i]) / constants.getNormalization() > Double.MAX_VALUE) { // corrected overflow check\n+                        throw new MathIllegalArgumentException(LocalizedFormats.OVERFLOW_IN_COST_EVALUATION);\n+                    }\n+                }\n+            }\n         }\n     } else {\n         // Convert API to internal handling of boundaries.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // fixed condition from || to &&\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // fixed condition from || to &&\n             hasFiniteBounds = true;\n             break;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) {\n             hasFiniteBounds = true;\n             break;\n         }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // replaced || with &&\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n            if (maxEvaluations <= 0 || convergenceChecker == null || objectiveFunction == null) {\n                throw new NotStrictlyPositiveException(maxEvaluations);\n            }\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // replaced || with &&\n             hasFiniteBounds = true;\n             break;\n         }\n@@ -29,6 +29,9 @@\n             boundaries[0] = lB;\n             boundaries[1] = uB;\n             // Abort early if the normalization will overflow (cf. \"encode\" method).\n+            if (maxEvaluations <= 0 || convergenceChecker == null || objectiveFunction == null) {\n+                throw new NotStrictlyPositiveException(maxEvaluations);\n+            }\n         }\n     } else {\n         // Convert API to internal handling of boundaries.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // fix: use && instead of ||\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n            for (int i = 0; i < lB.length; i++) {\n                if (Math.abs(uB[i] - lB[i]) < Math.ulp((double) (1f))) { // fix: use double instead of float\n                    throw new MathIllegalArgumentException(\n                        LocalizedFormats.ZERO_FRACTION_POINT);\n                }\n            }\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            } else {\n                if (inputSigma[i] == 0) { // fix: add check for inputSigma being 0\n                    throw new MathIllegalArgumentException(\n                        LocalizedFormats.ZERO_SIGMA);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // fix: use && instead of ||\n             hasFiniteBounds = true;\n             break;\n         }\n@@ -29,6 +29,12 @@\n             boundaries[0] = lB;\n             boundaries[1] = uB;\n             // Abort early if the normalization will overflow (cf. \"encode\" method).\n+            for (int i = 0; i < lB.length; i++) {\n+                if (Math.abs(uB[i] - lB[i]) < Math.ulp((double) (1f))) { // fix: use double instead of float\n+                    throw new MathIllegalArgumentException(\n+                        LocalizedFormats.ZERO_FRACTION_POINT);\n+                }\n+            }\n         }\n     } else {\n         // Convert API to internal handling of boundaries.\n@@ -46,6 +52,11 @@\n                 if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                     throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                 }\n+            } else {\n+                if (inputSigma[i] == 0) { // fix: add check for inputSigma being 0\n+                    throw new MathIllegalArgumentException(\n+                        LocalizedFormats.ZERO_SIGMA);\n+                }\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // use '&&' instead of '||'\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // use '&&' instead of '||'\n             hasFiniteBounds = true;\n             break;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one infinite bound, none can be finite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n            if (Double.isInfinite(ProblemTransform.this.scale)) {\n                throw new MathUnsupportedOperationException();\n            }\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) {\n             hasFiniteBounds = true;\n             break;\n         }\n@@ -20,7 +20,7 @@\n             }\n         }\n         if (hasInfiniteBounds) {\n-            // If there is at least one finite bound, none can be infinite,\n+            // If there is at least one infinite bound, none can be finite,\n             // because mixed cases are not supported by the current code.\n             throw new MathUnsupportedOperationException();\n         } else {\n@@ -29,6 +29,9 @@\n             boundaries[0] = lB;\n             boundaries[1] = uB;\n             // Abort early if the normalization will overflow (cf. \"encode\" method).\n+            if (Double.isInfinite(ProblemTransform.this.scale)) {\n+                throw new MathUnsupportedOperationException();\n+            }\n         }\n     } else {\n         // Convert API to internal handling of boundaries.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // fixed logical operator from || to &&\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one infinite bound, none can be finite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n            if ((boundaries[1][0] - boundaries[0][0]) * (init.length + 1) > Integer.MAX_VALUE) {\n                throw new MathUnsupportedOperationException();\n            }\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {        \n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // fixed logical operator from || to &&\n             hasFiniteBounds = true;\n             break;\n         }\n@@ -20,7 +20,7 @@\n             }\n         }\n         if (hasInfiniteBounds) {\n-            // If there is at least one finite bound, none can be infinite,\n+            // If there is at least one infinite bound, none can be finite,\n             // because mixed cases are not supported by the current code.\n             throw new MathUnsupportedOperationException();\n         } else {\n@@ -29,6 +29,9 @@\n             boundaries[0] = lB;\n             boundaries[1] = uB;\n             // Abort early if the normalization will overflow (cf. \"encode\" method).\n+            if ((boundaries[1][0] - boundaries[0][0]) * (init.length + 1) > Integer.MAX_VALUE) {\n+                throw new MathUnsupportedOperationException();\n+            }\n         }\n     } else {\n         // Convert API to internal handling of boundaries.\n@@ -38,7 +41,7 @@\n         if (inputSigma.length != init.length) {\n             throw new DimensionMismatchException(inputSigma.length, init.length);\n         }\n-        for (int i = 0; i < init.length; i++) {\n+        for (int i = 0; i < init.length; i++) {        \n             if (inputSigma[i] < 0) {\n                 throw new NotPositiveException(inputSigma[i]);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotStrictlyPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) {\n             hasFiniteBounds = true;\n             break;\n         }\n@@ -40,7 +40,7 @@\n         }\n         for (int i = 0; i < init.length; i++) {\n             if (inputSigma[i] < 0) {\n-                throw new NotPositiveException(inputSigma[i]);\n+                throw new NotStrictlyPositiveException(inputSigma[i]);\n             }\n             if (boundaries != null) {\n                 if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!(Double.isInfinite(lB[i]) || Double.isInfinite(uB[i]))) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!(Double.isInfinite(lB[i]) || Double.isInfinite(uB[i]))) {\n             hasFiniteBounds = true;\n             break;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // Change || to &&\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n            for (int i = 0; i < lB.length; i++) { // Add loop to check boundaries are valid\n                if (Double.isNaN(lB[i]) || Double.isNaN(uB[i])) {\n                    throw new NumberIsTooLargeException();\n                }\n                if (lB[i] >= uB[i]) {\n                    throw new NumberIsTooLargeException();\n                }\n            }\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // Change || to &&\n             hasFiniteBounds = true;\n             break;\n         }\n@@ -29,6 +29,14 @@\n             boundaries[0] = lB;\n             boundaries[1] = uB;\n             // Abort early if the normalization will overflow (cf. \"encode\" method).\n+            for (int i = 0; i < lB.length; i++) { // Add loop to check boundaries are valid\n+                if (Double.isNaN(lB[i]) || Double.isNaN(uB[i])) {\n+                    throw new NumberIsTooLargeException();\n+                }\n+                if (lB[i] >= uB[i]) {\n+                    throw new NumberIsTooLargeException();\n+                }\n+            }\n         }\n     } else {\n         // Convert API to internal handling of boundaries.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "There is no obvious bug in the provided code.", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { //fix: && instead of ||\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { //fix: && instead of ||\n             hasFiniteBounds = true;\n             break;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // Changed OR to AND\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // Changed OR to AND\n             hasFiniteBounds = true;\n             break;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // Fixed the OR operator to AND\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n            for (int i = 0; i < init.length; i++) {\n                if (init[i] < lB[i] || init[i] > uB[i]) {\n                    throw new OutOfRangeException(init[i], lB[i], uB[i]);\n                }\n            }\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // Fixed the OR operator to AND\n             hasFiniteBounds = true;\n             break;\n         }\n@@ -29,6 +29,11 @@\n             boundaries[0] = lB;\n             boundaries[1] = uB;\n             // Abort early if the normalization will overflow (cf. \"encode\" method).\n+            for (int i = 0; i < init.length; i++) {\n+                if (init[i] < lB[i] || init[i] > uB[i]) {\n+                    throw new OutOfRangeException(init[i], lB[i], uB[i]);\n+                }\n+            }\n         }\n     } else {\n         // Convert API to internal handling of boundaries.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // use && instead of ||\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}", "diff": "--- org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n+++ org/apache/commons/math3/optimization/direct/CMAESOptimizer.java@checkParameters\n@@ -5,7 +5,7 @@\n     // Checks whether there is at least one finite bound value.\n     boolean hasFiniteBounds = false;\n     for (int i = 0; i < lB.length; i++) {\n-        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\n+        if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) { // use && instead of ||\n             hasFiniteBounds = true;\n             break;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}]