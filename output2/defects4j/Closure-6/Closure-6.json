[{"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isSubtypeOf(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 6}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (rightType != null && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -10,7 +10,7 @@\n             JSType ownerType = getJSType(owner);\n             if (ownerType.isFunctionPrototypeType()) {\n                 FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n-                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n+                if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                     return true;\n                 }\n             }\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (rightType != null && !rightType.canAssignTo(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // changed function call for subtype checking\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) { // changed function call for subtype checking\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // changed function call for subtype checking\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isSubtypeOf(leftType)) { // changed function call for subtype checking\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // replaced canAssignTo with isSubtypeOf\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) { // replaced canAssignTo with isSubtypeOf\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // replaced canAssignTo with isSubtypeOf\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isSubtypeOf(leftType)) { // replaced canAssignTo with isSubtypeOf\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { # use isSubtypeOf instead of canAssignTo for correct type checking\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) { # use isSubtypeOf instead of canAssignTo for correct type checking\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { # use isSubtypeOf instead of canAssignTo for correct type checking\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isSubtypeOf(leftType)) { # use isSubtypeOf instead of canAssignTo for correct type checking\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,12 +1,8 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n-    // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n-            // Do not type-check interface methods, because we expect that\n-            // they will have dummy implementations that do not match the type\n-            // annotations.\n             JSType ownerType = getJSType(owner);\n             if (ownerType.isFunctionPrototypeType()) {\n                 FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isSubtypeOf(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // changed canAssignTo to isSubtypeOf\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) { // changed canAssignTo to isSubtypeOf\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // changed canAssignTo to isSubtypeOf\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isSubtypeOf(leftType)) { // changed canAssignTo to isSubtypeOf\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // using isSubtypeOf as canAssignTo is deprecated\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) { // using isSubtypeOf as canAssignTo is deprecated\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // using isSubtypeOf as canAssignTo is deprecated\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isSubtypeOf(leftType)) { // using isSubtypeOf as canAssignTo is deprecated\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isUnknownType() && !leftType.isUnknownType() && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -10,7 +10,7 @@\n             JSType ownerType = getJSType(owner);\n             if (ownerType.isFunctionPrototypeType()) {\n                 FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n-                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n+                if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                     return true;\n                 }\n             }\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isUnknownType() && !leftType.isUnknownType() && !rightType.canAssignTo(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // Changed .canAssignTo() to .isSubtypeOf()\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) { // Changed .canAssignTo() to .isSubtypeOf()\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // Changed .canAssignTo() to .isSubtypeOf()\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isSubtypeOf(leftType)) { // Changed .canAssignTo() to .isSubtypeOf()\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { //use isSubtypeOf instead of canAssignTo\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) { //use isSubtypeOf instead of canAssignTo\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { //use isSubtypeOf instead of canAssignTo\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isSubtypeOf(leftType)) { //use isSubtypeOf instead of canAssignTo\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType != null && ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (leftType == null || !rightType.canAssignTo(leftType)) {\n        if ((leftType != null && leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -8,9 +8,9 @@\n             // they will have dummy implementations that do not match the type\n             // annotations.\n             JSType ownerType = getJSType(owner);\n-            if (ownerType.isFunctionPrototypeType()) {\n+            if (ownerType != null && ownerType.isFunctionPrototypeType()) {\n                 FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n-                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n+                if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                     return true;\n                 }\n             }\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,6 +1,6 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n-        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n+    if (leftType == null || !rightType.canAssignTo(leftType)) {\n+        if ((leftType != null && leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n             mismatch(t, n, msg, rightType, leftType);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // Change from canAssignTo() to isSubtypeOf()\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) { // Change from canAssignTo() to isSubtypeOf()\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // Change from canAssignTo() to isSubtypeOf()\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isSubtypeOf(leftType)) { // Change from canAssignTo() to isSubtypeOf()\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isUnknownType() && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -10,7 +10,7 @@\n             JSType ownerType = getJSType(owner);\n             if (ownerType.isFunctionPrototypeType()) {\n                 FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n-                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n+                if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                     return true;\n                 }\n             }\n--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignTo\n@@ -1,5 +1,5 @@\n boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n-    if (!rightType.canAssignTo(leftType)) {\n+    if (!rightType.isUnknownType() && !rightType.canAssignTo(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}]