[{"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (n.getFirstChild().isName() || n.getFirstChild().isFunction()) {\n            return true;\n        }\n        if (n.getFirstChild().isGetProp()) {\n            Node target = n.getFirstChild().getFirstChild();\n            // Check if the target is an object-literal.\n            if (target != null && target.isObjectLit()) {\n                return true;\n            }\n            // Check if the target is a function call that returns\n            // an object-literal.\n            if (target != null && target.isCall()) {\n                Node functionNode = target.getFirstChild();\n                if (functionNode != null && functionNode.isName()) {\n                    String functionName = functionNode.getString();\n                    if (isCreateObject(functionName)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (n.isThis()) {\n        if (assignLhsChild != null && !NodeUtil.isLValue(n)) {\n            return true;\n        }\n        if (NodeUtil.isGetProp(n.getParent())) {\n            Node target = n.getParent().getFirstChild();\n            if (target.getType() == Token.THIS) {\n                // report this.someProp\n                return true;\n            }\n            if (target.isName() && isCreateObject(target.getString())) {\n                // report goog.createInstance().someProp\n                return true;\n            }\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -11,7 +11,30 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (n.getFirstChild().isName() || n.getFirstChild().isFunction()) {\n+            return true;\n+        }\n+        if (n.getFirstChild().isGetProp()) {\n+            Node target = n.getFirstChild().getFirstChild();\n+            // Check if the target is an object-literal.\n+            if (target != null && target.isObjectLit()) {\n+                return true;\n+            }\n+            // Check if the target is a function call that returns\n+            // an object-literal.\n+            if (target != null && target.isCall()) {\n+                Node functionNode = target.getFirstChild();\n+                if (functionNode != null && functionNode.isName()) {\n+                    String functionName = functionNode.getString();\n+                    if (isCreateObject(functionName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n     }\n+\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -1,8 +1,19 @@\n private boolean shouldReportThis(Node n, Node parent) {\n-    if (assignLhsChild != null) {\n-        // Always report a THIS on the left side of an assign.\n-        return true;\n+    if (n.isThis()) {\n+        if (assignLhsChild != null && !NodeUtil.isLValue(n)) {\n+            return true;\n+        }\n+        if (NodeUtil.isGetProp(n.getParent())) {\n+            Node target = n.getParent().getFirstChild();\n+            if (target.getType() == Token.THIS) {\n+                // report this.someProp\n+                return true;\n+            }\n+            if (target.isName() && isCreateObject(target.getString())) {\n+                // report goog.createInstance().someProp\n+                return true;\n+            }\n+        }\n     }\n-    // Also report a THIS with a property access.\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (!NodeUtil.mayHaveThis(n)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return n == assignLhsChild;\n    }\n    // Also report a THIS with a property access.\n    return NodeUtil.isObjectLitKey(n, parent);\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -11,6 +11,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (!NodeUtil.mayHaveThis(n)) {\n+            return false;\n+        }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -1,8 +1,8 @@\n private boolean shouldReportThis(Node n, Node parent) {\n     if (assignLhsChild != null) {\n         // Always report a THIS on the left side of an assign.\n-        return true;\n+        return n == assignLhsChild;\n     }\n     // Also report a THIS with a property access.\n-    return false;\n+    return NodeUtil.isObjectLitKey(n, parent);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n                // Don't traverse assignments to prototype properties\n                return false;\n            }\n            String leftName = lhs.getQualifiedName();\n            if (leftName != null && leftName.contains(\".prototype.\")) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null && NodeUtil.isThis(n)) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access.\n    return NodeUtil.isGet(parent);\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -25,14 +25,13 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n-                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n-                    return false;\n-                }\n-                String leftName = lhs.getQualifiedName();\n-                if (leftName != null && leftName.contains(\".prototype.\")) {\n-                    return false;\n-                }\n+            if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n+                // Don't traverse assignments to prototype properties\n+                return false;\n+            }\n+            String leftName = lhs.getQualifiedName();\n+            if (leftName != null && leftName.contains(\".prototype.\")) {\n+                return false;\n             }\n         }\n     }\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -1,8 +1,8 @@\n private boolean shouldReportThis(Node n, Node parent) {\n-    if (assignLhsChild != null) {\n+    if (assignLhsChild != null && NodeUtil.isThis(n)) {\n         // Always report a THIS on the left side of an assign.\n         return true;\n     }\n     // Also report a THIS with a property access.\n-    return false;\n+    return NodeUtil.isGet(parent);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs.getFirstChild();\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return n == assignLhsChild;\n    }\n    // Also report a THIS with a property access.\n    return NodeUtil.isThis(n);\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -20,7 +20,7 @@\n             // nested assignments properly (e.g., (a = this).property = c;),\n             // assignLhsChild should not be overridden.\n             if (assignLhsChild == null) {\n-                assignLhsChild = lhs;\n+                assignLhsChild = lhs.getFirstChild();\n             }\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -1,8 +1,8 @@\n private boolean shouldReportThis(Node n, Node parent) {\n     if (assignLhsChild != null) {\n         // Always report a THIS on the left side of an assign.\n-        return true;\n+        return n == assignLhsChild;\n     }\n     // Also report a THIS with a property access.\n-    return false;\n+    return NodeUtil.isThis(n);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            } else {\n                assignLhsChild = null; // reset to null if already set\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null && n == assignLhsChild) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access.\n    if (parent != null && parent.getType() == Token.GETPROP && parent.getFirstChild() == n) {\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -21,6 +21,8 @@\n             // assignLhsChild should not be overridden.\n             if (assignLhsChild == null) {\n                 assignLhsChild = lhs;\n+            } else {\n+                assignLhsChild = null; // reset to null if already set\n             }\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -1,8 +1,11 @@\n private boolean shouldReportThis(Node n, Node parent) {\n-    if (assignLhsChild != null) {\n+    if (assignLhsChild != null && n == assignLhsChild) {\n         // Always report a THIS on the left side of an assign.\n         return true;\n     }\n     // Also report a THIS with a property access.\n+    if (parent != null && parent.getType() == Token.GETPROP && parent.getFirstChild() == n) {\n+        return true;\n+    }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && \n           (jsDoc.isConstructor() || jsDoc.hasType() && jsDoc.getType().isThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (!NodeUtil.isValidSimpleName(n.getFirstFirstChild())) {\n            return false;\n        }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return assignLhsChild.getFirstChild() == n;\n    }\n    // Also report a THIS with a property access.\n    if (parent != null && parent.getType() == Token.GETPROP) {\n        return parent.getFirstChild() == n;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -3,7 +3,8 @@\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n         JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n-        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n+        if (jsDoc != null && \n+           (jsDoc.isConstructor() || jsDoc.hasType() && jsDoc.getType().isThisType())) {\n             return false;\n         }\n         // Don't traverse functions unless they would normally\n@@ -11,6 +12,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (!NodeUtil.isValidSimpleName(n.getFirstFirstChild())) {\n+            return false;\n+        }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -1,8 +1,11 @@\n private boolean shouldReportThis(Node n, Node parent) {\n     if (assignLhsChild != null) {\n         // Always report a THIS on the left side of an assign.\n-        return true;\n+        return assignLhsChild.getFirstChild() == n;\n     }\n     // Also report a THIS with a property access.\n+    if (parent != null && parent.getType() == Token.GETPROP) {\n+        return parent.getFirstChild() == n;\n+    }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        // Fix: add a return statement for false\n        return !NodeUtil.mayHaveThisLocal(n);\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access.\n    // Fix: Add a check for Token.GETPROP type\n    return parent != null && parent.getType() == Token.GETPROP;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -11,6 +11,8 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        // Fix: add a return statement for false\n+        return !NodeUtil.mayHaveThisLocal(n);\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -4,5 +4,6 @@\n         return true;\n     }\n     // Also report a THIS with a property access.\n-    return false;\n+    // Fix: Add a check for Token.GETPROP type\n+    return parent != null && parent.getType() == Token.GETPROP;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.mayHaveThisReferencingCalls(n);\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null && n == assignLhsChild) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access.\n    if (parent != null && parent.isGetProp() && n == parent.getLastChild()) {\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -11,6 +11,7 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.mayHaveThisReferencingCalls(n);\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -1,8 +1,11 @@\n private boolean shouldReportThis(Node n, Node parent) {\n-    if (assignLhsChild != null) {\n+    if (assignLhsChild != null && n == assignLhsChild) {\n         // Always report a THIS on the left side of an assign.\n         return true;\n     }\n     // Also report a THIS with a property access.\n+    if (parent != null && parent.isGetProp() && n == parent.getLastChild()) {\n+        return true;\n+    }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (!NodeUtil.functionHasInlineOrNonEmptyJsDocDescription(n) &&\n                !NodeUtil.hasLValue(n)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n.isFirstChildOf(lhs)) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            return true;\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp() &&\n                    \"prototype\".equals(lhs.getLastChild().getString())) {\n                return false;\n            }\n            String leftName = lhs.getQualifiedName();\n            return leftName == null || !leftName.contains(\".prototype.\");\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null && n == assignLhsChild) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access.\n    return NodeUtil.isObjectLitKey(n) || NodeUtil.isGet(n);\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,39 +1,39 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n+\n         // Don't traverse functions unless they would normally\n         // be able to have a @this annotation associated with them. e.g.,\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (!NodeUtil.functionHasInlineOrNonEmptyJsDocDescription(n) &&\n+                !NodeUtil.hasLValue(n)) {\n+            return false;\n+        }\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n-        if (n == lhs) {\n+        if (n.isFirstChildOf(lhs)) {\n             // Always traverse the left side of the assignment. To handle\n             // nested assignments properly (e.g., (a = this).property = c;),\n             // assignLhsChild should not be overridden.\n-            if (assignLhsChild == null) {\n-                assignLhsChild = lhs;\n-            }\n+            return true;\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n-                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n-                    return false;\n-                }\n-                String leftName = lhs.getQualifiedName();\n-                if (leftName != null && leftName.contains(\".prototype.\")) {\n-                    return false;\n-                }\n+            if (lhs.isGetProp() &&\n+                    \"prototype\".equals(lhs.getLastChild().getString())) {\n+                return false;\n             }\n+            String leftName = lhs.getQualifiedName();\n+            return leftName == null || !leftName.contains(\".prototype.\");\n         }\n     }\n     return true;\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -1,8 +1,8 @@\n private boolean shouldReportThis(Node n, Node parent) {\n-    if (assignLhsChild != null) {\n+    if (assignLhsChild != null && n == assignLhsChild) {\n         // Always report a THIS on the left side of an assign.\n         return true;\n     }\n     // Also report a THIS with a property access.\n-    return false;\n+    return NodeUtil.isObjectLitKey(n) || NodeUtil.isGet(n);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (!NodeUtil.isGetOrSetKey(n)) {\n            return false;\n        }\n        Node parentOfParent = parent.getParent();\n        if (parentOfParent == null) {\n            return false;\n        }\n        if (parentOfParent.getType() != Token.OBJECTLIT) {\n            return false;\n        }\n        return !parentOfParent.isFromExterns();\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return n.isThis() || NodeUtil.isObjectLitKey(n);\n    }\n    // Also report a THIS with a property access.\n    if (n.isGetProp()) {\n        Node obj = n.getFirstChild();\n        return obj.isThis() && !NodeUtil.isObjectLitKey(n);\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -11,6 +11,17 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (!NodeUtil.isGetOrSetKey(n)) {\n+            return false;\n+        }\n+        Node parentOfParent = parent.getParent();\n+        if (parentOfParent == null) {\n+            return false;\n+        }\n+        if (parentOfParent.getType() != Token.OBJECTLIT) {\n+            return false;\n+        }\n+        return !parentOfParent.isFromExterns();\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -1,8 +1,12 @@\n private boolean shouldReportThis(Node n, Node parent) {\n     if (assignLhsChild != null) {\n         // Always report a THIS on the left side of an assign.\n-        return true;\n+        return n.isThis() || NodeUtil.isObjectLitKey(n);\n     }\n     // Also report a THIS with a property access.\n+    if (n.isGetProp()) {\n+        Node obj = n.getFirstChild();\n+        return obj.isThis() && !NodeUtil.isObjectLitKey(n);\n+    }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.mayHaveThisAnnotation(n);\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return (assignLhsChild.isSameNode(n));\n    }\n    // Also report a THIS with a property access.\n    return (parent != null && parent.getType() == Token.GETPROP && parent.getFirstChild().getType() == Token.THIS);\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -11,6 +11,7 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.mayHaveThisAnnotation(n);\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -1,8 +1,8 @@\n private boolean shouldReportThis(Node n, Node parent) {\n     if (assignLhsChild != null) {\n         // Always report a THIS on the left side of an assign.\n-        return true;\n+        return (assignLhsChild.isSameNode(n));\n     }\n     // Also report a THIS with a property access.\n-    return false;\n+    return (parent != null && parent.getType() == Token.GETPROP && parent.getFirstChild().getType() == Token.THIS);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.canBeObjectDefinePropertiesFunction(n) || NodeUtil.isFunctionExpression(n)\n                || NodeUtil.isGetOrSetKey(n);\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access.\n    if (n.isGetProp() || n.isGetElem()) {\n        if (n.getFirstChild().isThis()) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -11,6 +11,8 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.canBeObjectDefinePropertiesFunction(n) || NodeUtil.isFunctionExpression(n)\n+                || NodeUtil.isGetOrSetKey(n);\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -4,5 +4,10 @@\n         return true;\n     }\n     // Also report a THIS with a property access.\n+    if (n.isGetProp() || n.isGetElem()) {\n+        if (n.getFirstChild().isThis()) {\n+            return true;\n+        }\n+    }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (!NodeUtil.mayHaveGoogThis(n)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access if the parent is not a GETPROP node\n    return !(parent instanceof GetProp);\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -11,6 +11,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (!NodeUtil.mayHaveGoogThis(n)) {\n+            return false;\n+        }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -3,6 +3,6 @@\n         // Always report a THIS on the left side of an assign.\n         return true;\n     }\n-    // Also report a THIS with a property access.\n-    return false;\n+    // Also report a THIS with a property access if the parent is not a GETPROP node\n+    return !(parent instanceof GetProp);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions that are not named function expressions.\n        String functionName = NodeUtil.getNearestFunctionName(n);\n        if (functionName.isEmpty()) {\n            return false;\n        }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access if it's not a prototype property.\n    if (parent != null && parent.getType() == Token.GETPROP) {\n        Node grandParent = parent.getParent();\n        if (grandParent != null && grandParent.getType() == Token.ASSIGN) {\n            Node lhs = grandParent.getFirstChild();\n            if (lhs.getType() == Token.GETPROP) {\n                String fullName = lhs.getQualifiedName();\n                if (fullName != null && fullName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -6,11 +6,11 @@\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n-        // Don't traverse functions unless they would normally\n-        // be able to have a @this annotation associated with them. e.g.,\n-        // var a = function() { }; // or\n-        // function a() {} // or\n-        // a.x = function() {};\n+        // Don't traverse functions that are not named function expressions.\n+        String functionName = NodeUtil.getNearestFunctionName(n);\n+        if (functionName.isEmpty()) {\n+            return false;\n+        }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -3,6 +3,18 @@\n         // Always report a THIS on the left side of an assign.\n         return true;\n     }\n-    // Also report a THIS with a property access.\n-    return false;\n+    // Also report a THIS with a property access if it's not a prototype property.\n+    if (parent != null && parent.getType() == Token.GETPROP) {\n+        Node grandParent = parent.getParent();\n+        if (grandParent != null && grandParent.getType() == Token.ASSIGN) {\n+            Node lhs = grandParent.getFirstChild();\n+            if (lhs.getType() == Token.GETPROP) {\n+                String fullName = lhs.getQualifiedName();\n+                if (fullName != null && fullName.contains(\".prototype.\")) {\n+                    return false;\n+                }\n+            }\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (!NodeUtil.mayHaveThis(n)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access if the prop access is  a GETPROP or GETELEM.\n    if (parent != null && (parent.getType() == Token.GETPROP || parent.getType() == Token.GETELEM)) {\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -11,6 +11,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (!NodeUtil.mayHaveThis(n)) {\n+            return false;\n+        }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -3,6 +3,9 @@\n         // Always report a THIS on the left side of an assign.\n         return true;\n     }\n-    // Also report a THIS with a property access.\n+    // Also report a THIS with a property access if the prop access is  a GETPROP or GETELEM.\n+    if (parent != null && (parent.getType() == Token.GETPROP || parent.getType() == Token.GETELEM)) {\n+        return true;\n+    }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (NodeUtil.mayHaveThis(n)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access.\n    if (parent != null && parent.getType() == Token.GETPROP && parent.getFirstChild() == n) {\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -11,6 +11,11 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (NodeUtil.mayHaveThis(n)) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -4,5 +4,8 @@\n         return true;\n     }\n     // Also report a THIS with a property access.\n+    if (parent != null && parent.getType() == Token.GETPROP && parent.getFirstChild() == n) {\n+        return true;\n+    }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = n.getJSDocInfo();\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.mayHaveSideEffects(n);\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            boolean lhsIsPrototype = lhs.isGetProp()\n                    && lhs.getLastChild().getString().equals(\"prototype\");\n            boolean lhsContainsPrototype = lhs\n                    .getQualifiedName()\n                    .contains(\".prototype.\");\n            if (lhsIsPrototype || lhsContainsPrototype) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null && NodeUtil.isThis(n)) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access.\n    return n.isGetProp() && NodeUtil.isThis(n.getFirstChild());\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = n.getJSDocInfo();\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,8 +11,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.mayHaveSideEffects(n);\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,14 +26,13 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n-                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n-                    return false;\n-                }\n-                String leftName = lhs.getQualifiedName();\n-                if (leftName != null && leftName.contains(\".prototype.\")) {\n-                    return false;\n-                }\n+            boolean lhsIsPrototype = lhs.isGetProp()\n+                    && lhs.getLastChild().getString().equals(\"prototype\");\n+            boolean lhsContainsPrototype = lhs\n+                    .getQualifiedName()\n+                    .contains(\".prototype.\");\n+            if (lhsIsPrototype || lhsContainsPrototype) {\n+                return false;\n             }\n         }\n     }\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -1,8 +1,8 @@\n private boolean shouldReportThis(Node n, Node parent) {\n-    if (assignLhsChild != null) {\n+    if (assignLhsChild != null && NodeUtil.isThis(n)) {\n         // Always report a THIS on the left side of an assign.\n         return true;\n     }\n     // Also report a THIS with a property access.\n-    return false;\n+    return n.isGetProp() && NodeUtil.isThis(n.getFirstChild());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            } else if (lhs.getType() == Token.NAME) {\n                // Do not traverse the right side of the assignment if the name is 'this'.\n                if (lhs.getString().equals(\"this\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access.\n    if (parent != null && parent.getType() == Token.GETPROP && parent.getFirstChild() == n) {\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -33,6 +33,11 @@\n                 if (leftName != null && leftName.contains(\".prototype.\")) {\n                     return false;\n                 }\n+            } else if (lhs.getType() == Token.NAME) {\n+                // Do not traverse the right side of the assignment if the name is 'this'.\n+                if (lhs.getString().equals(\"this\")) {\n+                    return false;\n+                }\n             }\n         }\n     }\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -4,5 +4,8 @@\n         return true;\n     }\n     // Also report a THIS with a property access.\n+    if (parent != null && parent.getType() == Token.GETPROP && parent.getFirstChild() == n) {\n+        return true;\n+    }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return n.isFromExterns() || NodeUtil.getEnclosingType(n, Token.CLASS) != null;\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle properly\n            // nested assignments (e.g., (a = this).property = c;), assignLhsChild should\n            // not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access.\n    return parent != null && NodeUtil.isGet(parent) && parent.getFirstChild() == n;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -11,14 +11,15 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return n.isFromExterns() || NodeUtil.getEnclosingType(n, Token.CLASS) != null;\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n-            // Always traverse the left side of the assignment. To handle\n-            // nested assignments properly (e.g., (a = this).property = c;),\n-            // assignLhsChild should not be overridden.\n+            // Always traverse the left side of the assignment. To handle properly\n+            // nested assignments (e.g., (a = this).property = c;), assignLhsChild should\n+            // not be overridden.\n             if (assignLhsChild == null) {\n                 assignLhsChild = lhs;\n             }\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -4,5 +4,5 @@\n         return true;\n     }\n     // Also report a THIS with a property access.\n-    return false;\n+    return parent != null && NodeUtil.isGet(parent) && parent.getFirstChild() == n;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them.\n        if (!NodeUtil.mayHaveThisProperty(n)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n## Fixed Function 2\nprivate boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n        // Always report a THIS on the left side of an assign.\n        return true;\n    }\n    // Also report a THIS with a property access.\n    if (parent != null && parent.getType() == Token.GETPROP && parent.getFirstChild() == n) {\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -7,10 +7,10 @@\n             return false;\n         }\n         // Don't traverse functions unless they would normally\n-        // be able to have a @this annotation associated with them. e.g.,\n-        // var a = function() { }; // or\n-        // function a() {} // or\n-        // a.x = function() {};\n+        // be able to have a @this annotation associated with them.\n+        if (!NodeUtil.mayHaveThisProperty(n)) {\n+            return false;\n+        }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldReportThis\n@@ -4,5 +4,8 @@\n         return true;\n     }\n     // Also report a THIS with a property access.\n+    if (parent != null && parent.getType() == Token.GETPROP && parent.getFirstChild() == n) {\n+        return true;\n+    }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]