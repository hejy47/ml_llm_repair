[{"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        JSDocInfo docInfo = null;\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (docInfo == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                     compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -7,17 +7,17 @@\n         boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n         // Find the lowest property defined on a class with visibility\n         // information.\n+        JSDocInfo docInfo = null;\n         if (isOverride) {\n             objectType = objectType.getImplicitPrototype();\n         }\n-        JSDocInfo docInfo = null;\n         for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n             docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n             if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                 break;\n             }\n         }\n-        if (objectType == null) {\n+        if (docInfo == null) {\n             // We couldn't find a visibility modifier; assume it's public.\n             return;\n         }\n@@ -55,7 +55,7 @@\n                 // 3) Accessing the property from inside a subclass\n                 // The first two have already been checked for.\n                 if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n-                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n+                     compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = dereference(getprop.getFirstChild().getJSType()).autobox();\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.isAssign() && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null) {\n                Visibility visibility = docInfo.getVisibility();\n                if (visibility != Visibility.INHERITED) {\n                    break;\n                }\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = null;\n            if (overridingInfo != null) {\n                overridingVisibility = overridingInfo.getVisibility();\n            }\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != null && overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || !currentClass.equals(ownerType))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -1,10 +1,10 @@\n private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n-    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n+    ObjectType objectType = dereference(getprop.getFirstChild().getJSType()).autobox();\n     String propertyName = getprop.getLastChild().getString();\n     if (objectType != null) {\n         // Is this a normal property access, or are we trying to override\n         // an existing property?\n-        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n+        boolean isOverride = t.inGlobalScope() && parent.isAssign() && parent.getFirstChild() == getprop;\n         // Find the lowest property defined on a class with visibility\n         // information.\n         if (isOverride) {\n@@ -13,8 +13,11 @@\n         JSDocInfo docInfo = null;\n         for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n             docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n-            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n-                break;\n+            if (docInfo != null) {\n+                Visibility visibility = docInfo.getVisibility();\n+                if (visibility != Visibility.INHERITED) {\n+                    break;\n+                }\n             }\n         }\n         if (objectType == null) {\n@@ -28,20 +31,23 @@\n             // Check an ASSIGN statement that's trying to override a property\n             // on a superclass.\n             JSDocInfo overridingInfo = parent.getJSDocInfo();\n-            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n+            Visibility overridingVisibility = null;\n+            if (overridingInfo != null) {\n+                overridingVisibility = overridingInfo.getVisibility();\n+            }\n             // Check that (a) the property *can* be overridden, and\n             // (b) that the visibility of the override is the same as the\n             // visibility of the original property.\n             if (visibility == Visibility.PRIVATE && !sameInput) {\n                 compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n-            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n+            } else if (overridingVisibility != null && overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                 compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n             }\n         } else {\n             if (sameInput) {\n                 // private access is always allowed in the same file.\n                 return;\n-            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n+            } else if (visibility == Visibility.PRIVATE && (currentClass == null || !currentClass.equals(ownerType))) {\n                 if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                     return;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != JSDocInfo.Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceFileName());\n        JSDocInfo.Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            JSDocInfo.Visibility overridingVisibility = overridingInfo == null ? JSDocInfo.Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == JSDocInfo.Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != JSDocInfo.Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == JSDocInfo.Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == JSDocInfo.Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubclassOf(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -13,7 +13,7 @@\n         JSDocInfo docInfo = null;\n         for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n             docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n-            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n+            if (docInfo != null && docInfo.getVisibility() != JSDocInfo.Visibility.INHERITED) {\n                 break;\n             }\n         }\n@@ -21,40 +21,40 @@\n             // We couldn't find a visibility modifier; assume it's public.\n             return;\n         }\n-        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n-        Visibility visibility = docInfo.getVisibility();\n+        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceFileName());\n+        JSDocInfo.Visibility visibility = docInfo.getVisibility();\n         JSType ownerType = normalizeClassType(objectType);\n         if (isOverride) {\n             // Check an ASSIGN statement that's trying to override a property\n             // on a superclass.\n             JSDocInfo overridingInfo = parent.getJSDocInfo();\n-            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n+            JSDocInfo.Visibility overridingVisibility = overridingInfo == null ? JSDocInfo.Visibility.INHERITED : overridingInfo.getVisibility();\n             // Check that (a) the property *can* be overridden, and\n             // (b) that the visibility of the override is the same as the\n             // visibility of the original property.\n-            if (visibility == Visibility.PRIVATE && !sameInput) {\n+            if (visibility == JSDocInfo.Visibility.PRIVATE && !sameInput) {\n                 compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n-            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n+            } else if (overridingVisibility != JSDocInfo.Visibility.INHERITED && overridingVisibility != visibility) {\n                 compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n             }\n         } else {\n             if (sameInput) {\n                 // private access is always allowed in the same file.\n                 return;\n-            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n+            } else if (visibility == JSDocInfo.Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                 if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                     return;\n                 }\n                 // private access is not allowed outside the file from a different\n                 // enclosing class.\n                 compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n-            } else if (visibility == Visibility.PROTECTED) {\n+            } else if (visibility == JSDocInfo.Visibility.PROTECTED) {\n                 // There are 3 types of legal accesses of a protected property:\n                 // 1) Accesses in the same file\n                 // 2) Overriding the property in a subclass\n                 // 3) Accessing the property from inside a subclass\n                 // The first two have already been checked for.\n-                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n+                if (currentClass == null || !currentClass.isSubclassOf(ownerType)) {\n                     compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && !overridingVisibility.equals(visibility)) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName,\n                        validator.getReadableJSTypeName(getprop.getFirstChild(), true), objectType.toString()));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName,\n                            validator.getReadableJSTypeName(getprop.getFirstChild(), true), objectType.toString()));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -34,7 +34,7 @@\n             // visibility of the original property.\n             if (visibility == Visibility.PRIVATE && !sameInput) {\n                 compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n-            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n+            } else if (overridingVisibility != Visibility.INHERITED && !overridingVisibility.equals(visibility)) {\n                 compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n             }\n         } else {\n@@ -47,7 +47,8 @@\n                 }\n                 // private access is not allowed outside the file from a different\n                 // enclosing class.\n-                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n+                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName,\n+                        validator.getReadableJSTypeName(getprop.getFirstChild(), true), objectType.toString()));\n             } else if (visibility == Visibility.PROTECTED) {\n                 // There are 3 types of legal accesses of a protected property:\n                 // 1) Accesses in the same file\n@@ -55,7 +56,8 @@\n                 // 3) Accessing the property from inside a subclass\n                 // The first two have already been checked for.\n                 if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n-                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n+                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName,\n+                            validator.getReadableJSTypeName(getprop.getFirstChild(), true), objectType.toString()));\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(getprop.getFirstChild().getJSType());\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        JSDocInfo docInfo = null;\n        Visibility visibility = null;\n        JSType ownerType = null;\n        boolean sameInput = false;\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                visibility = docInfo.getVisibility();\n                ownerType = normalizeClassType(objectType);\n                sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, ownerType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), ownerType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -1,5 +1,5 @@\n private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n-    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n+    ObjectType objectType = ObjectType.cast(getprop.getFirstChild().getJSType());\n     String propertyName = getprop.getLastChild().getString();\n     if (objectType != null) {\n         // Is this a normal property access, or are we trying to override\n@@ -7,13 +7,19 @@\n         boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n         // Find the lowest property defined on a class with visibility\n         // information.\n+        JSDocInfo docInfo = null;\n+        Visibility visibility = null;\n+        JSType ownerType = null;\n+        boolean sameInput = false;\n         if (isOverride) {\n             objectType = objectType.getImplicitPrototype();\n         }\n-        JSDocInfo docInfo = null;\n         for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n             docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n             if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n+                visibility = docInfo.getVisibility();\n+                ownerType = normalizeClassType(objectType);\n+                sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n                 break;\n             }\n         }\n@@ -21,9 +27,6 @@\n             // We couldn't find a visibility modifier; assume it's public.\n             return;\n         }\n-        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n-        Visibility visibility = docInfo.getVisibility();\n-        JSType ownerType = normalizeClassType(objectType);\n         if (isOverride) {\n             // Check an ASSIGN statement that's trying to override a property\n             // on a superclass.\n@@ -33,9 +36,9 @@\n             // (b) that the visibility of the override is the same as the\n             // visibility of the original property.\n             if (visibility == Visibility.PRIVATE && !sameInput) {\n-                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n+                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, ownerType.toString()));\n             } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n-                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n+                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), ownerType.toString(), overridingVisibility.name()));\n             }\n         } else {\n             if (sameInput) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null || docInfo == null || docInfo.getVisibility() == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -13,11 +13,11 @@\n         JSDocInfo docInfo = null;\n         for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n             docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n-            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n+            if (docInfo != null && docInfo.getVisibility() != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                 break;\n             }\n         }\n-        if (objectType == null) {\n+        if (objectType == null || docInfo == null || docInfo.getVisibility() == null) {\n             // We couldn't find a visibility modifier; assume it's public.\n             return;\n         }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (docInfo == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -17,7 +17,7 @@\n                 break;\n             }\n         }\n-        if (objectType == null) {\n+        if (docInfo == null) {\n             // We couldn't find a visibility modifier; assume it's public.\n             return;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, objectType.toString(), visibility.name(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || !ownerType.equals(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubclassOf(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -35,13 +35,13 @@\n             if (visibility == Visibility.PRIVATE && !sameInput) {\n                 compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n             } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n-                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n+                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, objectType.toString(), visibility.name(), overridingVisibility.name()));\n             }\n         } else {\n             if (sameInput) {\n                 // private access is always allowed in the same file.\n                 return;\n-            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n+            } else if (visibility == Visibility.PRIVATE && (currentClass == null || !ownerType.equals(currentClass))) {\n                 if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                     return;\n                 }\n@@ -54,7 +54,7 @@\n                 // 2) Overriding the property in a subclass\n                 // 3) Accessing the property from inside a subclass\n                 // The first two have already been checked for.\n-                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n+                if (currentClass == null || !currentClass.isSubclassOf(ownerType)) {\n                     compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceFileName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (!(currentClass != null && (currentClass.equals(ownerType) || currentClass.isSubclass(ownerType)))) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -21,7 +21,7 @@\n             // We couldn't find a visibility modifier; assume it's public.\n             return;\n         }\n-        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n+        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceFileName());\n         Visibility visibility = docInfo.getVisibility();\n         JSType ownerType = normalizeClassType(objectType);\n         if (isOverride) {\n@@ -54,7 +54,7 @@\n                 // 2) Overriding the property in a subclass\n                 // 3) Accessing the property from inside a subclass\n                 // The first two have already been checked for.\n-                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n+                if (!(currentClass != null && (currentClass.equals(ownerType) || currentClass.isSubclass(ownerType)))) {\n                     compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        if (visibility == null) {\n            // If visibility is null, we assume it's public.\n            return;\n        }\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -13,7 +13,7 @@\n         JSDocInfo docInfo = null;\n         for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n             docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n-            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n+            if (docInfo != null && docInfo.getVisibility() != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                 break;\n             }\n         }\n@@ -23,6 +23,10 @@\n         }\n         boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n         Visibility visibility = docInfo.getVisibility();\n+        if (visibility == null) {\n+            // If visibility is null, we assume it's public.\n+            return;\n+        }\n         JSType ownerType = normalizeClassType(objectType);\n         if (isOverride) {\n             // Check an ASSIGN statement that's trying to override a property\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, objectType.toString(), propertyName, visibility.name(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType == null || currentClass.isInterface() || !ownerType.equals(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isInterface() && !currentClass.isSubclass(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -35,13 +35,13 @@\n             if (visibility == Visibility.PRIVATE && !sameInput) {\n                 compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n             } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n-                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n+                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, objectType.toString(), propertyName, visibility.name(), overridingVisibility.name()));\n             }\n         } else {\n             if (sameInput) {\n                 // private access is always allowed in the same file.\n                 return;\n-            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n+            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType == null || currentClass.isInterface() || !ownerType.equals(currentClass))) {\n                 if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                     return;\n                 }\n@@ -54,7 +54,7 @@\n                 // 2) Overriding the property in a subclass\n                 // 3) Accessing the property from inside a subclass\n                 // The first two have already been checked for.\n-                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n+                if (currentClass == null || !currentClass.isInterface() && !currentClass.isSubclass(ownerType)) {\n                     compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from the same enclosing class or its subclass.\n                if (ownerType.isSubtype(currentClass)) {\n                    return;\n                }\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -45,8 +45,10 @@\n                 if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                     return;\n                 }\n-                // private access is not allowed outside the file from a different\n-                // enclosing class.\n+                // private access is not allowed outside the file from the same enclosing class or its subclass.\n+                if (ownerType.isSubtype(currentClass)) {\n+                    return;\n+                }\n                 compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n             } else if (visibility == Visibility.PROTECTED) {\n                 // There are 3 types of legal accesses of a protected property:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = Visibility.INHERITED;\n\n            if (overridingInfo != null) {\n                overridingVisibility = overridingInfo.getVisibility();\n            }\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !ownerType.isSubtype(currentClass)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -28,7 +28,11 @@\n             // Check an ASSIGN statement that's trying to override a property\n             // on a superclass.\n             JSDocInfo overridingInfo = parent.getJSDocInfo();\n-            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n+            Visibility overridingVisibility = Visibility.INHERITED;\n+\n+            if (overridingInfo != null) {\n+                overridingVisibility = overridingInfo.getVisibility();\n+            }\n             // Check that (a) the property *can* be overridden, and\n             // (b) that the visibility of the override is the same as the\n             // visibility of the original property.\n@@ -54,7 +58,7 @@\n                 // 2) Overriding the property in a subclass\n                 // 3) Accessing the property from inside a subclass\n                 // The first two have already been checked for.\n-                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n+                if (currentClass == null || !ownerType.isSubtype(currentClass)) {\n                     compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput && !currentClass.isSubclassOf(ownerType.getClassName())) {\n                // Private property cannot be overriden from other file and non subclass of owner.\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass)) && !currentClass.isSubclassOf(ownerType.getClassName())) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubclassOf(ownerType.getClassName())) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -32,7 +32,8 @@\n             // Check that (a) the property *can* be overridden, and\n             // (b) that the visibility of the override is the same as the\n             // visibility of the original property.\n-            if (visibility == Visibility.PRIVATE && !sameInput) {\n+            if (visibility == Visibility.PRIVATE && !sameInput && !currentClass.isSubclassOf(ownerType.getClassName())) {\n+                // Private property cannot be overriden from other file and non subclass of owner.\n                 compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n             } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                 compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n@@ -41,7 +42,7 @@\n             if (sameInput) {\n                 // private access is always allowed in the same file.\n                 return;\n-            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n+            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass)) && !currentClass.isSubclassOf(ownerType.getClassName())) {\n                 if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                     return;\n                 }\n@@ -54,7 +55,7 @@\n                 // 2) Overriding the property in a subclass\n                 // 3) Accessing the property from inside a subclass\n                 // The first two have already been checked for.\n-                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n+                if (currentClass == null || !currentClass.isSubclassOf(ownerType.getClassName())) {\n                     compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != null && docInfo.getVisibility() != Visibility.INHERITED) { // Fix: Check if visibility is not null before checking its value\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != null && overridingVisibility != visibility) { // Fix: Check if overridingVisibility is not null before checking its value\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -13,7 +13,7 @@\n         JSDocInfo docInfo = null;\n         for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n             docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n-            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n+            if (docInfo != null && docInfo.getVisibility() != null && docInfo.getVisibility() != Visibility.INHERITED) { // Fix: Check if visibility is not null before checking its value\n                 break;\n             }\n         }\n@@ -34,7 +34,7 @@\n             // visibility of the original property.\n             if (visibility == Visibility.PRIVATE && !sameInput) {\n                 compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n-            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n+            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != null && overridingVisibility != visibility) { // Fix: Check if overridingVisibility is not null before checking its value\n                 compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n             }\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n              if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, objectType.toString(), propertyName, visibility.name(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -32,10 +32,10 @@\n             // Check that (a) the property *can* be overridden, and\n             // (b) that the visibility of the override is the same as the\n             // visibility of the original property.\n-            if (visibility == Visibility.PRIVATE && !sameInput) {\n+              if (visibility == Visibility.PRIVATE && !sameInput) {\n                 compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n             } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n-                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n+                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, objectType.toString(), propertyName, visibility.name(), overridingVisibility.name()));\n             }\n         } else {\n             if (sameInput) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, objectType.toString(), propertyName, visibility.name(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, validator.getReadableJSTypeName(getprop.getFirstChild(), true), propertyName));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, validator.getReadableJSTypeName(getprop.getFirstChild(), true), propertyName));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -35,7 +35,7 @@\n             if (visibility == Visibility.PRIVATE && !sameInput) {\n                 compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n             } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n-                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n+                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, objectType.toString(), propertyName, visibility.name(), overridingVisibility.name()));\n             }\n         } else {\n             if (sameInput) {\n@@ -47,7 +47,7 @@\n                 }\n                 // private access is not allowed outside the file from a different\n                 // enclosing class.\n-                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n+                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, validator.getReadableJSTypeName(getprop.getFirstChild(), true), propertyName));\n             } else if (visibility == Visibility.PROTECTED) {\n                 // There are 3 types of legal accesses of a protected property:\n                 // 1) Accesses in the same file\n@@ -55,7 +55,7 @@\n                 // 3) Accessing the property from inside a subclass\n                 // The first two have already been checked for.\n                 if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n-                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n+                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, validator.getReadableJSTypeName(getprop.getFirstChild(), true), propertyName));\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(getprop.getFirstChild().getJSType());\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != JSDocInfo.Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getName());\n        JSDocInfo.Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = objectType;\n        if (ownerType.isFunctionType()) {\n            ownerType = ((FunctionType) ownerType).getInstanceType();\n        } else {\n            ownerType = normalizeClassType(ownerType);\n        }\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            JSDocInfo.Visibility overridingVisibility = overridingInfo == null ? JSDocInfo.Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == JSDocInfo.Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != JSDocInfo.Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == JSDocInfo.Visibility.PRIVATE && (currentClass == null || ownerType == null\n                || !ownerType.equals(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == JSDocInfo.Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubclass(ownerType)) {\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -1,5 +1,5 @@\n private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n-    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n+    ObjectType objectType = ObjectType.cast(getprop.getFirstChild().getJSType());\n     String propertyName = getprop.getLastChild().getString();\n     if (objectType != null) {\n         // Is this a normal property access, or are we trying to override\n@@ -13,7 +13,7 @@\n         JSDocInfo docInfo = null;\n         for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n             docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n-            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n+            if (docInfo != null && docInfo.getVisibility() != JSDocInfo.Visibility.INHERITED) {\n                 break;\n             }\n         }\n@@ -21,40 +21,46 @@\n             // We couldn't find a visibility modifier; assume it's public.\n             return;\n         }\n-        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n-        Visibility visibility = docInfo.getVisibility();\n-        JSType ownerType = normalizeClassType(objectType);\n+        boolean sameInput = t.getInput().getName().equals(docInfo.getName());\n+        JSDocInfo.Visibility visibility = docInfo.getVisibility();\n+        JSType ownerType = objectType;\n+        if (ownerType.isFunctionType()) {\n+            ownerType = ((FunctionType) ownerType).getInstanceType();\n+        } else {\n+            ownerType = normalizeClassType(ownerType);\n+        }\n         if (isOverride) {\n             // Check an ASSIGN statement that's trying to override a property\n             // on a superclass.\n             JSDocInfo overridingInfo = parent.getJSDocInfo();\n-            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n+            JSDocInfo.Visibility overridingVisibility = overridingInfo == null ? JSDocInfo.Visibility.INHERITED : overridingInfo.getVisibility();\n             // Check that (a) the property *can* be overridden, and\n             // (b) that the visibility of the override is the same as the\n             // visibility of the original property.\n-            if (visibility == Visibility.PRIVATE && !sameInput) {\n+            if (visibility == JSDocInfo.Visibility.PRIVATE && !sameInput) {\n                 compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n-            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n+            } else if (overridingVisibility != JSDocInfo.Visibility.INHERITED && overridingVisibility != visibility) {\n                 compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n             }\n         } else {\n             if (sameInput) {\n                 // private access is always allowed in the same file.\n                 return;\n-            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n+            } else if (visibility == JSDocInfo.Visibility.PRIVATE && (currentClass == null || ownerType == null\n+                || !ownerType.equals(currentClass))) {\n                 if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                     return;\n                 }\n                 // private access is not allowed outside the file from a different\n                 // enclosing class.\n                 compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n-            } else if (visibility == Visibility.PROTECTED) {\n+            } else if (visibility == JSDocInfo.Visibility.PROTECTED) {\n                 // There are 3 types of legal accesses of a protected property:\n                 // 1) Accesses in the same file\n                 // 2) Overriding the property in a subclass\n                 // 3) Accessing the property from inside a subclass\n                 // The first two have already been checked for.\n-                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n+                if (currentClass == null || !currentClass.isSubclass(ownerType)) {\n                     compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n    if (objectType != null) {\n        // Is this a normal property access, or are we trying to override\n        // an existing property?\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n        // Find the lowest property defined on a class with visibility\n        // information.\n        if (isOverride) {\n            objectType = objectType.getImplicitPrototype();\n        }\n        JSDocInfo docInfo = null;\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n                break;\n            }\n        }\n        if (objectType == null) {\n            // We couldn't find a visibility modifier; assume it's public.\n            return;\n        }\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n        Visibility visibility = docInfo.getVisibility();\n        JSType ownerType = normalizeClassType(objectType);\n        if (isOverride) {\n            // Check an ASSIGN statement that's trying to override a property\n            // on a superclass.\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\n            // Check that (a) the property *can* be overridden, and\n            // (b) that the visibility of the override is the same as the\n            // visibility of the original property.\n            if (visibility == Visibility.PRIVATE && !sameInput) {\n                compiler.report(t.makeError(getprop, BaseCheckAccessControls.PRIVATE_OVERRIDE, objectType.toString()));\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n                compiler.report(t.makeError(getprop, BaseCheckAccessControls.VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n            }\n        } else {\n            if (sameInput) {\n                // private access is always allowed in the same file.\n                return;\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                    return;\n                }\n                // private access is not allowed outside the file from a different\n                // enclosing class.\n                compiler.report(t.makeError(getprop, BaseCheckAccessControls.BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n            } else if (visibility == Visibility.PROTECTED) {\n                // There are 3 types of legal accesses of a protected property:\n                // 1) Accesses in the same file\n                // 2) Overriding the property in a subclass\n                // 3) Accessing the property from inside a subclass\n                // The first two have already been checked for.\n                if (currentClass == null || !currentClass.isSubclassOf(ownerType)) {\n                    compiler.report(t.makeError(getprop, BaseCheckAccessControls.BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n+++ com/google/javascript/jscomp/CheckAccessControls.java@checkPropertyVisibility\n@@ -33,9 +33,9 @@\n             // (b) that the visibility of the override is the same as the\n             // visibility of the original property.\n             if (visibility == Visibility.PRIVATE && !sameInput) {\n-                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n+                compiler.report(t.makeError(getprop, BaseCheckAccessControls.PRIVATE_OVERRIDE, objectType.toString()));\n             } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n-                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n+                compiler.report(t.makeError(getprop, BaseCheckAccessControls.VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\n             }\n         } else {\n             if (sameInput) {\n@@ -47,15 +47,15 @@\n                 }\n                 // private access is not allowed outside the file from a different\n                 // enclosing class.\n-                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n+                compiler.report(t.makeError(getprop, BaseCheckAccessControls.BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n             } else if (visibility == Visibility.PROTECTED) {\n                 // There are 3 types of legal accesses of a protected property:\n                 // 1) Accesses in the same file\n                 // 2) Overriding the property in a subclass\n                 // 3) Accessing the property from inside a subclass\n                 // The first two have already been checked for.\n-                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n-                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n+                if (currentClass == null || !currentClass.isSubclassOf(ownerType)) {\n+                    compiler.report(t.makeError(getprop, BaseCheckAccessControls.BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}]