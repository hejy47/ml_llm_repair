[{"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult1 = compareAsNumbers(op, left, right);\n            if (compareResult1 != null) {\n                result = compareResult1;\n            } else {\n                return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // We can only handle == and != here.\n                // In case of the named constant being NaN, the results can be different.\n                // This depends on how the constant will be converted to number which can be either NaN or 0.\n                // Therefore, for safety we should not handle the other comparisons except for EQ and NE.\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -111,11 +111,11 @@\n                 // Only eval if they are the same type\n                 return n;\n             }\n-            Boolean compareResult = compareAsNumbers(op, left, right);\n-            if (compareResult != null) {\n-                result = compareResult;\n+            Boolean compareResult1 = compareAsNumbers(op, left, right);\n+            if (compareResult1 != null) {\n+                result = compareResult1;\n             } else {\n-                return null;\n+                return n;\n             }\n             break;\n         case Token.NAME:\n@@ -141,10 +141,16 @@\n                 return n;\n             }\n             switch(op) {\n-                // If we knew the named value wouldn't be NaN, it would be nice\n-                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n-                case Token.LT:\n-                case Token.GT:\n+                // We can only handle == and != here.\n+                // In case of the named constant being NaN, the results can be different.\n+                // This depends on how the constant will be converted to number which can be either NaN or 0.\n+                // Therefore, for safety we should not handle the other comparisons except for EQ and NE.\n+                case Token.SHEQ:\n+                case Token.EQ:\n+                    result = true;\n+                    break;\n+                case Token.SHNE:\n+                case Token.NE:\n                     result = false;\n                     break;\n                 default:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.isEquivalentTo(right); \n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.isEquivalentTo(right);\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return null;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -36,11 +36,11 @@\n             switch(op) {\n                 case Token.SHEQ:\n                 case Token.EQ:\n-                    result = lhType == rhType;\n+                    result = left.isEquivalentTo(right); \n                     break;\n                 case Token.SHNE:\n                 case Token.NE:\n-                    result = lhType != rhType;\n+                    result = !left.isEquivalentTo(right);\n                     break;\n                 case Token.GE:\n                 case Token.LE:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    return n; // Removed to fix the bug\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -115,7 +115,7 @@\n             if (compareResult != null) {\n                 result = compareResult;\n             } else {\n-                return null;\n+                return n;\n             }\n             break;\n         case Token.NAME:\n@@ -145,8 +145,7 @@\n                 // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                 case Token.LT:\n                 case Token.GT:\n-                    result = false;\n-                    break;\n+                    return n; // Removed to fix the bug\n                 default:\n                     // don't handle that op\n                     return n;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result = false;\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch (lhType) {\n        case Token.VOID:\n            // Fall through\n        case Token.NULL:\n            // Fall through\n        case Token.TRUE:\n            // Fall through\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral && rhType == lhType) {\n                // Compare left and right nodes as values.\n                result = left.getBoolean() == right.getBoolean();\n            } else if (rhType == Token.NULL || rhType == Token.TRUE || rhType == Token.FALSE || rhType == Token.VOID) {\n                switch (op) {\n                    case Token.SHEQ:\n                    case Token.EQ:\n                        result = lhType == rhType;\n                        break;\n                    case Token.SHNE:\n                    case Token.NE:\n                        result = lhType != rhType;\n                        break;\n                    case Token.GE:\n                    case Token.LE:\n                    case Token.GT:\n                    case Token.LT:\n                        // Handle mixed boolean and numeric compares like:\n                        // alert(true > true, true > false, false > true, false > false);\n                        //\n                        // Handle null/undefined like:\n                        // alert(null > null, null >= null, null < null, null <= null);\n                        Boolean compareResult = compareAsNumbers(op, left, right);\n                        if (compareResult != null) {\n                            result = compareResult;\n                        } else {\n                            return n;\n                        }\n                        break;\n                    default:\n                        // we only handle == and != here\n                        return n;\n                }\n            } else {\n                return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral && (rhType == Token.NUMBER || rhType == Token.STRING)) {\n                switch (op) {\n                    case Token.SHEQ:\n                    case Token.EQ:\n                        result = left.getBoolean() == right.getBoolean();\n                        break;\n                    case Token.SHNE:\n                    case Token.NE:\n                        result = left.getBoolean() != right.getBoolean();\n                        break;\n                    case Token.GE:\n                    case Token.LE:\n                    case Token.GT:\n                    case Token.LT:\n                        // Handle boolean and numeric compares with numbers stored\n                        // as named values like: alert(true > 1, true < 2);\n                        Boolean compareResult = compareAsNumbers(op, left, right);\n                        if (compareResult != null) {\n                            result = compareResult;\n                        } else {\n                            return n;\n                        }\n                        break;\n                    default:\n                        // Only EQ and NE handled below\n                        return n;\n                }\n            } else if (right.getType() == Token.THIS && op == Token.SHEQ) {\n                result = true;\n            } else {\n                return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral && rhType == Token.STRING) {\n                switch (op) {\n                    case Token.SHEQ:\n                    case Token.EQ:\n                        result = left.getString().equals(right.getString());\n                        break;\n                    case Token.SHNE:\n                    case Token.NE:\n                        result = !left.getString().equals(right.getString());\n                        break;\n                    case Token.GE:\n                    case Token.GT:\n                    case Token.LE:\n                    case Token.LT:\n                        // Handle numeric compares with strings stored as literals\n                        // or named values.\n                        Boolean compareResult = compareAsNumbers(op, left, right);\n                        if (compareResult != null) {\n                            result = compareResult;\n                        } else {\n                            return n;\n                        }\n                        break;\n                    default:\n                        // we only handle == and != here\n                        return n;\n                }\n            } else {\n                return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral && (rhType == Token.NUMBER)) {\n                Boolean compareResult = compareAsNumbers(op, left, right);\n                if (compareResult != null) {\n                    result = compareResult;\n                } else {\n                    return n;\n                }\n            } else if (right.getType() == Token.NAME && right.getString().equals(\"NaN\")) {\n                switch (op) {\n                    case Token.SHEQ:\n                    case Token.EQ:\n                        result = false;\n                        break;\n                    case Token.SHNE:\n                    case Token.NE:\n                        result = true;\n                        break;\n                    default:\n                        return n;\n                }\n            } else {\n                return n;\n            }\n            break;\n        default:\n            // assert, this shouldn't happen\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -7,76 +7,96 @@\n         }\n     }\n     int op = n.getType();\n-    boolean result;\n-    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n+    boolean result = false;\n     boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n     boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n     int lhType = left.getType();\n     int rhType = right.getType();\n-    switch(lhType) {\n+    switch (lhType) {\n         case Token.VOID:\n-            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n-                return n;\n-            } else if (!rightLiteral) {\n-                return n;\n-            } else {\n-                result = compareToUndefined(right, op);\n-            }\n-            break;\n+            // Fall through\n         case Token.NULL:\n+            // Fall through\n         case Token.TRUE:\n+            // Fall through\n         case Token.FALSE:\n             if (undefinedRight) {\n                 result = compareToUndefined(left, op);\n                 break;\n             }\n-            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n+            if (rightLiteral && rhType == lhType) {\n+                // Compare left and right nodes as values.\n+                result = left.getBoolean() == right.getBoolean();\n+            } else if (rhType == Token.NULL || rhType == Token.TRUE || rhType == Token.FALSE || rhType == Token.VOID) {\n+                switch (op) {\n+                    case Token.SHEQ:\n+                    case Token.EQ:\n+                        result = lhType == rhType;\n+                        break;\n+                    case Token.SHNE:\n+                    case Token.NE:\n+                        result = lhType != rhType;\n+                        break;\n+                    case Token.GE:\n+                    case Token.LE:\n+                    case Token.GT:\n+                    case Token.LT:\n+                        // Handle mixed boolean and numeric compares like:\n+                        // alert(true > true, true > false, false > true, false > false);\n+                        //\n+                        // Handle null/undefined like:\n+                        // alert(null > null, null >= null, null < null, null <= null);\n+                        Boolean compareResult = compareAsNumbers(op, left, right);\n+                        if (compareResult != null) {\n+                            result = compareResult;\n+                        } else {\n+                            return n;\n+                        }\n+                        break;\n+                    default:\n+                        // we only handle == and != here\n+                        return n;\n+                }\n+            } else {\n                 return n;\n             }\n-            switch(op) {\n-                case Token.SHEQ:\n-                case Token.EQ:\n-                    result = lhType == rhType;\n-                    break;\n-                case Token.SHNE:\n-                case Token.NE:\n-                    result = lhType != rhType;\n-                    break;\n-                case Token.GE:\n-                case Token.LE:\n-                case Token.GT:\n-                case Token.LT:\n-                    Boolean compareResult = compareAsNumbers(op, left, right);\n-                    if (compareResult != null) {\n-                        result = compareResult;\n-                    } else {\n+            break;\n+        case Token.NAME:\n+            if (undefinedRight) {\n+                result = compareToUndefined(left, op);\n+                break;\n+            }\n+            if (rightLiteral && (rhType == Token.NUMBER || rhType == Token.STRING)) {\n+                switch (op) {\n+                    case Token.SHEQ:\n+                    case Token.EQ:\n+                        result = left.getBoolean() == right.getBoolean();\n+                        break;\n+                    case Token.SHNE:\n+                    case Token.NE:\n+                        result = left.getBoolean() != right.getBoolean();\n+                        break;\n+                    case Token.GE:\n+                    case Token.LE:\n+                    case Token.GT:\n+                    case Token.LT:\n+                        // Handle boolean and numeric compares with numbers stored\n+                        // as named values like: alert(true > 1, true < 2);\n+                        Boolean compareResult = compareAsNumbers(op, left, right);\n+                        if (compareResult != null) {\n+                            result = compareResult;\n+                        } else {\n+                            return n;\n+                        }\n+                        break;\n+                    default:\n+                        // Only EQ and NE handled below\n                         return n;\n-                    }\n-                    break;\n-                default:\n-                    // we only handle == and != here\n-                    return n;\n-            }\n-            break;\n-        case Token.THIS:\n-            if (right.getType() != Token.THIS) {\n+                }\n+            } else if (right.getType() == Token.THIS && op == Token.SHEQ) {\n+                result = true;\n+            } else {\n                 return n;\n-            }\n-            switch(op) {\n-                case Token.SHEQ:\n-                case Token.EQ:\n-                    result = true;\n-                    break;\n-                case Token.SHNE:\n-                case Token.NE:\n-                    result = false;\n-                    break;\n-                // We can only handle == and != here.\n-                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n-                // be converted to number.  The results are different depending on\n-                // whether it is a string, NaN or other number value.\n-                default:\n-                    return n;\n             }\n             break;\n         case Token.STRING:\n@@ -84,22 +104,35 @@\n                 result = compareToUndefined(left, op);\n                 break;\n             }\n-            if (Token.STRING != right.getType()) {\n-                // Only eval if they are the same type\n+            if (rightLiteral && rhType == Token.STRING) {\n+                switch (op) {\n+                    case Token.SHEQ:\n+                    case Token.EQ:\n+                        result = left.getString().equals(right.getString());\n+                        break;\n+                    case Token.SHNE:\n+                    case Token.NE:\n+                        result = !left.getString().equals(right.getString());\n+                        break;\n+                    case Token.GE:\n+                    case Token.GT:\n+                    case Token.LE:\n+                    case Token.LT:\n+                        // Handle numeric compares with strings stored as literals\n+                        // or named values.\n+                        Boolean compareResult = compareAsNumbers(op, left, right);\n+                        if (compareResult != null) {\n+                            result = compareResult;\n+                        } else {\n+                            return n;\n+                        }\n+                        break;\n+                    default:\n+                        // we only handle == and != here\n+                        return n;\n+                }\n+            } else {\n                 return n;\n-            }\n-            switch(op) {\n-                case Token.SHEQ:\n-                case Token.EQ:\n-                    result = left.getString().equals(right.getString());\n-                    break;\n-                case Token.SHNE:\n-                case Token.NE:\n-                    result = !left.getString().equals(right.getString());\n-                    break;\n-                default:\n-                    // we only handle == and != here\n-                    return n;\n             }\n             break;\n         case Token.NUMBER:\n@@ -107,53 +140,32 @@\n                 result = compareToUndefined(left, op);\n                 break;\n             }\n-            if (Token.NUMBER != right.getType()) {\n-                // Only eval if they are the same type\n+            if (rightLiteral && (rhType == Token.NUMBER)) {\n+                Boolean compareResult = compareAsNumbers(op, left, right);\n+                if (compareResult != null) {\n+                    result = compareResult;\n+                } else {\n+                    return n;\n+                }\n+            } else if (right.getType() == Token.NAME && right.getString().equals(\"NaN\")) {\n+                switch (op) {\n+                    case Token.SHEQ:\n+                    case Token.EQ:\n+                        result = false;\n+                        break;\n+                    case Token.SHNE:\n+                    case Token.NE:\n+                        result = true;\n+                        break;\n+                    default:\n+                        return n;\n+                }\n+            } else {\n                 return n;\n-            }\n-            Boolean compareResult = compareAsNumbers(op, left, right);\n-            if (compareResult != null) {\n-                result = compareResult;\n-            } else {\n-                return null;\n-            }\n-            break;\n-        case Token.NAME:\n-            if (undefinedRight) {\n-                result = compareToUndefined(left, op);\n-                break;\n-            }\n-            if (rightLiteral) {\n-                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n-                if (undefinedLeft) {\n-                    result = compareToUndefined(right, op);\n-                    break;\n-                }\n-            }\n-            if (Token.NAME != right.getType()) {\n-                // Only eval if they are the same type\n-                return n;\n-            }\n-            String ln = left.getString();\n-            String rn = right.getString();\n-            if (!ln.equals(rn)) {\n-                // Not the same value name.\n-                return n;\n-            }\n-            switch(op) {\n-                // If we knew the named value wouldn't be NaN, it would be nice\n-                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n-                case Token.LT:\n-                case Token.GT:\n-                    result = false;\n-                    break;\n-                default:\n-                    // don't handle that op\n-                    return n;\n             }\n             break;\n         default:\n-            // assert, this should cover all consts\n+            // assert, this shouldn't happen\n             return n;\n     }\n     Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            }\n            if (!rightLiteral) {\n                result = compareToUndefined(right, op);\n            } else {\n                result = compareToUndefined(left, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n            } else if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            else{\n                result = compareLiteral(op, left, right);\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (!rightLiteral || Token.STRING != right.getType()) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n            } else if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            else{\n                result = compareLiteral(op, left, right);\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}\n\n// Helper function to compare two literals and return the comparison result\nprivate boolean compareLiteral(int op, Node left, Node right){\n    switch(op) {\n        case Token.SHEQ:\n        case Token.EQ:\n            return left.equals(right);\n        case Token.SHNE:\n        case Token.NE:\n            return !left.equals(right);\n        case Token.GE:\n        case Token.LE:\n        case Token.GT:\n        case Token.LT:\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                return compareResult;\n            } else {\n                return false;\n            }\n        default:\n            // we only handle == and != here\n            return false;\n    }\n}\n\n// Helper function to compare a node with undefined\nprivate boolean compareToUndefined(Node node, int op){\n    switch(op) {\n        case Token.SHEQ:\n        case Token.EQ:\n            return (node.getType() == Token.NULL) || (node.getType() == Token.NAME && node.getString().equals(\"undefined\")) || (Token.VOID == node.getType() && NodeUtil.isLiteralValue(node.getFirstChild(), false));\n        case Token.SHNE:\n        case Token.NE:\n            return (node.getType() != Token.NULL) && !(node.getType() == Token.NAME && node.getString().equals(\"undefined\")) && !(Token.VOID == node.getType() && NodeUtil.isLiteralValue(node.getFirstChild(), false));\n        default:\n            return false;\n    }\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -17,10 +17,11 @@\n         case Token.VOID:\n             if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                 return n;\n-            } else if (!rightLiteral) {\n-                return n;\n+            }\n+            if (!rightLiteral) {\n+                result = compareToUndefined(right, op);\n             } else {\n-                result = compareToUndefined(right, op);\n+                result = compareToUndefined(left, op);\n             }\n             break;\n         case Token.NULL:\n@@ -28,34 +29,11 @@\n         case Token.FALSE:\n             if (undefinedRight) {\n                 result = compareToUndefined(left, op);\n-                break;\n-            }\n-            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n+            } else if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                 return n;\n             }\n-            switch(op) {\n-                case Token.SHEQ:\n-                case Token.EQ:\n-                    result = lhType == rhType;\n-                    break;\n-                case Token.SHNE:\n-                case Token.NE:\n-                    result = lhType != rhType;\n-                    break;\n-                case Token.GE:\n-                case Token.LE:\n-                case Token.GT:\n-                case Token.LT:\n-                    Boolean compareResult = compareAsNumbers(op, left, right);\n-                    if (compareResult != null) {\n-                        result = compareResult;\n-                    } else {\n-                        return n;\n-                    }\n-                    break;\n-                default:\n-                    // we only handle == and != here\n-                    return n;\n+            else{\n+                result = compareLiteral(op, left, right);\n             }\n             break;\n         case Token.THIS:\n@@ -80,12 +58,7 @@\n             }\n             break;\n         case Token.STRING:\n-            if (undefinedRight) {\n-                result = compareToUndefined(left, op);\n-                break;\n-            }\n-            if (Token.STRING != right.getType()) {\n-                // Only eval if they are the same type\n+            if (!rightLiteral || Token.STRING != right.getType()) {\n                 return n;\n             }\n             switch(op) {\n@@ -105,17 +78,12 @@\n         case Token.NUMBER:\n             if (undefinedRight) {\n                 result = compareToUndefined(left, op);\n-                break;\n-            }\n-            if (Token.NUMBER != right.getType()) {\n+            } else if (Token.NUMBER != right.getType()) {\n                 // Only eval if they are the same type\n                 return n;\n             }\n-            Boolean compareResult = compareAsNumbers(op, left, right);\n-            if (compareResult != null) {\n-                result = compareResult;\n-            } else {\n-                return null;\n+            else{\n+                result = compareLiteral(op, left, right);\n             }\n             break;\n         case Token.NAME:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result = false; //set default result to false\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return null;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -7,7 +7,7 @@\n         }\n     }\n     int op = n.getType();\n-    boolean result;\n+    boolean result = false; //set default result to false\n     // TODO(johnlenz): Use the JSType to compare nodes of different types.\n     boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n     boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -115,7 +115,7 @@\n             if (compareResult != null) {\n                 result = compareResult;\n             } else {\n-                return null;\n+                return n;\n             }\n             break;\n         case Token.NAME:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = result ? NodeUtil.newBoolean(true) : NodeUtil.newBoolean(false);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -115,7 +115,7 @@\n             if (compareResult != null) {\n                 result = compareResult;\n             } else {\n-                return null;\n+                return n;\n             }\n             break;\n         case Token.NAME:\n@@ -156,7 +156,7 @@\n             // assert, this should cover all consts\n             return n;\n     }\n-    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n+    Node newNode = result ? NodeUtil.newBoolean(true) : NodeUtil.newBoolean(false);\n     n.getParent().replaceChild(n, newNode);\n     reportCodeChange();\n     return newNode;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType() && Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType() && Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -107,7 +107,7 @@\n                 result = compareToUndefined(left, op);\n                 break;\n             }\n-            if (Token.NUMBER != right.getType()) {\n+            if (Token.NUMBER != right.getType() && Token.NAME != right.getType()) {\n                 // Only eval if they are the same type\n                 return n;\n             }\n@@ -115,7 +115,7 @@\n             if (compareResult != null) {\n                 result = compareResult;\n             } else {\n-                return null;\n+                return n;\n             }\n             break;\n         case Token.NAME:\n@@ -130,7 +130,7 @@\n                     break;\n                 }\n             }\n-            if (Token.NAME != right.getType()) {\n+            if (Token.NAME != right.getType() && Token.NUMBER != right.getType()) {\n                 // Only eval if they are the same type\n                 return n;\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = (left.getType() == right.getType());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = (left.getType() != right.getType());\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.STRING) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.NUMBER) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return null;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (rhType != Token.NAME) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -36,11 +36,11 @@\n             switch(op) {\n                 case Token.SHEQ:\n                 case Token.EQ:\n-                    result = lhType == rhType;\n+                    result = (left.getType() == right.getType());\n                     break;\n                 case Token.SHNE:\n                 case Token.NE:\n-                    result = lhType != rhType;\n+                    result = (left.getType() != right.getType());\n                     break;\n                 case Token.GE:\n                 case Token.LE:\n@@ -84,7 +84,7 @@\n                 result = compareToUndefined(left, op);\n                 break;\n             }\n-            if (Token.STRING != right.getType()) {\n+            if (rhType != Token.STRING) {\n                 // Only eval if they are the same type\n                 return n;\n             }\n@@ -107,7 +107,7 @@\n                 result = compareToUndefined(left, op);\n                 break;\n             }\n-            if (Token.NUMBER != right.getType()) {\n+            if (rhType != Token.NUMBER) {\n                 // Only eval if they are the same type\n                 return n;\n             }\n@@ -130,7 +130,7 @@\n                     break;\n                 }\n             }\n-            if (Token.NAME != right.getType()) {\n+            if (rhType != Token.NAME) {\n                 // Only eval if they are the same type\n                 return n;\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != lhType && (rhType != Token.NULL || lhType == Token.TRUE || op != Token.EQ && op != Token.SHEQ)) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getBoolean() == right.getBoolean();\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = left.getBoolean() != right.getBoolean();\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return null;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -30,17 +30,17 @@\n                 result = compareToUndefined(left, op);\n                 break;\n             }\n-            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n+            if (rhType != lhType && (rhType != Token.NULL || lhType == Token.TRUE || op != Token.EQ && op != Token.SHEQ)) {\n                 return n;\n             }\n             switch(op) {\n                 case Token.SHEQ:\n                 case Token.EQ:\n-                    result = lhType == rhType;\n+                    result = left.getBoolean() == right.getBoolean();\n                     break;\n                 case Token.SHNE:\n                 case Token.NE:\n-                    result = lhType != rhType;\n+                    result = left.getBoolean() != right.getBoolean();\n                     break;\n                 case Token.GE:\n                 case Token.LE:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                // Add missing cases for gte and lte\n                case Token.GE:\n                case Token.LE:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -115,7 +115,7 @@\n             if (compareResult != null) {\n                 result = compareResult;\n             } else {\n-                return null;\n+                return n;\n             }\n             break;\n         case Token.NAME:\n@@ -145,6 +145,9 @@\n                 // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                 case Token.LT:\n                 case Token.GT:\n+                // Add missing cases for gte and lte\n+                case Token.GE:\n+                case Token.LE:\n                     result = false;\n                     break;\n                 default:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.replaceWith(newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -115,7 +115,7 @@\n             if (compareResult != null) {\n                 result = compareResult;\n             } else {\n-                return null;\n+                return n;\n             }\n             break;\n         case Token.NAME:\n@@ -157,7 +157,7 @@\n             return n;\n     }\n     Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n-    n.getParent().replaceChild(n, newNode);\n+    n.replaceWith(newNode);\n     reportCodeChange();\n     return newNode;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        // Return the node itself instead of null.\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                // Return the node itself instead of null.\n                return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -50,6 +50,7 @@\n                     if (compareResult != null) {\n                         result = compareResult;\n                     } else {\n+                        // Return the node itself instead of null.\n                         return n;\n                     }\n                     break;\n@@ -115,7 +116,8 @@\n             if (compareResult != null) {\n                 result = compareResult;\n             } else {\n-                return null;\n+                // Return the node itself instead of null.\n+                return n;\n             }\n             break;\n         case Token.NAME:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = IR.bool(result);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -115,7 +115,7 @@\n             if (compareResult != null) {\n                 result = compareResult;\n             } else {\n-                return null;\n+                return n;\n             }\n             break;\n         case Token.NAME:\n@@ -156,7 +156,7 @@\n             // assert, this should cover all consts\n             return n;\n     }\n-    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n+    Node newNode = IR.bool(result);\n     n.getParent().replaceChild(n, newNode);\n     reportCodeChange();\n     return newNode;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch (lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch (op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    // Only compare numbers if both operands are numbers\n                    if (lhType != rhType || lhType != Token.NUMBER) {\n                        return n;\n                    }\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch (op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch (op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return null;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch (op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.replaceWith(newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -13,7 +13,7 @@\n     boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n     int lhType = left.getType();\n     int rhType = right.getType();\n-    switch(lhType) {\n+    switch (lhType) {\n         case Token.VOID:\n             if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                 return n;\n@@ -33,7 +33,7 @@\n             if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                 return n;\n             }\n-            switch(op) {\n+            switch (op) {\n                 case Token.SHEQ:\n                 case Token.EQ:\n                     result = lhType == rhType;\n@@ -46,6 +46,10 @@\n                 case Token.LE:\n                 case Token.GT:\n                 case Token.LT:\n+                    // Only compare numbers if both operands are numbers\n+                    if (lhType != rhType || lhType != Token.NUMBER) {\n+                        return n;\n+                    }\n                     Boolean compareResult = compareAsNumbers(op, left, right);\n                     if (compareResult != null) {\n                         result = compareResult;\n@@ -62,7 +66,7 @@\n             if (right.getType() != Token.THIS) {\n                 return n;\n             }\n-            switch(op) {\n+            switch (op) {\n                 case Token.SHEQ:\n                 case Token.EQ:\n                     result = true;\n@@ -88,7 +92,7 @@\n                 // Only eval if they are the same type\n                 return n;\n             }\n-            switch(op) {\n+            switch (op) {\n                 case Token.SHEQ:\n                 case Token.EQ:\n                     result = left.getString().equals(right.getString());\n@@ -140,7 +144,7 @@\n                 // Not the same value name.\n                 return n;\n             }\n-            switch(op) {\n+            switch (op) {\n                 // If we knew the named value wouldn't be NaN, it would be nice\n                 // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                 case Token.LT:\n@@ -157,7 +161,7 @@\n             return n;\n     }\n     Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n-    n.getParent().replaceChild(n, newNode);\n+    n.replaceWith(newNode);\n     reportCodeChange();\n     return newNode;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch (lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch (op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n        case Token.STRING:\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (!NodeUtil.isLiteralValue(right, false)) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch (op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.isEquivalentTo(right);\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.isEquivalentTo(right);\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch (op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -13,7 +13,7 @@\n     boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n     int lhType = left.getType();\n     int rhType = right.getType();\n-    switch(lhType) {\n+    switch (lhType) {\n         case Token.VOID:\n             if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                 return n;\n@@ -33,7 +33,7 @@\n             if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                 return n;\n             }\n-            switch(op) {\n+            switch (op) {\n                 case Token.SHEQ:\n                 case Token.EQ:\n                     result = lhType == rhType;\n@@ -59,63 +59,28 @@\n             }\n             break;\n         case Token.THIS:\n-            if (right.getType() != Token.THIS) {\n-                return n;\n-            }\n-            switch(op) {\n-                case Token.SHEQ:\n-                case Token.EQ:\n-                    result = true;\n-                    break;\n-                case Token.SHNE:\n-                case Token.NE:\n-                    result = false;\n-                    break;\n-                // We can only handle == and != here.\n-                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n-                // be converted to number.  The results are different depending on\n-                // whether it is a string, NaN or other number value.\n-                default:\n-                    return n;\n-            }\n-            break;\n         case Token.STRING:\n-            if (undefinedRight) {\n-                result = compareToUndefined(left, op);\n-                break;\n-            }\n-            if (Token.STRING != right.getType()) {\n-                // Only eval if they are the same type\n-                return n;\n-            }\n-            switch(op) {\n-                case Token.SHEQ:\n-                case Token.EQ:\n-                    result = left.getString().equals(right.getString());\n-                    break;\n-                case Token.SHNE:\n-                case Token.NE:\n-                    result = !left.getString().equals(right.getString());\n-                    break;\n-                default:\n-                    // we only handle == and != here\n-                    return n;\n-            }\n-            break;\n         case Token.NUMBER:\n             if (undefinedRight) {\n                 result = compareToUndefined(left, op);\n                 break;\n             }\n-            if (Token.NUMBER != right.getType()) {\n+            if (!NodeUtil.isLiteralValue(right, false)) {\n                 // Only eval if they are the same type\n                 return n;\n             }\n-            Boolean compareResult = compareAsNumbers(op, left, right);\n-            if (compareResult != null) {\n-                result = compareResult;\n-            } else {\n-                return null;\n+            switch (op) {\n+                case Token.SHEQ:\n+                case Token.EQ:\n+                    result = left.isEquivalentTo(right);\n+                    break;\n+                case Token.SHNE:\n+                case Token.NE:\n+                    result = !left.isEquivalentTo(right);\n+                    break;\n+                default:\n+                    // we only handle == and != here\n+                    return n;\n             }\n             break;\n         case Token.NAME:\n@@ -140,7 +105,7 @@\n                 // Not the same value name.\n                 return n;\n             }\n-            switch(op) {\n+            switch (op) {\n                 // If we knew the named value wouldn't be NaN, it would be nice\n                 // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                 case Token.LT:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != lhType) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return null;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -30,17 +30,17 @@\n                 result = compareToUndefined(left, op);\n                 break;\n             }\n-            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n+            if (rhType != lhType) {\n                 return n;\n             }\n             switch(op) {\n                 case Token.SHEQ:\n                 case Token.EQ:\n-                    result = lhType == rhType;\n+                    result = true;\n                     break;\n                 case Token.SHNE:\n                 case Token.NE:\n-                    result = lhType != rhType;\n+                    result = false;\n                     break;\n                 case Token.GE:\n                 case Token.LE:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return n;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            } else {\n                boolean leftLiteral = NodeUtil.isLiteralValue(left, false);\n                if (leftLiteral) {\n                    boolean undefinedRight = (right.getString().equals(\"undefined\"));\n                    if (undefinedRight) {\n                        result = compareToUndefined(left, op);\n                        break;\n                     }\n                } \n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -115,7 +115,7 @@\n             if (compareResult != null) {\n                 result = compareResult;\n             } else {\n-                return null;\n+                return n;\n             }\n             break;\n         case Token.NAME:\n@@ -129,6 +129,15 @@\n                     result = compareToUndefined(right, op);\n                     break;\n                 }\n+            } else {\n+                boolean leftLiteral = NodeUtil.isLiteralValue(left, false);\n+                if (leftLiteral) {\n+                    boolean undefinedRight = (right.getString().equals(\"undefined\"));\n+                    if (undefinedRight) {\n+                        result = compareToUndefined(left, op);\n+                        break;\n+                     }\n+                } \n             }\n             if (Token.NAME != right.getType()) {\n                 // Only eval if they are the same type\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\n        // We only handle non-literal operands for LT and GT.\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\n            return n;\n        }\n    }\n    int op = n.getType();\n    boolean result;\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); \n    int lhType = left.getType();\n    int rhType = right.getType();\n    switch(lhType) {\n        case Token.VOID:\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n                return n;\n            } else if (!rightLiteral) {\n                return n;\n            } else {\n                result = compareToUndefined(right, op);\n            }\n            break;\n        case Token.NULL:\n        case Token.TRUE:\n        case Token.FALSE:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rhType != lhType && (parseFloat(left.getString()) == null || parseFloat(right.getString()) == null)) { // Handle NaN comparison\n                if (op == Token.GE || op == Token.LE || op == Token.GT || op == Token.LT) {\n                    if(lhType == Token.TRUE || lhType == Token.FALSE){\n                        result = compareBooleans(lhType == Token.TRUE, rhType == Token.TRUE, op);\n                    } else if(lhType == Token.NULL) {\n                        result = compareNull(lhType, rhType, op);\n                    } else {\n                        result = false;\n                    }\n                } else {\n                    return n;\n                }\n                break;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = lhType == rhType;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = lhType != rhType;\n                    break;\n                case Token.GE:\n                case Token.LE:\n                case Token.GT:\n                case Token.LT:\n                    Boolean compareResult = compareAsNumbers(op, left, right);\n                    if (compareResult != null) {\n                        result = compareResult;\n                    } else {\n                        return n;\n                    }\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.THIS:\n            if (right.getType() != Token.THIS) {\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = true;\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = false;\n                    break;\n                // We can only handle == and != here.\n                // GT, LT, GE, LE depend on the type of \"this\" and how it will\n                // be converted to number.  The results are different depending on\n                // whether it is a string, NaN or other number value.\n                default:\n                    return n;\n            }\n            break;\n        case Token.STRING:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.STRING != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            switch(op) {\n                case Token.SHEQ:\n                case Token.EQ:\n                    result = left.getString().equals(right.getString());\n                    break;\n                case Token.SHNE:\n                case Token.NE:\n                    result = !left.getString().equals(right.getString());\n                    break;\n                default:\n                    // we only handle == and != here\n                    return n;\n            }\n            break;\n        case Token.NUMBER:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (Token.NUMBER != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n                result = compareResult;\n            } else {\n                return null;\n            }\n            break;\n        case Token.NAME:\n            if (undefinedRight) {\n                result = compareToUndefined(left, op);\n                break;\n            }\n            if (rightLiteral) {\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n                if (undefinedLeft) {\n                    result = compareToUndefined(right, op);\n                    break;\n                }\n            }\n            if (Token.NAME != right.getType()) {\n                // Only eval if they are the same type\n                return n;\n            }\n            String ln = left.getString();\n            String rn = right.getString();\n            if (!ln.equals(rn)) {\n                // Not the same value name.\n                return n;\n            }\n            switch(op) {\n                // If we knew the named value wouldn't be NaN, it would be nice\n                // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n                case Token.LT:\n                case Token.GT:\n                    result = false;\n                    break;\n                default:\n                    // don't handle that op\n                    return n;\n            }\n            break;\n        default:\n            // assert, this should cover all consts\n            return n;\n    }\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldComparison\n@@ -10,7 +10,7 @@\n     boolean result;\n     // TODO(johnlenz): Use the JSType to compare nodes of different types.\n     boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n-    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n+    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))); \n     int lhType = left.getType();\n     int rhType = right.getType();\n     switch(lhType) {\n@@ -30,8 +30,19 @@\n                 result = compareToUndefined(left, op);\n                 break;\n             }\n-            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\n-                return n;\n+            if (rhType != lhType && (parseFloat(left.getString()) == null || parseFloat(right.getString()) == null)) { // Handle NaN comparison\n+                if (op == Token.GE || op == Token.LE || op == Token.GT || op == Token.LT) {\n+                    if(lhType == Token.TRUE || lhType == Token.FALSE){\n+                        result = compareBooleans(lhType == Token.TRUE, rhType == Token.TRUE, op);\n+                    } else if(lhType == Token.NULL) {\n+                        result = compareNull(lhType, rhType, op);\n+                    } else {\n+                        result = false;\n+                    }\n+                } else {\n+                    return n;\n+                }\n+                break;\n             }\n             switch(op) {\n                 case Token.SHEQ:\n", "finish_reason": "stop", "valid": false, "num": 1}]