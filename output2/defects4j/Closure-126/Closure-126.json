[{"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n                if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    Node prevChild = null; // added for fix\n    for (Node c : n.children()) {\n        // Fix: skip if c is the last child and has no children\n        if (c == n.getLastChild() && !c.hasChildren()) {\n            continue;\n        }\n        // Fix: If prevChild is an IF, skip since it was already processed\n        if (prevChild != null && prevChild.isIf()) {\n            prevChild = c;\n            continue;\n        }\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n            prevChild = c; // added for fix\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -45,7 +45,17 @@\n     // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n     // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n     // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n+    Node prevChild = null; // added for fix\n     for (Node c : n.children()) {\n+        // Fix: skip if c is the last child and has no children\n+        if (c == n.getLastChild() && !c.hasChildren()) {\n+            continue;\n+        }\n+        // Fix: If prevChild is an IF, skip since it was already processed\n+        if (prevChild != null && prevChild.isIf()) {\n+            prevChild = c;\n+            continue;\n+        }\n         // An 'if' block to process below.\n         if (c.isIf()) {\n             Node ifTree = c;\n@@ -61,9 +71,7 @@\n             if (falseBlock != null) {\n                 tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n             }\n-        }\n-        if (c == n.getLastChild()) {\n-            break;\n+            prevChild = c; // added for fix\n         }\n     }\n     // Now try to minimize the exits of the last child, if it is removed\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    List<Node> children = new ArrayList<>(n.children());\n    for (int i = 0; i < children.size(); i++) {\n        Node c = children.get(i);\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -26,7 +26,7 @@\n             Node catchCodeBlock = catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n+        if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock = n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n@@ -45,7 +45,9 @@\n     // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n     // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n     // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n+    List<Node> children = new ArrayList<>(n.children());\n+    for (int i = 0; i < children.size(); i++) {\n+        Node c = children.get(i);\n         // An 'if' block to process below.\n         if (c.isIf()) {\n             Node ifTree = c;\n@@ -62,9 +64,6 @@\n                 tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n             }\n         }\n-        if (c == n.getLastChild()) {\n-            break;\n-        }\n     }\n     // Now try to minimize the exits of the last child, if it is removed\n     // look at what has become the last child.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getFirstChild(); //fixed to get into the catch block\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n                if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -23,7 +23,7 @@\n         if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n             Preconditions.checkState(allCatchNodes.hasOneChild());\n             Node catchNode = allCatchNodes.getFirstChild();\n-            Node catchCodeBlock = catchNode.getLastChild();\n+            Node catchCodeBlock = catchNode.getFirstChild(); //fixed to get into the catch block\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n                 if (NodeUtil.hasFinally(n)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n                if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n            // Check if the entire if statement can be removed\n            if (ifTree.getFirstChild().getBooleanProp(Node.SKIP_MINIMIZE)) {\n                NodeUtil.removeChild(n, ifTree);\n                // Restart at the beginning of the block, since there may be other conditionals that need to be processed\n                tryMinimizeExits(n, exitType, labelName);\n                return;\n            }\n        }\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -61,6 +61,13 @@\n             if (falseBlock != null) {\n                 tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n             }\n+            // Check if the entire if statement can be removed\n+            if (ifTree.getFirstChild().getBooleanProp(Node.SKIP_MINIMIZE)) {\n+                NodeUtil.removeChild(n, ifTree);\n+                // Restart at the beginning of the block, since there may be other conditionals that need to be processed\n+                tryMinimizeExits(n, exitType, labelName);\n+                return;\n+            }\n         }\n         if (c == n.getLastChild()) {\n             break;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node catchBlock = NodeUtil.getCatchBlock(n);\n        if (catchBlock != null) {\n            Preconditions.checkState(catchBlock.hasOneChild());\n            Node catchCodeBlock = catchBlock.getFirstChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = NodeUtil.getFinallyBlock(n);\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n        return;\n    }\n    // The rest assumes a block with at least one child.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock = ifTree.getFirstChild().getNext();\n            Node falseBlock = trueBlock.getNext();\n\n            // Fix the true block.\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n\n            // Fix the else block only if it exists.\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n\n        // Recurse on this child of n.\n        tryMinimizeExits(c, exitType, labelName);\n\n        // Once the child is processed it may go away and be replaced\n        // with the next sibling, so only continue if c is still a child of n.\n        if (c.getParent() != n) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -19,15 +19,14 @@\n     if (n.isTry()) {\n         Node tryBlock = n.getFirstChild();\n         tryMinimizeExits(tryBlock, exitType, labelName);\n-        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n-        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n-            Preconditions.checkState(allCatchNodes.hasOneChild());\n-            Node catchNode = allCatchNodes.getFirstChild();\n-            Node catchCodeBlock = catchNode.getLastChild();\n+        Node catchBlock = NodeUtil.getCatchBlock(n);\n+        if (catchBlock != null) {\n+            Preconditions.checkState(catchBlock.hasOneChild());\n+            Node catchCodeBlock = catchBlock.getFirstChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n-            Node finallyBlock = n.getLastChild();\n+        if (NodeUtil.hasFinally(n)) {\n+            Node finallyBlock = NodeUtil.getFinallyBlock(n);\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n     }\n@@ -35,9 +34,9 @@\n     if (n.isLabel()) {\n         Node labelBlock = n.getLastChild();\n         tryMinimizeExits(labelBlock, exitType, labelName);\n+        return;\n     }\n-    // TODO(johnlenz): The last case of SWITCH statement?\n-    // The rest assumes a block with at least one child, bail on anything else.\n+    // The rest assumes a block with at least one child.\n     if (!n.isBlock() || n.getLastChild() == null) {\n         return;\n     }\n@@ -49,29 +48,24 @@\n         // An 'if' block to process below.\n         if (c.isIf()) {\n             Node ifTree = c;\n-            Node trueBlock, falseBlock;\n-            // First, the true condition block.\n-            trueBlock = ifTree.getFirstChild().getNext();\n-            falseBlock = trueBlock.getNext();\n+            Node trueBlock = ifTree.getFirstChild().getNext();\n+            Node falseBlock = trueBlock.getNext();\n+\n+            // Fix the true block.\n             tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n-            // Now the else block.\n-            // The if blocks may have changed, get them again.\n-            trueBlock = ifTree.getFirstChild().getNext();\n-            falseBlock = trueBlock.getNext();\n+\n+            // Fix the else block only if it exists.\n             if (falseBlock != null) {\n                 tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n             }\n         }\n-        if (c == n.getLastChild()) {\n-            break;\n-        }\n-    }\n-    // Now try to minimize the exits of the last child, if it is removed\n-    // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n+\n+        // Recurse on this child of n.\n         tryMinimizeExits(c, exitType, labelName);\n-        // If the node is still the last child, we are done.\n-        if (c == n.getLastChild()) {\n+\n+        // Once the child is processed it may go away and be replaced\n+        // with the next sibling, so only continue if c is still a child of n.\n+        if (c.getParent() != n) {\n             break;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    int childCount = n.getChildCount();\n    for (int i = childCount - 1; i >= 0; i--) {\n        Node c = n.getChildAtIndex(i);\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the child at this index, we are done.\n        if (c == n.getChildAtIndex(i)) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -26,7 +26,7 @@\n             Node catchCodeBlock = catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n+        if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock = n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n@@ -68,10 +68,12 @@\n     }\n     // Now try to minimize the exits of the last child, if it is removed\n     // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n+    int childCount = n.getChildCount();\n+    for (int i = childCount - 1; i >= 0; i--) {\n+        Node c = n.getChildAtIndex(i);\n         tryMinimizeExits(c, exitType, labelName);\n-        // If the node is still the last child, we are done.\n-        if (c == n.getLastChild()) {\n+        // If the node is still the child at this index, we are done.\n+        if (c == n.getChildAtIndex(i)) {\n             break;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getNext();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    NodeList children = n.children();\n    for (int i = 0; i < children.getLength(); i++) {\n        Node c = children.item(i);\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null;) {\n        Node prev = c.getPrevious();\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n        c = prev;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -26,8 +26,8 @@\n             Node catchCodeBlock = catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n-            Node finallyBlock = n.getLastChild();\n+        if (NodeUtil.hasFinally(n)) {\n+            Node finallyBlock = n.getNext();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n     }\n@@ -36,7 +36,6 @@\n         Node labelBlock = n.getLastChild();\n         tryMinimizeExits(labelBlock, exitType, labelName);\n     }\n-    // TODO(johnlenz): The last case of SWITCH statement?\n     // The rest assumes a block with at least one child, bail on anything else.\n     if (!n.isBlock() || n.getLastChild() == null) {\n         return;\n@@ -45,7 +44,9 @@\n     // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n     // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n     // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n+    NodeList children = n.children();\n+    for (int i = 0; i < children.getLength(); i++) {\n+        Node c = children.item(i);\n         // An 'if' block to process below.\n         if (c.isIf()) {\n             Node ifTree = c;\n@@ -68,11 +69,13 @@\n     }\n     // Now try to minimize the exits of the last child, if it is removed\n     // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n+    for (Node c = n.getLastChild(); c != null;) {\n+        Node prev = c.getPrevious();\n         tryMinimizeExits(c, exitType, labelName);\n         // If the node is still the last child, we are done.\n         if (c == n.getLastChild()) {\n             break;\n         }\n+        c = prev;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah) {} else { if (blah2) {} else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -26,7 +26,7 @@\n             Node catchCodeBlock = catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n+        if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock = n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n@@ -43,7 +43,7 @@\n     }\n     // Multiple if-exits can be converted in a single pass.\n     // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n-    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n+    // become \"if (blah) {} else { if (blah2) {} else { other_stmt; } }\"\n     // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n     for (Node c : n.children()) {\n         // An 'if' block to process below.\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n                if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c.getNext() == null) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = c.getPrevious()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -62,13 +62,13 @@\n                 tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n             }\n         }\n-        if (c == n.getLastChild()) {\n+        if (c.getNext() == null) {\n             break;\n         }\n     }\n     // Now try to minimize the exits of the last child, if it is removed\n     // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n+    for (Node c = n.getLastChild(); c != null; c = c.getPrevious()) {\n         tryMinimizeExits(c, exitType, labelName);\n         // If the node is still the last child, we are done.\n         if (c == n.getLastChild()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // The last case of SWITCH statement.\n    if (n.isSwitch()) {\n        for (Node c = n.getFirstChild().getNext(); c != null; c = c.getNext()) {\n            Node caseBlock = c.getLastChild();\n            tryMinimizeExits(caseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -26,7 +26,7 @@\n             Node catchCodeBlock = catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n+        if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock = n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n@@ -36,7 +36,14 @@\n         Node labelBlock = n.getLastChild();\n         tryMinimizeExits(labelBlock, exitType, labelName);\n     }\n-    // TODO(johnlenz): The last case of SWITCH statement?\n+    // The last case of SWITCH statement.\n+    if (n.isSwitch()) {\n+        for (Node c = n.getFirstChild().getNext(); c != null; c = c.getNext()) {\n+            Node caseBlock = c.getLastChild();\n+            tryMinimizeExits(caseBlock, exitType, labelName);\n+        }\n+        return;\n+    }\n     // The rest assumes a block with at least one child, bail on anything else.\n     if (!n.isBlock() || n.getLastChild() == null) {\n         return;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        \n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n        return;\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n        return;\n    }\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -5,6 +5,7 @@\n         compiler.reportCodeChange();\n         return;\n     }\n+\n     // Just an 'if'.\n     if (n.isIf()) {\n         Node ifBlock = n.getFirstChild().getNext();\n@@ -15,6 +16,7 @@\n         }\n         return;\n     }\n+\n     // Just a 'try/catch/finally'.\n     if (n.isTry()) {\n         Node tryBlock = n.getFirstChild();\n@@ -26,21 +28,28 @@\n             Node catchCodeBlock = catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n+        \n+        if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock = n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n+        return;\n     }\n+\n     // Just a 'label'.\n     if (n.isLabel()) {\n         Node labelBlock = n.getLastChild();\n         tryMinimizeExits(labelBlock, exitType, labelName);\n+        return;\n     }\n-    // TODO(johnlenz): The last case of SWITCH statement?\n+\n     // The rest assumes a block with at least one child, bail on anything else.\n     if (!n.isBlock() || n.getLastChild() == null) {\n         return;\n     }\n+\n+    // TODO(johnlenz): The last case of SWITCH statement?\n+\n     // Multiple if-exits can be converted in a single pass.\n     // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n     // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n@@ -54,6 +63,7 @@\n             trueBlock = ifTree.getFirstChild().getNext();\n             falseBlock = trueBlock.getNext();\n             tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n+\n             // Now the else block.\n             // The if blocks may have changed, get them again.\n             trueBlock = ifTree.getFirstChild().getNext();\n@@ -62,10 +72,8 @@\n                 tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n             }\n         }\n-        if (c == n.getLastChild()) {\n-            break;\n-        }\n     }\n+\n     // Now try to minimize the exits of the last child, if it is removed\n     // look at what has become the last child.\n     for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (!blah && !blah2) { other_stmt; }\".\n    LinkedList<Node> nonExitStatements = new LinkedList<>();\n    boolean hasIfExitBlock = tryMinimizeIfBlockExits(n, nonExitStatements, exitType, labelName);\n    if (hasIfExitBlock) {\n        for (Node nonExit : nonExitStatements) {\n            NodeUtil.removeChild(n, nonExit);\n            NodeUtil.insertBefore(n.getLastChild(), nonExit);\n        }\n    }\n    // Try to minimize the exits of the last child,\n    // if it is removed look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}\n\n/**\n * Tries to minimize the exits of an if block.\n * Returns true if the block had an exit, false otherwise.\n */\nprivate boolean tryMinimizeIfBlockExits(Node n, LinkedList<Node> nonExitStatements, int exitType, String labelName) {\n    Preconditions.checkState(n.isBlock(), n);\n    if (n.hasChildren() && !n.getLastChild().isControlStructure()) {\n        nonExitStatements.add(n.getLastChild());\n        return false;\n    }\n    boolean hasIfExitBlock = false;\n    for (Node c : n.children()) {\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock = ifTree.getFirstChild().getNext();\n            Node falseBlock = trueBlock.getNext();\n            boolean trueBlockHasExit = tryMinimizeIfBlockExits(trueBlock, nonExitStatements, exitType, labelName);\n            boolean falseBlockHasExit = falseBlock != null && tryMinimizeIfBlockExits(falseBlock, nonExitStatements, exitType, labelName);\n            if (trueBlockHasExit || falseBlockHasExit) {\n                hasIfExitBlock = true;\n                if (falseBlock != null) {\n                    Node ifNode = IR.ifNode(ifTree.detachChildren());\n                    ifNode.useSourceInfoFromForTree(ifTree);\n                    n.replaceChild(c, ifNode);\n                    ifNode.getFirstChild().addChildToFront(falseBlock.detach());\n                    if (trueBlock.getLastChild().isControlStructure()) {\n                        nonExitStatements.add(trueBlock.getLastChild());\n                    }\n                    if (falseBlock.getLastChild().isControlStructure()) {\n                        nonExitStatements.add(falseBlock.getLastChild());\n                    }\n                    break;\n                }\n                else {\n                    // False block absent.\n                    Node ifNode = IR.ifNode(ifTree.detachChildren());\n                    ifNode.useSourceInfoFromForTree(ifTree);\n                    n.replaceChild(c, ifNode);\n                    if (trueBlock.getLastChild().isControlStructure()) {\n                        nonExitStatements.add(trueBlock.getLastChild());\n                    }\n                    break;\n                }\n            }\n        }\n        else if (matchingExitNode(c, exitType, labelName)) {\n            nonExitStatements.clear();\n            nonExitStatements.add(c);\n            hasIfExitBlock = true;\n            break;\n        }\n        else if (!c.isControlStructure()) {\n            nonExitStatements.add(c);\n        }\n    }\n    return hasIfExitBlock;\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -26,7 +26,7 @@\n             Node catchCodeBlock = catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n+        if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock = n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n@@ -43,31 +43,17 @@\n     }\n     // Multiple if-exits can be converted in a single pass.\n     // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n-    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n-    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n-        // An 'if' block to process below.\n-        if (c.isIf()) {\n-            Node ifTree = c;\n-            Node trueBlock, falseBlock;\n-            // First, the true condition block.\n-            trueBlock = ifTree.getFirstChild().getNext();\n-            falseBlock = trueBlock.getNext();\n-            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n-            // Now the else block.\n-            // The if blocks may have changed, get them again.\n-            trueBlock = ifTree.getFirstChild().getNext();\n-            falseBlock = trueBlock.getNext();\n-            if (falseBlock != null) {\n-                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n-            }\n-        }\n-        if (c == n.getLastChild()) {\n-            break;\n+    // become \"if (!blah && !blah2) { other_stmt; }\".\n+    LinkedList<Node> nonExitStatements = new LinkedList<>();\n+    boolean hasIfExitBlock = tryMinimizeIfBlockExits(n, nonExitStatements, exitType, labelName);\n+    if (hasIfExitBlock) {\n+        for (Node nonExit : nonExitStatements) {\n+            NodeUtil.removeChild(n, nonExit);\n+            NodeUtil.insertBefore(n.getLastChild(), nonExit);\n         }\n     }\n-    // Now try to minimize the exits of the last child, if it is removed\n-    // look at what has become the last child.\n+    // Try to minimize the exits of the last child,\n+    // if it is removed look at what has become the last child.\n     for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n         tryMinimizeExits(c, exitType, labelName);\n         // If the node is still the last child, we are done.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node finallyBlock = NodeUtil.getFinallyBlock(n);\n        if (finallyBlock != null) {\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n        Node catchNodes = NodeUtil.getCatchBlocks(n);\n        for (Node catchNode : catchNodes.children()) {\n            tryMinimizeExits(catchNode.getLastChild(), exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -19,16 +19,13 @@\n     if (n.isTry()) {\n         Node tryBlock = n.getFirstChild();\n         tryMinimizeExits(tryBlock, exitType, labelName);\n-        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n-        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n-            Preconditions.checkState(allCatchNodes.hasOneChild());\n-            Node catchNode = allCatchNodes.getFirstChild();\n-            Node catchCodeBlock = catchNode.getLastChild();\n-            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n+        Node finallyBlock = NodeUtil.getFinallyBlock(n);\n+        if (finallyBlock != null) {\n+            tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n-            Node finallyBlock = n.getLastChild();\n-            tryMinimizeExits(finallyBlock, exitType, labelName);\n+        Node catchNodes = NodeUtil.getCatchBlocks(n);\n+        for (Node catchNode : catchNodes.children()) {\n+            tryMinimizeExits(catchNode.getLastChild(), exitType, labelName);\n         }\n     }\n     // Just a 'label'.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n        return;\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -26,7 +26,7 @@\n             Node catchCodeBlock = catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n+        if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock = n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n@@ -35,6 +35,7 @@\n     if (n.isLabel()) {\n         Node labelBlock = n.getLastChild();\n         tryMinimizeExits(labelBlock, exitType, labelName);\n+        return;\n     }\n     // TODO(johnlenz): The last case of SWITCH statement?\n     // The rest assumes a block with at least one child, bail on anything else.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    Iterator<Node> iterator = n.children().iterator();\n    Node prev = null;\n    while (iterator.hasNext()) {\n        Node c = iterator.next();\n        if (c.isIf() && prev != null && prev.isIf()) {\n            // Merge if blocks\n            Node ifTree1 = prev;\n            Node ifTree2 = c;\n            Node trueBlock1 = ifTree1.getFirstChild().getNext();\n            Node falseBlock1 = trueBlock1.getNext();\n            Node trueBlock2 = ifTree2.getFirstChild().getNext();\n            Node falseBlock2 = trueBlock2.getNext();\n            Node trueBlock = IR.block();\n            Node falseBlock = IR.block();\n            // Build nested if block\n            ifTree1.replaceChild(falseBlock1, IR.ifNode(falseBlock1.detach(), trueBlock.detach()));\n            ifTree1.replaceChild(trueBlock1, IR.ifNode(trueBlock1.detach(), falseBlock));\n            // Merge true blocks\n            trueBlock.addChildToBack(trueBlock1.detach());\n            trueBlock.addChildToBack(trueBlock2.detach());\n            // Merge false blocks\n            if (falseBlock1.hasChildren() && falseBlock2.hasChildren()) {\n                Node tempTrue = IR.block();\n                Node tempFalse = IR.block();\n                tryMinimizeIfBlockExits(falseBlock1, falseBlock2, ifTree2, exitType, labelName);\n                tempTrue.addChildrenToFront(falseBlock1.removeChildren());\n                tempFalse.addChildrenToFront(falseBlock2.removeChildren());\n                falseBlock.addChildToBack(IR.ifNode(tempTrue.detach(), tempFalse.detach()));\n            } else if (falseBlock1.hasChildren()) {\n                falseBlock.addChildrenToFront(falseBlock1.removeChildren());\n            } else if (falseBlock2.hasChildren()) {\n                falseBlock.addChildrenToFront(falseBlock2.removeChildren());\n            }\n            NodeUtil.removeChild(n, ifTree2);\n            compiler.reportCodeChange();\n            c = ifTree1;\n            iterator = n.children().iterator();\n        }\n        tryMinimizeExits(c, exitType, labelName);\n        prev = c;\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -26,7 +26,7 @@\n             Node catchCodeBlock = catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n+        if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock = n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n@@ -45,34 +45,45 @@\n     // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n     // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n     // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n-        // An 'if' block to process below.\n-        if (c.isIf()) {\n-            Node ifTree = c;\n-            Node trueBlock, falseBlock;\n-            // First, the true condition block.\n-            trueBlock = ifTree.getFirstChild().getNext();\n-            falseBlock = trueBlock.getNext();\n-            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n-            // Now the else block.\n-            // The if blocks may have changed, get them again.\n-            trueBlock = ifTree.getFirstChild().getNext();\n-            falseBlock = trueBlock.getNext();\n-            if (falseBlock != null) {\n-                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n+    Iterator<Node> iterator = n.children().iterator();\n+    Node prev = null;\n+    while (iterator.hasNext()) {\n+        Node c = iterator.next();\n+        if (c.isIf() && prev != null && prev.isIf()) {\n+            // Merge if blocks\n+            Node ifTree1 = prev;\n+            Node ifTree2 = c;\n+            Node trueBlock1 = ifTree1.getFirstChild().getNext();\n+            Node falseBlock1 = trueBlock1.getNext();\n+            Node trueBlock2 = ifTree2.getFirstChild().getNext();\n+            Node falseBlock2 = trueBlock2.getNext();\n+            Node trueBlock = IR.block();\n+            Node falseBlock = IR.block();\n+            // Build nested if block\n+            ifTree1.replaceChild(falseBlock1, IR.ifNode(falseBlock1.detach(), trueBlock.detach()));\n+            ifTree1.replaceChild(trueBlock1, IR.ifNode(trueBlock1.detach(), falseBlock));\n+            // Merge true blocks\n+            trueBlock.addChildToBack(trueBlock1.detach());\n+            trueBlock.addChildToBack(trueBlock2.detach());\n+            // Merge false blocks\n+            if (falseBlock1.hasChildren() && falseBlock2.hasChildren()) {\n+                Node tempTrue = IR.block();\n+                Node tempFalse = IR.block();\n+                tryMinimizeIfBlockExits(falseBlock1, falseBlock2, ifTree2, exitType, labelName);\n+                tempTrue.addChildrenToFront(falseBlock1.removeChildren());\n+                tempFalse.addChildrenToFront(falseBlock2.removeChildren());\n+                falseBlock.addChildToBack(IR.ifNode(tempTrue.detach(), tempFalse.detach()));\n+            } else if (falseBlock1.hasChildren()) {\n+                falseBlock.addChildrenToFront(falseBlock1.removeChildren());\n+            } else if (falseBlock2.hasChildren()) {\n+                falseBlock.addChildrenToFront(falseBlock2.removeChildren());\n             }\n+            NodeUtil.removeChild(n, ifTree2);\n+            compiler.reportCodeChange();\n+            c = ifTree1;\n+            iterator = n.children().iterator();\n         }\n-        if (c == n.getLastChild()) {\n-            break;\n-        }\n-    }\n-    // Now try to minimize the exits of the last child, if it is removed\n-    // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n         tryMinimizeExits(c, exitType, labelName);\n-        // If the node is still the last child, we are done.\n-        if (c == n.getLastChild()) {\n-            break;\n-        }\n+        prev = c;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        n.detach();\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -1,7 +1,7 @@\n void tryMinimizeExits(Node n, int exitType, String labelName) {\n     // Just an 'exit'.\n     if (matchingExitNode(n, exitType, labelName)) {\n-        NodeUtil.removeChild(n.getParent(), n);\n+        n.detach();\n         compiler.reportCodeChange();\n         return;\n     }\n@@ -26,7 +26,7 @@\n             Node catchCodeBlock = catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n+        if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock = n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        n.detach();\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getSecondChild();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getSecondChild();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getSecondChild();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -1,13 +1,13 @@\n void tryMinimizeExits(Node n, int exitType, String labelName) {\n     // Just an 'exit'.\n     if (matchingExitNode(n, exitType, labelName)) {\n-        NodeUtil.removeChild(n.getParent(), n);\n+        n.detach();\n         compiler.reportCodeChange();\n         return;\n     }\n     // Just an 'if'.\n     if (n.isIf()) {\n-        Node ifBlock = n.getFirstChild().getNext();\n+        Node ifBlock = n.getSecondChild();\n         tryMinimizeExits(ifBlock, exitType, labelName);\n         Node elseBlock = ifBlock.getNext();\n         if (elseBlock != null) {\n@@ -26,7 +26,7 @@\n             Node catchCodeBlock = catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n+        if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock = n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n@@ -51,12 +51,12 @@\n             Node ifTree = c;\n             Node trueBlock, falseBlock;\n             // First, the true condition block.\n-            trueBlock = ifTree.getFirstChild().getNext();\n+            trueBlock = ifTree.getSecondChild();\n             falseBlock = trueBlock.getNext();\n             tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n             // Now the else block.\n             // The if blocks may have changed, get them again.\n-            trueBlock = ifTree.getFirstChild().getNext();\n+            trueBlock = ifTree.getSecondChild();\n             falseBlock = trueBlock.getNext();\n             if (falseBlock != null) {\n                 tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getFirstChild().getNext();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    // TODO(johnlenz): The last case of SWITCH statement?\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n        // An 'if' block to process below.\n        if (c.isIf()) {\n            Node ifTree = c;\n            Node trueBlock, falseBlock;\n            // First, the true condition block.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            // Now the else block.\n            // The if blocks may have changed, get them again.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n            if (falseBlock != null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n+++ com/google/javascript/jscomp/MinimizeExitPoints.java@tryMinimizeExits\n@@ -23,10 +23,10 @@\n         if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n             Preconditions.checkState(allCatchNodes.hasOneChild());\n             Node catchNode = allCatchNodes.getFirstChild();\n-            Node catchCodeBlock = catchNode.getLastChild();\n+            Node catchCodeBlock = catchNode.getFirstChild().getNext();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n-                if (NodeUtil.hasFinally(n)) {\n+        if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock = n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}]