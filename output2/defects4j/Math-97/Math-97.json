[{"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) < Function.EPSILON) {\n            return min;\n        } else if (Math.abs(yMax) < Function.EPSILON) {\n            return max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,14 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        if (Math.abs(yMin) < Function.EPSILON) {\n+            return min;\n+        } else if (Math.abs(yMax) < Function.EPSILON) {\n+            return max;\n+        } else {\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        // neither value is close to zero and min and max do not bracket root.\n        throw new FunctionEvaluationException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -9,7 +9,7 @@\n     if (sign >= 0) {\n         // check if either value is close to a zero\n         // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        throw new FunctionEvaluationException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        double tol = solver.getAbsoluteAccuracy();\n        if (Math.abs(yMin) <= tol || Math.abs(yMax) <= tol) {\n            ret = (Math.abs(yMin) < Math.abs(yMax)) ? min : max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,13 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        double tol = solver.getAbsoluteAccuracy();\n+        if (Math.abs(yMin) <= tol || Math.abs(yMax) <= tol) {\n+            ret = (Math.abs(yMin) < Math.abs(yMax)) ? min : max;\n+        } else {\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n            setResult(min);\n            return min;\n        } else if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n            setResult(max);\n            return max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,16 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n+            setResult(min);\n+            return min;\n+        } else if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n+            setResult(max);\n+            return max;\n+        } else {\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) < Function.EPSILON) {\n            return min;\n        }\n        if (Math.abs(yMax) < Function.EPSILON) {\n            return max;\n        }\n        // neither value is close to zero and min and max do not bracket root.\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,6 +8,12 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n+        if (Math.abs(yMin) < Function.EPSILON) {\n+            return min;\n+        }\n+        if (Math.abs(yMax) < Function.EPSILON) {\n+            return max;\n+        }\n         // neither value is close to zero and min and max do not bracket root.\n         throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) <= Function.EPSILON) {\n            ret = min;\n        } else if (Math.abs(yMax) <= Function.EPSILON) {\n            ret = max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,14 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        if (Math.abs(yMin) <= Function.EPSILON) {\n+            ret = min;\n+        } else if (Math.abs(yMax) <= Function.EPSILON) {\n+            ret = max;\n+        } else {\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        if(Math.abs(yMin) < Function.EPSILON){\n            ret = min;\n        } else if(Math.abs(yMax) < Function.EPSILON){\n            ret = max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,14 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        if(Math.abs(yMin) < Function.EPSILON){\n+            ret = min;\n+        } else if(Math.abs(yMax) < Function.EPSILON){\n+            ret = max;\n+        } else {\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) < Function.EPSILON) {\n            ret = min;\n        } else if (Math.abs(yMax) < Function.EPSILON) {\n            ret = max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,14 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        if (Math.abs(yMin) < Function.EPSILON) {\n+            ret = min;\n+        } else if (Math.abs(yMax) < Function.EPSILON) {\n+            ret = max;\n+        } else {\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        double yMinAbs = Math.abs(yMin);\n        double yMaxAbs = Math.abs(yMax);\n        if (yMinAbs < yMaxAbs) {\n          ret = min;\n        } else {\n          ret = max;\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,13 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        double yMinAbs = Math.abs(yMin);\n+        double yMaxAbs = Math.abs(yMax);\n+        if (yMinAbs < yMaxAbs) {\n+          ret = min;\n+        } else {\n+          ret = max;\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        double y;\n        if (Math.abs(yMin) < Math.abs(yMax)) {\n            y = yMin;\n            ret = min;\n        } else {\n            y = yMax;\n            ret = max;\n        }\n        if (Math.abs(y) <= FunctionValues.DEFAULT_TOLERANCE) {\n            setResult(ret, 0);\n        } else {\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,19 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        double y;\n+        if (Math.abs(yMin) < Math.abs(yMax)) {\n+            y = yMin;\n+            ret = min;\n+        } else {\n+            y = yMax;\n+            ret = max;\n+        }\n+        if (Math.abs(y) <= FunctionValues.DEFAULT_TOLERANCE) {\n+            setResult(ret, 0);\n+        } else {\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        if (Math.abs(yMin) < Math.abs(yMax)) {\n            if (yMin == 0) {\n                return min;\n            }\n            ret = solve(min, yMin, max, yMax, min, yMin);\n        } else {\n            if (yMax == 0) {\n                return max;\n            }\n            ret = solve(min, yMin, max, yMax, max, yMax);\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -7,9 +7,17 @@\n     // Verify bracketing\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n-        // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        if (Math.abs(yMin) < Math.abs(yMax)) {\n+            if (yMin == 0) {\n+                return min;\n+            }\n+            ret = solve(min, yMin, max, yMax, min, yMin);\n+        } else {\n+            if (yMax == 0) {\n+                return max;\n+            }\n+            ret = solve(min, yMin, max, yMax, max, yMax);\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) < FunctionEvaluator.DEFAULT_ABSOLUTE_ACCURACY) {\n            ret = min;\n        } else if (Math.abs(yMax) < FunctionEvaluator.DEFAULT_ABSOLUTE_ACCURACY) {\n            ret = max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,14 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        if (Math.abs(yMin) < FunctionEvaluator.DEFAULT_ABSOLUTE_ACCURACY) {\n+            ret = min;\n+        } else if (Math.abs(yMax) < FunctionEvaluator.DEFAULT_ABSOLUTE_ACCURACY) {\n+            ret = max;\n+        } else {\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) < FunctionUtils.EPSILON) {\n            return min;\n        }\n        if (Math.abs(yMax) < FunctionUtils.EPSILON) {\n            return max;\n        }\n        // neither value is close to zero and min and max do not bracket root.\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,6 +8,12 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n+        if (Math.abs(yMin) < FunctionUtils.EPSILON) {\n+            return min;\n+        }\n+        if (Math.abs(yMax) < FunctionUtils.EPSILON) {\n+            return max;\n+        }\n         // neither value is close to zero and min and max do not bracket root.\n         throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) < Math.abs(yMax)) {\n            ret = min;\n        } else {\n            ret = max;\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,11 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        if (Math.abs(yMin) < Math.abs(yMax)) {\n+            ret = min;\n+        } else {\n+            ret = max;\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) < TOLERANCE) {\n            ret = min;\n        } else if (Math.abs(yMax) < TOLERANCE) {\n            ret = max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,14 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        if (Math.abs(yMin) < TOLERANCE) {\n+            ret = min;\n+        } else if (Math.abs(yMax) < TOLERANCE) {\n+            ret = max;\n+        } else {\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double ret = Double.NaN;\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // check if either value is close to a zero\n        if(Math.abs(yMin) < Function.EPSILON) {\n            ret = min;\n        } else if(Math.abs(yMax) < Function.EPSILON) {\n            ret = max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n    return ret;\n}", "diff": "--- org/apache/commons/math/analysis/BrentSolver.java@solve\n+++ org/apache/commons/math/analysis/BrentSolver.java@solve\n@@ -8,8 +8,14 @@\n     double sign = yMin * yMax;\n     if (sign >= 0) {\n         // check if either value is close to a zero\n-        // neither value is close to zero and min and max do not bracket root.\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        if(Math.abs(yMin) < Function.EPSILON) {\n+            ret = min;\n+        } else if(Math.abs(yMax) < Function.EPSILON) {\n+            ret = max;\n+        } else {\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+        }\n     } else {\n         // solve using only the first endpoint as initial guess\n         ret = solve(min, yMin, max, yMax, min, yMin);\n", "finish_reason": "stop", "valid": false, "num": 1}]