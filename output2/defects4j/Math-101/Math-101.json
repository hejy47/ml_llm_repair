[{"output": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    if (startIndex + n > source.length()) {\n        // not enough characters to parse imaginary character\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -48,7 +48,13 @@\n     // parse imaginary character\n     int n = getImaginaryCharacter().length();\n     startIndex = pos.getIndex();\n-    int endIndex = startIndex + n;\n+    if (startIndex + n > source.length()) {\n+        // not enough characters to parse imaginary character\n+        pos.setIndex(initialIndex);\n+        pos.setErrorIndex(startIndex);\n+        return null;\n+    }\n+    endIndex = startIndex + n;\n     if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n         // set index back to initial, error index should be the start index\n         // character examined.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 1; // default sign is positive\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            break; // positive sign can be omitted\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -14,7 +14,7 @@\n     // parse sign\n     int startIndex = pos.getIndex();\n     char c = parseNextCharacter(source, pos);\n-    int sign = 0;\n+    int sign = 1; // default sign is positive\n     switch(c) {\n         case 0:\n             // no sign\n@@ -24,8 +24,7 @@\n             sign = -1;\n             break;\n         case '+':\n-            sign = 1;\n-            break;\n+            break; // positive sign can be omitted\n         default:\n             // invalid sign\n             // set index back to initial, error index should be the last\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    String imaginaryChar = getImaginaryCharacter();\n    if (source.length() - pos.getIndex() < imaginaryChar.length()) {\n        // not enough characters to possibly be the imaginaryChar\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n    if (source.substring(pos.getIndex(), pos.getIndex() + imaginaryChar.length()).equals(imaginaryChar)) {\n        // imaginary character found\n        pos.setIndex(pos.getIndex() + imaginaryChar.length());\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    } else {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(pos.getIndex());\n        return null;\n    }\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -46,16 +46,20 @@\n         return null;\n     }\n     // parse imaginary character\n-    int n = getImaginaryCharacter().length();\n-    startIndex = pos.getIndex();\n-    int endIndex = startIndex + n;\n-    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+    String imaginaryChar = getImaginaryCharacter();\n+    if (source.length() - pos.getIndex() < imaginaryChar.length()) {\n+        // not enough characters to possibly be the imaginaryChar\n+        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+    }\n+    if (source.substring(pos.getIndex(), pos.getIndex() + imaginaryChar.length()).equals(imaginaryChar)) {\n+        // imaginary character found\n+        pos.setIndex(pos.getIndex() + imaginaryChar.length());\n+        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+    } else {\n         // set index back to initial, error index should be the start index\n         // character examined.\n         pos.setIndex(initialIndex);\n-        pos.setErrorIndex(startIndex);\n+        pos.setErrorIndex(pos.getIndex());\n         return null;\n     }\n-    pos.setIndex(endIndex);\n-    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length() || source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -49,7 +49,7 @@\n     int n = getImaginaryCharacter().length();\n     startIndex = pos.getIndex();\n     int endIndex = startIndex + n;\n-    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+    if (endIndex > source.length() || source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n         // set index back to initial, error index should be the start index\n         // character examined.\n         pos.setIndex(initialIndex);\n", "finish_reason": "stop", "valid": true, "num": 2}, {"output": "## Fixed Function 1\npublic Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    String imaginaryCharacter = getImaginaryCharacter();\n    if (source.regionMatches(pos.getIndex(), imaginaryCharacter, 0, imaginaryCharacter.length())) {\n        pos.setIndex(pos.getIndex() + imaginaryCharacter.length());\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    } else {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(pos.getIndex());\n        return null;\n    }\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -46,16 +46,15 @@\n         return null;\n     }\n     // parse imaginary character\n-    int n = getImaginaryCharacter().length();\n-    startIndex = pos.getIndex();\n-    int endIndex = startIndex + n;\n-    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+    String imaginaryCharacter = getImaginaryCharacter();\n+    if (source.regionMatches(pos.getIndex(), imaginaryCharacter, 0, imaginaryCharacter.length())) {\n+        pos.setIndex(pos.getIndex() + imaginaryCharacter.length());\n+        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+    } else {\n         // set index back to initial, error index should be the start index\n         // character examined.\n         pos.setIndex(initialIndex);\n-        pos.setErrorIndex(startIndex);\n+        pos.setErrorIndex(pos.getIndex());\n         return null;\n     }\n-    pos.setIndex(endIndex);\n-    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.length() < endIndex || !source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -49,7 +49,7 @@\n     int n = getImaginaryCharacter().length();\n     startIndex = pos.getIndex();\n     int endIndex = startIndex + n;\n-    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+    if (source.length() < endIndex || !source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n         // set index back to initial, error index should be the start index\n         // character examined.\n         pos.setIndex(initialIndex);\n", "finish_reason": "stop", "valid": true, "num": 4}, {"output": "There are multiple possible fixes for this buggy function, depending on the specific error being addressed. Here are three potential fixes: \n\n## Fixed Function 1\npublic Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex-1);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex-1);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (startIndex + n > source.length() || source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex-1);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}\n\nIn this fix, two issues have been addressed: First, the error index when encountering an invalid sign is set to the correct value (the start index of the invalid character, not the end index). Second, when checking if the imaginary character is present, the code first checks if the end index is within the bounds of the source string to avoid an out-of-bounds exception.\n\n## Fixed Function 2\npublic Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(initialIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(initialIndex + 1);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    String imaginaryString = source.substring(startIndex, endIndex);\n    if (!imaginaryString.equals(getImaginaryCharacter())) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(endIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}\n\nThis fix is similar to the previous one except that it sets the error index differently when encountering an invalid sign. It sets it to the initial index instead of the start index of the invalid character. Additionally, it sets the error index for an invalid imaginary number to the index following the last valid character (which will be the start index of the imaginary character when it is not present). Finally, it reads the substring for the imaginary character into a separate variable before comparing it to the expected value.\n\n## Fixed Function 3\npublic Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    char c;\n    try {\n        c = source.charAt(pos.getIndex());\n    } catch (IndexOutOfBoundsException e) {\n        return new Complex(re.doubleValue(), 0.0);\n    }\n    int sign = 0;\n    switch(c) {\n        case '-':\n            sign = -1;\n            pos.setIndex(pos.getIndex() + 1);\n            break;\n        case '+':\n            sign = 1;\n            pos.setIndex(pos.getIndex() + 1);\n            break;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    if (pos.getIndex() >= source.length() || !source.substring(pos.getIndex(), pos.getIndex() + getImaginaryCharacter().length()).equals(getImaginaryCharacter())) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    pos.setIndex(pos.getIndex() + getImaginaryCharacter().length());\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}\n\nThis fix takes a different approach to parsing the sign character. Rather than using the `parseNextCharacter` method, it tries to extract the character from the `source` string using the `charAt` method. If this method throws an exception (indicating that the index is out of bounds), it assumes that the string has no sign and sets the imaginary part to 0. If the character is a valid sign, it adjusts the index accordingly and sets the sign variable. Finally, it checks that the expected imaginary character is present by comparing substrings of the `source` string using the `substring` method. If the imaginary character is not present, it sets the index back to the initial index and returns null.", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -31,7 +31,7 @@\n             // set index back to initial, error index should be the last\n             // character examined.\n             pos.setIndex(initialIndex);\n-            pos.setErrorIndex(startIndex);\n+            pos.setErrorIndex(startIndex-1);\n             return null;\n     }\n     // parse whitespace\n@@ -43,17 +43,18 @@\n         // set index back to initial, error index should already be set\n         // character examined.\n         pos.setIndex(initialIndex);\n+        pos.setErrorIndex(startIndex-1);\n         return null;\n     }\n     // parse imaginary character\n     int n = getImaginaryCharacter().length();\n     startIndex = pos.getIndex();\n     int endIndex = startIndex + n;\n-    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+    if (startIndex + n > source.length() || source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n         // set index back to initial, error index should be the start index\n         // character examined.\n         pos.setIndex(initialIndex);\n-        pos.setErrorIndex(startIndex);\n+        pos.setErrorIndex(startIndex-1);\n         return null;\n     }\n     pos.setIndex(endIndex);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 1; // set default sign to positive\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            c = parseNextCharacter(source, pos); // move on to next character after sign\n            break;\n        case '+':\n            c = parseNextCharacter(source, pos); // move on to next character after sign\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -14,7 +14,7 @@\n     // parse sign\n     int startIndex = pos.getIndex();\n     char c = parseNextCharacter(source, pos);\n-    int sign = 0;\n+    int sign = 1; // set default sign to positive\n     switch(c) {\n         case 0:\n             // no sign\n@@ -22,9 +22,10 @@\n             return new Complex(re.doubleValue(), 0.0);\n         case '-':\n             sign = -1;\n+            c = parseNextCharacter(source, pos); // move on to next character after sign\n             break;\n         case '+':\n-            sign = 1;\n+            c = parseNextCharacter(source, pos); // move on to next character after sign\n             break;\n         default:\n             // invalid sign\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    String imaginaryChar = getImaginaryCharacter();\n    if (source.regionMatches(true, pos.getIndex(), imaginaryChar, 0, imaginaryChar.length())) {\n        pos.setIndex(pos.getIndex() + imaginaryChar.length());\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n    // set index back to initial, error index should be the start index\n    // character examined.\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(pos.getIndex());\n    return null;\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -46,16 +46,14 @@\n         return null;\n     }\n     // parse imaginary character\n-    int n = getImaginaryCharacter().length();\n-    startIndex = pos.getIndex();\n-    int endIndex = startIndex + n;\n-    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n-        // set index back to initial, error index should be the start index\n-        // character examined.\n-        pos.setIndex(initialIndex);\n-        pos.setErrorIndex(startIndex);\n-        return null;\n+    String imaginaryChar = getImaginaryCharacter();\n+    if (source.regionMatches(true, pos.getIndex(), imaginaryChar, 0, imaginaryChar.length())) {\n+        pos.setIndex(pos.getIndex() + imaginaryChar.length());\n+        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n     }\n-    pos.setIndex(endIndex);\n-    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+    // set index back to initial, error index should be the start index\n+    // character examined.\n+    pos.setIndex(initialIndex);\n+    pos.setErrorIndex(pos.getIndex());\n+    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 1; // fixed here as it is the default value\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -14,7 +14,7 @@\n     // parse sign\n     int startIndex = pos.getIndex();\n     char c = parseNextCharacter(source, pos);\n-    int sign = 0;\n+    int sign = 1; // fixed here as it is the default value\n     switch(c) {\n         case 0:\n             // no sign\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\npublic Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length()) {\n        // the imaginary character is missing or broken\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    String imaginaryChar = source.substring(startIndex, endIndex);\n    if (!imaginaryChar.equals(getImaginaryCharacter())) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -49,7 +49,14 @@\n     int n = getImaginaryCharacter().length();\n     startIndex = pos.getIndex();\n     int endIndex = startIndex + n;\n-    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+    if (endIndex > source.length()) {\n+        // the imaginary character is missing or broken\n+        pos.setIndex(initialIndex);\n+        pos.setErrorIndex(startIndex);\n+        return null;\n+    }\n+    String imaginaryChar = source.substring(startIndex, endIndex);\n+    if (!imaginaryChar.equals(getImaginaryCharacter())) {\n         // set index back to initial, error index should be the start index\n         // character examined.\n         pos.setIndex(initialIndex);\n", "finish_reason": "stop", "valid": true, "num": 1}, {"output": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getImaginaryFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -37,7 +37,7 @@\n     // parse whitespace\n     parseAndIgnoreWhitespace(source, pos);\n     // parse imaginary\n-    Number im = parseNumber(source, getRealFormat(), pos);\n+    Number im = parseNumber(source, getImaginaryFormat(), pos);\n     if (im == null) {\n         // invalid imaginary number\n         // set index back to initial, error index should already be set\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 1; // default sign is positive\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            // Fall through to '+' case\n        case '+':\n            // parse imaginary\n            Number im = parseNumber(source, getRealFormat(), pos);\n            if (im == null) {\n                // invalid imaginary number\n                // set index back to initial, error index should already be set\n                // character examined.\n                pos.setIndex(initialIndex);\n                return null;\n            }\n            // parse imaginary character\n            int n = getImaginaryCharacter().length();\n            startIndex = pos.getIndex();\n            int endIndex = startIndex + n;\n            if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n                // set index back to initial, error index should be the start index\n                // character examined.\n                pos.setIndex(initialIndex);\n                pos.setErrorIndex(startIndex);\n                return null;\n            }\n            pos.setIndex(endIndex);\n            return new Complex(re.doubleValue(), im.doubleValue() * sign);\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -14,7 +14,7 @@\n     // parse sign\n     int startIndex = pos.getIndex();\n     char c = parseNextCharacter(source, pos);\n-    int sign = 0;\n+    int sign = 1; // default sign is positive\n     switch(c) {\n         case 0:\n             // no sign\n@@ -22,10 +22,30 @@\n             return new Complex(re.doubleValue(), 0.0);\n         case '-':\n             sign = -1;\n-            break;\n+            // Fall through to '+' case\n         case '+':\n-            sign = 1;\n-            break;\n+            // parse imaginary\n+            Number im = parseNumber(source, getRealFormat(), pos);\n+            if (im == null) {\n+                // invalid imaginary number\n+                // set index back to initial, error index should already be set\n+                // character examined.\n+                pos.setIndex(initialIndex);\n+                return null;\n+            }\n+            // parse imaginary character\n+            int n = getImaginaryCharacter().length();\n+            startIndex = pos.getIndex();\n+            int endIndex = startIndex + n;\n+            if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+                // set index back to initial, error index should be the start index\n+                // character examined.\n+                pos.setIndex(initialIndex);\n+                pos.setErrorIndex(startIndex);\n+                return null;\n+            }\n+            pos.setIndex(endIndex);\n+            return new Complex(re.doubleValue(), im.doubleValue() * sign);\n         default:\n             // invalid sign\n             // set index back to initial, error index should be the last\n@@ -34,28 +54,4 @@\n             pos.setErrorIndex(startIndex);\n             return null;\n     }\n-    // parse whitespace\n-    parseAndIgnoreWhitespace(source, pos);\n-    // parse imaginary\n-    Number im = parseNumber(source, getRealFormat(), pos);\n-    if (im == null) {\n-        // invalid imaginary number\n-        // set index back to initial, error index should already be set\n-        // character examined.\n-        pos.setIndex(initialIndex);\n-        return null;\n-    }\n-    // parse imaginary character\n-    int n = getImaginaryCharacter().length();\n-    startIndex = pos.getIndex();\n-    int endIndex = startIndex + n;\n-    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n-        // set index back to initial, error index should be the start index\n-        // character examined.\n-        pos.setIndex(initialIndex);\n-        pos.setErrorIndex(startIndex);\n-        return null;\n-    }\n-    pos.setIndex(endIndex);\n-    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    String imaginaryChar = getImaginaryCharacter();\n    int n = imaginaryChar.length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex <= source.length() && source.substring(startIndex, endIndex).compareTo(imaginaryChar) == 0) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    } else {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -46,16 +46,18 @@\n         return null;\n     }\n     // parse imaginary character\n-    int n = getImaginaryCharacter().length();\n+    String imaginaryChar = getImaginaryCharacter();\n+    int n = imaginaryChar.length();\n     startIndex = pos.getIndex();\n     int endIndex = startIndex + n;\n-    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+    if (endIndex <= source.length() && source.substring(startIndex, endIndex).compareTo(imaginaryChar) == 0) {\n+        pos.setIndex(endIndex);\n+        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+    } else {\n         // set index back to initial, error index should be the start index\n         // character examined.\n         pos.setIndex(initialIndex);\n         pos.setErrorIndex(startIndex);\n         return null;\n     }\n-    pos.setIndex(endIndex);\n-    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n }\n", "finish_reason": "stop", "valid": true, "num": 1}, {"output": "## Fixed Function 1\npublic Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    String imaginaryCharacter = getImaginaryCharacter();\n    int n = imaginaryCharacter.length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (source.length() >= endIndex && source.substring(startIndex, endIndex).compareTo(imaginaryCharacter) == 0) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    } else {\n        // set index back to initial, error index should be the start index\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -46,16 +46,17 @@\n         return null;\n     }\n     // parse imaginary character\n-    int n = getImaginaryCharacter().length();\n+    String imaginaryCharacter = getImaginaryCharacter();\n+    int n = imaginaryCharacter.length();\n     startIndex = pos.getIndex();\n     int endIndex = startIndex + n;\n-    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+    if (source.length() >= endIndex && source.substring(startIndex, endIndex).compareTo(imaginaryCharacter) == 0) {\n+        pos.setIndex(endIndex);\n+        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+    } else {\n         // set index back to initial, error index should be the start index\n-        // character examined.\n         pos.setIndex(initialIndex);\n         pos.setErrorIndex(startIndex);\n         return null;\n     }\n-    pos.setIndex(endIndex);\n-    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n }\n", "finish_reason": "stop", "valid": true, "num": 1}, {"output": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch(c) {\n        case 0:\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-':\n            sign = -1;\n            break;\n        case '+':\n            sign = 1;\n            break;\n        default:\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n    }\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length() || !source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}", "diff": "--- org/apache/commons/math/complex/ComplexFormat.java@parse\n+++ org/apache/commons/math/complex/ComplexFormat.java@parse\n@@ -49,7 +49,7 @@\n     int n = getImaginaryCharacter().length();\n     startIndex = pos.getIndex();\n     int endIndex = startIndex + n;\n-    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+    if (endIndex > source.length() || !source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n         // set index back to initial, error index should be the start index\n         // character examined.\n         pos.setIndex(initialIndex);\n", "finish_reason": "stop", "valid": true, "num": 1}]